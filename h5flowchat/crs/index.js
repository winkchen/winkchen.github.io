webpackJsonp([1],{108:function(n,t,e){n.exports=e(109)},109:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_element_ui_lib_theme_chalk_index_css__ = __webpack_require__(62);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_element_ui_lib_theme_chalk_index_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_element_ui_lib_theme_chalk_index_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_element_ui_lib__ = __webpack_require__(65);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_element_ui_lib___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_element_ui_lib__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__crsPlugin_js__ = __webpack_require__(117);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_vue__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_vue__);\n\n\n\n\nwindow.tPlugin = __WEBPACK_IMPORTED_MODULE_2__crsPlugin_js__[\"a\" /* default */];\n\n\n\n\n__WEBPACK_IMPORTED_MODULE_3_vue___default.a.use(__WEBPACK_IMPORTED_MODULE_1_element_ui_lib___default.a);\n\n//import crs from './crs.index.js';\n\n\n//require.ensure([], function (require) {\n__webpack_require__(167);\n//}, '');\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vdHBsdWdpbi9zcmMvanMvc2NhZmYvY3JzL2luZGV4LmpzPzYxMzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9kZWZhdWx0MiBmcm9tICdlbGVtZW50LXVpL2xpYi90aGVtZS1jaGFsay9pbmRleC5jc3MnO1xuaW1wb3J0IF9kZWZhdWx0IGZyb20gJ2VsZW1lbnQtdWkvbGliJztcbmltcG9ydCB0UGx1Z2luIGZyb20gXCIuL2Nyc1BsdWdpbi5qc1wiO1xuXG53aW5kb3cudFBsdWdpbiA9IHRQbHVnaW47XG5cbmltcG9ydCB2dWUgZnJvbSAndnVlJztcblxuXG52dWUudXNlKF9kZWZhdWx0KTtcblxuLy9pbXBvcnQgY3JzIGZyb20gJy4vY3JzLmluZGV4LmpzJztcblxuXG4vL3JlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbiAocmVxdWlyZSkge1xucmVxdWlyZSgnLi9jcnMuaW5kZXguanMnKTtcbi8vfSwgJycpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdHBsdWdpbi9zcmMvanMvc2NhZmYvY3JzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///109\n")},117:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_element_ui_lib_theme_chalk_index_css__ = __webpack_require__(62);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_element_ui_lib_theme_chalk_index_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_element_ui_lib_theme_chalk_index_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_element_ui_lib__ = __webpack_require__(65);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_element_ui_lib___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_element_ui_lib__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__tPlugin_js__ = __webpack_require__(118);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__scaff_chart_crsChild_crsCheck_js__ = __webpack_require__(155);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__scaff_chart_crsChild_crschartController_js__ = __webpack_require__(157);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__scaff_menus_crsChild_comments_normal_js__ = __webpack_require__(162);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__scaff_menus_crsChild_comments_pySpark_js__ = __webpack_require__(163);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__scaff_menus_crsChild_comments_spark_js__ = __webpack_require__(164);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__scaff_menus_crsChild_input_tdwInput_js__ = __webpack_require__(165);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__scaff_menus_crsChild_output_tdwOutput_js__ = __webpack_require__(166);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__tencent_idf_index_js__ = __webpack_require__(69);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__tencent_idf_index_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10__tencent_idf_index_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_vue__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_vue__);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__WEBPACK_IMPORTED_MODULE_11_vue___default.a.use(__WEBPACK_IMPORTED_MODULE_1_element_ui_lib___default.a);\n\nvar mouse = __WEBPACK_IMPORTED_MODULE_10__tencent_idf_index_js__["Event"].mouse,\n    AddReSizeFunc = mouse.AddReSizeFunc,\n    AddMouseMoveFunc = mouse.AddMouseMoveFunc,\n    AddMouseUpFunc = mouse.AddMouseUpFunc,\n    removeMMRFunc = mouse.removeMMRFunc,\n    removeMURFunc = mouse.removeMURFunc,\n    removeReSizeFunc = mouse.removeReSizeFunc;\n\nvar crsPlugin = function crsPlugin(options) {\n    __WEBPACK_IMPORTED_MODULE_2__tPlugin_js__["a" /* default */].call(this, options);\n\n    this.chartControlClass = __WEBPACK_IMPORTED_MODULE_4__scaff_chart_crsChild_crschartController_js__["a" /* default */];\n\n    this.checkControl = new __WEBPACK_IMPORTED_MODULE_3__scaff_chart_crsChild_crsCheck_js__["a" /* default */]();\n};\ncrsPlugin.prototype = new __WEBPACK_IMPORTED_MODULE_2__tPlugin_js__["a" /* default */]();\n\n//渲染菜单\ncrsPlugin.prototype.renderMenus = function (json) {\n\n    var listHtml = \'\';\n    //获取菜单对象的集合\n    var menus = this.menuRegister.getMenus();\n    menus.forEach(function (m) {\n        if ("childNodes" in m) {\n            m.childNodes = [];\n        }\n    });\n\n    var tmpMenus = Object.assign([], menus);\n\n    //处理menus,添加一个关系属性childNodes\n    for (var i = 0; i < tmpMenus.length; i++) {\n        var nodeI = tmpMenus[i];\n        for (var j = 1; j < tmpMenus.length; j++) {\n            if (nodeI.procId == tmpMenus[j].parentId) {\n                if (typeof nodeI.childNodes === "undefined") {\n                    nodeI.childNodes = [];\n                }\n                nodeI.childNodes.push(tmpMenus[j]);\n                tmpMenus[j].parentNode = nodeI;\n            }\n        }\n    }\n    //生成树形菜单 => 第一级数组去掉为子节点的数组\n    for (var i = 0; i < tmpMenus.length; i++) {\n\n        if (typeof tmpMenus[i].parentId !== "undefined") {\n            tmpMenus.splice(i, 1);\n            i--;\n        }\n    }\n\n    this.treeMenu = tmpMenus;\n\n    /*listHtml = `<ul class="v-topnav">${this.creatMenuHTML(tmpMenus)}</ul>`;\r\n      //渲染出 菜单列表 \r\n    this._els.menu.empty().append(listHtml);\r\n      this.createJQPlugin();\r\n      //绑定为手风琴系列\r\n    $(this._els.menu).accordion({\r\n        accordion: false,\r\n        speed: 300,\r\n        closedSign: \'[+]\',\r\n        openedSign: \'[-]\'\r\n    });*/\n\n    var $menu = $(\'<div id="v-menu-plugin"></div>\').appendTo(this._els.menu.empty());\n\n    renderElementMenu("#v-menu-plugin", tmpMenus);\n\n    //绑定 拖拽事件\n    this.bindDrag(this._els.menu, this._els.chart, this.treeMenu);\n};\n//绑定拖拽事件\ncrsPlugin.prototype.bindDrag = function ($menus, $chat, treeMenu) {\n    var dragging = false,\n        mov = null,\n        _this = this,\n        inArea = false,\n        areaPoint = {\n        x: 0,\n        y: 0\n    };\n    $menus.off(\'mousedown\').on(\'mousedown\', "li.el-menu-item", function (e) {\n        e.preventDefault();\n        var curDom = this;\n        AddMouseMoveFunc("mouseMove_Menu", function (e) {\n            if (!dragging) {\n                dragging = true;\n                mov = _this.creatMov(curDom, treeMenu);\n                $chat.addClass(\'moving\');\n            }\n            if (mov) {\n                mov.style.left = e.pageX - 10 + "px";\n                mov.style.top = e.pageY - 10 + "px";\n            }\n        });\n        //全局当鼠标左键弹上时\n        AddMouseUpFunc("mouseUp_Menu", function (e) {\n            removeMMRFunc("mouseMove_Menu");\n            removeMURFunc("mouseUp_Menu");\n            dragging = false;\n            $chat.removeClass(\'moving\');\n            if (mov) {\n                if (inArea) {\n                    _this.addNewTask(mov, areaPoint);\n                }\n\n                _this.dropMov(mov);\n                mov = null;\n            }\n        });\n    });\n\n    $chat.off(\'mouseover\').off(\'mouseout\').off(\'mousemove\').on(\'mouseover\', function (e) {\n        if (dragging) {\n            inArea = true;\n        }\n    }).on(\'mouseout\', function (e) {\n        inArea = false;\n    }).on(\'mousemove\', function (e) {\n        if (inArea) {\n            areaPoint.x = e.offsetX;\n            areaPoint.y = e.offsetY;\n        }\n    });\n};\n\ncrsPlugin.prototype.creatMov = function (copyDom, treeMenu) {\n    var $d = $(copyDom);\n    var div = document.createElement(\'div\');\n\n    var indexId = $d.attr("title");\n    var node = getMenuByindexId(treeMenu, indexId);\n\n    document.body.appendChild(div);\n    div.innerHTML = "<span class=\'node-name " + (node.class || "") + "\' data-procId=\'" + node.procId + "\'  data-nodeType=\'" + (node.nodeType || 1) + "\'>" + node.text + "</span>";\n    div.setAttribute(\'class\', \'menu-move\');\n    return div;\n};\n\nvar getMenuByindexId = function getMenuByindexId(treeMenu, indexId) {\n\n    var func = function func(menus) {\n        var r = null;\n        for (var i = 0; i < menus.length; i++) {\n            if (menus[i].indexId == indexId) {\n                r = menus[i];\n                break;\n            } else if (menus[i].childNodes) {\n                var tmp = func(menus[i].childNodes);\n                if (tmp) {\n                    r = tmp;\n                }\n            }\n        }\n        return r;\n    };\n\n    return func(treeMenu);\n};\n\nvar renderElementMenu = function renderElementMenu(id, menus) {\n\n    var createMenus = function createMenus(menus) {\n        var tmpStr = "";\n        for (var i = 0; i < menus.length; i++) {\n            var t = i + 1;\n            menus[i].indexId = menus[i].parentNode ? menus[i].parentNode.indexId + \'-\' + t : t;\n            if (menus[i].childNodes && menus[i].childNodes.length > 0) {\n                tmpStr += "<el-submenu index=\\"" + menus[i].indexId + "\\" >";\n                tmpStr += "<template slot=\\"title\\">\\n                    <span>" + menus[i].text + "</span>\\n                    </template>";\n                tmpStr += createMenus(menus[i].childNodes);\n                tmpStr += \'</el-submenu>\';\n            } else {\n                tmpStr += "<el-menu-item index=\\"" + menus[i].indexId + "\\" title=\\"" + menus[i].indexId + "\\">" + menus[i].text + "</el-menu-item>";\n            }\n        }\n        return tmpStr;\n    };\n\n    var str = createMenus(menus);\n\n    var res = __WEBPACK_IMPORTED_MODULE_11_vue___default.a.compile("\\n    <el-row class=\\"tac v-drag-menus\\" >\\n        <el-col :span=\\"24\\">\\n        <el-menu\\n            default-active=\\"1\\"\\n            class=\\"el-menu-vertical-demo\\"\\n            style=\\"background-color:transparent\\"\\n            >\\n            " + str + "\\n        </el-menu>\\n        </el-col>\\n    </el-row>");\n\n    new __WEBPACK_IMPORTED_MODULE_11_vue___default.a({\n        el: id,\n        data: function data() {\n            return {\n                menus: menus\n            };\n        },\n\n        render: res.render,\n        staticRenderFns: res.staticRenderFns\n    });\n};\n\n/* harmony default export */ __webpack_exports__["a"] = (crsPlugin);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vdHBsdWdpbi9zcmMvanMvc2NhZmYvY3JzL2Nyc1BsdWdpbi5qcz80ZTNkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZGVmYXVsdDIgZnJvbSBcImVsZW1lbnQtdWkvbGliL3RoZW1lLWNoYWxrL2luZGV4LmNzc1wiO1xuaW1wb3J0IF9kZWZhdWx0IGZyb20gXCJlbGVtZW50LXVpL2xpYlwiO1xuaW1wb3J0IHRQbHVnaW4gZnJvbSAnLi4vLi4vdFBsdWdpbi5qcyc7XG5cbmltcG9ydCBjcnNDaGVjayBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vc2NhZmYvY2hhcnQvY3JzQ2hpbGQvY3JzQ2hlY2suanNcIjtcblxuaW1wb3J0IGNoYXJ0Q29udHJvbCBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vc2NhZmYvY2hhcnQvY3JzQ2hpbGQvY3JzY2hhcnRDb250cm9sbGVyLmpzXCI7XG5cbmltcG9ydCB7IG5vcmFtbCB9IGZyb20gXCIuLi8uLi8uLi8uLi8uLi9zY2FmZi9tZW51cy9jcnNDaGlsZC9jb21tZW50cy9ub3JtYWwuanNcIjtcbmltcG9ydCB7IHB5U3BhcmsgfSBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vc2NhZmYvbWVudXMvY3JzQ2hpbGQvY29tbWVudHMvcHlTcGFyay5qc1wiO1xuaW1wb3J0IHsgc3BhcmsgfSBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vc2NhZmYvbWVudXMvY3JzQ2hpbGQvY29tbWVudHMvc3BhcmsuanNcIjtcbmltcG9ydCB7IHRkd0lucHV0IH0gZnJvbSBcIi4uLy4uLy4uLy4uLy4uL3NjYWZmL21lbnVzL2Nyc0NoaWxkL2lucHV0L3Rkd0lucHV0LmpzXCI7XG5pbXBvcnQgeyB0ZHdPdXRwdXQgfSBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vc2NhZmYvbWVudXMvY3JzQ2hpbGQvb3V0cHV0L3Rkd091dHB1dC5qc1wiO1xuXG5pbXBvcnQgeyBVdGlscywgRXZlbnQgfSBmcm9tIFwiQHRlbmNlbnQvaWRmL2luZGV4LmpzXCI7XG5cbmltcG9ydCB2dWUgZnJvbSAndnVlJztcblxuXG52dWUudXNlKF9kZWZhdWx0KTtcblxudmFyIG1vdXNlID0gRXZlbnQubW91c2UsXG4gICAgQWRkUmVTaXplRnVuYyA9IG1vdXNlLkFkZFJlU2l6ZUZ1bmMsXG4gICAgQWRkTW91c2VNb3ZlRnVuYyA9IG1vdXNlLkFkZE1vdXNlTW92ZUZ1bmMsXG4gICAgQWRkTW91c2VVcEZ1bmMgPSBtb3VzZS5BZGRNb3VzZVVwRnVuYyxcbiAgICByZW1vdmVNTVJGdW5jID0gbW91c2UucmVtb3ZlTU1SRnVuYyxcbiAgICByZW1vdmVNVVJGdW5jID0gbW91c2UucmVtb3ZlTVVSRnVuYyxcbiAgICByZW1vdmVSZVNpemVGdW5jID0gbW91c2UucmVtb3ZlUmVTaXplRnVuYztcblxudmFyIGNyc1BsdWdpbiA9IGZ1bmN0aW9uIGNyc1BsdWdpbihvcHRpb25zKSB7XG4gICAgdFBsdWdpbi5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5jaGFydENvbnRyb2xDbGFzcyA9IGNoYXJ0Q29udHJvbDtcblxuICAgIHRoaXMuY2hlY2tDb250cm9sID0gbmV3IGNyc0NoZWNrKCk7XG59O1xuY3JzUGx1Z2luLnByb3RvdHlwZSA9IG5ldyB0UGx1Z2luKCk7XG5cbi8v5riy5p+T6I+c5Y2VXG5jcnNQbHVnaW4ucHJvdG90eXBlLnJlbmRlck1lbnVzID0gZnVuY3Rpb24gKGpzb24pIHtcblxuICAgIHZhciBsaXN0SHRtbCA9ICcnO1xuICAgIC8v6I635Y+W6I+c5Y2V5a+56LGh55qE6ZuG5ZCIXG4gICAgdmFyIG1lbnVzID0gdGhpcy5tZW51UmVnaXN0ZXIuZ2V0TWVudXMoKTtcbiAgICBtZW51cy5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIGlmIChcImNoaWxkTm9kZXNcIiBpbiBtKSB7XG4gICAgICAgICAgICBtLmNoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHRtcE1lbnVzID0gT2JqZWN0LmFzc2lnbihbXSwgbWVudXMpO1xuXG4gICAgLy/lpITnkIZtZW51cyzmt7vliqDkuIDkuKrlhbPns7vlsZ7mgKdjaGlsZE5vZGVzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0bXBNZW51cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZUkgPSB0bXBNZW51c1tpXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCB0bXBNZW51cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKG5vZGVJLnByb2NJZCA9PSB0bXBNZW51c1tqXS5wYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZUkuY2hpbGROb2RlcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBub2RlSS5jaGlsZE5vZGVzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGVJLmNoaWxkTm9kZXMucHVzaCh0bXBNZW51c1tqXSk7XG4gICAgICAgICAgICAgICAgdG1wTWVudXNbal0ucGFyZW50Tm9kZSA9IG5vZGVJO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8v55Sf5oiQ5qCR5b2i6I+c5Y2VID0+IOesrOS4gOe6p+aVsOe7hOWOu+aOieS4uuWtkOiKgueCueeahOaVsOe7hFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG1wTWVudXMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICBpZiAodHlwZW9mIHRtcE1lbnVzW2ldLnBhcmVudElkICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0bXBNZW51cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnRyZWVNZW51ID0gdG1wTWVudXM7XG5cbiAgICAvKmxpc3RIdG1sID0gYDx1bCBjbGFzcz1cInYtdG9wbmF2XCI+JHt0aGlzLmNyZWF0TWVudUhUTUwodG1wTWVudXMpfTwvdWw+YDtcclxuICAgICAgLy/muLLmn5Plh7og6I+c5Y2V5YiX6KGoIFxyXG4gICAgdGhpcy5fZWxzLm1lbnUuZW1wdHkoKS5hcHBlbmQobGlzdEh0bWwpO1xyXG4gICAgICB0aGlzLmNyZWF0ZUpRUGx1Z2luKCk7XHJcbiAgICAgIC8v57uR5a6a5Li65omL6aOO55C057O75YiXXHJcbiAgICAkKHRoaXMuX2Vscy5tZW51KS5hY2NvcmRpb24oe1xyXG4gICAgICAgIGFjY29yZGlvbjogZmFsc2UsXHJcbiAgICAgICAgc3BlZWQ6IDMwMCxcclxuICAgICAgICBjbG9zZWRTaWduOiAnWytdJyxcclxuICAgICAgICBvcGVuZWRTaWduOiAnWy1dJ1xyXG4gICAgfSk7Ki9cblxuICAgIHZhciAkbWVudSA9ICQoJzxkaXYgaWQ9XCJ2LW1lbnUtcGx1Z2luXCI+PC9kaXY+JykuYXBwZW5kVG8odGhpcy5fZWxzLm1lbnUuZW1wdHkoKSk7XG5cbiAgICByZW5kZXJFbGVtZW50TWVudShcIiN2LW1lbnUtcGx1Z2luXCIsIHRtcE1lbnVzKTtcblxuICAgIC8v57uR5a6aIOaLluaLveS6i+S7tlxuICAgIHRoaXMuYmluZERyYWcodGhpcy5fZWxzLm1lbnUsIHRoaXMuX2Vscy5jaGFydCwgdGhpcy50cmVlTWVudSk7XG59O1xuLy/nu5Hlrprmi5bmi73kuovku7ZcbmNyc1BsdWdpbi5wcm90b3R5cGUuYmluZERyYWcgPSBmdW5jdGlvbiAoJG1lbnVzLCAkY2hhdCwgdHJlZU1lbnUpIHtcbiAgICB2YXIgZHJhZ2dpbmcgPSBmYWxzZSxcbiAgICAgICAgbW92ID0gbnVsbCxcbiAgICAgICAgX3RoaXMgPSB0aGlzLFxuICAgICAgICBpbkFyZWEgPSBmYWxzZSxcbiAgICAgICAgYXJlYVBvaW50ID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgfTtcbiAgICAkbWVudXMub2ZmKCdtb3VzZWRvd24nKS5vbignbW91c2Vkb3duJywgXCJsaS5lbC1tZW51LWl0ZW1cIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgY3VyRG9tID0gdGhpcztcbiAgICAgICAgQWRkTW91c2VNb3ZlRnVuYyhcIm1vdXNlTW92ZV9NZW51XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoIWRyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG1vdiA9IF90aGlzLmNyZWF0TW92KGN1ckRvbSwgdHJlZU1lbnUpO1xuICAgICAgICAgICAgICAgICRjaGF0LmFkZENsYXNzKCdtb3ZpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3YpIHtcbiAgICAgICAgICAgICAgICBtb3Yuc3R5bGUubGVmdCA9IGUucGFnZVggLSAxMCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICBtb3Yuc3R5bGUudG9wID0gZS5wYWdlWSAtIDEwICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy/lhajlsYDlvZPpvKDmoIflt6bplK7lvLnkuIrml7ZcbiAgICAgICAgQWRkTW91c2VVcEZ1bmMoXCJtb3VzZVVwX01lbnVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJlbW92ZU1NUkZ1bmMoXCJtb3VzZU1vdmVfTWVudVwiKTtcbiAgICAgICAgICAgIHJlbW92ZU1VUkZ1bmMoXCJtb3VzZVVwX01lbnVcIik7XG4gICAgICAgICAgICBkcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgJGNoYXQucmVtb3ZlQ2xhc3MoJ21vdmluZycpO1xuICAgICAgICAgICAgaWYgKG1vdikge1xuICAgICAgICAgICAgICAgIGlmIChpbkFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkTmV3VGFzayhtb3YsIGFyZWFQb2ludCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX3RoaXMuZHJvcE1vdihtb3YpO1xuICAgICAgICAgICAgICAgIG1vdiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgJGNoYXQub2ZmKCdtb3VzZW92ZXInKS5vZmYoJ21vdXNlb3V0Jykub2ZmKCdtb3VzZW1vdmUnKS5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGRyYWdnaW5nKSB7XG4gICAgICAgICAgICBpbkFyZWEgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSkub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaW5BcmVhID0gZmFsc2U7XG4gICAgfSkub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChpbkFyZWEpIHtcbiAgICAgICAgICAgIGFyZWFQb2ludC54ID0gZS5vZmZzZXRYO1xuICAgICAgICAgICAgYXJlYVBvaW50LnkgPSBlLm9mZnNldFk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbmNyc1BsdWdpbi5wcm90b3R5cGUuY3JlYXRNb3YgPSBmdW5jdGlvbiAoY29weURvbSwgdHJlZU1lbnUpIHtcbiAgICB2YXIgJGQgPSAkKGNvcHlEb20pO1xuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIHZhciBpbmRleElkID0gJGQuYXR0cihcInRpdGxlXCIpO1xuICAgIHZhciBub2RlID0gZ2V0TWVudUJ5aW5kZXhJZCh0cmVlTWVudSwgaW5kZXhJZCk7XG5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gICAgZGl2LmlubmVySFRNTCA9IFwiPHNwYW4gY2xhc3M9J25vZGUtbmFtZSBcIiArIChub2RlLmNsYXNzIHx8IFwiXCIpICsgXCInIGRhdGEtcHJvY0lkPSdcIiArIG5vZGUucHJvY0lkICsgXCInICBkYXRhLW5vZGVUeXBlPSdcIiArIChub2RlLm5vZGVUeXBlIHx8IDEpICsgXCInPlwiICsgbm9kZS50ZXh0ICsgXCI8L3NwYW4+XCI7XG4gICAgZGl2LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnbWVudS1tb3ZlJyk7XG4gICAgcmV0dXJuIGRpdjtcbn07XG5cbnZhciBnZXRNZW51QnlpbmRleElkID0gZnVuY3Rpb24gZ2V0TWVudUJ5aW5kZXhJZCh0cmVlTWVudSwgaW5kZXhJZCkge1xuXG4gICAgdmFyIGZ1bmMgPSBmdW5jdGlvbiBmdW5jKG1lbnVzKSB7XG4gICAgICAgIHZhciByID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZW51cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG1lbnVzW2ldLmluZGV4SWQgPT0gaW5kZXhJZCkge1xuICAgICAgICAgICAgICAgIHIgPSBtZW51c1tpXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVudXNbaV0uY2hpbGROb2Rlcykge1xuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBmdW5jKG1lbnVzW2ldLmNoaWxkTm9kZXMpO1xuICAgICAgICAgICAgICAgIGlmICh0bXApIHtcbiAgICAgICAgICAgICAgICAgICAgciA9IHRtcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jKHRyZWVNZW51KTtcbn07XG5cbnZhciByZW5kZXJFbGVtZW50TWVudSA9IGZ1bmN0aW9uIHJlbmRlckVsZW1lbnRNZW51KGlkLCBtZW51cykge1xuXG4gICAgdmFyIGNyZWF0ZU1lbnVzID0gZnVuY3Rpb24gY3JlYXRlTWVudXMobWVudXMpIHtcbiAgICAgICAgdmFyIHRtcFN0ciA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVudXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0ID0gaSArIDE7XG4gICAgICAgICAgICBtZW51c1tpXS5pbmRleElkID0gbWVudXNbaV0ucGFyZW50Tm9kZSA/IG1lbnVzW2ldLnBhcmVudE5vZGUuaW5kZXhJZCArICctJyArIHQgOiB0O1xuICAgICAgICAgICAgaWYgKG1lbnVzW2ldLmNoaWxkTm9kZXMgJiYgbWVudXNbaV0uY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdG1wU3RyICs9IFwiPGVsLXN1Ym1lbnUgaW5kZXg9XFxcIlwiICsgbWVudXNbaV0uaW5kZXhJZCArIFwiXFxcIiA+XCI7XG4gICAgICAgICAgICAgICAgdG1wU3RyICs9IFwiPHRlbXBsYXRlIHNsb3Q9XFxcInRpdGxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuPlwiICsgbWVudXNbaV0udGV4dCArIFwiPC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgPC90ZW1wbGF0ZT5cIjtcbiAgICAgICAgICAgICAgICB0bXBTdHIgKz0gY3JlYXRlTWVudXMobWVudXNbaV0uY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICAgICAgdG1wU3RyICs9ICc8L2VsLXN1Ym1lbnU+JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG1wU3RyICs9IFwiPGVsLW1lbnUtaXRlbSBpbmRleD1cXFwiXCIgKyBtZW51c1tpXS5pbmRleElkICsgXCJcXFwiIHRpdGxlPVxcXCJcIiArIG1lbnVzW2ldLmluZGV4SWQgKyBcIlxcXCI+XCIgKyBtZW51c1tpXS50ZXh0ICsgXCI8L2VsLW1lbnUtaXRlbT5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG1wU3RyO1xuICAgIH07XG5cbiAgICB2YXIgc3RyID0gY3JlYXRlTWVudXMobWVudXMpO1xuXG4gICAgdmFyIHJlcyA9IHZ1ZS5jb21waWxlKFwiXFxuICAgIDxlbC1yb3cgY2xhc3M9XFxcInRhYyB2LWRyYWctbWVudXNcXFwiID5cXG4gICAgICAgIDxlbC1jb2wgOnNwYW49XFxcIjI0XFxcIj5cXG4gICAgICAgIDxlbC1tZW51XFxuICAgICAgICAgICAgZGVmYXVsdC1hY3RpdmU9XFxcIjFcXFwiXFxuICAgICAgICAgICAgY2xhc3M9XFxcImVsLW1lbnUtdmVydGljYWwtZGVtb1xcXCJcXG4gICAgICAgICAgICBzdHlsZT1cXFwiYmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudFxcXCJcXG4gICAgICAgICAgICA+XFxuICAgICAgICAgICAgXCIgKyBzdHIgKyBcIlxcbiAgICAgICAgPC9lbC1tZW51PlxcbiAgICAgICAgPC9lbC1jb2w+XFxuICAgIDwvZWwtcm93PlwiKTtcblxuICAgIG5ldyB2dWUoe1xuICAgICAgICBlbDogaWQsXG4gICAgICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1lbnVzOiBtZW51c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW5kZXI6IHJlcy5yZW5kZXIsXG4gICAgICAgIHN0YXRpY1JlbmRlckZuczogcmVzLnN0YXRpY1JlbmRlckZuc1xuICAgIH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JzUGx1Z2luO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdHBsdWdpbi9zcmMvanMvc2NhZmYvY3JzL2Nyc1BsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///117\n')},118:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__scaff_chart_base_chartController_js__ = __webpack_require__(67);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__scaff_menus_base_menuBase_js__ = __webpack_require__(119);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__scaff_prop_properHandle_js__ = __webpack_require__(120);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__tencent_idf_index_js__ = __webpack_require__(69);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__tencent_idf_index_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__tencent_idf_index_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_tippy_js__ = __webpack_require__(154);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_tippy_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_tippy_js__);\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\n\n\n\n\n\n\n\n\n\n\nvar mouse = __WEBPACK_IMPORTED_MODULE_3__tencent_idf_index_js__["Event"].mouse,\n    AddReSizeFunc = mouse.AddReSizeFunc,\n    AddMouseMoveFunc = mouse.AddMouseMoveFunc,\n    AddMouseUpFunc = mouse.AddMouseUpFunc,\n    removeMMRFunc = mouse.removeMMRFunc,\n    removeMURFunc = mouse.removeMURFunc,\n    removeReSizeFunc = mouse.removeReSizeFunc;\n\nvar tplugin = function tplugin(options) {\n    if (typeof options === "undefined") {\n        options = {};\n    }\n    this.mouseEvent = mouse;\n\n    this.chartControlClass = __WEBPACK_IMPORTED_MODULE_0__scaff_chart_base_chartController_js__["a" /* default */];\n    //图形控制器\n    this.chartControl = null;\n    //右侧属性渲染控制器\n    this.properControl = null;\n    //tips渲染控制器\n    this.tipsControl = null;\n    //菜单注册机\n    this.menuRegister = Object.assign({}, __WEBPACK_IMPORTED_MODULE_1__scaff_menus_base_menuBase_js__["b" /* menuRegister */]);\n\n    this.curSelectedNode = null;\n\n    this.options = Object.assign({\n        //菜单数据列表\n        menusData: [],\n\n        //开启属性功能\n        useProp: true,\n        //属性栏目\n        prop: {\n            dataChange: function dataChange() {},\n            methods: {}\n        },\n        //图形参数\n        chart: {\n            //节点单击\n            nodeClick: {\n                cover: false,\n                run: function run(data, node) {}\n            },\n            //节点双击\n            nodeDbClick: {\n                cover: false,\n                run: function run(data, node) {}\n            },\n            //添加节点\n            nodeAdd: {\n                cover: false,\n                run: function run(data, node) {}\n            },\n            //删除节点\n            nodeDel: {\n                cover: false,\n                run: function run(data, node) {}\n            },\n            //容器点击\n            contentClick: {\n                cover: false,\n                run: function run(data, node) {}\n            },\n            nodeMouseenter: {\n                cover: false,\n                run: function run(node) {}\n            },\n            nodeMouseleave: {\n                cover: false,\n                run: function run(node) {}\n            }\n        },\n        useStart: true,\n        useEnd: true\n\n    }, options);\n\n    this.default = {\n        html: "<div class=\\"flowchart-panel\\">\\n                <div class=\\"left\\">\\n                    <ul class=\\"nodes\\" data-flow=\\"menu\\">\\n                    </ul>\\n                </div>\\n                <div class=\\"middle\\" data-flow=\\"middle\\">\\n                    <div class=\\"demo-chart\\">\\n                    \\n                    </div>\\n                    <div class=\\"demo-proto v-menu-pro\\">\\n                        <div ></div>\\n                    </div>\\n                    <div class=\\"v-tippy\\" id=\\"v-tippy\\"></div>\\n                </div>\\n            </div>",\n\n        chart: {\n            parent: null,\n            nodeClick: function nodeClick(data, node) {\n                console.log(this);\n                var _this = this.parent;\n                if (_this.curSelectedNode) {\n                    _this.curSelectedNode.removeClass(\'active\');\n                }\n\n                if (_this._els && _this._els.prop && _this.options.useProp) {\n                    _this._els.prop.addClass(\'active\');\n                }\n                node._el.addClass(\'active\');\n                _this.curSelectedNode = node._el;\n\n                //如果有菜单 唤醒菜单 菜单唯一键 procId\n                var menu = _this.menuRegister.getMenuObj(data.procId);\n\n                if (menu) {\n\n                    //如果 开启属性功能\n                    if (_this.options.useProp && _this.properControl && _this._els) {\n\n                        _this.properControl.render({\n                            el: _this._els.prop.children()[0],\n                            data: data.params,\n                            html: menu.baseHTML + menu.scattHTML,\n                            dataChange: function dataChange(key, newVal) {\n                                //node节点 保存编辑后的数据\n                                node.setParamsOfKey(key, newVal);\n                                if (key === "status") {\n                                    //改变展示的节点UI状态\n                                    node._el.find(\'.node-scatt >b\').text(newVal);\n                                }\n                                if (_this.options.prop.dataChange) {\n                                    _this.options.prop.dataChange(node, key, newVal);\n                                }\n                            },\n\n                            methods: _this.options.prop.methods\n                        });\n                    }\n                } else {\n                    if (_this.options.useProp && _this._els) {\n                        _this.properControl.render({\n                            el: _this._els.prop.children()[0],\n                            data: { aa: 11 },\n                            html: "",\n                            dataChange: function dataChange(key, newVal) {\n                                //node节点 保存编辑后的数据\n                                node.setParamsOfKey(key, newVal);\n                                if (key === "status") {\n                                    //改变展示的节点UI状态\n                                    node._el.find(\'.node-scatt >b\').text(newVal);\n                                }\n                                if (_this.options.prop.dataChange) {\n                                    _this.options.prop.dataChange(node, key, newVal);\n                                }\n                            },\n\n                            methods: _this.options.prop.methods\n                        });\n                    }\n                }\n            },\n            nodeDbClick: function nodeDbClick(data, node) {\n                var _this = this.parent;\n                if (_this.curSelectedNode) {\n                    _this.curSelectedNode.removeClass(\'editor\');\n                }\n                node._el.addClass(\'editor\').children(\'input\').focus();\n            },\n            nodeInputBlur: function nodeInputBlur(data, node) {\n                var _this = this.parent;\n                if (_this.curSelectedNode) {\n                    _this.curSelectedNode.removeClass(\'editor\');\n                }\n            },\n            nodeDel: function nodeDel(data, node) {\n                var _this = this.parent;\n            },\n            contentClick: function contentClick() {\n                var _this = this.parent;\n                if (_this) {\n                    if (_this._els && _this._els.prop) {\n                        _this._els.prop.removeClass(\'active\');\n                    }\n                    //如果有属性模块 那么进行属性栏目销毁 释放内存\n                    if (_this.properHandle) {\n                        _this.properHandle.destroy();\n                    }\n                    if (_this.curSelectedNode) {\n                        _this.curSelectedNode.removeClass(\'active\').removeClass(\'editor\');\n                    }\n                }\n            },\n            /*\r\n                tips绑定事件\r\n            */\n            nodeMouseenter: function nodeMouseenter(node, that, callback) {\n                var _this = this.parent;\n                var content = null;\n                //如果 开启tips功能\n                if (_this.options.useTips) {\n                    //if(node._el[0]._tippy){\n                    //    node._el[0]._tippy.show();\n                    //    content = node._el[0]._tippy.popper.querySelector(\'.tippy-content\');\n                    // }\n                    callback.call(this, node._el, node);\n                }\n            },\n            nodeMouseleave: function nodeMouseleave(node, that, callback) {\n                var _this = this.parent;\n                var content = null;\n                //if(node._el[0]._tippy){\n                //     node._el[0]._tippy.hide();\n                //     content = node._el[0]._tippy.popper.querySelector(\'.tippy-content\');\n                // }\n                callback.call(this, node._el, node);\n            }\n\n        }\n    };\n\n    this.initMenus();\n    this.initOptionCharts();\n\n    //如果开启属性模块,那么实例化属性模块对象\n    if (this.options.useProp) {\n        this.properControl = new __WEBPACK_IMPORTED_MODULE_2__scaff_prop_properHandle_js__["a" /* properHandle */]();\n    }\n    //如果开启TIPS模块,那么实例化属性模块对象\n    if (this.options.useTips) {\n        this.tipsControl = new __WEBPACK_IMPORTED_MODULE_2__scaff_prop_properHandle_js__["a" /* properHandle */]();\n    }\n\n    __WEBPACK_IMPORTED_MODULE_3__tencent_idf_index_js__["Event"].mouse.start();\n\n    if (options._els) {\n        this._els = options._els;\n    }\n};\n\n//待传入的综合参数\ntplugin.prototype.norm = {\n    chart: {}\n\n    //渲染插件\n};tplugin.prototype.render = function (jq, json) {\n    if (this.chartControl) {\n        this.chartControl.clear();\n        this.jq.off().empty();\n    }\n    this.jq = $(jq);\n    this.jq.append(this.default.html);\n    if (!this._els) {\n        this._els = {\n            menu: this.jq.find(\'[data-flow="menu"]\'),\n            chart: this.jq.find(\'[data-flow="middle"] >div:eq(0)\'),\n            prop: this.jq.find(\'[data-flow="middle"] >div:eq(1)\'),\n            tippy: this.jq.find(\'[data-flow="middle"] >div:eq(2)\')\n        };\n    }\n    if (!json) {\n        json = \'{"nodes":[],"connections":[]}\';\n    }\n    this.renderChart(json);\n    this.renderMenus();\n\n    //绑定tippy方法\n    //this.bindTippy();\n};\n\n//获得图形数据\ntplugin.prototype.save = function () {\n    return this.chartControl.toJson();\n};\n\n//初始化&对齐 菜单数据 和 注册的 菜单对象\ntplugin.prototype.initMenus = function () {\n    var _this2 = this;\n\n    var menusData = this.options.menusData;\n    menusData.forEach(function (obj) {\n        var hasMenu = false;\n        _this2.menuRegister.getMenus().forEach(function (menu) {\n            if (menu.procId === obj.procId) {\n                hasMenu = true;\n                for (var i in obj) {\n                    if (_typeof(obj[i]) === "object") {\n                        menu[i] = Object.assign({}, obj[i]);\n                    } else {\n                        menu[i] = obj[i];\n                    }\n                }\n                return false;\n            }\n        });\n        if (!hasMenu) {\n            var menu = new __WEBPACK_IMPORTED_MODULE_1__scaff_menus_base_menuBase_js__["a" /* menuBase */]();\n            for (var i in obj) {\n                if (_typeof(obj[i]) === "object") {\n                    menu[i] = Object.assign({}, obj[i]);\n                } else {\n                    menu[i] = obj[i];\n                }\n            }\n\n            _this2.menuRegister.add(menu);\n        }\n    });\n};\n\n//a初始化&对齐 图形参数\ntplugin.prototype.initOptionCharts = function () {\n\n    this.default.chart.parent = this;\n\n    var charOptions = this.options.chart,\n        _this = this;\n\n    for (var i in charOptions) {\n        if (i === "nodeMouseenter") {\n            (function (key) {\n                this.norm.chart[key] = function (node) {\n                    _this.default.chart[key](node, this, function (popper, node) {\n                        if (charOptions[key].run) {\n                            return charOptions[key].run.call(this, popper, node);\n                        } else {\n                            return charOptions[key].call(this, popper, node);\n                        }\n                    });\n                };\n            }).call(this, i);\n            continue;\n        }\n\n        if (i === "nodeMouseleave") {\n\n            (function (key) {\n                this.norm.chart[key] = function (node) {\n\n                    _this.default.chart[key](node, this, function (popper, node) {\n                        if (charOptions[key].run) {\n                            return charOptions[key].run.call(this, popper, node);\n                        } else {\n                            return charOptions[key].call(this, popper, node);\n                        }\n                    });\n                };\n            }).call(this, i);\n            continue;\n        }\n        if (charOptions[i].cover) {\n            (function (key) {\n                this.norm.chart[key] = charOptions[key].run;\n                this.norm.chart[key].cover = true;\n            }).call(this, i);\n        } else {\n            (function (key) {\n                this.norm.chart[key] = function (data, node) {\n                    if (typeof _this.default.chart[key] === "function") {\n                        _this.default.chart[key](data, node, this);\n                    }\n                    if (charOptions[key].run) {\n\n                        return charOptions[key].run(data, node, this);\n                    } else {\n                        return charOptions[key](data, node, this);\n                    }\n                };\n            }).call(this, i);\n        }\n    }\n};\n\n//渲染图形\ntplugin.prototype.renderChart = function (json) {\n    var _this = this;\n\n    if (!this.chartControl) {\n\n        this.chartControl = new this.chartControlClass(this._els.chart, this.norm.chart);\n    }\n\n    //渲染数据\n    this.chartControl.fromJson(json, {\n        // 节点添加时的回调函数\n        creat: function creat(node, el) {\n            var menu = _this.menuRegister.getMenuObj(node._data.procId);\n\n            if (menu && typeof menu.setNodeElement === "function") {\n                el.append(menu.setNodeElement(node._data.params));\n            }\n        },\n        useStart: this.options.useStart,\n        useEnd: this.options.useEnd\n    });\n};\n\n//渲染菜单\ntplugin.prototype.renderMenus = function (json) {\n\n    var listHtml = \'\';\n    //获取菜单对象的集合\n    var menus = this.menuRegister.getMenus();\n    menus.forEach(function (m) {\n        if ("childNodes" in m) {\n            m.childNodes = [];\n        }\n    });\n\n    var tmpMenus = Object.assign([], menus);\n\n    //处理menus,添加一个关系属性childNodes\n    for (var i = 0; i < tmpMenus.length; i++) {\n        var nodeI = tmpMenus[i];\n        for (var j = 1; j < tmpMenus.length; j++) {\n            if (nodeI.procId == tmpMenus[j].parentId) {\n                if (typeof nodeI.childNodes === "undefined") {\n                    nodeI.childNodes = [];\n                }\n                nodeI.childNodes.push(tmpMenus[j]);\n            }\n        }\n    }\n    //生成树形菜单 => 第一级数组去掉为子节点的数组\n    for (var i = 0; i < tmpMenus.length; i++) {\n\n        if (typeof tmpMenus[i].parentId !== "undefined") {\n            tmpMenus.splice(i, 1);\n            i--;\n        }\n    }\n\n    listHtml = "<ul class=\\"v-topnav\\">" + this.creatMenuHTML(tmpMenus) + "</ul>";\n\n    //渲染出 菜单列表 \n    this._els.menu.empty().append(listHtml);\n\n    this.createJQPlugin();\n\n    //绑定为手风琴系列\n    $(this._els.menu).accordion({\n        accordion: false,\n        speed: 300,\n        closedSign: \'[+]\',\n        openedSign: \'[-]\'\n    });\n\n    //绑定 拖拽事件\n    this.bindDrag(this._els.menu, this._els.chart);\n};\n//根据树形结构 生成html\ntplugin.prototype.creatMenuHTML = function (treeMenus) {\n    var _this3 = this;\n\n    var str = "";\n    treeMenus.forEach(function (node) {\n        if (node.procId === "startnode" || node.procId === "endnode") {\n            return;\n        }\n        if (typeof node.childNodes === "undefined") {\n            str += "<li><span class=\'node-name " + (node.class || "") + "\' data-procId=\'" + node.procId + "\'  data-nodeType=\'" + (node.nodeType || 1) + "\'>" + node.text + "</span></li>";\n        } else {\n            str += "<li>\\n                        <a class=\'node-name " + (node.class || "") + "\' data-procId=\'" + node.procId + "\'  data-nodeType=\'" + (node.nodeType || 1) + "\'>" + node.text + "</a>\\n                    <ul>";\n            str += _this3.creatMenuHTML(node.childNodes);\n            str += "</ul>\\n                    </li>";\n        }\n    });\n\n    return str;\n};\n\n//绑定拖拽事件\ntplugin.prototype.bindDrag = function ($menus, $chat) {\n    var dragging = false,\n        mov = null,\n        _this = this,\n        inArea = false,\n        areaPoint = {\n        x: 0,\n        y: 0\n    };\n    $menus.off(\'mousedown\').on(\'mousedown\', "span.node-name", function (e) {\n        e.preventDefault();\n        var curDom = this;\n        AddMouseMoveFunc("mouseMove_Menu", function (e) {\n            if (!dragging) {\n                dragging = true;\n                mov = _this.creatMov(curDom);\n                $chat.addClass(\'moving\');\n            }\n            if (mov) {\n                mov.style.left = e.pageX - 10 + "px";\n                mov.style.top = e.pageY - 10 + "px";\n            }\n        });\n        //全局当鼠标左键弹上时\n        AddMouseUpFunc("mouseUp_Menu", function (e) {\n            removeMMRFunc("mouseMove_Menu");\n            removeMURFunc("mouseUp_Menu");\n            dragging = false;\n            $chat.removeClass(\'moving\');\n            if (mov) {\n                if (inArea) {\n                    _this.addNewTask(mov, areaPoint);\n                }\n\n                _this.dropMov(mov);\n                mov = null;\n            }\n        });\n    });\n\n    $chat.off(\'mouseover\').off(\'mouseout\').off(\'mousemove\').on(\'mouseover\', function (e) {\n        if (dragging) {\n            inArea = true;\n        }\n    }).on(\'mouseout\', function (e) {\n        inArea = false;\n    }).on(\'mousemove\', function (e) {\n        if (inArea) {\n            areaPoint.x = e.offsetX;\n            areaPoint.y = e.offsetY;\n        }\n    });\n};\n\ntplugin.prototype.creatMov = function (copyDom) {\n    var div = document.createElement(\'div\');\n\n    document.body.appendChild(div);\n    div.innerHTML = copyDom.outerHTML;\n    div.setAttribute(\'class\', \'menu-move\');\n    return div;\n};\n\ntplugin.prototype.dropMov = function (dom) {\n    document.body.removeChild(dom);\n};\n\ntplugin.prototype.addNewTask = function (mov, point) {\n    var _this = this,\n        $t = $(mov).find(\'span\'),\n        menu = this.menuRegister.getMenuObj($t.attr(\'data-procId\')),\n        option = {\n        name: menu.text,\n        point: {\n            x: point.x,\n            y: point.y\n        },\n        data: {\n            //菜单类型标记\n            procId: menu.procId,\n            //菜单附加数据\n            params: $.extend({}, menu.baseData, menu.scattData)\n        },\n        class: "node-process",\n        removable: menu.baseData.removable || true,\n        creat: function creat(node, element) {\n            //menu 自定义一个状态UI, 在node节点上 增加元素\n            if (typeof menu.setNodeElement === "function") {\n                element.append(menu.setNodeElement(node._data.params));\n            }\n        }\n    };\n\n    this.chartControl.addNode(option);\n\n    // 绑定tips事件\n    //this.bindTippy();\n};\n\n//创建 即时的jq插件\ntplugin.prototype.createJQPlugin = function () {\n    (function ($) {\n        $.fn.extend({\n\n            //pass the options variable to the function\n            accordion: function accordion(options) {\n\n                var defaults = {\n                    accordion: \'true\',\n                    speed: 300,\n                    closedSign: \'[+]\',\n                    openedSign: \'[-]\'\n                };\n\n                // Extend our default options with those provided.\n                var opts = $.extend(defaults, options);\n                //Assign current element to variable, in this case is UL element\n                var $this = $(this);\n\n                //add a mark [+] to a multilevel menu\n                $this.find("li").each(function () {\n                    if ($(this).find("ul").size() != 0) {\n                        //add the multilevel sign next to the link\n                        $(this).find("a:first").append("<span>" + opts.closedSign + "</span>");\n\n                        //avoid jumping to the top of the page when the href is an #\n                        if ($(this).find("a:first").attr(\'href\') == "#") {\n                            $(this).find("a:first").click(function () {\n                                return false;\n                            });\n                        }\n                    }\n                });\n\n                //open active level\n                $this.find("li.active").each(function () {\n                    $(this).parents("ul").slideDown(opts.speed);\n                    $(this).parents("ul").parent("li").find("span:first").html(opts.openedSign);\n                });\n\n                $this.find("li a").click(function () {\n                    if ($(this).parent().find("ul").size() != 0) {\n                        if (opts.accordion) {\n                            //Do nothing when the list is open\n                            if (!$(this).parent().find("ul").is(\':visible\')) {\n                                parents = $(this).parent().parents("ul");\n                                visible = $this.find("ul:visible");\n                                visible.each(function (visibleIndex) {\n                                    var close = true;\n                                    parents.each(function (parentIndex) {\n                                        if (parents[parentIndex] == visible[visibleIndex]) {\n                                            close = false;\n                                            return false;\n                                        }\n                                    });\n                                    if (close) {\n                                        if ($(this).parent().find("ul") != visible[visibleIndex]) {\n                                            $(visible[visibleIndex]).slideUp(opts.speed, function () {\n                                                $(this).parent("li").find("span:first").html(opts.closedSign);\n                                            });\n                                        }\n                                    }\n                                });\n                            }\n                        }\n                        if ($(this).parent().removeClass(\'v-active\').find("ul:first").is(":visible")) {\n                            $(this).parent().find("ul:first").slideUp(opts.speed, function () {\n                                $(this).parent("li").find("span:first").delay(opts.speed).html(opts.closedSign);\n                            });\n                        } else {\n                            $(this).parent().addClass(\'v-active\').find("ul:first").slideDown(opts.speed, function () {\n                                $(this).parent("li").find("span:first").delay(opts.speed).html(opts.openedSign);\n                            });\n                        }\n                    }\n                });\n            }\n        });\n    })(jQuery);\n};\n\n// 绑定tips\ntplugin.prototype.bindTippy = function () {\n    var _this = this;\n    this._els.chart.find(\'div.task\').each(function () {\n        if ("_tippy" in this) {\n            return;\n        }\n        __WEBPACK_IMPORTED_MODULE_4_tippy_js___default()(this, {\n            theme: \'honeybee\',\n            animation: \'shift-toward\',\n            arrow: true,\n            html: "#v-tippy",\n            placement: \'right\',\n            trigger: \'\'\n        });\n    });\n};\n\n/* harmony default export */ __webpack_exports__["a"] = (tplugin);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vdHBsdWdpbi9zcmMvanMvdFBsdWdpbi5qcz9iOWZiIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuaW1wb3J0IGNoYXJ0Q29udHJvbCBmcm9tIFwiLi4vLi4vLi4vc2NhZmYvY2hhcnQvYmFzZS9jaGFydENvbnRyb2xsZXIuanNcIjtcblxuaW1wb3J0IHsgbWVudUJhc2UsIG1lbnVSZWdpc3RlciB9IGZyb20gXCIuLi8uLi8uLi9zY2FmZi9tZW51cy9iYXNlL21lbnVCYXNlLmpzXCI7XG5cbmltcG9ydCB7IHByb3BlckhhbmRsZSBhcyBwcm9wZXJDb250cm9sIH0gZnJvbSBcIi4uLy4uLy4uL3NjYWZmL3Byb3AvcHJvcGVySGFuZGxlLmpzXCI7XG5cbmltcG9ydCB7IFV0aWxzLCBFdmVudCB9IGZyb20gXCJAdGVuY2VudC9pZGYvaW5kZXguanNcIjtcblxuaW1wb3J0IHRpcHB5IGZyb20gJ3RpcHB5LmpzJztcblxudmFyIG1vdXNlID0gRXZlbnQubW91c2UsXG4gICAgQWRkUmVTaXplRnVuYyA9IG1vdXNlLkFkZFJlU2l6ZUZ1bmMsXG4gICAgQWRkTW91c2VNb3ZlRnVuYyA9IG1vdXNlLkFkZE1vdXNlTW92ZUZ1bmMsXG4gICAgQWRkTW91c2VVcEZ1bmMgPSBtb3VzZS5BZGRNb3VzZVVwRnVuYyxcbiAgICByZW1vdmVNTVJGdW5jID0gbW91c2UucmVtb3ZlTU1SRnVuYyxcbiAgICByZW1vdmVNVVJGdW5jID0gbW91c2UucmVtb3ZlTVVSRnVuYyxcbiAgICByZW1vdmVSZVNpemVGdW5jID0gbW91c2UucmVtb3ZlUmVTaXplRnVuYztcblxudmFyIHRwbHVnaW4gPSBmdW5jdGlvbiB0cGx1Z2luKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLm1vdXNlRXZlbnQgPSBtb3VzZTtcblxuICAgIHRoaXMuY2hhcnRDb250cm9sQ2xhc3MgPSBjaGFydENvbnRyb2w7XG4gICAgLy/lm77lvaLmjqfliLblmahcbiAgICB0aGlzLmNoYXJ0Q29udHJvbCA9IG51bGw7XG4gICAgLy/lj7PkvqflsZ7mgKfmuLLmn5PmjqfliLblmahcbiAgICB0aGlzLnByb3BlckNvbnRyb2wgPSBudWxsO1xuICAgIC8vdGlwc+a4suafk+aOp+WItuWZqFxuICAgIHRoaXMudGlwc0NvbnRyb2wgPSBudWxsO1xuICAgIC8v6I+c5Y2V5rOo5YaM5py6XG4gICAgdGhpcy5tZW51UmVnaXN0ZXIgPSBPYmplY3QuYXNzaWduKHt9LCBtZW51UmVnaXN0ZXIpO1xuXG4gICAgdGhpcy5jdXJTZWxlY3RlZE5vZGUgPSBudWxsO1xuXG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIC8v6I+c5Y2V5pWw5o2u5YiX6KGoXG4gICAgICAgIG1lbnVzRGF0YTogW10sXG5cbiAgICAgICAgLy/lvIDlkK/lsZ7mgKflip/og71cbiAgICAgICAgdXNlUHJvcDogdHJ1ZSxcbiAgICAgICAgLy/lsZ7mgKfmoI/nm65cbiAgICAgICAgcHJvcDoge1xuICAgICAgICAgICAgZGF0YUNoYW5nZTogZnVuY3Rpb24gZGF0YUNoYW5nZSgpIHt9LFxuICAgICAgICAgICAgbWV0aG9kczoge31cbiAgICAgICAgfSxcbiAgICAgICAgLy/lm77lvaLlj4LmlbBcbiAgICAgICAgY2hhcnQ6IHtcbiAgICAgICAgICAgIC8v6IqC54K55Y2V5Ye7XG4gICAgICAgICAgICBub2RlQ2xpY2s6IHtcbiAgICAgICAgICAgICAgICBjb3ZlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgcnVuOiBmdW5jdGlvbiBydW4oZGF0YSwgbm9kZSkge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvL+iKgueCueWPjOWHu1xuICAgICAgICAgICAgbm9kZURiQ2xpY2s6IHtcbiAgICAgICAgICAgICAgICBjb3ZlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgcnVuOiBmdW5jdGlvbiBydW4oZGF0YSwgbm9kZSkge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvL+a3u+WKoOiKgueCuVxuICAgICAgICAgICAgbm9kZUFkZDoge1xuICAgICAgICAgICAgICAgIGNvdmVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBydW46IGZ1bmN0aW9uIHJ1bihkYXRhLCBub2RlKSB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8v5Yig6Zmk6IqC54K5XG4gICAgICAgICAgICBub2RlRGVsOiB7XG4gICAgICAgICAgICAgICAgY292ZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJ1bjogZnVuY3Rpb24gcnVuKGRhdGEsIG5vZGUpIHt9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy/lrrnlmajngrnlh7tcbiAgICAgICAgICAgIGNvbnRlbnRDbGljazoge1xuICAgICAgICAgICAgICAgIGNvdmVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBydW46IGZ1bmN0aW9uIHJ1bihkYXRhLCBub2RlKSB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5vZGVNb3VzZWVudGVyOiB7XG4gICAgICAgICAgICAgICAgY292ZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJ1bjogZnVuY3Rpb24gcnVuKG5vZGUpIHt9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbm9kZU1vdXNlbGVhdmU6IHtcbiAgICAgICAgICAgICAgICBjb3ZlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgcnVuOiBmdW5jdGlvbiBydW4obm9kZSkge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdXNlU3RhcnQ6IHRydWUsXG4gICAgICAgIHVzZUVuZDogdHJ1ZVxuXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmRlZmF1bHQgPSB7XG4gICAgICAgIGh0bWw6IFwiPGRpdiBjbGFzcz1cXFwiZmxvd2NoYXJ0LXBhbmVsXFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwibGVmdFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8dWwgY2xhc3M9XFxcIm5vZGVzXFxcIiBkYXRhLWZsb3c9XFxcIm1lbnVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPC91bD5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm1pZGRsZVxcXCIgZGF0YS1mbG93PVxcXCJtaWRkbGVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZGVtby1jaGFydFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZGVtby1wcm90byB2LW1lbnUtcHJvXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2ID48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidi10aXBweVxcXCIgaWQ9XFxcInYtdGlwcHlcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cIixcblxuICAgICAgICBjaGFydDoge1xuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgbm9kZUNsaWNrOiBmdW5jdGlvbiBub2RlQ2xpY2soZGF0YSwgbm9kZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMpO1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXMucGFyZW50O1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jdXJTZWxlY3RlZE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY3VyU2VsZWN0ZWROb2RlLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2VscyAmJiBfdGhpcy5fZWxzLnByb3AgJiYgX3RoaXMub3B0aW9ucy51c2VQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9lbHMucHJvcC5hZGRDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUuX2VsLmFkZENsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jdXJTZWxlY3RlZE5vZGUgPSBub2RlLl9lbDtcblxuICAgICAgICAgICAgICAgIC8v5aaC5p6c5pyJ6I+c5Y2VIOWUpOmGkuiPnOWNlSDoj5zljZXllK/kuIDplK4gcHJvY0lkXG4gICAgICAgICAgICAgICAgdmFyIG1lbnUgPSBfdGhpcy5tZW51UmVnaXN0ZXIuZ2V0TWVudU9iaihkYXRhLnByb2NJZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAobWVudSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8v5aaC5p6cIOW8gOWQr+WxnuaAp+WKn+iDvVxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy51c2VQcm9wICYmIF90aGlzLnByb3BlckNvbnRyb2wgJiYgX3RoaXMuX2Vscykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9wZXJDb250cm9sLnJlbmRlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWw6IF90aGlzLl9lbHMucHJvcC5jaGlsZHJlbigpWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEucGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IG1lbnUuYmFzZUhUTUwgKyBtZW51LnNjYXR0SFRNTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhQ2hhbmdlOiBmdW5jdGlvbiBkYXRhQ2hhbmdlKGtleSwgbmV3VmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbm9kZeiKgueCuSDkv53lrZjnvJbovpHlkI7nmoTmlbDmja5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRQYXJhbXNPZktleShrZXksIG5ld1ZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwic3RhdHVzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8v5pS55Y+Y5bGV56S655qE6IqC54K5VUnnirbmgIFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuX2VsLmZpbmQoJy5ub2RlLXNjYXR0ID5iJykudGV4dChuZXdWYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLnByb3AuZGF0YUNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub3B0aW9ucy5wcm9wLmRhdGFDaGFuZ2Uobm9kZSwga2V5LCBuZXdWYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZHM6IF90aGlzLm9wdGlvbnMucHJvcC5tZXRob2RzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLnVzZVByb3AgJiYgX3RoaXMuX2Vscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJvcGVyQ29udHJvbC5yZW5kZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsOiBfdGhpcy5fZWxzLnByb3AuY2hpbGRyZW4oKVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IGFhOiAxMSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUNoYW5nZTogZnVuY3Rpb24gZGF0YUNoYW5nZShrZXksIG5ld1ZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL25vZGXoioLngrkg5L+d5a2Y57yW6L6R5ZCO55qE5pWw5o2uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0UGFyYW1zT2ZLZXkoa2V5LCBuZXdWYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcInN0YXR1c1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL+aUueWPmOWxleekuueahOiKgueCuVVJ54q25oCBXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLl9lbC5maW5kKCcubm9kZS1zY2F0dCA+YicpLnRleHQobmV3VmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5wcm9wLmRhdGFDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9wdGlvbnMucHJvcC5kYXRhQ2hhbmdlKG5vZGUsIGtleSwgbmV3VmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2RzOiBfdGhpcy5vcHRpb25zLnByb3AubWV0aG9kc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbm9kZURiQ2xpY2s6IGZ1bmN0aW9uIG5vZGVEYkNsaWNrKGRhdGEsIG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY3VyU2VsZWN0ZWROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmN1clNlbGVjdGVkTm9kZS5yZW1vdmVDbGFzcygnZWRpdG9yJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUuX2VsLmFkZENsYXNzKCdlZGl0b3InKS5jaGlsZHJlbignaW5wdXQnKS5mb2N1cygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5vZGVJbnB1dEJsdXI6IGZ1bmN0aW9uIG5vZGVJbnB1dEJsdXIoZGF0YSwgbm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXMucGFyZW50O1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jdXJTZWxlY3RlZE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY3VyU2VsZWN0ZWROb2RlLnJlbW92ZUNsYXNzKCdlZGl0b3InKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbm9kZURlbDogZnVuY3Rpb24gbm9kZURlbChkYXRhLCBub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGVudENsaWNrOiBmdW5jdGlvbiBjb250ZW50Q2xpY2soKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fZWxzICYmIF90aGlzLl9lbHMucHJvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Vscy5wcm9wLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL+WmguaenOacieWxnuaAp+aooeWdlyDpgqPkuYjov5vooYzlsZ7mgKfmoI/nm67plIDmr4Eg6YeK5pS+5YaF5a2YXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wZXJIYW5kbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnByb3BlckhhbmRsZS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmN1clNlbGVjdGVkTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY3VyU2VsZWN0ZWROb2RlLnJlbW92ZUNsYXNzKCdhY3RpdmUnKS5yZW1vdmVDbGFzcygnZWRpdG9yJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgIHRpcHPnu5Hlrprkuovku7ZcclxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG5vZGVNb3VzZWVudGVyOiBmdW5jdGlvbiBub2RlTW91c2VlbnRlcihub2RlLCB0aGF0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXMucGFyZW50O1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvL+WmguaenCDlvIDlkK90aXBz5Yqf6IO9XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMudXNlVGlwcykge1xuICAgICAgICAgICAgICAgICAgICAvL2lmKG5vZGUuX2VsWzBdLl90aXBweSl7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgIG5vZGUuX2VsWzBdLl90aXBweS5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgIGNvbnRlbnQgPSBub2RlLl9lbFswXS5fdGlwcHkucG9wcGVyLnF1ZXJ5U2VsZWN0b3IoJy50aXBweS1jb250ZW50Jyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBub2RlLl9lbCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5vZGVNb3VzZWxlYXZlOiBmdW5jdGlvbiBub2RlTW91c2VsZWF2ZShub2RlLCB0aGF0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXMucGFyZW50O1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvL2lmKG5vZGUuX2VsWzBdLl90aXBweSl7XG4gICAgICAgICAgICAgICAgLy8gICAgIG5vZGUuX2VsWzBdLl90aXBweS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgLy8gICAgIGNvbnRlbnQgPSBub2RlLl9lbFswXS5fdGlwcHkucG9wcGVyLnF1ZXJ5U2VsZWN0b3IoJy50aXBweS1jb250ZW50Jyk7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgbm9kZS5fZWwsIG5vZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5pbml0TWVudXMoKTtcbiAgICB0aGlzLmluaXRPcHRpb25DaGFydHMoKTtcblxuICAgIC8v5aaC5p6c5byA5ZCv5bGe5oCn5qih5Z2XLOmCo+S5iOWunuS+i+WMluWxnuaAp+aooeWdl+WvueixoVxuICAgIGlmICh0aGlzLm9wdGlvbnMudXNlUHJvcCkge1xuICAgICAgICB0aGlzLnByb3BlckNvbnRyb2wgPSBuZXcgcHJvcGVyQ29udHJvbCgpO1xuICAgIH1cbiAgICAvL+WmguaenOW8gOWQr1RJUFPmqKHlnZcs6YKj5LmI5a6e5L6L5YyW5bGe5oCn5qih5Z2X5a+56LGhXG4gICAgaWYgKHRoaXMub3B0aW9ucy51c2VUaXBzKSB7XG4gICAgICAgIHRoaXMudGlwc0NvbnRyb2wgPSBuZXcgcHJvcGVyQ29udHJvbCgpO1xuICAgIH1cblxuICAgIEV2ZW50Lm1vdXNlLnN0YXJ0KCk7XG5cbiAgICBpZiAob3B0aW9ucy5fZWxzKSB7XG4gICAgICAgIHRoaXMuX2VscyA9IG9wdGlvbnMuX2VscztcbiAgICB9XG59O1xuXG4vL+W+heS8oOWFpeeahOe7vOWQiOWPguaVsFxudHBsdWdpbi5wcm90b3R5cGUubm9ybSA9IHtcbiAgICBjaGFydDoge31cblxuICAgIC8v5riy5p+T5o+S5Lu2XG59O3RwbHVnaW4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChqcSwganNvbikge1xuICAgIGlmICh0aGlzLmNoYXJ0Q29udHJvbCkge1xuICAgICAgICB0aGlzLmNoYXJ0Q29udHJvbC5jbGVhcigpO1xuICAgICAgICB0aGlzLmpxLm9mZigpLmVtcHR5KCk7XG4gICAgfVxuICAgIHRoaXMuanEgPSAkKGpxKTtcbiAgICB0aGlzLmpxLmFwcGVuZCh0aGlzLmRlZmF1bHQuaHRtbCk7XG4gICAgaWYgKCF0aGlzLl9lbHMpIHtcbiAgICAgICAgdGhpcy5fZWxzID0ge1xuICAgICAgICAgICAgbWVudTogdGhpcy5qcS5maW5kKCdbZGF0YS1mbG93PVwibWVudVwiXScpLFxuICAgICAgICAgICAgY2hhcnQ6IHRoaXMuanEuZmluZCgnW2RhdGEtZmxvdz1cIm1pZGRsZVwiXSA+ZGl2OmVxKDApJyksXG4gICAgICAgICAgICBwcm9wOiB0aGlzLmpxLmZpbmQoJ1tkYXRhLWZsb3c9XCJtaWRkbGVcIl0gPmRpdjplcSgxKScpLFxuICAgICAgICAgICAgdGlwcHk6IHRoaXMuanEuZmluZCgnW2RhdGEtZmxvdz1cIm1pZGRsZVwiXSA+ZGl2OmVxKDIpJylcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFqc29uKSB7XG4gICAgICAgIGpzb24gPSAne1wibm9kZXNcIjpbXSxcImNvbm5lY3Rpb25zXCI6W119JztcbiAgICB9XG4gICAgdGhpcy5yZW5kZXJDaGFydChqc29uKTtcbiAgICB0aGlzLnJlbmRlck1lbnVzKCk7XG5cbiAgICAvL+e7keWumnRpcHB55pa55rOVXG4gICAgLy90aGlzLmJpbmRUaXBweSgpO1xufTtcblxuLy/ojrflvpflm77lvaLmlbDmja5cbnRwbHVnaW4ucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnRDb250cm9sLnRvSnNvbigpO1xufTtcblxuLy/liJ3lp4vljJYm5a+56b2QIOiPnOWNleaVsOaNriDlkowg5rOo5YaM55qEIOiPnOWNleWvueixoVxudHBsdWdpbi5wcm90b3R5cGUuaW5pdE1lbnVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIG1lbnVzRGF0YSA9IHRoaXMub3B0aW9ucy5tZW51c0RhdGE7XG4gICAgbWVudXNEYXRhLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgaGFzTWVudSA9IGZhbHNlO1xuICAgICAgICBfdGhpczIubWVudVJlZ2lzdGVyLmdldE1lbnVzKCkuZm9yRWFjaChmdW5jdGlvbiAobWVudSkge1xuICAgICAgICAgICAgaWYgKG1lbnUucHJvY0lkID09PSBvYmoucHJvY0lkKSB7XG4gICAgICAgICAgICAgICAgaGFzTWVudSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90eXBlb2Yob2JqW2ldKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVudVtpXSA9IE9iamVjdC5hc3NpZ24oe30sIG9ialtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZW51W2ldID0gb2JqW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaGFzTWVudSkge1xuICAgICAgICAgICAgdmFyIG1lbnUgPSBuZXcgbWVudUJhc2UoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90eXBlb2Yob2JqW2ldKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBtZW51W2ldID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqW2ldKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZW51W2ldID0gb2JqW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX3RoaXMyLm1lbnVSZWdpc3Rlci5hZGQobWVudSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8vYeWIneWni+WMliblr7npvZAg5Zu+5b2i5Y+C5pWwXG50cGx1Z2luLnByb3RvdHlwZS5pbml0T3B0aW9uQ2hhcnRzID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5kZWZhdWx0LmNoYXJ0LnBhcmVudCA9IHRoaXM7XG5cbiAgICB2YXIgY2hhck9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuY2hhcnQsXG4gICAgICAgIF90aGlzID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgaW4gY2hhck9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGkgPT09IFwibm9kZU1vdXNlZW50ZXJcIikge1xuICAgICAgICAgICAgKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vcm0uY2hhcnRba2V5XSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRlZmF1bHQuY2hhcnRba2V5XShub2RlLCB0aGlzLCBmdW5jdGlvbiAocG9wcGVyLCBub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhck9wdGlvbnNba2V5XS5ydW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhck9wdGlvbnNba2V5XS5ydW4uY2FsbCh0aGlzLCBwb3BwZXIsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhck9wdGlvbnNba2V5XS5jYWxsKHRoaXMsIHBvcHBlciwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KS5jYWxsKHRoaXMsIGkpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaSA9PT0gXCJub2RlTW91c2VsZWF2ZVwiKSB7XG5cbiAgICAgICAgICAgIChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3JtLmNoYXJ0W2tleV0gPSBmdW5jdGlvbiAobm9kZSkge1xuXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRlZmF1bHQuY2hhcnRba2V5XShub2RlLCB0aGlzLCBmdW5jdGlvbiAocG9wcGVyLCBub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhck9wdGlvbnNba2V5XS5ydW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhck9wdGlvbnNba2V5XS5ydW4uY2FsbCh0aGlzLCBwb3BwZXIsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhck9wdGlvbnNba2V5XS5jYWxsKHRoaXMsIHBvcHBlciwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KS5jYWxsKHRoaXMsIGkpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXJPcHRpb25zW2ldLmNvdmVyKSB7XG4gICAgICAgICAgICAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9ybS5jaGFydFtrZXldID0gY2hhck9wdGlvbnNba2V5XS5ydW47XG4gICAgICAgICAgICAgICAgdGhpcy5ub3JtLmNoYXJ0W2tleV0uY292ZXIgPSB0cnVlO1xuICAgICAgICAgICAgfSkuY2FsbCh0aGlzLCBpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3JtLmNoYXJ0W2tleV0gPSBmdW5jdGlvbiAoZGF0YSwgbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIF90aGlzLmRlZmF1bHQuY2hhcnRba2V5XSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kZWZhdWx0LmNoYXJ0W2tleV0oZGF0YSwgbm9kZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJPcHRpb25zW2tleV0ucnVuKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFyT3B0aW9uc1trZXldLnJ1bihkYXRhLCBub2RlLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFyT3B0aW9uc1trZXldKGRhdGEsIG5vZGUsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pLmNhbGwodGhpcywgaSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vL+a4suafk+WbvuW9olxudHBsdWdpbi5wcm90b3R5cGUucmVuZGVyQ2hhcnQgPSBmdW5jdGlvbiAoanNvbikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoIXRoaXMuY2hhcnRDb250cm9sKSB7XG5cbiAgICAgICAgdGhpcy5jaGFydENvbnRyb2wgPSBuZXcgdGhpcy5jaGFydENvbnRyb2xDbGFzcyh0aGlzLl9lbHMuY2hhcnQsIHRoaXMubm9ybS5jaGFydCk7XG4gICAgfVxuXG4gICAgLy/muLLmn5PmlbDmja5cbiAgICB0aGlzLmNoYXJ0Q29udHJvbC5mcm9tSnNvbihqc29uLCB7XG4gICAgICAgIC8vIOiKgueCuea3u+WKoOaXtueahOWbnuiwg+WHveaVsFxuICAgICAgICBjcmVhdDogZnVuY3Rpb24gY3JlYXQobm9kZSwgZWwpIHtcbiAgICAgICAgICAgIHZhciBtZW51ID0gX3RoaXMubWVudVJlZ2lzdGVyLmdldE1lbnVPYmoobm9kZS5fZGF0YS5wcm9jSWQpO1xuXG4gICAgICAgICAgICBpZiAobWVudSAmJiB0eXBlb2YgbWVudS5zZXROb2RlRWxlbWVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgZWwuYXBwZW5kKG1lbnUuc2V0Tm9kZUVsZW1lbnQobm9kZS5fZGF0YS5wYXJhbXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdXNlU3RhcnQ6IHRoaXMub3B0aW9ucy51c2VTdGFydCxcbiAgICAgICAgdXNlRW5kOiB0aGlzLm9wdGlvbnMudXNlRW5kXG4gICAgfSk7XG59O1xuXG4vL+a4suafk+iPnOWNlVxudHBsdWdpbi5wcm90b3R5cGUucmVuZGVyTWVudXMgPSBmdW5jdGlvbiAoanNvbikge1xuXG4gICAgdmFyIGxpc3RIdG1sID0gJyc7XG4gICAgLy/ojrflj5boj5zljZXlr7nosaHnmoTpm4blkIhcbiAgICB2YXIgbWVudXMgPSB0aGlzLm1lbnVSZWdpc3Rlci5nZXRNZW51cygpO1xuICAgIG1lbnVzLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgaWYgKFwiY2hpbGROb2Rlc1wiIGluIG0pIHtcbiAgICAgICAgICAgIG0uY2hpbGROb2RlcyA9IFtdO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgdG1wTWVudXMgPSBPYmplY3QuYXNzaWduKFtdLCBtZW51cyk7XG5cbiAgICAvL+WkhOeQhm1lbnVzLOa3u+WKoOS4gOS4quWFs+ezu+WxnuaAp2NoaWxkTm9kZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRtcE1lbnVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlSSA9IHRtcE1lbnVzW2ldO1xuICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHRtcE1lbnVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAobm9kZUkucHJvY0lkID09IHRtcE1lbnVzW2pdLnBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlSS5jaGlsZE5vZGVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJLmNoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZUkuY2hpbGROb2Rlcy5wdXNoKHRtcE1lbnVzW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvL+eUn+aIkOagkeW9ouiPnOWNlSA9PiDnrKzkuIDnuqfmlbDnu4TljrvmjonkuLrlrZDoioLngrnnmoTmlbDnu4RcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRtcE1lbnVzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0bXBNZW51c1tpXS5wYXJlbnRJZCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdG1wTWVudXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGlzdEh0bWwgPSBcIjx1bCBjbGFzcz1cXFwidi10b3BuYXZcXFwiPlwiICsgdGhpcy5jcmVhdE1lbnVIVE1MKHRtcE1lbnVzKSArIFwiPC91bD5cIjtcblxuICAgIC8v5riy5p+T5Ye6IOiPnOWNleWIl+ihqCBcbiAgICB0aGlzLl9lbHMubWVudS5lbXB0eSgpLmFwcGVuZChsaXN0SHRtbCk7XG5cbiAgICB0aGlzLmNyZWF0ZUpRUGx1Z2luKCk7XG5cbiAgICAvL+e7keWumuS4uuaJi+mjjueQtOezu+WIl1xuICAgICQodGhpcy5fZWxzLm1lbnUpLmFjY29yZGlvbih7XG4gICAgICAgIGFjY29yZGlvbjogZmFsc2UsXG4gICAgICAgIHNwZWVkOiAzMDAsXG4gICAgICAgIGNsb3NlZFNpZ246ICdbK10nLFxuICAgICAgICBvcGVuZWRTaWduOiAnWy1dJ1xuICAgIH0pO1xuXG4gICAgLy/nu5Hlrpog5ouW5ou95LqL5Lu2XG4gICAgdGhpcy5iaW5kRHJhZyh0aGlzLl9lbHMubWVudSwgdGhpcy5fZWxzLmNoYXJ0KTtcbn07XG4vL+agueaNruagkeW9oue7k+aehCDnlJ/miJBodG1sXG50cGx1Z2luLnByb3RvdHlwZS5jcmVhdE1lbnVIVE1MID0gZnVuY3Rpb24gKHRyZWVNZW51cykge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgdHJlZU1lbnVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUucHJvY0lkID09PSBcInN0YXJ0bm9kZVwiIHx8IG5vZGUucHJvY0lkID09PSBcImVuZG5vZGVcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZS5jaGlsZE5vZGVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBzdHIgKz0gXCI8bGk+PHNwYW4gY2xhc3M9J25vZGUtbmFtZSBcIiArIChub2RlLmNsYXNzIHx8IFwiXCIpICsgXCInIGRhdGEtcHJvY0lkPSdcIiArIG5vZGUucHJvY0lkICsgXCInICBkYXRhLW5vZGVUeXBlPSdcIiArIChub2RlLm5vZGVUeXBlIHx8IDEpICsgXCInPlwiICsgbm9kZS50ZXh0ICsgXCI8L3NwYW4+PC9saT5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ciArPSBcIjxsaT5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz0nbm9kZS1uYW1lIFwiICsgKG5vZGUuY2xhc3MgfHwgXCJcIikgKyBcIicgZGF0YS1wcm9jSWQ9J1wiICsgbm9kZS5wcm9jSWQgKyBcIicgIGRhdGEtbm9kZVR5cGU9J1wiICsgKG5vZGUubm9kZVR5cGUgfHwgMSkgKyBcIic+XCIgKyBub2RlLnRleHQgKyBcIjwvYT5cXG4gICAgICAgICAgICAgICAgICAgIDx1bD5cIjtcbiAgICAgICAgICAgIHN0ciArPSBfdGhpczMuY3JlYXRNZW51SFRNTChub2RlLmNoaWxkTm9kZXMpO1xuICAgICAgICAgICAgc3RyICs9IFwiPC91bD5cXG4gICAgICAgICAgICAgICAgICAgIDwvbGk+XCI7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBzdHI7XG59O1xuXG4vL+e7keWumuaLluaLveS6i+S7tlxudHBsdWdpbi5wcm90b3R5cGUuYmluZERyYWcgPSBmdW5jdGlvbiAoJG1lbnVzLCAkY2hhdCkge1xuICAgIHZhciBkcmFnZ2luZyA9IGZhbHNlLFxuICAgICAgICBtb3YgPSBudWxsLFxuICAgICAgICBfdGhpcyA9IHRoaXMsXG4gICAgICAgIGluQXJlYSA9IGZhbHNlLFxuICAgICAgICBhcmVhUG9pbnQgPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICB9O1xuICAgICRtZW51cy5vZmYoJ21vdXNlZG93bicpLm9uKCdtb3VzZWRvd24nLCBcInNwYW4ubm9kZS1uYW1lXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIGN1ckRvbSA9IHRoaXM7XG4gICAgICAgIEFkZE1vdXNlTW92ZUZ1bmMoXCJtb3VzZU1vdmVfTWVudVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKCFkcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIGRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBtb3YgPSBfdGhpcy5jcmVhdE1vdihjdXJEb20pO1xuICAgICAgICAgICAgICAgICRjaGF0LmFkZENsYXNzKCdtb3ZpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3YpIHtcbiAgICAgICAgICAgICAgICBtb3Yuc3R5bGUubGVmdCA9IGUucGFnZVggLSAxMCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICBtb3Yuc3R5bGUudG9wID0gZS5wYWdlWSAtIDEwICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy/lhajlsYDlvZPpvKDmoIflt6bplK7lvLnkuIrml7ZcbiAgICAgICAgQWRkTW91c2VVcEZ1bmMoXCJtb3VzZVVwX01lbnVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJlbW92ZU1NUkZ1bmMoXCJtb3VzZU1vdmVfTWVudVwiKTtcbiAgICAgICAgICAgIHJlbW92ZU1VUkZ1bmMoXCJtb3VzZVVwX01lbnVcIik7XG4gICAgICAgICAgICBkcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgJGNoYXQucmVtb3ZlQ2xhc3MoJ21vdmluZycpO1xuICAgICAgICAgICAgaWYgKG1vdikge1xuICAgICAgICAgICAgICAgIGlmIChpbkFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkTmV3VGFzayhtb3YsIGFyZWFQb2ludCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX3RoaXMuZHJvcE1vdihtb3YpO1xuICAgICAgICAgICAgICAgIG1vdiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgJGNoYXQub2ZmKCdtb3VzZW92ZXInKS5vZmYoJ21vdXNlb3V0Jykub2ZmKCdtb3VzZW1vdmUnKS5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGRyYWdnaW5nKSB7XG4gICAgICAgICAgICBpbkFyZWEgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSkub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaW5BcmVhID0gZmFsc2U7XG4gICAgfSkub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChpbkFyZWEpIHtcbiAgICAgICAgICAgIGFyZWFQb2ludC54ID0gZS5vZmZzZXRYO1xuICAgICAgICAgICAgYXJlYVBvaW50LnkgPSBlLm9mZnNldFk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbnRwbHVnaW4ucHJvdG90eXBlLmNyZWF0TW92ID0gZnVuY3Rpb24gKGNvcHlEb20pIHtcbiAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gICAgZGl2LmlubmVySFRNTCA9IGNvcHlEb20ub3V0ZXJIVE1MO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ21lbnUtbW92ZScpO1xuICAgIHJldHVybiBkaXY7XG59O1xuXG50cGx1Z2luLnByb3RvdHlwZS5kcm9wTW92ID0gZnVuY3Rpb24gKGRvbSkge1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZG9tKTtcbn07XG5cbnRwbHVnaW4ucHJvdG90eXBlLmFkZE5ld1Rhc2sgPSBmdW5jdGlvbiAobW92LCBwb2ludCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICR0ID0gJChtb3YpLmZpbmQoJ3NwYW4nKSxcbiAgICAgICAgbWVudSA9IHRoaXMubWVudVJlZ2lzdGVyLmdldE1lbnVPYmooJHQuYXR0cignZGF0YS1wcm9jSWQnKSksXG4gICAgICAgIG9wdGlvbiA9IHtcbiAgICAgICAgbmFtZTogbWVudS50ZXh0LFxuICAgICAgICBwb2ludDoge1xuICAgICAgICAgICAgeDogcG9pbnQueCxcbiAgICAgICAgICAgIHk6IHBvaW50LnlcbiAgICAgICAgfSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgLy/oj5zljZXnsbvlnovmoIforrBcbiAgICAgICAgICAgIHByb2NJZDogbWVudS5wcm9jSWQsXG4gICAgICAgICAgICAvL+iPnOWNlemZhOWKoOaVsOaNrlxuICAgICAgICAgICAgcGFyYW1zOiAkLmV4dGVuZCh7fSwgbWVudS5iYXNlRGF0YSwgbWVudS5zY2F0dERhdGEpXG4gICAgICAgIH0sXG4gICAgICAgIGNsYXNzOiBcIm5vZGUtcHJvY2Vzc1wiLFxuICAgICAgICByZW1vdmFibGU6IG1lbnUuYmFzZURhdGEucmVtb3ZhYmxlIHx8IHRydWUsXG4gICAgICAgIGNyZWF0OiBmdW5jdGlvbiBjcmVhdChub2RlLCBlbGVtZW50KSB7XG4gICAgICAgICAgICAvL21lbnUg6Ieq5a6a5LmJ5LiA5Liq54q25oCBVUksIOWcqG5vZGXoioLngrnkuIog5aKe5Yqg5YWD57SgXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lbnUuc2V0Tm9kZUVsZW1lbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kKG1lbnUuc2V0Tm9kZUVsZW1lbnQobm9kZS5fZGF0YS5wYXJhbXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmNoYXJ0Q29udHJvbC5hZGROb2RlKG9wdGlvbik7XG5cbiAgICAvLyDnu5Hlrpp0aXBz5LqL5Lu2XG4gICAgLy90aGlzLmJpbmRUaXBweSgpO1xufTtcblxuLy/liJvlu7og5Y2z5pe255qEanHmj5Lku7ZcbnRwbHVnaW4ucHJvdG90eXBlLmNyZWF0ZUpRUGx1Z2luID0gZnVuY3Rpb24gKCkge1xuICAgIChmdW5jdGlvbiAoJCkge1xuICAgICAgICAkLmZuLmV4dGVuZCh7XG5cbiAgICAgICAgICAgIC8vcGFzcyB0aGUgb3B0aW9ucyB2YXJpYWJsZSB0byB0aGUgZnVuY3Rpb25cbiAgICAgICAgICAgIGFjY29yZGlvbjogZnVuY3Rpb24gYWNjb3JkaW9uKG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3JkaW9uOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgICAgIHNwZWVkOiAzMDAsXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlZFNpZ246ICdbK10nLFxuICAgICAgICAgICAgICAgICAgICBvcGVuZWRTaWduOiAnWy1dJ1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBFeHRlbmQgb3VyIGRlZmF1bHQgb3B0aW9ucyB3aXRoIHRob3NlIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAgIHZhciBvcHRzID0gJC5leHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIC8vQXNzaWduIGN1cnJlbnQgZWxlbWVudCB0byB2YXJpYWJsZSwgaW4gdGhpcyBjYXNlIGlzIFVMIGVsZW1lbnRcbiAgICAgICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgLy9hZGQgYSBtYXJrIFsrXSB0byBhIG11bHRpbGV2ZWwgbWVudVxuICAgICAgICAgICAgICAgICR0aGlzLmZpbmQoXCJsaVwiKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCQodGhpcykuZmluZChcInVsXCIpLnNpemUoKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2FkZCB0aGUgbXVsdGlsZXZlbCBzaWduIG5leHQgdG8gdGhlIGxpbmtcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykuZmluZChcImE6Zmlyc3RcIikuYXBwZW5kKFwiPHNwYW4+XCIgKyBvcHRzLmNsb3NlZFNpZ24gKyBcIjwvc3Bhbj5cIik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYXZvaWQganVtcGluZyB0byB0aGUgdG9wIG9mIHRoZSBwYWdlIHdoZW4gdGhlIGhyZWYgaXMgYW4gI1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCQodGhpcykuZmluZChcImE6Zmlyc3RcIikuYXR0cignaHJlZicpID09IFwiI1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5maW5kKFwiYTpmaXJzdFwiKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy9vcGVuIGFjdGl2ZSBsZXZlbFxuICAgICAgICAgICAgICAgICR0aGlzLmZpbmQoXCJsaS5hY3RpdmVcIikuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcykucGFyZW50cyhcInVsXCIpLnNsaWRlRG93bihvcHRzLnNwZWVkKTtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5wYXJlbnRzKFwidWxcIikucGFyZW50KFwibGlcIikuZmluZChcInNwYW46Zmlyc3RcIikuaHRtbChvcHRzLm9wZW5lZFNpZ24pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgJHRoaXMuZmluZChcImxpIGFcIikuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoJCh0aGlzKS5wYXJlbnQoKS5maW5kKFwidWxcIikuc2l6ZSgpICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLmFjY29yZGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vRG8gbm90aGluZyB3aGVuIHRoZSBsaXN0IGlzIG9wZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISQodGhpcykucGFyZW50KCkuZmluZChcInVsXCIpLmlzKCc6dmlzaWJsZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudHMgPSAkKHRoaXMpLnBhcmVudCgpLnBhcmVudHMoXCJ1bFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJsZSA9ICR0aGlzLmZpbmQoXCJ1bDp2aXNpYmxlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmxlLmVhY2goZnVuY3Rpb24gKHZpc2libGVJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsb3NlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudHMuZWFjaChmdW5jdGlvbiAocGFyZW50SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50c1twYXJlbnRJbmRleF0gPT0gdmlzaWJsZVt2aXNpYmxlSW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkKHRoaXMpLnBhcmVudCgpLmZpbmQoXCJ1bFwiKSAhPSB2aXNpYmxlW3Zpc2libGVJbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh2aXNpYmxlW3Zpc2libGVJbmRleF0pLnNsaWRlVXAob3B0cy5zcGVlZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5wYXJlbnQoXCJsaVwiKS5maW5kKFwic3BhbjpmaXJzdFwiKS5odG1sKG9wdHMuY2xvc2VkU2lnbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCQodGhpcykucGFyZW50KCkucmVtb3ZlQ2xhc3MoJ3YtYWN0aXZlJykuZmluZChcInVsOmZpcnN0XCIpLmlzKFwiOnZpc2libGVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLnBhcmVudCgpLmZpbmQoXCJ1bDpmaXJzdFwiKS5zbGlkZVVwKG9wdHMuc3BlZWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5wYXJlbnQoXCJsaVwiKS5maW5kKFwic3BhbjpmaXJzdFwiKS5kZWxheShvcHRzLnNwZWVkKS5odG1sKG9wdHMuY2xvc2VkU2lnbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykucGFyZW50KCkuYWRkQ2xhc3MoJ3YtYWN0aXZlJykuZmluZChcInVsOmZpcnN0XCIpLnNsaWRlRG93bihvcHRzLnNwZWVkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykucGFyZW50KFwibGlcIikuZmluZChcInNwYW46Zmlyc3RcIikuZGVsYXkob3B0cy5zcGVlZCkuaHRtbChvcHRzLm9wZW5lZFNpZ24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pKGpRdWVyeSk7XG59O1xuXG4vLyDnu5Hlrpp0aXBzXG50cGx1Z2luLnByb3RvdHlwZS5iaW5kVGlwcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLl9lbHMuY2hhcnQuZmluZCgnZGl2LnRhc2snKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKFwiX3RpcHB5XCIgaW4gdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRpcHB5KHRoaXMsIHtcbiAgICAgICAgICAgIHRoZW1lOiAnaG9uZXliZWUnLFxuICAgICAgICAgICAgYW5pbWF0aW9uOiAnc2hpZnQtdG93YXJkJyxcbiAgICAgICAgICAgIGFycm93OiB0cnVlLFxuICAgICAgICAgICAgaHRtbDogXCIjdi10aXBweVwiLFxuICAgICAgICAgICAgcGxhY2VtZW50OiAncmlnaHQnLFxuICAgICAgICAgICAgdHJpZ2dlcjogJydcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB0cGx1Z2luO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdHBsdWdpbi9zcmMvanMvdFBsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///118\n')},119:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return menuBases; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_menu_menuBase_js__ = __webpack_require__(68);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_0__core_menu_menuBase_js__["b"]; });\n\n\nvar menuBases = function menuBases() {\n    __WEBPACK_IMPORTED_MODULE_0__core_menu_menuBase_js__["a" /* menuBase */].call(this);\n\n    this.procId = "0";\n    this.text = "";\n    //组件的 公共数据结构\n    this.baseData = $.extend(this.baseData, {});\n\n    //组件的 特性数据结构\n    this.scattData = {};\n\n    //添加后的节点是否可以删除\n    this.baseData.removable = true;\n\n    //特性模板\n    this.scattHTML = "";\n\n    //设置 图形节点的内容\n    this.setNodeElement = function (data) {\n\n        return "";\n    };\n};\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc2NhZmYvbWVudXMvYmFzZS9tZW51QmFzZS5qcz9kYzgyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1lbnVCYXNlLCBtZW51UmVnaXN0ZXIgfSBmcm9tICcuLi8uLi8uLi9jb3JlL21lbnUvbWVudUJhc2UuanMnO1xuXG52YXIgbWVudUJhc2VzID0gZnVuY3Rpb24gbWVudUJhc2VzKCkge1xuICAgIG1lbnVCYXNlLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnByb2NJZCA9IFwiMFwiO1xuICAgIHRoaXMudGV4dCA9IFwiXCI7XG4gICAgLy/nu4Tku7bnmoQg5YWs5YWx5pWw5o2u57uT5p6EXG4gICAgdGhpcy5iYXNlRGF0YSA9ICQuZXh0ZW5kKHRoaXMuYmFzZURhdGEsIHt9KTtcblxuICAgIC8v57uE5Lu255qEIOeJueaAp+aVsOaNrue7k+aehFxuICAgIHRoaXMuc2NhdHREYXRhID0ge307XG5cbiAgICAvL+a3u+WKoOWQjueahOiKgueCueaYr+WQpuWPr+S7peWIoOmZpFxuICAgIHRoaXMuYmFzZURhdGEucmVtb3ZhYmxlID0gdHJ1ZTtcblxuICAgIC8v54m55oCn5qih5p2/XG4gICAgdGhpcy5zY2F0dEhUTUwgPSBcIlwiO1xuXG4gICAgLy/orr7nva4g5Zu+5b2i6IqC54K555qE5YaF5a65XG4gICAgdGhpcy5zZXROb2RlRWxlbWVudCA9IGZ1bmN0aW9uIChkYXRhKSB7XG5cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfTtcbn07XG5cbmV4cG9ydCB7IG1lbnVCYXNlcyBhcyBtZW51QmFzZSwgbWVudVJlZ2lzdGVyIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zY2FmZi9tZW51cy9iYXNlL21lbnVCYXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///119\n')},120:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return properHandles; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_prop_properHandle_js__ = __webpack_require__(121);\n\nvar properHandles = function properHandles() {\n    __WEBPACK_IMPORTED_MODULE_0__core_prop_properHandle_js__["a" /* default */].call(this);\n};\nproperHandles.prototype = new __WEBPACK_IMPORTED_MODULE_0__core_prop_properHandle_js__["a" /* default */]();\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc2NhZmYvcHJvcC9wcm9wZXJIYW5kbGUuanM/YzljYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcHJvcGVySGFuZGxlIGZyb20gJy4uLy4uL2NvcmUvcHJvcC9wcm9wZXJIYW5kbGUuanMnO1xudmFyIHByb3BlckhhbmRsZXMgPSBmdW5jdGlvbiBwcm9wZXJIYW5kbGVzKCkge1xuICAgIHByb3BlckhhbmRsZS5jYWxsKHRoaXMpO1xufTtcbnByb3BlckhhbmRsZXMucHJvdG90eXBlID0gbmV3IHByb3BlckhhbmRsZSgpO1xuXG5leHBvcnQgeyBwcm9wZXJIYW5kbGVzIGFzIHByb3BlckhhbmRsZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc2NhZmYvcHJvcC9wcm9wZXJIYW5kbGUuanNcbi8vIG1vZHVsZSBpZCA9IDEyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///120\n')},121:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_vue__);\n\n\nvar properHandle = function properHandle() {\n    this._vue = null;\n    this.ptComponet = null;\n    this.unwatchs = [];\n\n    this.extend = $.extend;\n\n    var ptMixin = {\n        template: "<div></div>",\n\n        methods: {}\n\n    };\n    this.ptComponet = __WEBPACK_IMPORTED_MODULE_0_vue___default.a.extend({\n        mixins: [ptMixin]\n    });\n};\n\nproperHandle.prototype.render = function (options) {\n    var _this = this;\n\n    this.options = this.extend({\n        el: "",\n        data: {},\n        html: "",\n        dataChange: function dataChange() {}\n\n    }, options);\n\n    var _data = JSON.parse(JSON.stringify(this.options.data)),\n        methods = this.extend({}, this.options.methods);\n\n    this.destroy();\n\n    this._vue = new this.ptComponet({\n        el: this.options.el,\n        data: function data() {\n            return _data;\n        },\n\n        template: "<div>" + this.options.html + "</div>",\n        methods: methods\n    });\n\n    for (var i in this.options.data) {\n        (function (tmpKey) {\n            var unwatch = _this._vue.$watch(tmpKey, function (newVal, oldVal) {\n                _this.options.dataChange(tmpKey, newVal, oldVal);\n            }, {\n                deep: true\n            });\n            _this.unwatchs.push(unwatch);\n        })(i);\n    }\n};\n//销毁实例vue对象\nproperHandle.prototype.destroy = function () {\n    if (this._vue) {\n        if (this.unwatchs.length > 0) {\n            this.unwatchs.forEach(function (unwatch) {\n\n                unwatch();\n            });\n            this.unwatchs = [];\n        }\n        this._vue.$destroy();\n        this._vue = null;\n    }\n};\n\n/* harmony default export */ __webpack_exports__["a"] = (properHandle);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vY29yZS9wcm9wL3Byb3BlckhhbmRsZS5qcz80YTFiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBWdWUgZnJvbSAndnVlJztcblxudmFyIHByb3BlckhhbmRsZSA9IGZ1bmN0aW9uIHByb3BlckhhbmRsZSgpIHtcbiAgICB0aGlzLl92dWUgPSBudWxsO1xuICAgIHRoaXMucHRDb21wb25ldCA9IG51bGw7XG4gICAgdGhpcy51bndhdGNocyA9IFtdO1xuXG4gICAgdGhpcy5leHRlbmQgPSAkLmV4dGVuZDtcblxuICAgIHZhciBwdE1peGluID0ge1xuICAgICAgICB0ZW1wbGF0ZTogXCI8ZGl2PjwvZGl2PlwiLFxuXG4gICAgICAgIG1ldGhvZHM6IHt9XG5cbiAgICB9O1xuICAgIHRoaXMucHRDb21wb25ldCA9IFZ1ZS5leHRlbmQoe1xuICAgICAgICBtaXhpbnM6IFtwdE1peGluXVxuICAgIH0pO1xufTtcblxucHJvcGVySGFuZGxlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLmV4dGVuZCh7XG4gICAgICAgIGVsOiBcIlwiLFxuICAgICAgICBkYXRhOiB7fSxcbiAgICAgICAgaHRtbDogXCJcIixcbiAgICAgICAgZGF0YUNoYW5nZTogZnVuY3Rpb24gZGF0YUNoYW5nZSgpIHt9XG5cbiAgICB9LCBvcHRpb25zKTtcblxuICAgIHZhciBfZGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5vcHRpb25zLmRhdGEpKSxcbiAgICAgICAgbWV0aG9kcyA9IHRoaXMuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMubWV0aG9kcyk7XG5cbiAgICB0aGlzLmRlc3Ryb3koKTtcblxuICAgIHRoaXMuX3Z1ZSA9IG5ldyB0aGlzLnB0Q29tcG9uZXQoe1xuICAgICAgICBlbDogdGhpcy5vcHRpb25zLmVsLFxuICAgICAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9kYXRhO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRlbXBsYXRlOiBcIjxkaXY+XCIgKyB0aGlzLm9wdGlvbnMuaHRtbCArIFwiPC9kaXY+XCIsXG4gICAgICAgIG1ldGhvZHM6IG1ldGhvZHNcbiAgICB9KTtcblxuICAgIGZvciAodmFyIGkgaW4gdGhpcy5vcHRpb25zLmRhdGEpIHtcbiAgICAgICAgKGZ1bmN0aW9uICh0bXBLZXkpIHtcbiAgICAgICAgICAgIHZhciB1bndhdGNoID0gX3RoaXMuX3Z1ZS4kd2F0Y2godG1wS2V5LCBmdW5jdGlvbiAobmV3VmFsLCBvbGRWYWwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vcHRpb25zLmRhdGFDaGFuZ2UodG1wS2V5LCBuZXdWYWwsIG9sZFZhbCk7XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgZGVlcDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpcy51bndhdGNocy5wdXNoKHVud2F0Y2gpO1xuICAgICAgICB9KShpKTtcbiAgICB9XG59O1xuLy/plIDmr4Hlrp7kvot2dWXlr7nosaFcbnByb3BlckhhbmRsZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fdnVlKSB7XG4gICAgICAgIGlmICh0aGlzLnVud2F0Y2hzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMudW53YXRjaHMuZm9yRWFjaChmdW5jdGlvbiAodW53YXRjaCkge1xuXG4gICAgICAgICAgICAgICAgdW53YXRjaCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnVud2F0Y2hzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdnVlLiRkZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX3Z1ZSA9IG51bGw7XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgcHJvcGVySGFuZGxlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29yZS9wcm9wL3Byb3BlckhhbmRsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///121\n')},155:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib_comm_chart_check_js__ = __webpack_require__(156);\n\nvar crsCheck = function crsCheck() {\n    __WEBPACK_IMPORTED_MODULE_0__lib_comm_chart_check_js__["a" /* default */].call(this);\n    this.base = new __WEBPACK_IMPORTED_MODULE_0__lib_comm_chart_check_js__["a" /* default */]();\n\n    this.island = function (json) {\n        //自定义\n        return this.base.island(json);\n    };\n};\n\n/* harmony default export */ __webpack_exports__["a"] = (crsCheck);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc2NhZmYvY2hhcnQvY3JzQ2hpbGQvY3JzQ2hlY2suanM/MDFhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY2hlY2tCYXNlIGZyb20gXCIuLi8uLi8uLi9saWIvY29tbS9jaGFydC9jaGVjay5qc1wiO1xudmFyIGNyc0NoZWNrID0gZnVuY3Rpb24gY3JzQ2hlY2soKSB7XG4gICAgY2hlY2tCYXNlLmNhbGwodGhpcyk7XG4gICAgdGhpcy5iYXNlID0gbmV3IGNoZWNrQmFzZSgpO1xuXG4gICAgdGhpcy5pc2xhbmQgPSBmdW5jdGlvbiAoanNvbikge1xuICAgICAgICAvL+iHquWumuS5iVxuICAgICAgICByZXR1cm4gdGhpcy5iYXNlLmlzbGFuZChqc29uKTtcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JzQ2hlY2s7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zY2FmZi9jaGFydC9jcnNDaGlsZC9jcnNDaGVjay5qc1xuLy8gbW9kdWxlIGlkID0gMTU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///155\n')},156:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('var check = function check() {\n\n    /**\r\n     * 检测合法性 \r\n        参数： \r\n         {string} funcNames 方法名 多方法以空格隔开 \r\n         {object} json数据 图形控件.toJson的返回值  \r\n    */\n    this.check = function (funcNames, json) {\n        var _this = this;\n\n        var blg = true;\n        var funcArr = funcNames.replace(/\\s+/g, " ").trim(),\n            blgArr = [];\n\n        funcArr.split(" ").forEach(function (funcName) {\n            if (funcName in _this) {\n                blgArr.push(_this[funcName](json));\n            }\n        });\n\n        blgArr.forEach(function (bl) {\n            blg = blg && bl;\n            if (blg === false) {\n                return false;\n            }\n        });\n\n        return blg;\n    };\n\n    // 空函数\n    this.none = function (json) {\n        return true;\n    };\n\n    // 检测闭环\n    this.closedLoop = function (json) {\n        if (typeof json === "undefined") {\n            return true;\n        }\n        if (!"connections" in json) {\n            return true;\n        }\n        var connections = json.connections,\n            nodes = [],\n            pageTargetIds = [];\n\n        var addNodes = function addNodes(sourceId, targetId) {\n            var hasSourceNode = false,\n                hasTargetNode = false;\n            nodes.forEach(function (n) {\n                if (n.id === sourceId) {\n                    hasSourceNode = true;\n                    n.targetIds.push(targetId);\n                }\n                if (n.id === targetId) {\n                    hasTargetNode = true;\n                    n.sourceIds.push(sourceId);\n                }\n            });\n\n            if (hasSourceNode === false) {\n                nodes.push({\n                    id: sourceId,\n                    targetIds: [targetId],\n                    sourceIds: []\n                });\n                if (sourceId === targetId) {\n                    nodes[nodes.length - 1].sourceIds.push(sourceId);\n                }\n            }\n            if (hasTargetNode === false) {\n                nodes.push({\n                    id: targetId,\n                    targetIds: [],\n                    sourceIds: [sourceId]\n                });\n            }\n        };\n\n        connections.forEach(function (c) {\n            addNodes(c.pageSourceId, c.pageTargetId);\n        });\n\n        var blg = true;\n        nodes.forEach(function (n) {\n            var sourceIds = n.sourceIds;\n            sourceIds.forEach(function (sid) {\n                n.targetIds.forEach(function (tid) {\n                    if (sid === tid) {\n                        blg = false;\n                        return false;\n                    }\n                });\n            });\n        });\n\n        return blg;\n    };\n\n    //检测 孤立节点\n    this.island = function (json) {\n        if (typeof json === "undefined") {\n            return true;\n        }\n        if (!("connections" in json && "nodes" in json)) {\n            return true;\n        }\n\n        var connections = json.connections,\n            nodes = json.nodes,\n            blg = true;\n\n        nodes.forEach(function (n) {\n            var id = n.elId,\n                hasNode = false;\n\n            connections.forEach(function (c) {\n                if (id === c.pageSourceId) {\n                    hasNode = true;\n                    return false;\n                }\n\n                if (id === c.pageTargetId) {\n                    hasNode = true;\n                    return false;\n                }\n            });\n\n            if (!hasNode) {\n                blg = false;\n                return false;\n            }\n        });\n\n        return blg;\n    };\n};\n\n/* harmony default export */ __webpack_exports__["a"] = (check);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbW0vY2hhcnQvY2hlY2suanM/NjM2MCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY2hlY2sgPSBmdW5jdGlvbiBjaGVjaygpIHtcblxuICAgIC8qKlxyXG4gICAgICog5qOA5rWL5ZCI5rOV5oCnIFxyXG4gICAgICAgIOWPguaVsO+8miBcclxuICAgICAgICAge3N0cmluZ30gZnVuY05hbWVzIOaWueazleWQjSDlpJrmlrnms5Xku6XnqbrmoLzpmpTlvIAgXHJcbiAgICAgICAgIHtvYmplY3R9IGpzb27mlbDmja4g5Zu+5b2i5o6n5Lu2LnRvSnNvbueahOi/lOWbnuWAvCAgXHJcbiAgICAqL1xuICAgIHRoaXMuY2hlY2sgPSBmdW5jdGlvbiAoZnVuY05hbWVzLCBqc29uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGJsZyA9IHRydWU7XG4gICAgICAgIHZhciBmdW5jQXJyID0gZnVuY05hbWVzLnJlcGxhY2UoL1xccysvZywgXCIgXCIpLnRyaW0oKSxcbiAgICAgICAgICAgIGJsZ0FyciA9IFtdO1xuXG4gICAgICAgIGZ1bmNBcnIuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24gKGZ1bmNOYW1lKSB7XG4gICAgICAgICAgICBpZiAoZnVuY05hbWUgaW4gX3RoaXMpIHtcbiAgICAgICAgICAgICAgICBibGdBcnIucHVzaChfdGhpc1tmdW5jTmFtZV0oanNvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBibGdBcnIuZm9yRWFjaChmdW5jdGlvbiAoYmwpIHtcbiAgICAgICAgICAgIGJsZyA9IGJsZyAmJiBibDtcbiAgICAgICAgICAgIGlmIChibGcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYmxnO1xuICAgIH07XG5cbiAgICAvLyDnqbrlh73mlbBcbiAgICB0aGlzLm5vbmUgPSBmdW5jdGlvbiAoanNvbikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLy8g5qOA5rWL6Zet546vXG4gICAgdGhpcy5jbG9zZWRMb29wID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIVwiY29ubmVjdGlvbnNcIiBpbiBqc29uKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29ubmVjdGlvbnMgPSBqc29uLmNvbm5lY3Rpb25zLFxuICAgICAgICAgICAgbm9kZXMgPSBbXSxcbiAgICAgICAgICAgIHBhZ2VUYXJnZXRJZHMgPSBbXTtcblxuICAgICAgICB2YXIgYWRkTm9kZXMgPSBmdW5jdGlvbiBhZGROb2Rlcyhzb3VyY2VJZCwgdGFyZ2V0SWQpIHtcbiAgICAgICAgICAgIHZhciBoYXNTb3VyY2VOb2RlID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgaGFzVGFyZ2V0Tm9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgIGlmIChuLmlkID09PSBzb3VyY2VJZCkge1xuICAgICAgICAgICAgICAgICAgICBoYXNTb3VyY2VOb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbi50YXJnZXRJZHMucHVzaCh0YXJnZXRJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuLmlkID09PSB0YXJnZXRJZCkge1xuICAgICAgICAgICAgICAgICAgICBoYXNUYXJnZXROb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbi5zb3VyY2VJZHMucHVzaChzb3VyY2VJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChoYXNTb3VyY2VOb2RlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogc291cmNlSWQsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldElkczogW3RhcmdldElkXSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlSWRzOiBbXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VJZCA9PT0gdGFyZ2V0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0uc291cmNlSWRzLnB1c2goc291cmNlSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNUYXJnZXROb2RlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogdGFyZ2V0SWQsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldElkczogW10sXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUlkczogW3NvdXJjZUlkXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbm5lY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIGFkZE5vZGVzKGMucGFnZVNvdXJjZUlkLCBjLnBhZ2VUYXJnZXRJZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBibGcgPSB0cnVlO1xuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlSWRzID0gbi5zb3VyY2VJZHM7XG4gICAgICAgICAgICBzb3VyY2VJZHMuZm9yRWFjaChmdW5jdGlvbiAoc2lkKSB7XG4gICAgICAgICAgICAgICAgbi50YXJnZXRJZHMuZm9yRWFjaChmdW5jdGlvbiAodGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWQgPT09IHRpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYmxnO1xuICAgIH07XG5cbiAgICAvL+ajgOa1iyDlraTnq4voioLngrlcbiAgICB0aGlzLmlzbGFuZCA9IGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoXCJjb25uZWN0aW9uc1wiIGluIGpzb24gJiYgXCJub2Rlc1wiIGluIGpzb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb25uZWN0aW9ucyA9IGpzb24uY29ubmVjdGlvbnMsXG4gICAgICAgICAgICBub2RlcyA9IGpzb24ubm9kZXMsXG4gICAgICAgICAgICBibGcgPSB0cnVlO1xuXG4gICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIHZhciBpZCA9IG4uZWxJZCxcbiAgICAgICAgICAgICAgICBoYXNOb2RlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGNvbm5lY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWQgPT09IGMucGFnZVNvdXJjZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc05vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGlkID09PSBjLnBhZ2VUYXJnZXRJZCkge1xuICAgICAgICAgICAgICAgICAgICBoYXNOb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWhhc05vZGUpIHtcbiAgICAgICAgICAgICAgICBibGcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBibGc7XG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNoZWNrO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NvbW0vY2hhcnQvY2hlY2suanNcbi8vIG1vZHVsZSBpZCA9IDE1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///156\n')},157:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__base_chartBase_js__ = __webpack_require__(158);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__base_chartController_js__ = __webpack_require__(67);\n\n\n\nvar crschartController = function crschartController(select, options) {\n    //继承\n    __WEBPACK_IMPORTED_MODULE_1__base_chartController_js__["a" /* default */].call(this, select, options);\n    //设置 base对象\n    this.base = new __WEBPACK_IMPORTED_MODULE_1__base_chartController_js__["a" /* default */]();\n    //创建图形\n    this.createFlow(__WEBPACK_IMPORTED_MODULE_0__base_chartBase_js__["a" /* default */]);\n    //绑定chart引用\n    this.base.chart = this.chart;\n\n    /** \r\n        开始覆写 xxxx\r\n    */\n    this.fromJson = function (json, option) {\n        this.base.fromJson(json, option);\n    };\n};\n\n/* harmony default export */ __webpack_exports__["a"] = (crschartController);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc2NhZmYvY2hhcnQvY3JzQ2hpbGQvY3JzY2hhcnRDb250cm9sbGVyLmpzP2QwZGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENoYXJ0IGZyb20gJy4uL2Jhc2UvY2hhcnRCYXNlLmpzJztcbmltcG9ydCBjaGFydENvbnRyb2xsZXIgZnJvbSAnLi4vYmFzZS9jaGFydENvbnRyb2xsZXIuanMnO1xuXG52YXIgY3JzY2hhcnRDb250cm9sbGVyID0gZnVuY3Rpb24gY3JzY2hhcnRDb250cm9sbGVyKHNlbGVjdCwgb3B0aW9ucykge1xuICAgIC8v57un5om/XG4gICAgY2hhcnRDb250cm9sbGVyLmNhbGwodGhpcywgc2VsZWN0LCBvcHRpb25zKTtcbiAgICAvL+iuvue9riBiYXNl5a+56LGhXG4gICAgdGhpcy5iYXNlID0gbmV3IGNoYXJ0Q29udHJvbGxlcigpO1xuICAgIC8v5Yib5bu65Zu+5b2iXG4gICAgdGhpcy5jcmVhdGVGbG93KENoYXJ0KTtcbiAgICAvL+e7keWummNoYXJ05byV55SoXG4gICAgdGhpcy5iYXNlLmNoYXJ0ID0gdGhpcy5jaGFydDtcblxuICAgIC8qKiBcclxuICAgICAgICDlvIDlp4vopoblhpkgeHh4eFxyXG4gICAgKi9cbiAgICB0aGlzLmZyb21Kc29uID0gZnVuY3Rpb24gKGpzb24sIG9wdGlvbikge1xuICAgICAgICB0aGlzLmJhc2UuZnJvbUpzb24oanNvbiwgb3B0aW9uKTtcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JzY2hhcnRDb250cm9sbGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc2NhZmYvY2hhcnQvY3JzQ2hpbGQvY3JzY2hhcnRDb250cm9sbGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///157\n')},158:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_chart_chart_js__ = __webpack_require__(159);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__chartNodeBase_js__ = __webpack_require__(161);\n\n\n\nvar chartBase = function chartBase(container, options) {\n\n    __WEBPACK_IMPORTED_MODULE_0__core_chart_chart_js__["a" /* default */].call(this, container, options);\n\n    this.base = new __WEBPACK_IMPORTED_MODULE_0__core_chart_chart_js__["a" /* default */]();\n\n    this.ChartNode = __WEBPACK_IMPORTED_MODULE_1__chartNodeBase_js__["a" /* default */];\n\n    /**\r\n     * 添加起点\r\n     * @param {obj} options node参数\r\n     */\n    this.addNodeStart = function (options) {\n        options = $.extend({\n            html: \'\\n            <div class="window task taskcircle taskcirclestart">\\n            </div> \\n            \'\n        }, options);\n        var node = this.base.addNode.call(this, options);\n        var _this = this;\n\n        node.addSmallPort({\n            isSource: true,\n            dragOptions: {\n                stop: function stop(e) {\n\n                    var connections = _this._jsPlumb.getConnections({\n                        source: $(e.drag.el).attr("elid")\n                    });\n\n                    _this.bindConnections(connections, this._nodes, this.options);\n                }\n            }\n        });\n        return node;\n    };\n\n    /**\r\n     * 添加终点\r\n     * @param {obj} options node参数\r\n     */\n    this.addNodeEnd = function (options) {\n        options = $.extend({\n            html: \'\\n            <div class="window task taskcircle taskcirclend">\\n            </div> \\n            \'\n        }, options);\n        var node = this.base.addNode.call(this, options);\n        node.addSmallPort({\n            isTarget: true,\n            position: \'Top\'\n        });\n        return node;\n    };\n\n    /**\r\n     * 起点连接线\r\n     * @param {obj} item connection参数\r\n     */\n    this.connectStart = function (item) {\n        this._jsPlumb.makeTarget(item.pageTargetId, {\n            anchor: "Top",\n            isTarget: true,\n            maxConnections: -1\n        });\n\n        return this._jsPlumb.connect({\n            source: item.pageSourceId,\n            target: item.pageTargetId,\n            deleteEndpointsOnDetach: true,\n\n            paintStyle: {\n                stroke: "#1fb139",\n                strokeWidth: 2\n            },\n            connector: ["Bezier", {\n                curviness: 100\n            }],\n            endpoints: [["Dot", {\n                radius: 4\n            }], ["Dot", {\n                radius: 6,\n                cssClass: "jspl-point-top"\n            }]],\n            endpointStyles: [{\n                fillStyle: \'#1fb139\'\n            }, {\n                fill: "#f65d3b",\n                stroke: "rgba(0,0,0,0)",\n                strokeWidth: 8\n            }]\n        });\n    };\n\n    /**\r\n     * 终点连接线\r\n     * @param {obj} item connection参数\r\n     */\n    this.connectEnd = function (item) {\n        this._jsPlumb.makeTarget(item.pageTargetId, {\n            anchor: "Top",\n            isTarget: true,\n            maxConnections: -1\n        });\n\n        return this._jsPlumb.connect({\n            source: item.pageSourceId,\n            target: item.pageTargetId,\n            deleteEndpointsOnDetach: true,\n\n            paintStyle: {\n                stroke: "#0096f2",\n                strokeWidth: 2\n            },\n            connector: ["Bezier", {\n                curviness: 100\n            }],\n            endpoints: [["Dot", {\n                radius: 6\n            }], ["Dot", {\n                radius: 4,\n                cssClass: "jspl-point-top"\n            }]],\n            endpointStyles: [{\n                fillStyle: \'#0096f2\'\n            }, {\n                fill: "#f65d3b",\n                stroke: "rgba(0,0,0,0)",\n                strokeWidth: 8\n            }]\n        });\n    };\n\n    /**\r\n     *  图形导出为json\r\n     *  重写基础类\r\n     */\n    this.toJson = function () {\n        var _this2 = this;\n\n        // 获取所有节点\n        var nodes = [];\n        this._nodes.forEach(function (item) {\n\n            nodes.push(item.toPlainObj());\n        });\n\n        // 获取所有连接\n        var connections = this._jsPlumb.getAllConnections().map(function (connection) {\n\n            var rJson = {\n                connectionId: connection.id,\n                pageSourceId: connection.sourceId,\n                pageTargetId: connection.targetId\n            };\n\n            var sourceNode = _this2.getNodeById(connection.sourceId);\n\n            if (sourceNode._options && sourceNode._options.nodeStyle === "start") {\n                rJson.nodeStyle = "start";\n            } else {\n                var targetNode = _this2.getNodeById(connection.targetId);\n                if (targetNode._options && targetNode._options.nodeStyle === "end") {\n                    rJson.nodeStyle = "end";\n                }\n            }\n\n            return rJson;\n        });\n\n        return {\n            nodes: nodes,\n            connections: connections\n        };\n    };\n\n    /**\r\n     * 渲染节点\r\n     * @param {obj} nodes nodes数组\r\n     * @param {obj} options options 来自fromJson的输入参数 {creat,useStart,useEnd}\r\n     * \r\n     * 覆写基础类 \r\n     */\n    this.renderNodes = function (nodes, options) {\n        var _this3 = this;\n\n        this.base.renderNodes.call(this, nodes, options);\n\n        options = $.extend({\n            useStart: true,\n            useEnd: true\n        }, options);\n\n        var startBlg = true,\n            endBlg = true;\n\n        if (options.useStart) {\n            startBlg = false;\n        }\n        if (options.useEnd) {\n            endBlg = false;\n        }\n\n        nodes && nodes.forEach(function (item) {\n            var op = {\n                name: item.name,\n                point: {\n                    x: item._x,\n                    y: item._y\n                },\n                data: item,\n                class: item.className,\n                removable: item.removable,\n                nodeId: item.nodeId,\n                unPort: true,\n                nodeStyle: item.nodeStyle\n            };\n\n            switch (item.nodeStyle) {\n                case "start":\n                    _this3.addNodeStart(op);\n                    startBlg = true;\n                    break;\n                case "end":\n                    _this3.addNodeEnd(op);\n                    endBlg = true;\n                    break;\n            }\n        });\n\n        if (!startBlg) {\n            this.addNodeStart({\n                name: \'\',\n                point: {\n                    x: 25,\n                    y: 25\n                },\n                class: \'\',\n                removable: false,\n                nodeId: null,\n                data: {},\n                creat: false,\n                unPort: true,\n                nodeStyle: "start"\n            });\n        }\n        if (!endBlg) {\n            this.addNodeEnd({\n                name: \'\',\n                point: {\n                    x: 25,\n                    y: 210\n                },\n                class: \'\',\n                removable: false,\n                nodeId: null,\n                data: {},\n                creat: false,\n                unPort: true,\n                nodeStyle: "end"\n            });\n        }\n    };\n\n    /**\r\n     * 渲染连接线与点\r\n     * @param {obj} connections connections数组\r\n     * \r\n     * 覆写基础类 \r\n     */\n    this.renderConnections = function (connections, nodes, options) {\n        var _this4 = this;\n\n        this.base.renderConnections.call(this, connections, nodes, options);\n\n        connections && connections.forEach(function (item) {\n            var connect = null;\n            switch (item.nodeStyle) {\n                case "start":\n\n                    connect = _this4.connectStart(item);\n                    break;\n                case "end":\n\n                    connect = _this4.connectEnd(item);\n                    break;\n            }\n            if (connect) {\n                var node = _this4.getNodeById(item.pageSourceId);\n\n                node.connectorEvent.init(node, connect, options);\n            }\n        });\n    };\n};\n\nchartBase.prototype = new __WEBPACK_IMPORTED_MODULE_0__core_chart_chart_js__["a" /* default */]();\n\n/* harmony default export */ __webpack_exports__["a"] = (chartBase);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc2NhZmYvY2hhcnQvYmFzZS9jaGFydEJhc2UuanM/MjExOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY2hhcnRDb3JlIGZyb20gJy4uLy4uLy4uL2NvcmUvY2hhcnQvY2hhcnQuanMnO1xuaW1wb3J0IGNoYXJ0Tm9kZUJhc2UgZnJvbSAnLi9jaGFydE5vZGVCYXNlLmpzJztcblxudmFyIGNoYXJ0QmFzZSA9IGZ1bmN0aW9uIGNoYXJ0QmFzZShjb250YWluZXIsIG9wdGlvbnMpIHtcblxuICAgIGNoYXJ0Q29yZS5jYWxsKHRoaXMsIGNvbnRhaW5lciwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmJhc2UgPSBuZXcgY2hhcnRDb3JlKCk7XG5cbiAgICB0aGlzLkNoYXJ0Tm9kZSA9IGNoYXJ0Tm9kZUJhc2U7XG5cbiAgICAvKipcclxuICAgICAqIOa3u+WKoOi1t+eCuVxyXG4gICAgICogQHBhcmFtIHtvYmp9IG9wdGlvbnMgbm9kZeWPguaVsFxyXG4gICAgICovXG4gICAgdGhpcy5hZGROb2RlU3RhcnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gJC5leHRlbmQoe1xuICAgICAgICAgICAgaHRtbDogJ1xcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ3aW5kb3cgdGFzayB0YXNrY2lyY2xlIHRhc2tjaXJjbGVzdGFydFwiPlxcbiAgICAgICAgICAgIDwvZGl2PiBcXG4gICAgICAgICAgICAnXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYmFzZS5hZGROb2RlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgbm9kZS5hZGRTbWFsbFBvcnQoe1xuICAgICAgICAgICAgaXNTb3VyY2U6IHRydWUsXG4gICAgICAgICAgICBkcmFnT3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHN0b3A6IGZ1bmN0aW9uIHN0b3AoZSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25uZWN0aW9ucyA9IF90aGlzLl9qc1BsdW1iLmdldENvbm5lY3Rpb25zKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogJChlLmRyYWcuZWwpLmF0dHIoXCJlbGlkXCIpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmJpbmRDb25uZWN0aW9ucyhjb25uZWN0aW9ucywgdGhpcy5fbm9kZXMsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcblxuICAgIC8qKlxyXG4gICAgICog5re75Yqg57uI54K5XHJcbiAgICAgKiBAcGFyYW0ge29ian0gb3B0aW9ucyBub2Rl5Y+C5pWwXHJcbiAgICAgKi9cbiAgICB0aGlzLmFkZE5vZGVFbmQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gJC5leHRlbmQoe1xuICAgICAgICAgICAgaHRtbDogJ1xcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ3aW5kb3cgdGFzayB0YXNrY2lyY2xlIHRhc2tjaXJjbGVuZFwiPlxcbiAgICAgICAgICAgIDwvZGl2PiBcXG4gICAgICAgICAgICAnXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYmFzZS5hZGROb2RlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIG5vZGUuYWRkU21hbGxQb3J0KHtcbiAgICAgICAgICAgIGlzVGFyZ2V0OiB0cnVlLFxuICAgICAgICAgICAgcG9zaXRpb246ICdUb3AnXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuXG4gICAgLyoqXHJcbiAgICAgKiDotbfngrnov57mjqXnur9cclxuICAgICAqIEBwYXJhbSB7b2JqfSBpdGVtIGNvbm5lY3Rpb27lj4LmlbBcclxuICAgICAqL1xuICAgIHRoaXMuY29ubmVjdFN0YXJ0ID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5fanNQbHVtYi5tYWtlVGFyZ2V0KGl0ZW0ucGFnZVRhcmdldElkLCB7XG4gICAgICAgICAgICBhbmNob3I6IFwiVG9wXCIsXG4gICAgICAgICAgICBpc1RhcmdldDogdHJ1ZSxcbiAgICAgICAgICAgIG1heENvbm5lY3Rpb25zOiAtMVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fanNQbHVtYi5jb25uZWN0KHtcbiAgICAgICAgICAgIHNvdXJjZTogaXRlbS5wYWdlU291cmNlSWQsXG4gICAgICAgICAgICB0YXJnZXQ6IGl0ZW0ucGFnZVRhcmdldElkLFxuICAgICAgICAgICAgZGVsZXRlRW5kcG9pbnRzT25EZXRhY2g6IHRydWUsXG5cbiAgICAgICAgICAgIHBhaW50U3R5bGU6IHtcbiAgICAgICAgICAgICAgICBzdHJva2U6IFwiIzFmYjEzOVwiLFxuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29ubmVjdG9yOiBbXCJCZXppZXJcIiwge1xuICAgICAgICAgICAgICAgIGN1cnZpbmVzczogMTAwXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIGVuZHBvaW50czogW1tcIkRvdFwiLCB7XG4gICAgICAgICAgICAgICAgcmFkaXVzOiA0XG4gICAgICAgICAgICB9XSwgW1wiRG90XCIsIHtcbiAgICAgICAgICAgICAgICByYWRpdXM6IDYsXG4gICAgICAgICAgICAgICAgY3NzQ2xhc3M6IFwianNwbC1wb2ludC10b3BcIlxuICAgICAgICAgICAgfV1dLFxuICAgICAgICAgICAgZW5kcG9pbnRTdHlsZXM6IFt7XG4gICAgICAgICAgICAgICAgZmlsbFN0eWxlOiAnIzFmYjEzOSdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBmaWxsOiBcIiNmNjVkM2JcIixcbiAgICAgICAgICAgICAgICBzdHJva2U6IFwicmdiYSgwLDAsMCwwKVwiLFxuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiA4XG4gICAgICAgICAgICB9XVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXHJcbiAgICAgKiDnu4jngrnov57mjqXnur9cclxuICAgICAqIEBwYXJhbSB7b2JqfSBpdGVtIGNvbm5lY3Rpb27lj4LmlbBcclxuICAgICAqL1xuICAgIHRoaXMuY29ubmVjdEVuZCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHRoaXMuX2pzUGx1bWIubWFrZVRhcmdldChpdGVtLnBhZ2VUYXJnZXRJZCwge1xuICAgICAgICAgICAgYW5jaG9yOiBcIlRvcFwiLFxuICAgICAgICAgICAgaXNUYXJnZXQ6IHRydWUsXG4gICAgICAgICAgICBtYXhDb25uZWN0aW9uczogLTFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2pzUGx1bWIuY29ubmVjdCh7XG4gICAgICAgICAgICBzb3VyY2U6IGl0ZW0ucGFnZVNvdXJjZUlkLFxuICAgICAgICAgICAgdGFyZ2V0OiBpdGVtLnBhZ2VUYXJnZXRJZCxcbiAgICAgICAgICAgIGRlbGV0ZUVuZHBvaW50c09uRGV0YWNoOiB0cnVlLFxuXG4gICAgICAgICAgICBwYWludFN0eWxlOiB7XG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBcIiMwMDk2ZjJcIixcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogMlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbm5lY3RvcjogW1wiQmV6aWVyXCIsIHtcbiAgICAgICAgICAgICAgICBjdXJ2aW5lc3M6IDEwMFxuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICBlbmRwb2ludHM6IFtbXCJEb3RcIiwge1xuICAgICAgICAgICAgICAgIHJhZGl1czogNlxuICAgICAgICAgICAgfV0sIFtcIkRvdFwiLCB7XG4gICAgICAgICAgICAgICAgcmFkaXVzOiA0LFxuICAgICAgICAgICAgICAgIGNzc0NsYXNzOiBcImpzcGwtcG9pbnQtdG9wXCJcbiAgICAgICAgICAgIH1dXSxcbiAgICAgICAgICAgIGVuZHBvaW50U3R5bGVzOiBbe1xuICAgICAgICAgICAgICAgIGZpbGxTdHlsZTogJyMwMDk2ZjInXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgZmlsbDogXCIjZjY1ZDNiXCIsXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBcInJnYmEoMCwwLDAsMClcIixcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogOFxuICAgICAgICAgICAgfV1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxyXG4gICAgICogIOWbvuW9ouWvvOWHuuS4umpzb25cclxuICAgICAqICDph43lhpnln7rnoYDnsbtcclxuICAgICAqL1xuICAgIHRoaXMudG9Kc29uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAvLyDojrflj5bmiYDmnInoioLngrlcbiAgICAgICAgdmFyIG5vZGVzID0gW107XG4gICAgICAgIHRoaXMuX25vZGVzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcblxuICAgICAgICAgICAgbm9kZXMucHVzaChpdGVtLnRvUGxhaW5PYmooKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIOiOt+WPluaJgOaciei/nuaOpVxuICAgICAgICB2YXIgY29ubmVjdGlvbnMgPSB0aGlzLl9qc1BsdW1iLmdldEFsbENvbm5lY3Rpb25zKCkubWFwKGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG5cbiAgICAgICAgICAgIHZhciBySnNvbiA9IHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uSWQ6IGNvbm5lY3Rpb24uaWQsXG4gICAgICAgICAgICAgICAgcGFnZVNvdXJjZUlkOiBjb25uZWN0aW9uLnNvdXJjZUlkLFxuICAgICAgICAgICAgICAgIHBhZ2VUYXJnZXRJZDogY29ubmVjdGlvbi50YXJnZXRJZFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHNvdXJjZU5vZGUgPSBfdGhpczIuZ2V0Tm9kZUJ5SWQoY29ubmVjdGlvbi5zb3VyY2VJZCk7XG5cbiAgICAgICAgICAgIGlmIChzb3VyY2VOb2RlLl9vcHRpb25zICYmIHNvdXJjZU5vZGUuX29wdGlvbnMubm9kZVN0eWxlID09PSBcInN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICBySnNvbi5ub2RlU3R5bGUgPSBcInN0YXJ0XCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXROb2RlID0gX3RoaXMyLmdldE5vZGVCeUlkKGNvbm5lY3Rpb24udGFyZ2V0SWQpO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXROb2RlLl9vcHRpb25zICYmIHRhcmdldE5vZGUuX29wdGlvbnMubm9kZVN0eWxlID09PSBcImVuZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJKc29uLm5vZGVTdHlsZSA9IFwiZW5kXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gckpzb247XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2Rlczogbm9kZXMsXG4gICAgICAgICAgICBjb25uZWN0aW9uczogY29ubmVjdGlvbnNcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXHJcbiAgICAgKiDmuLLmn5PoioLngrlcclxuICAgICAqIEBwYXJhbSB7b2JqfSBub2RlcyBub2Rlc+aVsOe7hFxyXG4gICAgICogQHBhcmFtIHtvYmp9IG9wdGlvbnMgb3B0aW9ucyDmnaXoh6pmcm9tSnNvbueahOi+k+WFpeWPguaVsCB7Y3JlYXQsdXNlU3RhcnQsdXNlRW5kfVxyXG4gICAgICogXHJcbiAgICAgKiDopoblhpnln7rnoYDnsbsgXHJcbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlck5vZGVzID0gZnVuY3Rpb24gKG5vZGVzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuYmFzZS5yZW5kZXJOb2Rlcy5jYWxsKHRoaXMsIG5vZGVzLCBvcHRpb25zKTtcblxuICAgICAgICBvcHRpb25zID0gJC5leHRlbmQoe1xuICAgICAgICAgICAgdXNlU3RhcnQ6IHRydWUsXG4gICAgICAgICAgICB1c2VFbmQ6IHRydWVcbiAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIHN0YXJ0QmxnID0gdHJ1ZSxcbiAgICAgICAgICAgIGVuZEJsZyA9IHRydWU7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMudXNlU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXJ0QmxnID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMudXNlRW5kKSB7XG4gICAgICAgICAgICBlbmRCbGcgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGVzICYmIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBvcCA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBpdGVtLm5hbWUsXG4gICAgICAgICAgICAgICAgcG9pbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgeDogaXRlbS5feCxcbiAgICAgICAgICAgICAgICAgICAgeTogaXRlbS5feVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGF0YTogaXRlbSxcbiAgICAgICAgICAgICAgICBjbGFzczogaXRlbS5jbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgcmVtb3ZhYmxlOiBpdGVtLnJlbW92YWJsZSxcbiAgICAgICAgICAgICAgICBub2RlSWQ6IGl0ZW0ubm9kZUlkLFxuICAgICAgICAgICAgICAgIHVuUG9ydDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBub2RlU3R5bGU6IGl0ZW0ubm9kZVN0eWxlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGl0ZW0ubm9kZVN0eWxlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0YXJ0XCI6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzMy5hZGROb2RlU3RhcnQob3ApO1xuICAgICAgICAgICAgICAgICAgICBzdGFydEJsZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMzLmFkZE5vZGVFbmQob3ApO1xuICAgICAgICAgICAgICAgICAgICBlbmRCbGcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFzdGFydEJsZykge1xuICAgICAgICAgICAgdGhpcy5hZGROb2RlU3RhcnQoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICcnLFxuICAgICAgICAgICAgICAgIHBvaW50OiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IDI1LFxuICAgICAgICAgICAgICAgICAgICB5OiAyNVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2xhc3M6ICcnLFxuICAgICAgICAgICAgICAgIHJlbW92YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgbm9kZUlkOiBudWxsLFxuICAgICAgICAgICAgICAgIGRhdGE6IHt9LFxuICAgICAgICAgICAgICAgIGNyZWF0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB1blBvcnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgbm9kZVN0eWxlOiBcInN0YXJ0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZW5kQmxnKSB7XG4gICAgICAgICAgICB0aGlzLmFkZE5vZGVFbmQoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICcnLFxuICAgICAgICAgICAgICAgIHBvaW50OiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IDI1LFxuICAgICAgICAgICAgICAgICAgICB5OiAyMTBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNsYXNzOiAnJyxcbiAgICAgICAgICAgICAgICByZW1vdmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG5vZGVJZDogbnVsbCxcbiAgICAgICAgICAgICAgICBkYXRhOiB7fSxcbiAgICAgICAgICAgICAgICBjcmVhdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdW5Qb3J0OiB0cnVlLFxuICAgICAgICAgICAgICAgIG5vZGVTdHlsZTogXCJlbmRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXHJcbiAgICAgKiDmuLLmn5Pov57mjqXnur/kuI7ngrlcclxuICAgICAqIEBwYXJhbSB7b2JqfSBjb25uZWN0aW9ucyBjb25uZWN0aW9uc+aVsOe7hFxyXG4gICAgICogXHJcbiAgICAgKiDopoblhpnln7rnoYDnsbsgXHJcbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlckNvbm5lY3Rpb25zID0gZnVuY3Rpb24gKGNvbm5lY3Rpb25zLCBub2Rlcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICB0aGlzLmJhc2UucmVuZGVyQ29ubmVjdGlvbnMuY2FsbCh0aGlzLCBjb25uZWN0aW9ucywgbm9kZXMsIG9wdGlvbnMpO1xuXG4gICAgICAgIGNvbm5lY3Rpb25zICYmIGNvbm5lY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBjb25uZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIHN3aXRjaCAoaXRlbS5ub2RlU3R5bGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RhcnRcIjpcblxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0ID0gX3RoaXM0LmNvbm5lY3RTdGFydChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3QgPSBfdGhpczQuY29ubmVjdEVuZChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29ubmVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gX3RoaXM0LmdldE5vZGVCeUlkKGl0ZW0ucGFnZVNvdXJjZUlkKTtcblxuICAgICAgICAgICAgICAgIG5vZGUuY29ubmVjdG9yRXZlbnQuaW5pdChub2RlLCBjb25uZWN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn07XG5cbmNoYXJ0QmFzZS5wcm90b3R5cGUgPSBuZXcgY2hhcnRDb3JlKCk7XG5cbmV4cG9ydCBkZWZhdWx0IGNoYXJ0QmFzZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NjYWZmL2NoYXJ0L2Jhc2UvY2hhcnRCYXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNThcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///158\n')},159:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__jsPlumb_js__ = __webpack_require__(160);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__jsPlumb_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__jsPlumb_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__chartNode_js__ = __webpack_require__(85);\n\n\n\n/**\r\n * @class 画布  基于jsplumb.js?v= 2.6.9 开发\r\n */\nvar Chart = function Chart(container, options) {\n    if (arguments.length < 2) {\n        return;\n    }\n    this.ChartNode = __WEBPACK_IMPORTED_MODULE_1__chartNode_js__[\"a\" /* default */];\n    this._jsPlumb = null;\n    this._container = container;\n    this.options = $.extend({\n        nodeDbClick: function nodeDbClick() {},\n        nodeClick: function nodeClick() {},\n        contentClick: function contentClick() {},\n        nodeDel: function nodeDel() {},\n        nodeInputBlur: function nodeInputBlur() {},\n        nodeMouseenter: function nodeMouseenter() {},\n        nodeMouseleave: function nodeMouseleave() {}\n    }, options);\n    this._nodes = [];\n    this._seedName = 'n';\n    this._seedId = 0;\n\n    this.init();\n};\n\nChart.prototype.nodeId = function () {\n    return this._seedName + this._seedId++ + new Date().getTime().toString().substring(3);\n};\n\n/**\r\n * 初始化方法\r\n * @param  {Object} [options] 初始化参数\r\n * @param {Function} [options.onNodeClick] 节点点击事件回调函数，参数为节点绑定的数据\r\n */\nChart.prototype.init = function () {\n    var _this2 = this;\n\n    this._jsPlumb = __WEBPACK_IMPORTED_MODULE_0__jsPlumb_js___default.a.jsPlumb.getInstance();\n    this._jsPlumb.importDefaults({\n        ConnectionOverlays: [[\"PlainArrow\", {\n            width: 15,\n            location: 1, //[ 0, 1 ],\n            id: \"arrow\",\n            length: 8\n        }]],\n        Endpoints: [//https://jsplumbtoolkit.com/community/apidocs/classes/Endpoints.Dot.html \n        [\"Dot\", {\n            radius: 6,\n            cssClass: \"jspl-point-bottom\"\n\n        }], [\"Dot\", {\n            radius: 6,\n            cssClass: \"jspl-point-top\"\n\n        }]],\n        EndpointStyles: [{\n            fillStyle: '#f65d3b'\n        }, {\n            fillStyle: '#0096f2'\n        }]\n\n    });\n\n    this._container.addClass('flow-chart-canvas-lkiarest');\n\n    var _this = this;\n    // 节点点击事件\n    this._container.on('click', '.task', function (e) {\n\n        var $t = $(this);\n        var node = _this.getNodeById($t.attr('id'));\n\n        _this.options.nodeClick(node._data, node);\n\n        e.stopPropagation();\n    })\n    // 节点双击事件\n    .on('dblclick', '.task', function (e) {\n\n        var $t = $(this);\n        var node = _this.getNodeById($t.attr('id'));\n\n        _this.options.nodeDbClick.call(_this, node._data, node);\n        e.stopPropagation();\n    }).on('blur', '.task > input', function (e) {\n        var $t = $(this),\n            $task = $t.parents('.task');\n        var node = _this.getNodeById($task.attr('id'));\n        var val = $t.val(),\n            data = node.getData();\n        node._name = val;\n\n        $task.children('span.node-flow-name').text(node._name);\n\n        _this.options.nodeInputBlur.call(_this, node._data, node);\n        e.stopPropagation();\n    })\n    // 画布空白点击事件\n    .on('click', function (e) {\n\n        _this.options.contentClick.call(_this);\n\n        e.stopPropagation();\n    });\n\n    // 删除节点\n    this._container.on('click', '.remove', function (event) {\n        var nodeId = $(event.target).parent().attr('id'),\n            delNode = _this.getNodeById(nodeId),\n            data = null;\n        if (delNode) {\n            data = delNode.getData();\n        }\n\n        if (_this.options.nodeDel.cover) {\n            _this.options.nodeDel.call(_this, data, delNode);\n        } else {\n\n            if (delNode) {\n\n                delNode.dispose();\n                _this2.removeNode(nodeId);\n            }\n            _this.options.nodeDel.call(_this, data, delNode);\n        }\n        event.stopPropagation();\n    });\n    //节点 悬停\n    this._container.parent().on('mouseenter', '.task.node-process', function (event) {\n        var node = _this.getNodeById($(this).attr('id'));\n\n        _this.options.nodeMouseenter.call(_this, node);\n    }).on('mouseleave', '.task.node-process', function (event) {\n        var node = _this.getNodeById($(this).attr('id'));\n        _this.options.nodeMouseleave.call(_this, node);\n    });\n};\n\n/**\r\n * 添加新节点\r\n * @param {String} name    节点名称\r\n * @param {Number} x       节点x坐标\r\n * @param {Number} y       节点y坐标\r\n * @param {Object} options 节点参数，可参考 {class ChartNode} 构造参数\r\n * @param {String} [options.id] 节点id，若未定义则由系统自动分配\r\n * @param {string} html dom内容\r\n */\nChart.prototype.addNode = function (options) {\n    //name, x, y,\n    var nodeId = options && options.nodeId || this.nodeId();\n    var node = new this.ChartNode(nodeId, options);\n    node.setPlumb(this._jsPlumb);\n    node.setContainer(this._container);\n\n    var html = \"\";\n    if (!options.html) {\n        html = '\\n        <div class=\"window task\">\\n            <span class=\"node-flow-name\">' + node._name + '</span>\\n            <input value=\"' + node._name + '\"/>\\n        </div>\\n        ';\n    } else {\n        html = options.html;\n    }\n    var npt = {\n        removable: options.removable,\n        container: this._container,\n        elementCallback: function elementCallback(node, el) {\n            if (typeof options.creat === \"string\") {\n                var c = new Function(\"node\", \"el\", '(' + options.creat + ')(node,el)');\n\n                c(node, el);\n            } else if (typeof options.creat === \"function\") {\n                options.creat(node, el);\n            }\n        },\n        html: html\n    };\n\n    node.createElemt(npt);\n\n    this._nodes.push(node);\n\n    var _this = this;\n    if (!options.unPort) {\n        node.addPort({\n            isSource: true,\n            dragOptions: {\n                stop: function stop(e) {\n\n                    var connections = _this._jsPlumb.getConnections({\n                        source: $(e.drag.el).attr(\"elid\")\n                    });\n\n                    _this.bindConnections(connections, this._nodes, this.options);\n                }\n            }\n        });\n\n        node.addPort({\n            isTarget: true,\n            position: 'Top',\n            dragOptions: {\n                stop: function stop(e) {\n                    // console.log(\"top\",e)\n                    //var r = this.getConnections({\n                    //   source:\n                    //   target:\n                    //});\n                }\n            }\n        });\n    } else {}\n\n    return node;\n};\n\n/**\r\n * 删除节点\r\n * @param {String} nodeId 节点ID \r\n */\nChart.prototype.removeNode = function (nodeId) {\n    var nodes = this._nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        var node = nodes[i];\n        if (node.getId() === nodeId) {\n            node.dispose();\n            nodes.splice(i, 1);\n            return node;\n        }\n    }\n};\n\n//获得所有节点\nChart.prototype.getNodes = function () {\n    return this._nodes;\n};\n\n//获得某个节点 根据nodeId \nChart.prototype.getNodeById = function (id) {\n    var l = this._nodes;\n    for (var i = 0; i < l.length; i++) {\n        if (l[i]._id === id) {\n            return l[i];\n        }\n    }\n    return null;\n};\n\n/**\r\n * 序列化以保存\r\n */\nChart.prototype.toJson = function () {\n    // 获取所有节点\n    var nodes = [];\n    this._nodes.forEach(function (item) {\n\n        nodes.push(item.toPlainObj());\n    });\n\n    // 获取所有连接\n    var connections = this._jsPlumb.getAllConnections().map(function (connection) {\n        return {\n            connectionId: connection.id,\n            pageSourceId: connection.sourceId,\n            pageTargetId: connection.targetId\n        };\n    });\n\n    return {\n        nodes: nodes,\n        connections: connections\n    };\n};\n\n/**\r\n * 反序列化保存的数据并绘制流程图\r\n */\nChart.prototype.fromJson = function (jsonStr, options) {\n    if (!jsonStr || jsonStr === '') {\n        console.error('draw from json failed: empty json string');\n        reutrn;\n    }\n\n    if (!options) {\n        options = {};\n    }\n\n    this.options = $.extend(this.options, Object.assign({}, options));\n\n    var jsonObj = null;\n\n    try {\n        if (typeof jsonStr === \"string\") {\n            jsonObj = JSON.parse(jsonStr);\n        } else {\n            jsonObj = jsonStr;\n        }\n    } catch (e) {\n        console.error('invalid json string', e);\n        return;\n    }\n\n    this.clear();\n\n    var nodes = jsonObj.nodes;\n    var connections = jsonObj.connections;\n\n    this.renderNodes(nodes, this.options);\n\n    this.renderConnections(connections, nodes, this.options);\n\n    this._jsPlumb.repaintEverything();\n};\n\n/**\r\n * 渲染节点\r\n * @param {obj} nodes nodes数组\r\n * @param {obj} options options 来自fromJson的输入参数 {creat,useStart,useEnd}\r\n */\nChart.prototype.renderNodes = function (nodes, options) {\n    var _this3 = this;\n\n    nodes && nodes.forEach(function (item) {\n        if (!item.nodeStyle || item.nodeStyle === \"normal\") {\n            var node = _this3.addNode($.extend(options, {\n                name: item.name,\n                point: {\n                    x: item._x,\n                    y: item._y\n                },\n                class: item.className,\n                removable: item.removable,\n                nodeId: item.nodeId,\n                data: item\n            }));\n            _this3._jsPlumb.repaint(item.elId);\n        }\n    });\n};\n\n/**\r\n * 渲染连接线与点\r\n * @param {obj} connections connections数组\r\n * param {obj} options options 来自fromJson的输入参数 \r\n */\nChart.prototype.renderConnections = function (connections, nodes, options) {\n    var _this4 = this;\n\n    connections && connections.forEach(function (item) {\n\n        if (!item.nodeStyle || item.nodeStyle === \"normal\") {\n            _this4._jsPlumb.makeTarget(item.pageTargetId, {\n                anchor: \"Top\",\n                isTarget: true,\n                maxConnections: -1,\n                endpoint: [\"Dot\", {\n                    radius: 6,\n                    cssClass: \"jspl-point-top\",\n                    hoverClass: \"jspl-point-bottom-hover\"\n                }],\n                paintStyle: {\n                    fill: \"#f65d3b\",\n                    stroke: \"rgba(0,0,0,0)\",\n                    strokeWidth: 8\n                }\n\n            });\n\n            var connect = _this4._jsPlumb.connect({\n                source: item.pageSourceId,\n                target: item.pageTargetId,\n                deleteEndpointsOnDetach: true,\n\n                paintStyle: {\n                    stroke: \"#0096f2\",\n                    strokeWidth: 2\n                },\n                connector: [\"Bezier\", {\n                    curviness: 100\n                }]\n\n            });\n\n            var node = _this4.getNodeById(item.pageSourceId);\n\n            node.connectorEvent.init(node, connect, options);\n        }\n    });\n};\n\n/**\r\n * 重新绑定connector线条事件\r\n */\nChart.prototype.bindConnections = function (connections, nodes, options) {\n    var _this5 = this;\n\n    connections && connections.forEach(function (item) {\n\n        var node = _this5.getNodeById(item.sourceId);\n\n        node.connectorEvent.init(node, item, options);\n    });\n};\n\n/**\r\n * 清除画布中的元素\r\n */\nChart.prototype.clear = function () {\n    this._nodes && this._nodes.forEach(function (item) {\n        item.dispose();\n    });\n\n    this._nodes = [];\n    this._jsPlumb.deleteEveryEndpoint(this._container);\n    this._jsPlumb.removeAllEndpoints(this._container);\n};\n\n/**\r\n * 销毁释放\r\n */\nChart.prototype.dispose = function () {\n    this.clear();\n    this._container.off('click'); // unbind events\n    this._container = null;\n};\n\nChart.ready = function (callback) {\n    jsPlumb.ready(callback);\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Chart);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vY29yZS9jaGFydC9jaGFydC5qcz8xYzIyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBqc1BsdW1iTSBmcm9tICcuL2pzUGx1bWIuanMnO1xuaW1wb3J0IENoYXJ0Tm9kZSBmcm9tICcuL2NoYXJ0Tm9kZS5qcyc7XG5cbi8qKlxyXG4gKiBAY2xhc3Mg55S75biDICDln7rkuo5qc3BsdW1iLmpzP3Y9IDIuNi45IOW8gOWPkVxyXG4gKi9cbnZhciBDaGFydCA9IGZ1bmN0aW9uIENoYXJ0KGNvbnRhaW5lciwgb3B0aW9ucykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuQ2hhcnROb2RlID0gQ2hhcnROb2RlO1xuICAgIHRoaXMuX2pzUGx1bWIgPSBudWxsO1xuICAgIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7XG4gICAgICAgIG5vZGVEYkNsaWNrOiBmdW5jdGlvbiBub2RlRGJDbGljaygpIHt9LFxuICAgICAgICBub2RlQ2xpY2s6IGZ1bmN0aW9uIG5vZGVDbGljaygpIHt9LFxuICAgICAgICBjb250ZW50Q2xpY2s6IGZ1bmN0aW9uIGNvbnRlbnRDbGljaygpIHt9LFxuICAgICAgICBub2RlRGVsOiBmdW5jdGlvbiBub2RlRGVsKCkge30sXG4gICAgICAgIG5vZGVJbnB1dEJsdXI6IGZ1bmN0aW9uIG5vZGVJbnB1dEJsdXIoKSB7fSxcbiAgICAgICAgbm9kZU1vdXNlZW50ZXI6IGZ1bmN0aW9uIG5vZGVNb3VzZWVudGVyKCkge30sXG4gICAgICAgIG5vZGVNb3VzZWxlYXZlOiBmdW5jdGlvbiBub2RlTW91c2VsZWF2ZSgpIHt9XG4gICAgfSwgb3B0aW9ucyk7XG4gICAgdGhpcy5fbm9kZXMgPSBbXTtcbiAgICB0aGlzLl9zZWVkTmFtZSA9ICduJztcbiAgICB0aGlzLl9zZWVkSWQgPSAwO1xuXG4gICAgdGhpcy5pbml0KCk7XG59O1xuXG5DaGFydC5wcm90b3R5cGUubm9kZUlkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWVkTmFtZSArIHRoaXMuX3NlZWRJZCsrICsgbmV3IERhdGUoKS5nZXRUaW1lKCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMyk7XG59O1xuXG4vKipcclxuICog5Yid5aeL5YyW5pa55rOVXHJcbiAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIOWIneWni+WMluWPguaVsFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbk5vZGVDbGlja10g6IqC54K554K55Ye75LqL5Lu25Zue6LCD5Ye95pWw77yM5Y+C5pWw5Li66IqC54K557uR5a6a55qE5pWw5o2uXHJcbiAqL1xuQ2hhcnQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB0aGlzLl9qc1BsdW1iID0ganNQbHVtYk0uanNQbHVtYi5nZXRJbnN0YW5jZSgpO1xuICAgIHRoaXMuX2pzUGx1bWIuaW1wb3J0RGVmYXVsdHMoe1xuICAgICAgICBDb25uZWN0aW9uT3ZlcmxheXM6IFtbXCJQbGFpbkFycm93XCIsIHtcbiAgICAgICAgICAgIHdpZHRoOiAxNSxcbiAgICAgICAgICAgIGxvY2F0aW9uOiAxLCAvL1sgMCwgMSBdLFxuICAgICAgICAgICAgaWQ6IFwiYXJyb3dcIixcbiAgICAgICAgICAgIGxlbmd0aDogOFxuICAgICAgICB9XV0sXG4gICAgICAgIEVuZHBvaW50czogWy8vaHR0cHM6Ly9qc3BsdW1idG9vbGtpdC5jb20vY29tbXVuaXR5L2FwaWRvY3MvY2xhc3Nlcy9FbmRwb2ludHMuRG90Lmh0bWwgXG4gICAgICAgIFtcIkRvdFwiLCB7XG4gICAgICAgICAgICByYWRpdXM6IDYsXG4gICAgICAgICAgICBjc3NDbGFzczogXCJqc3BsLXBvaW50LWJvdHRvbVwiXG5cbiAgICAgICAgfV0sIFtcIkRvdFwiLCB7XG4gICAgICAgICAgICByYWRpdXM6IDYsXG4gICAgICAgICAgICBjc3NDbGFzczogXCJqc3BsLXBvaW50LXRvcFwiXG5cbiAgICAgICAgfV1dLFxuICAgICAgICBFbmRwb2ludFN0eWxlczogW3tcbiAgICAgICAgICAgIGZpbGxTdHlsZTogJyNmNjVkM2InXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGZpbGxTdHlsZTogJyMwMDk2ZjInXG4gICAgICAgIH1dXG5cbiAgICB9KTtcblxuICAgIHRoaXMuX2NvbnRhaW5lci5hZGRDbGFzcygnZmxvdy1jaGFydC1jYW52YXMtbGtpYXJlc3QnKTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgLy8g6IqC54K554K55Ye75LqL5Lu2XG4gICAgdGhpcy5fY29udGFpbmVyLm9uKCdjbGljaycsICcudGFzaycsIGZ1bmN0aW9uIChlKSB7XG5cbiAgICAgICAgdmFyICR0ID0gJCh0aGlzKTtcbiAgICAgICAgdmFyIG5vZGUgPSBfdGhpcy5nZXROb2RlQnlJZCgkdC5hdHRyKCdpZCcpKTtcblxuICAgICAgICBfdGhpcy5vcHRpb25zLm5vZGVDbGljayhub2RlLl9kYXRhLCBub2RlKTtcblxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0pXG4gICAgLy8g6IqC54K55Y+M5Ye75LqL5Lu2XG4gICAgLm9uKCdkYmxjbGljaycsICcudGFzaycsIGZ1bmN0aW9uIChlKSB7XG5cbiAgICAgICAgdmFyICR0ID0gJCh0aGlzKTtcbiAgICAgICAgdmFyIG5vZGUgPSBfdGhpcy5nZXROb2RlQnlJZCgkdC5hdHRyKCdpZCcpKTtcblxuICAgICAgICBfdGhpcy5vcHRpb25zLm5vZGVEYkNsaWNrLmNhbGwoX3RoaXMsIG5vZGUuX2RhdGEsIG5vZGUpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0pLm9uKCdibHVyJywgJy50YXNrID4gaW5wdXQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgJHQgPSAkKHRoaXMpLFxuICAgICAgICAgICAgJHRhc2sgPSAkdC5wYXJlbnRzKCcudGFzaycpO1xuICAgICAgICB2YXIgbm9kZSA9IF90aGlzLmdldE5vZGVCeUlkKCR0YXNrLmF0dHIoJ2lkJykpO1xuICAgICAgICB2YXIgdmFsID0gJHQudmFsKCksXG4gICAgICAgICAgICBkYXRhID0gbm9kZS5nZXREYXRhKCk7XG4gICAgICAgIG5vZGUuX25hbWUgPSB2YWw7XG5cbiAgICAgICAgJHRhc2suY2hpbGRyZW4oJ3NwYW4ubm9kZS1mbG93LW5hbWUnKS50ZXh0KG5vZGUuX25hbWUpO1xuXG4gICAgICAgIF90aGlzLm9wdGlvbnMubm9kZUlucHV0Qmx1ci5jYWxsKF90aGlzLCBub2RlLl9kYXRhLCBub2RlKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9KVxuICAgIC8vIOeUu+W4g+epuueZveeCueWHu+S6i+S7tlxuICAgIC5vbignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuXG4gICAgICAgIF90aGlzLm9wdGlvbnMuY29udGVudENsaWNrLmNhbGwoX3RoaXMpO1xuXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSk7XG5cbiAgICAvLyDliKDpmaToioLngrlcbiAgICB0aGlzLl9jb250YWluZXIub24oJ2NsaWNrJywgJy5yZW1vdmUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIG5vZGVJZCA9ICQoZXZlbnQudGFyZ2V0KS5wYXJlbnQoKS5hdHRyKCdpZCcpLFxuICAgICAgICAgICAgZGVsTm9kZSA9IF90aGlzLmdldE5vZGVCeUlkKG5vZGVJZCksXG4gICAgICAgICAgICBkYXRhID0gbnVsbDtcbiAgICAgICAgaWYgKGRlbE5vZGUpIHtcbiAgICAgICAgICAgIGRhdGEgPSBkZWxOb2RlLmdldERhdGEoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdGhpcy5vcHRpb25zLm5vZGVEZWwuY292ZXIpIHtcbiAgICAgICAgICAgIF90aGlzLm9wdGlvbnMubm9kZURlbC5jYWxsKF90aGlzLCBkYXRhLCBkZWxOb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgaWYgKGRlbE5vZGUpIHtcblxuICAgICAgICAgICAgICAgIGRlbE5vZGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIF90aGlzMi5yZW1vdmVOb2RlKG5vZGVJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5vcHRpb25zLm5vZGVEZWwuY2FsbChfdGhpcywgZGF0YSwgZGVsTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSk7XG4gICAgLy/oioLngrkg5oKs5YGcXG4gICAgdGhpcy5fY29udGFpbmVyLnBhcmVudCgpLm9uKCdtb3VzZWVudGVyJywgJy50YXNrLm5vZGUtcHJvY2VzcycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgbm9kZSA9IF90aGlzLmdldE5vZGVCeUlkKCQodGhpcykuYXR0cignaWQnKSk7XG5cbiAgICAgICAgX3RoaXMub3B0aW9ucy5ub2RlTW91c2VlbnRlci5jYWxsKF90aGlzLCBub2RlKTtcbiAgICB9KS5vbignbW91c2VsZWF2ZScsICcudGFzay5ub2RlLXByb2Nlc3MnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfdGhpcy5nZXROb2RlQnlJZCgkKHRoaXMpLmF0dHIoJ2lkJykpO1xuICAgICAgICBfdGhpcy5vcHRpb25zLm5vZGVNb3VzZWxlYXZlLmNhbGwoX3RoaXMsIG5vZGUpO1xuICAgIH0pO1xufTtcblxuLyoqXHJcbiAqIOa3u+WKoOaWsOiKgueCuVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAgICDoioLngrnlkI3np7BcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggICAgICAg6IqC54K5eOWdkOagh1xyXG4gKiBAcGFyYW0ge051bWJlcn0geSAgICAgICDoioLngrl55Z2Q5qCHXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIOiKgueCueWPguaVsO+8jOWPr+WPguiAgyB7Y2xhc3MgQ2hhcnROb2RlfSDmnoTpgKDlj4LmlbBcclxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmlkXSDoioLngrlpZO+8jOiLpeacquWumuS5ieWImeeUseezu+e7n+iHquWKqOWIhumFjVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbCBkb23lhoXlrrlcclxuICovXG5DaGFydC5wcm90b3R5cGUuYWRkTm9kZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLy9uYW1lLCB4LCB5LFxuICAgIHZhciBub2RlSWQgPSBvcHRpb25zICYmIG9wdGlvbnMubm9kZUlkIHx8IHRoaXMubm9kZUlkKCk7XG4gICAgdmFyIG5vZGUgPSBuZXcgdGhpcy5DaGFydE5vZGUobm9kZUlkLCBvcHRpb25zKTtcbiAgICBub2RlLnNldFBsdW1iKHRoaXMuX2pzUGx1bWIpO1xuICAgIG5vZGUuc2V0Q29udGFpbmVyKHRoaXMuX2NvbnRhaW5lcik7XG5cbiAgICB2YXIgaHRtbCA9IFwiXCI7XG4gICAgaWYgKCFvcHRpb25zLmh0bWwpIHtcbiAgICAgICAgaHRtbCA9ICdcXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ3aW5kb3cgdGFza1wiPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwibm9kZS1mbG93LW5hbWVcIj4nICsgbm9kZS5fbmFtZSArICc8L3NwYW4+XFxuICAgICAgICAgICAgPGlucHV0IHZhbHVlPVwiJyArIG5vZGUuX25hbWUgKyAnXCIvPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICAnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGh0bWwgPSBvcHRpb25zLmh0bWw7XG4gICAgfVxuICAgIHZhciBucHQgPSB7XG4gICAgICAgIHJlbW92YWJsZTogb3B0aW9ucy5yZW1vdmFibGUsXG4gICAgICAgIGNvbnRhaW5lcjogdGhpcy5fY29udGFpbmVyLFxuICAgICAgICBlbGVtZW50Q2FsbGJhY2s6IGZ1bmN0aW9uIGVsZW1lbnRDYWxsYmFjayhub2RlLCBlbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNyZWF0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBuZXcgRnVuY3Rpb24oXCJub2RlXCIsIFwiZWxcIiwgJygnICsgb3B0aW9ucy5jcmVhdCArICcpKG5vZGUsZWwpJyk7XG5cbiAgICAgICAgICAgICAgICBjKG5vZGUsIGVsKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuY3JlYXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY3JlYXQobm9kZSwgZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBodG1sOiBodG1sXG4gICAgfTtcblxuICAgIG5vZGUuY3JlYXRlRWxlbXQobnB0KTtcblxuICAgIHRoaXMuX25vZGVzLnB1c2gobm9kZSk7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmICghb3B0aW9ucy51blBvcnQpIHtcbiAgICAgICAgbm9kZS5hZGRQb3J0KHtcbiAgICAgICAgICAgIGlzU291cmNlOiB0cnVlLFxuICAgICAgICAgICAgZHJhZ09wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKGUpIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgY29ubmVjdGlvbnMgPSBfdGhpcy5fanNQbHVtYi5nZXRDb25uZWN0aW9ucyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6ICQoZS5kcmFnLmVsKS5hdHRyKFwiZWxpZFwiKVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5iaW5kQ29ubmVjdGlvbnMoY29ubmVjdGlvbnMsIHRoaXMuX25vZGVzLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbm9kZS5hZGRQb3J0KHtcbiAgICAgICAgICAgIGlzVGFyZ2V0OiB0cnVlLFxuICAgICAgICAgICAgcG9zaXRpb246ICdUb3AnLFxuICAgICAgICAgICAgZHJhZ09wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJ0b3BcIixlKVxuICAgICAgICAgICAgICAgICAgICAvL3ZhciByID0gdGhpcy5nZXRDb25uZWN0aW9ucyh7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgc291cmNlOlxuICAgICAgICAgICAgICAgICAgICAvLyAgIHRhcmdldDpcbiAgICAgICAgICAgICAgICAgICAgLy99KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7fVxuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG4vKipcclxuICog5Yig6Zmk6IqC54K5XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBub2RlSWQg6IqC54K5SUQgXHJcbiAqL1xuQ2hhcnQucHJvdG90eXBlLnJlbW92ZU5vZGUgPSBmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5fbm9kZXM7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlLmdldElkKCkgPT09IG5vZGVJZCkge1xuICAgICAgICAgICAgbm9kZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8v6I635b6X5omA5pyJ6IqC54K5XG5DaGFydC5wcm90b3R5cGUuZ2V0Tm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vZGVzO1xufTtcblxuLy/ojrflvpfmn5DkuKroioLngrkg5qC55o2ubm9kZUlkIFxuQ2hhcnQucHJvdG90eXBlLmdldE5vZGVCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGwgPSB0aGlzLl9ub2RlcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGxbaV0uX2lkID09PSBpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGxbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcclxuICog5bqP5YiX5YyW5Lul5L+d5a2YXHJcbiAqL1xuQ2hhcnQucHJvdG90eXBlLnRvSnNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyDojrflj5bmiYDmnInoioLngrlcbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICB0aGlzLl9ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG5cbiAgICAgICAgbm9kZXMucHVzaChpdGVtLnRvUGxhaW5PYmooKSk7XG4gICAgfSk7XG5cbiAgICAvLyDojrflj5bmiYDmnInov57mjqVcbiAgICB2YXIgY29ubmVjdGlvbnMgPSB0aGlzLl9qc1BsdW1iLmdldEFsbENvbm5lY3Rpb25zKCkubWFwKGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb25uZWN0aW9uSWQ6IGNvbm5lY3Rpb24uaWQsXG4gICAgICAgICAgICBwYWdlU291cmNlSWQ6IGNvbm5lY3Rpb24uc291cmNlSWQsXG4gICAgICAgICAgICBwYWdlVGFyZ2V0SWQ6IGNvbm5lY3Rpb24udGFyZ2V0SWRcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIG5vZGVzOiBub2RlcyxcbiAgICAgICAgY29ubmVjdGlvbnM6IGNvbm5lY3Rpb25zXG4gICAgfTtcbn07XG5cbi8qKlxyXG4gKiDlj43luo/liJfljJbkv53lrZjnmoTmlbDmja7lubbnu5jliLbmtYHnqIvlm75cclxuICovXG5DaGFydC5wcm90b3R5cGUuZnJvbUpzb24gPSBmdW5jdGlvbiAoanNvblN0ciwgb3B0aW9ucykge1xuICAgIGlmICghanNvblN0ciB8fCBqc29uU3RyID09PSAnJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdkcmF3IGZyb20ganNvbiBmYWlsZWQ6IGVtcHR5IGpzb24gc3RyaW5nJyk7XG4gICAgICAgIHJldXRybjtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHRoaXMub3B0aW9ucywgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucykpO1xuXG4gICAgdmFyIGpzb25PYmogPSBudWxsO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uU3RyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBqc29uT2JqID0gSlNPTi5wYXJzZShqc29uU3RyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGpzb25PYmogPSBqc29uU3RyO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdpbnZhbGlkIGpzb24gc3RyaW5nJywgZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICB2YXIgbm9kZXMgPSBqc29uT2JqLm5vZGVzO1xuICAgIHZhciBjb25uZWN0aW9ucyA9IGpzb25PYmouY29ubmVjdGlvbnM7XG5cbiAgICB0aGlzLnJlbmRlck5vZGVzKG5vZGVzLCB0aGlzLm9wdGlvbnMpO1xuXG4gICAgdGhpcy5yZW5kZXJDb25uZWN0aW9ucyhjb25uZWN0aW9ucywgbm9kZXMsIHRoaXMub3B0aW9ucyk7XG5cbiAgICB0aGlzLl9qc1BsdW1iLnJlcGFpbnRFdmVyeXRoaW5nKCk7XG59O1xuXG4vKipcclxuICog5riy5p+T6IqC54K5XHJcbiAqIEBwYXJhbSB7b2JqfSBub2RlcyBub2Rlc+aVsOe7hFxyXG4gKiBAcGFyYW0ge29ian0gb3B0aW9ucyBvcHRpb25zIOadpeiHqmZyb21Kc29u55qE6L6T5YWl5Y+C5pWwIHtjcmVhdCx1c2VTdGFydCx1c2VFbmR9XHJcbiAqL1xuQ2hhcnQucHJvdG90eXBlLnJlbmRlck5vZGVzID0gZnVuY3Rpb24gKG5vZGVzLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICBub2RlcyAmJiBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmICghaXRlbS5ub2RlU3R5bGUgfHwgaXRlbS5ub2RlU3R5bGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gX3RoaXMzLmFkZE5vZGUoJC5leHRlbmQob3B0aW9ucywge1xuICAgICAgICAgICAgICAgIG5hbWU6IGl0ZW0ubmFtZSxcbiAgICAgICAgICAgICAgICBwb2ludDoge1xuICAgICAgICAgICAgICAgICAgICB4OiBpdGVtLl94LFxuICAgICAgICAgICAgICAgICAgICB5OiBpdGVtLl95XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjbGFzczogaXRlbS5jbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgcmVtb3ZhYmxlOiBpdGVtLnJlbW92YWJsZSxcbiAgICAgICAgICAgICAgICBub2RlSWQ6IGl0ZW0ubm9kZUlkLFxuICAgICAgICAgICAgICAgIGRhdGE6IGl0ZW1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIF90aGlzMy5fanNQbHVtYi5yZXBhaW50KGl0ZW0uZWxJZCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8qKlxyXG4gKiDmuLLmn5Pov57mjqXnur/kuI7ngrlcclxuICogQHBhcmFtIHtvYmp9IGNvbm5lY3Rpb25zIGNvbm5lY3Rpb25z5pWw57uEXHJcbiAqIHBhcmFtIHtvYmp9IG9wdGlvbnMgb3B0aW9ucyDmnaXoh6pmcm9tSnNvbueahOi+k+WFpeWPguaVsCBcclxuICovXG5DaGFydC5wcm90b3R5cGUucmVuZGVyQ29ubmVjdGlvbnMgPSBmdW5jdGlvbiAoY29ubmVjdGlvbnMsIG5vZGVzLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICBjb25uZWN0aW9ucyAmJiBjb25uZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG5cbiAgICAgICAgaWYgKCFpdGVtLm5vZGVTdHlsZSB8fCBpdGVtLm5vZGVTdHlsZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgICAgX3RoaXM0Ll9qc1BsdW1iLm1ha2VUYXJnZXQoaXRlbS5wYWdlVGFyZ2V0SWQsIHtcbiAgICAgICAgICAgICAgICBhbmNob3I6IFwiVG9wXCIsXG4gICAgICAgICAgICAgICAgaXNUYXJnZXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgbWF4Q29ubmVjdGlvbnM6IC0xLFxuICAgICAgICAgICAgICAgIGVuZHBvaW50OiBbXCJEb3RcIiwge1xuICAgICAgICAgICAgICAgICAgICByYWRpdXM6IDYsXG4gICAgICAgICAgICAgICAgICAgIGNzc0NsYXNzOiBcImpzcGwtcG9pbnQtdG9wXCIsXG4gICAgICAgICAgICAgICAgICAgIGhvdmVyQ2xhc3M6IFwianNwbC1wb2ludC1ib3R0b20taG92ZXJcIlxuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIHBhaW50U3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogXCIjZjY1ZDNiXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogXCJyZ2JhKDAsMCwwLDApXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiA4XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGNvbm5lY3QgPSBfdGhpczQuX2pzUGx1bWIuY29ubmVjdCh7XG4gICAgICAgICAgICAgICAgc291cmNlOiBpdGVtLnBhZ2VTb3VyY2VJZCxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGl0ZW0ucGFnZVRhcmdldElkLFxuICAgICAgICAgICAgICAgIGRlbGV0ZUVuZHBvaW50c09uRGV0YWNoOiB0cnVlLFxuXG4gICAgICAgICAgICAgICAgcGFpbnRTdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBzdHJva2U6IFwiIzAwOTZmMlwiLFxuICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogMlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yOiBbXCJCZXppZXJcIiwge1xuICAgICAgICAgICAgICAgICAgICBjdXJ2aW5lc3M6IDEwMFxuICAgICAgICAgICAgICAgIH1dXG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgbm9kZSA9IF90aGlzNC5nZXROb2RlQnlJZChpdGVtLnBhZ2VTb3VyY2VJZCk7XG5cbiAgICAgICAgICAgIG5vZGUuY29ubmVjdG9yRXZlbnQuaW5pdChub2RlLCBjb25uZWN0LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuLyoqXHJcbiAqIOmHjeaWsOe7keWummNvbm5lY3Rvcue6v+adoeS6i+S7tlxyXG4gKi9cbkNoYXJ0LnByb3RvdHlwZS5iaW5kQ29ubmVjdGlvbnMgPSBmdW5jdGlvbiAoY29ubmVjdGlvbnMsIG5vZGVzLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICBjb25uZWN0aW9ucyAmJiBjb25uZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG5cbiAgICAgICAgdmFyIG5vZGUgPSBfdGhpczUuZ2V0Tm9kZUJ5SWQoaXRlbS5zb3VyY2VJZCk7XG5cbiAgICAgICAgbm9kZS5jb25uZWN0b3JFdmVudC5pbml0KG5vZGUsIGl0ZW0sIG9wdGlvbnMpO1xuICAgIH0pO1xufTtcblxuLyoqXHJcbiAqIOa4hemZpOeUu+W4g+S4reeahOWFg+e0oFxyXG4gKi9cbkNoYXJ0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9ub2RlcyAmJiB0aGlzLl9ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGl0ZW0uZGlzcG9zZSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fbm9kZXMgPSBbXTtcbiAgICB0aGlzLl9qc1BsdW1iLmRlbGV0ZUV2ZXJ5RW5kcG9pbnQodGhpcy5fY29udGFpbmVyKTtcbiAgICB0aGlzLl9qc1BsdW1iLnJlbW92ZUFsbEVuZHBvaW50cyh0aGlzLl9jb250YWluZXIpO1xufTtcblxuLyoqXHJcbiAqIOmUgOavgemHiuaUvlxyXG4gKi9cbkNoYXJ0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgICB0aGlzLl9jb250YWluZXIub2ZmKCdjbGljaycpOyAvLyB1bmJpbmQgZXZlbnRzXG4gICAgdGhpcy5fY29udGFpbmVyID0gbnVsbDtcbn07XG5cbkNoYXJ0LnJlYWR5ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAganNQbHVtYi5yZWFkeShjYWxsYmFjayk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDaGFydDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvcmUvY2hhcnQvY2hhcnQuanNcbi8vIG1vZHVsZSBpZCA9IDE1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///159\n")},160:function(module,exports,__webpack_require__){eval('var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};/**\r\n * jsBezier\r\n *\r\n * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)\r\n *\r\n * licensed under the MIT license.\r\n *\r\n * a set of Bezier curve functions that deal with Beziers, used by jsPlumb, and perhaps useful for other people.  These functions work with Bezier\r\n * curves of arbitrary degree.\r\n *\r\n * - functions are all in the \'jsBezier\' namespace.\r\n *\r\n * - all input points should be in the format {x:.., y:..}. all output points are in this format too.\r\n *\r\n * - all input curves should be in the format [ {x:.., y:..}, {x:.., y:..}, {x:.., y:..}, {x:.., y:..} ]\r\n *\r\n * - \'location\' as used as an input here refers to a decimal in the range 0-1 inclusive, which indicates a point some proportion along the length\r\n * of the curve.  location as output has the same format and meaning.\r\n *\r\n *\r\n * Function List:\r\n * --------------\r\n *\r\n * distanceFromCurve(point, curve)\r\n *\r\n * \tCalculates the distance that the given point lies from the given Bezier.  Note that it is computed relative to the center of the Bezier,\r\n * so if you have stroked the curve with a wide pen you may wish to take that into account!  The distance returned is relative to the values\r\n * of the curve and the point - it will most likely be pixels.\r\n *\r\n * gradientAtPoint(curve, location)\r\n *\r\n * \tCalculates the gradient to the curve at the given location, as a decimal between 0 and 1 inclusive.\r\n *\r\n * gradientAtPointAlongCurveFrom (curve, location)\r\n *\r\n *\tCalculates the gradient at the point on the given curve that is \'distance\' units from location.\r\n *\r\n * nearestPointOnCurve(point, curve)\r\n *\r\n *\tCalculates the nearest point to the given point on the given curve.  The return value of this is a JS object literal, containing both the\r\n *point\'s coordinates and also the \'location\' of the point (see above), for example:  { point:{x:551,y:150}, location:0.263365 }.\r\n *\r\n * pointOnCurve(curve, location)\r\n *\r\n * \tCalculates the coordinates of the point on the given Bezier curve at the given location.\r\n *\r\n * pointAlongCurveFrom(curve, location, distance)\r\n *\r\n * \tCalculates the coordinates of the point on the given curve that is \'distance\' units from location.  \'distance\' should be in the same coordinate\r\n * space as that used to construct the Bezier curve.  For an HTML Canvas usage, for example, distance would be a measure of pixels.\r\n *\r\n * locationAlongCurveFrom(curve, location, distance)\r\n *\r\n * \tCalculates the location on the given curve that is \'distance\' units from location.  \'distance\' should be in the same coordinate\r\n * space as that used to construct the Bezier curve.  For an HTML Canvas usage, for example, distance would be a measure of pixels.\r\n *\r\n * perpendicularToCurveAt(curve, location, length, distance)\r\n *\r\n * \tCalculates the perpendicular to the given curve at the given location.  length is the length of the line you wish for (it will be centered\r\n * on the point at \'location\'). distance is optional, and allows you to specify a point along the path from the given location as the center of\r\n * the perpendicular returned.  The return value of this is an array of two points: [ {x:...,y:...}, {x:...,y:...} ].\r\n *\r\n *\r\n */(function(){var root=this;if(typeof Math.sgn=="undefined"){Math.sgn=function(x){return x==0?0:x>0?1:-1;};}var Vectors={subtract:function subtract(v1,v2){return{x:v1.x-v2.x,y:v1.y-v2.y};},dotProduct:function dotProduct(v1,v2){return v1.x*v2.x+v1.y*v2.y;},square:function square(v){return Math.sqrt(v.x*v.x+v.y*v.y);},scale:function scale(v,s){return{x:v.x*s,y:v.y*s};}},maxRecursion=64,flatnessTolerance=Math.pow(2.0,-maxRecursion-1);/**\r\n     * Calculates the distance that the point lies from the curve.\r\n     *\r\n     * @param point a point in the form {x:567, y:3342}\r\n     * @param curve a Bezier curve in the form [{x:..., y:...}, {x:..., y:...}, {x:..., y:...}, {x:..., y:...}].  note that this is currently\r\n     * hardcoded to assume cubiz beziers, but would be better off supporting any degree.\r\n     * @return a JS object literal containing location and distance, for example: {location:0.35, distance:10}.  Location is analogous to the location\r\n     * argument you pass to the pointOnPath function: it is a ratio of distance travelled along the curve.  Distance is the distance in pixels from\r\n     * the point to the curve.\r\n     */var _distanceFromCurve=function _distanceFromCurve(point,curve){var candidates=[],w=_convertToBezier(point,curve),degree=curve.length-1,higherDegree=2*degree-1,numSolutions=_findRoots(w,higherDegree,candidates,0),v=Vectors.subtract(point,curve[0]),dist=Vectors.square(v),t=0.0;for(var i=0;i<numSolutions;i++){v=Vectors.subtract(point,_bezier(curve,degree,candidates[i],null,null));var newDist=Vectors.square(v);if(newDist<dist){dist=newDist;t=candidates[i];}}v=Vectors.subtract(point,curve[degree]);newDist=Vectors.square(v);if(newDist<dist){dist=newDist;t=1.0;}return{location:t,distance:dist};};/**\r\n     * finds the nearest point on the curve to the given point.\r\n     */var _nearestPointOnCurve=function _nearestPointOnCurve(point,curve){var td=_distanceFromCurve(point,curve);return{point:_bezier(curve,curve.length-1,td.location,null,null),location:td.location};};var _convertToBezier=function _convertToBezier(point,curve){var degree=curve.length-1,higherDegree=2*degree-1,c=[],d=[],cdTable=[],w=[],z=[[1.0,0.6,0.3,0.1],[0.4,0.6,0.6,0.4],[0.1,0.3,0.6,1.0]];for(var i=0;i<=degree;i++){c[i]=Vectors.subtract(curve[i],point);}for(var i=0;i<=degree-1;i++){d[i]=Vectors.subtract(curve[i+1],curve[i]);d[i]=Vectors.scale(d[i],3.0);}for(var row=0;row<=degree-1;row++){for(var column=0;column<=degree;column++){if(!cdTable[row])cdTable[row]=[];cdTable[row][column]=Vectors.dotProduct(d[row],c[column]);}}for(i=0;i<=higherDegree;i++){if(!w[i])w[i]=[];w[i].y=0.0;w[i].x=parseFloat(i)/higherDegree;}var n=degree,m=degree-1;for(var k=0;k<=n+m;k++){var lb=Math.max(0,k-m),ub=Math.min(k,n);for(i=lb;i<=ub;i++){j=k-i;w[i+j].y+=cdTable[j][i]*z[j][i];}}return w;};/**\r\n     * counts how many roots there are.\r\n     */var _findRoots=function _findRoots(w,degree,t,depth){var left=[],right=[],left_count,right_count,left_t=[],right_t=[];switch(_getCrossingCount(w,degree)){case 0:{return 0;}case 1:{if(depth>=maxRecursion){t[0]=(w[0].x+w[degree].x)/2.0;return 1;}if(_isFlatEnough(w,degree)){t[0]=_computeXIntercept(w,degree);return 1;}break;}}_bezier(w,degree,0.5,left,right);left_count=_findRoots(left,degree,left_t,depth+1);right_count=_findRoots(right,degree,right_t,depth+1);for(var i=0;i<left_count;i++){t[i]=left_t[i];}for(var i=0;i<right_count;i++){t[i+left_count]=right_t[i];}return left_count+right_count;};var _getCrossingCount=function _getCrossingCount(curve,degree){var n_crossings=0,sign,old_sign;sign=old_sign=Math.sgn(curve[0].y);for(var i=1;i<=degree;i++){sign=Math.sgn(curve[i].y);if(sign!=old_sign)n_crossings++;old_sign=sign;}return n_crossings;};var _isFlatEnough=function _isFlatEnough(curve,degree){var error,intercept_1,intercept_2,left_intercept,right_intercept,a,b,c,det,dInv,a1,b1,c1,a2,b2,c2;a=curve[0].y-curve[degree].y;b=curve[degree].x-curve[0].x;c=curve[0].x*curve[degree].y-curve[degree].x*curve[0].y;var max_distance_above=max_distance_below=0.0;for(var i=1;i<degree;i++){var value=a*curve[i].x+b*curve[i].y+c;if(value>max_distance_above)max_distance_above=value;else if(value<max_distance_below)max_distance_below=value;}a1=0.0;b1=1.0;c1=0.0;a2=a;b2=b;c2=c-max_distance_above;det=a1*b2-a2*b1;dInv=1.0/det;intercept_1=(b1*c2-b2*c1)*dInv;a2=a;b2=b;c2=c-max_distance_below;det=a1*b2-a2*b1;dInv=1.0/det;intercept_2=(b1*c2-b2*c1)*dInv;left_intercept=Math.min(intercept_1,intercept_2);right_intercept=Math.max(intercept_1,intercept_2);error=right_intercept-left_intercept;return error<flatnessTolerance?1:0;};var _computeXIntercept=function _computeXIntercept(curve,degree){var XLK=1.0,YLK=0.0,XNM=curve[degree].x-curve[0].x,YNM=curve[degree].y-curve[0].y,XMK=curve[0].x-0.0,YMK=curve[0].y-0.0,det=XNM*YLK-YNM*XLK,detInv=1.0/det,S=(XNM*YMK-YNM*XMK)*detInv;return 0.0+XLK*S;};var _bezier=function _bezier(curve,degree,t,left,right){var temp=[[]];for(var j=0;j<=degree;j++){temp[0][j]=curve[j];}for(var i=1;i<=degree;i++){for(var j=0;j<=degree-i;j++){if(!temp[i])temp[i]=[];if(!temp[i][j])temp[i][j]={};temp[i][j].x=(1.0-t)*temp[i-1][j].x+t*temp[i-1][j+1].x;temp[i][j].y=(1.0-t)*temp[i-1][j].y+t*temp[i-1][j+1].y;}}if(left!=null)for(j=0;j<=degree;j++){left[j]=temp[j][0];}if(right!=null)for(j=0;j<=degree;j++){right[j]=temp[degree-j][j];}return temp[degree][0];};var _curveFunctionCache={};var _getCurveFunctions=function _getCurveFunctions(order){var fns=_curveFunctionCache[order];if(!fns){fns=[];var f_term=function f_term(){return function(t){return Math.pow(t,order);};},l_term=function l_term(){return function(t){return Math.pow(1-t,order);};},c_term=function c_term(c){return function(t){return c;};},t_term=function t_term(){return function(t){return t;};},one_minus_t_term=function one_minus_t_term(){return function(t){return 1-t;};},_termFunc=function _termFunc(terms){return function(t){var p=1;for(var i=0;i<terms.length;i++){p=p*terms[i](t);}return p;};};fns.push(new f_term());// first is t to the power of the curve order\nfor(var i=1;i<order;i++){var terms=[new c_term(order)];for(var j=0;j<order-i;j++){terms.push(new t_term());}for(var j=0;j<i;j++){terms.push(new one_minus_t_term());}fns.push(new _termFunc(terms));}fns.push(new l_term());// last is (1-t) to the power of the curve order\n_curveFunctionCache[order]=fns;}return fns;};/**\r\n     * calculates a point on the curve, for a Bezier of arbitrary order.\r\n     * @param curve an array of control points, eg [{x:10,y:20}, {x:50,y:50}, {x:100,y:100}, {x:120,y:100}].  For a cubic bezier this should have four points.\r\n     * @param location a decimal indicating the distance along the curve the point should be located at.  this is the distance along the curve as it travels, taking the way it bends into account.  should be a number from 0 to 1, inclusive.\r\n     */var _pointOnPath=function _pointOnPath(curve,location){var cc=_getCurveFunctions(curve.length-1),_x=0,_y=0;for(var i=0;i<curve.length;i++){_x=_x+curve[i].x*cc[i](location);_y=_y+curve[i].y*cc[i](location);}return{x:_x,y:_y};};var _dist=function _dist(p1,p2){return Math.sqrt(Math.pow(p1.x-p2.x,2)+Math.pow(p1.y-p2.y,2));};var _isPoint=function _isPoint(curve){return curve[0].x==curve[1].x&&curve[0].y==curve[1].y;};/**\r\n     * finds the point that is \'distance\' along the path from \'location\'.  this method returns both the x,y location of the point and also\r\n     * its \'location\' (proportion of travel along the path); the method below - _pointAlongPathFrom - calls this method and just returns the\r\n     * point.\r\n     */var _pointAlongPath=function _pointAlongPath(curve,location,distance){if(_isPoint(curve)){return{point:curve[0],location:location};}var prev=_pointOnPath(curve,location),tally=0,curLoc=location,direction=distance>0?1:-1,cur=null;while(tally<Math.abs(distance)){curLoc+=0.005*direction;cur=_pointOnPath(curve,curLoc);tally+=_dist(cur,prev);prev=cur;}return{point:cur,location:curLoc};};var _length=function _length(curve){if(_isPoint(curve))return 0;var prev=_pointOnPath(curve,0),tally=0,curLoc=0,direction=1,cur=null;while(curLoc<1){curLoc+=0.005*direction;cur=_pointOnPath(curve,curLoc);tally+=_dist(cur,prev);prev=cur;}return tally;};/**\r\n     * finds the point that is \'distance\' along the path from \'location\'.\r\n     */var _pointAlongPathFrom=function _pointAlongPathFrom(curve,location,distance){return _pointAlongPath(curve,location,distance).point;};/**\r\n     * finds the location that is \'distance\' along the path from \'location\'.\r\n     */var _locationAlongPathFrom=function _locationAlongPathFrom(curve,location,distance){return _pointAlongPath(curve,location,distance).location;};/**\r\n     * returns the gradient of the curve at the given location, which is a decimal between 0 and 1 inclusive.\r\n     *\r\n     * thanks // http://bimixual.org/AnimationLibrary/beziertangents.html\r\n     */var _gradientAtPoint=function _gradientAtPoint(curve,location){var p1=_pointOnPath(curve,location),p2=_pointOnPath(curve.slice(0,curve.length-1),location),dy=p2.y-p1.y,dx=p2.x-p1.x;return dy==0?Infinity:Math.atan(dy/dx);};/**\r\n     returns the gradient of the curve at the point which is \'distance\' from the given location.\r\n     if this point is greater than location 1, the gradient at location 1 is returned.\r\n     if this point is less than location 0, the gradient at location 0 is returned.\r\n     */var _gradientAtPointAlongPathFrom=function _gradientAtPointAlongPathFrom(curve,location,distance){var p=_pointAlongPath(curve,location,distance);if(p.location>1)p.location=1;if(p.location<0)p.location=0;return _gradientAtPoint(curve,p.location);};/**\r\n     * calculates a line that is \'length\' pixels long, perpendicular to, and centered on, the path at \'distance\' pixels from the given location.\r\n     * if distance is not supplied, the perpendicular for the given location is computed (ie. we set distance to zero).\r\n     */var _perpendicularToPathAt=function _perpendicularToPathAt(curve,location,length,distance){distance=distance==null?0:distance;var p=_pointAlongPath(curve,location,distance),m=_gradientAtPoint(curve,p.location),_theta2=Math.atan(-1/m),y=length/2*Math.sin(_theta2),x=length/2*Math.cos(_theta2);return[{x:p.point.x+x,y:p.point.y+y},{x:p.point.x-x,y:p.point.y-y}];};var jsBezier=this.jsBezier={distanceFromCurve:_distanceFromCurve,gradientAtPoint:_gradientAtPoint,gradientAtPointAlongCurveFrom:_gradientAtPointAlongPathFrom,nearestPointOnCurve:_nearestPointOnCurve,pointOnCurve:_pointOnPath,pointAlongCurveFrom:_pointAlongPathFrom,perpendicularToCurveAt:_perpendicularToPathAt,locationAlongCurveFrom:_locationAlongPathFrom,getLength:_length,version:"0.9.0"};if(true){exports.jsBezier=jsBezier;}}).call(typeof window!==\'undefined\'?window:this);/**\r\n * Biltong v0.4.0\r\n *\r\n * Various geometry functions written as part of jsPlumb and perhaps useful for others.\r\n *\r\n * Copyright (c) 2017 jsPlumb\r\n * https://jsplumbtoolkit.com\r\n *\r\n * Permission is hereby granted, free of charge, to any person\r\n * obtaining a copy of this software and associated documentation\r\n * files (the "Software"), to deal in the Software without\r\n * restriction, including without limitation the rights to use,\r\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following\r\n * conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\r\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\r\n * OTHER DEALINGS IN THE SOFTWARE.\r\n */;(function(){"use strict";var root=this;var Biltong=root.Biltong={version:"0.4.0"};if(true){exports.Biltong=Biltong;}var _isa=function _isa(a){return Object.prototype.toString.call(a)==="[object Array]";},_pointHelper=function _pointHelper(p1,p2,fn){p1=_isa(p1)?p1:[p1.x,p1.y];p2=_isa(p2)?p2:[p2.x,p2.y];return fn(p1,p2);},/**\r\n         * @name Biltong.gradient\r\n         * @function\r\n         * @desc Calculates the gradient of a line between the two points.\r\n         * @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.\r\n         * @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.\r\n         * @return {Float} The gradient of a line between the two points.\r\n         */_gradient=Biltong.gradient=function(p1,p2){return _pointHelper(p1,p2,function(_p1,_p2){if(_p2[0]==_p1[0])return _p2[1]>_p1[1]?Infinity:-Infinity;else if(_p2[1]==_p1[1])return _p2[0]>_p1[0]?0:-0;else return(_p2[1]-_p1[1])/(_p2[0]-_p1[0]);});},/**\r\n         * @name Biltong.normal\r\n         * @function\r\n         * @desc Calculates the gradient of a normal to a line between the two points.\r\n         * @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.\r\n         * @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.\r\n         * @return {Float} The gradient of a normal to a line between the two points.\r\n         */_normal=Biltong.normal=function(p1,p2){return-1/_gradient(p1,p2);},/**\r\n         * @name Biltong.lineLength\r\n         * @function\r\n         * @desc Calculates the length of a line between the two points.\r\n         * @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.\r\n         * @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.\r\n         * @return {Float} The length of a line between the two points.\r\n         */_lineLength=Biltong.lineLength=function(p1,p2){return _pointHelper(p1,p2,function(_p1,_p2){return Math.sqrt(Math.pow(_p2[1]-_p1[1],2)+Math.pow(_p2[0]-_p1[0],2));});},/**\r\n         * @name Biltong.quadrant\r\n         * @function\r\n         * @desc Calculates the quadrant in which the angle between the two points lies.\r\n         * @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.\r\n         * @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.\r\n         * @return {Integer} The quadrant - 1 for upper right, 2 for lower right, 3 for lower left, 4 for upper left.\r\n         */_quadrant=Biltong.quadrant=function(p1,p2){return _pointHelper(p1,p2,function(_p1,_p2){if(_p2[0]>_p1[0]){return _p2[1]>_p1[1]?2:1;}else if(_p2[0]==_p1[0]){return _p2[1]>_p1[1]?2:1;}else{return _p2[1]>_p1[1]?3:4;}});},/**\r\n         * @name Biltong.theta\r\n         * @function\r\n         * @desc Calculates the angle between the two points.\r\n         * @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.\r\n         * @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.\r\n         * @return {Float} The angle between the two points.\r\n         */_theta=Biltong.theta=function(p1,p2){return _pointHelper(p1,p2,function(_p1,_p2){var m=_gradient(_p1,_p2),t=Math.atan(m),s=_quadrant(_p1,_p2);if(s==4||s==3)t+=Math.PI;if(t<0)t+=2*Math.PI;return t;});},/**\r\n         * @name Biltong.intersects\r\n         * @function\r\n         * @desc Calculates whether or not the two rectangles intersect.\r\n         * @param {Rectangle} r1 First rectangle, as a js object in the form `{x:.., y:.., w:.., h:..}`\r\n         * @param {Rectangle} r2 Second rectangle, as a js object in the form `{x:.., y:.., w:.., h:..}`\r\n         * @return {Boolean} True if the rectangles intersect, false otherwise.\r\n         */_intersects=Biltong.intersects=function(r1,r2){var x1=r1.x,x2=r1.x+r1.w,y1=r1.y,y2=r1.y+r1.h,a1=r2.x,a2=r2.x+r2.w,b1=r2.y,b2=r2.y+r2.h;return x1<=a1&&a1<=x2&&y1<=b1&&b1<=y2||x1<=a2&&a2<=x2&&y1<=b1&&b1<=y2||x1<=a1&&a1<=x2&&y1<=b2&&b2<=y2||x1<=a2&&a1<=x2&&y1<=b2&&b2<=y2||a1<=x1&&x1<=a2&&b1<=y1&&y1<=b2||a1<=x2&&x2<=a2&&b1<=y1&&y1<=b2||a1<=x1&&x1<=a2&&b1<=y2&&y2<=b2||a1<=x2&&x1<=a2&&b1<=y2&&y2<=b2;},/**\r\n         * @name Biltong.encloses\r\n         * @function\r\n         * @desc Calculates whether or not r2 is completely enclosed by r1.\r\n         * @param {Rectangle} r1 First rectangle, as a js object in the form `{x:.., y:.., w:.., h:..}`\r\n         * @param {Rectangle} r2 Second rectangle, as a js object in the form `{x:.., y:.., w:.., h:..}`\r\n         * @param {Boolean} [allowSharedEdges=false] If true, the concept of enclosure allows for one or more edges to be shared by the two rectangles.\r\n         * @return {Boolean} True if r1 encloses r2, false otherwise.\r\n         */_encloses=Biltong.encloses=function(r1,r2,allowSharedEdges){var x1=r1.x,x2=r1.x+r1.w,y1=r1.y,y2=r1.y+r1.h,a1=r2.x,a2=r2.x+r2.w,b1=r2.y,b2=r2.y+r2.h,c=function c(v1,v2,v3,v4){return allowSharedEdges?v1<=v2&&v3>=v4:v1<v2&&v3>v4;};return c(x1,a1,x2,a2)&&c(y1,b1,y2,b2);},_segmentMultipliers=[null,[1,-1],[1,1],[-1,1],[-1,-1]],_inverseSegmentMultipliers=[null,[-1,-1],[-1,1],[1,1],[1,-1]],/**\r\n         * @name Biltong.pointOnLine\r\n         * @function\r\n         * @desc Calculates a point on the line from `fromPoint` to `toPoint` that is `distance` units along the length of the line.\r\n         * @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.\r\n         * @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.\r\n         * @return {Point} Point on the line, in the form `{ x:..., y:... }`.\r\n         */_pointOnLine=Biltong.pointOnLine=function(fromPoint,toPoint,distance){var m=_gradient(fromPoint,toPoint),s=_quadrant(fromPoint,toPoint),segmentMultiplier=distance>0?_segmentMultipliers[s]:_inverseSegmentMultipliers[s],theta=Math.atan(m),y=Math.abs(distance*Math.sin(theta))*segmentMultiplier[1],x=Math.abs(distance*Math.cos(theta))*segmentMultiplier[0];return{x:fromPoint.x+x,y:fromPoint.y+y};},/**\r\n         * @name Biltong.perpendicularLineTo\r\n         * @function\r\n         * @desc Calculates a line of length `length` that is perpendicular to the line from `fromPoint` to `toPoint` and passes through `toPoint`.\r\n         * @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.\r\n         * @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.\r\n         * @return {Line} Perpendicular line, in the form `[ { x:..., y:... }, { x:..., y:... } ]`.\r\n         */_perpendicularLineTo=Biltong.perpendicularLineTo=function(fromPoint,toPoint,length){var m=_gradient(fromPoint,toPoint),theta2=Math.atan(-1/m),y=length/2*Math.sin(theta2),x=length/2*Math.cos(theta2);return[{x:toPoint.x+x,y:toPoint.y+y},{x:toPoint.x-x,y:toPoint.y-y}];};}).call(typeof window!==\'undefined\'?window:this);;(function(){"use strict";var root=this,Sniff={android:navigator.userAgent.toLowerCase().indexOf("android")>-1},matchesSelector=function matchesSelector(el,selector,ctx){ctx=ctx||el.parentNode;var possibles=ctx.querySelectorAll(selector);for(var i=0;i<possibles.length;i++){if(possibles[i]===el){return true;}}return false;},_gel=function _gel(el){return typeof el=="string"||el.constructor===String?document.getElementById(el):el;},_t=function _t(e){return e.srcElement||e.target;},//\n// gets path info for the given event - the path from target to obj, in the event\'s bubble chain. if doCompute\n// is false we just return target for the path.\n//\n_pi=function _pi(e,target,obj,doCompute){if(!doCompute)return{path:[target],end:1};else if(typeof e.path!=="undefined"&&e.path.indexOf){return{path:e.path,end:e.path.indexOf(obj)};}else{var out={path:[],end:-1},_one=function _one(el){out.path.push(el);if(el===obj){out.end=out.path.length-1;}else if(el.parentNode!=null){_one(el.parentNode);}};_one(target);return out;}},_d=function _d(l,fn){for(var i=0,j=l.length;i<j;i++){if(l[i]==fn)break;}if(i<l.length)l.splice(i,1);},guid=1,//\n// this function generates a guid for every handler, sets it on the handler, then adds\n// it to the associated object\'s map of handlers for the given event. this is what enables us\n// to unbind all events of some type, or all events (the second of which can be requested by the user,\n// but it also used by Mottle when an element is removed.)\n_store=function _store(obj,event,fn){var g=guid++;obj.__ta=obj.__ta||{};obj.__ta[event]=obj.__ta[event]||{};// store each handler with a unique guid.\nobj.__ta[event][g]=fn;// set the guid on the handler.\nfn.__tauid=g;return g;},_unstore=function _unstore(obj,event,fn){obj.__ta&&obj.__ta[event]&&delete obj.__ta[event][fn.__tauid];// a handler might have attached extra functions, so we unbind those too.\nif(fn.__taExtra){for(var i=0;i<fn.__taExtra.length;i++){_unbind(obj,fn.__taExtra[i][0],fn.__taExtra[i][1]);}fn.__taExtra.length=0;}// a handler might have attached an unstore callback\nfn.__taUnstore&&fn.__taUnstore();},_curryChildFilter=function _curryChildFilter(children,obj,fn,evt){if(children==null)return fn;else{var c=children.split(","),_fn=function _fn(e){_fn.__tauid=fn.__tauid;var t=_t(e),target=t;// t is the target element on which the event occurred. it is the\n// element we will wish to pass to any callbacks.\nvar pathInfo=_pi(e,t,obj,children!=null);if(pathInfo.end!=-1){for(var p=0;p<pathInfo.end;p++){target=pathInfo.path[p];for(var i=0;i<c.length;i++){if(matchesSelector(target,c[i],obj)){fn.apply(target,arguments);}}}}};registerExtraFunction(fn,evt,_fn);return _fn;}},//\n// registers an \'extra\' function on some event listener function we were given - a function that we\n// created and bound to the element as part of our housekeeping, and which we want to unbind and remove\n// whenever the given function is unbound.\nregisterExtraFunction=function registerExtraFunction(fn,evt,newFn){fn.__taExtra=fn.__taExtra||[];fn.__taExtra.push([evt,newFn]);},DefaultHandler=function DefaultHandler(obj,evt,fn,children){if(isTouchDevice&&touchMap[evt]){var tfn=_curryChildFilter(children,obj,fn,touchMap[evt]);_bind(obj,touchMap[evt],tfn,fn);}if(evt==="focus"&&obj.getAttribute("tabindex")==null){obj.setAttribute("tabindex","1");}_bind(obj,evt,_curryChildFilter(children,obj,fn,evt),fn);},SmartClickHandler=function SmartClickHandler(obj,evt,fn,children){if(obj.__taSmartClicks==null){var down=function down(e){obj.__tad=_pageLocation(e);},up=function up(e){obj.__tau=_pageLocation(e);},click=function click(e){if(obj.__tad&&obj.__tau&&obj.__tad[0]===obj.__tau[0]&&obj.__tad[1]===obj.__tau[1]){for(var i=0;i<obj.__taSmartClicks.length;i++){obj.__taSmartClicks[i].apply(_t(e),[e]);}}};DefaultHandler(obj,"mousedown",down,children);DefaultHandler(obj,"mouseup",up,children);DefaultHandler(obj,"click",click,children);obj.__taSmartClicks=[];}// store in the list of callbacks\nobj.__taSmartClicks.push(fn);// the unstore function removes this function from the object\'s listener list for this type.\nfn.__taUnstore=function(){_d(obj.__taSmartClicks,fn);};},_tapProfiles={"tap":{touches:1,taps:1},"dbltap":{touches:1,taps:2},"contextmenu":{touches:2,taps:1}},TapHandler=function TapHandler(clickThreshold,dblClickThreshold){return function(obj,evt,fn,children){// if event is contextmenu, for devices which are mouse only, we want to\n// use the default bind.\nif(evt=="contextmenu"&&isMouseDevice)DefaultHandler(obj,evt,fn,children);else{// the issue here is that this down handler gets registered only for the\n// child nodes in the first registration. in fact it should be registered with\n// no child selector and then on down we should cycle through the registered\n// functions to see if one of them matches. on mouseup we should execute ALL of\n// the functions whose children are either null or match the element.\nif(obj.__taTapHandler==null){var tt=obj.__taTapHandler={tap:[],dbltap:[],contextmenu:[],down:false,taps:0,downSelectors:[]};var down=function down(e){var target=_t(e),pathInfo=_pi(e,target,obj,children!=null),finished=false;for(var p=0;p<pathInfo.end;p++){if(finished)return;target=pathInfo.path[p];for(var i=0;i<tt.downSelectors.length;i++){if(tt.downSelectors[i]==null||matchesSelector(target,tt.downSelectors[i],obj)){tt.down=true;setTimeout(clearSingle,clickThreshold);setTimeout(clearDouble,dblClickThreshold);finished=true;break;// we only need one match on mousedown\n}}}},up=function up(e){if(tt.down){var target=_t(e),currentTarget,pathInfo;tt.taps++;var tc=_touchCount(e);for(var eventId in _tapProfiles){if(_tapProfiles.hasOwnProperty(eventId)){var p=_tapProfiles[eventId];if(p.touches===tc&&(p.taps===1||p.taps===tt.taps)){for(var i=0;i<tt[eventId].length;i++){pathInfo=_pi(e,target,obj,tt[eventId][i][1]!=null);for(var pLoop=0;pLoop<pathInfo.end;pLoop++){currentTarget=pathInfo.path[pLoop];// this is a single event registration handler.\nif(tt[eventId][i][1]==null||matchesSelector(currentTarget,tt[eventId][i][1],obj)){tt[eventId][i][0].apply(currentTarget,[e]);break;}}}}}}}},clearSingle=function clearSingle(){tt.down=false;},clearDouble=function clearDouble(){tt.taps=0;};DefaultHandler(obj,"mousedown",down);DefaultHandler(obj,"mouseup",up);}// add this child selector (it can be null, that\'s fine).\nobj.__taTapHandler.downSelectors.push(children);obj.__taTapHandler[evt].push([fn,children]);// the unstore function removes this function from the object\'s listener list for this type.\nfn.__taUnstore=function(){_d(obj.__taTapHandler[evt],fn);};}};},meeHelper=function meeHelper(type,evt,obj,target){for(var i in obj.__tamee[type]){if(obj.__tamee[type].hasOwnProperty(i)){obj.__tamee[type][i].apply(target,[evt]);}}},MouseEnterExitHandler=function MouseEnterExitHandler(){var activeElements=[];return function(obj,evt,fn,children){if(!obj.__tamee){// __tamee holds a flag saying whether the mouse is currently "in" the element, and a list of\n// both mouseenter and mouseexit functions.\nobj.__tamee={over:false,mouseenter:[],mouseexit:[]};// register over and out functions\nvar over=function over(e){var t=_t(e);if(children==null&&t==obj&&!obj.__tamee.over||matchesSelector(t,children,obj)&&(t.__tamee==null||!t.__tamee.over)){meeHelper("mouseenter",e,obj,t);t.__tamee=t.__tamee||{};t.__tamee.over=true;activeElements.push(t);}},out=function out(e){var t=_t(e);// is the current target one of the activeElements? and is the\n// related target NOT a descendant of it?\nfor(var i=0;i<activeElements.length;i++){if(t==activeElements[i]&&!matchesSelector(e.relatedTarget||e.toElement,"*",t)){t.__tamee.over=false;activeElements.splice(i,1);meeHelper("mouseexit",e,obj,t);}}};_bind(obj,"mouseover",_curryChildFilter(children,obj,over,"mouseover"),over);_bind(obj,"mouseout",_curryChildFilter(children,obj,out,"mouseout"),out);}fn.__taUnstore=function(){delete obj.__tamee[evt][fn.__tauid];};_store(obj,evt,fn);obj.__tamee[evt][fn.__tauid]=fn;};},isTouchDevice="ontouchstart"in document.documentElement,isMouseDevice="onmousedown"in document.documentElement,touchMap={"mousedown":"touchstart","mouseup":"touchend","mousemove":"touchmove"},touchstart="touchstart",touchend="touchend",touchmove="touchmove",iev=function(){var rv=-1;if(navigator.appName==\'Microsoft Internet Explorer\'){var ua=navigator.userAgent,re=new RegExp("MSIE ([0-9]{1,}[\\.0-9]{0,})");if(re.exec(ua)!=null)rv=parseFloat(RegExp.$1);}return rv;}(),isIELT9=iev>-1&&iev<9,_genLoc=function _genLoc(e,prefix){if(e==null)return[0,0];var ts=_touches(e),t=_getTouch(ts,0);return[t[prefix+"X"],t[prefix+"Y"]];},_pageLocation=function _pageLocation(e){if(e==null)return[0,0];if(isIELT9){return[e.clientX+document.documentElement.scrollLeft,e.clientY+document.documentElement.scrollTop];}else{return _genLoc(e,"page");}},_screenLocation=function _screenLocation(e){return _genLoc(e,"screen");},_clientLocation=function _clientLocation(e){return _genLoc(e,"client");},_getTouch=function _getTouch(touches,idx){return touches.item?touches.item(idx):touches[idx];},_touches=function _touches(e){return e.touches&&e.touches.length>0?e.touches:e.changedTouches&&e.changedTouches.length>0?e.changedTouches:e.targetTouches&&e.targetTouches.length>0?e.targetTouches:[e];},_touchCount=function _touchCount(e){return _touches(e).length;},//http://www.quirksmode.org/blog/archives/2005/10/_and_the_winner_1.html\n_bind=function _bind(obj,type,fn,originalFn){_store(obj,type,fn);originalFn.__tauid=fn.__tauid;if(obj.addEventListener)obj.addEventListener(type,fn,false);else if(obj.attachEvent){var key=type+fn.__tauid;obj["e"+key]=fn;// TODO look at replacing with .call(..)\nobj[key]=function(){obj["e"+key]&&obj["e"+key](window.event);};obj.attachEvent("on"+type,obj[key]);}},_unbind=function _unbind(obj,type,fn){if(fn==null)return;_each(obj,function(){var _el=_gel(this);_unstore(_el,type,fn);// it has been bound if there is a tauid. otherwise it was not bound and we can ignore it.\nif(fn.__tauid!=null){if(_el.removeEventListener){_el.removeEventListener(type,fn,false);if(isTouchDevice&&touchMap[type])_el.removeEventListener(touchMap[type],fn,false);}else if(this.detachEvent){var key=type+fn.__tauid;_el[key]&&_el.detachEvent("on"+type,_el[key]);_el[key]=null;_el["e"+key]=null;}}// if a touch event was also registered, deregister now.\nif(fn.__taTouchProxy){_unbind(obj,fn.__taTouchProxy[1],fn.__taTouchProxy[0]);}});},_each=function _each(obj,fn){if(obj==null)return;// if a list (or list-like), use it. if a string, get a list\n// by running the string through querySelectorAll. else, assume\n// it\'s an Element.\n// obj.top is "unknown" in IE8.\nobj=typeof Window!=="undefined"&&typeof obj.top!=="unknown"&&obj==obj.top?[obj]:typeof obj!=="string"&&obj.tagName==null&&obj.length!=null?obj:typeof obj==="string"?document.querySelectorAll(obj):[obj];for(var i=0;i<obj.length;i++){fn.apply(obj[i]);}};/**\r\n     * Mottle offers support for abstracting out the differences\r\n     * between touch and mouse devices, plus "smart click" functionality\r\n     * (don\'t fire click if the mouse has moved between mousedown and mouseup),\r\n     * and synthesized click/tap events.\r\n     * @class Mottle\r\n     * @constructor\r\n     * @param {Object} params Constructor params\r\n     * @param {Number} [params.clickThreshold=250] Threshold, in milliseconds beyond which a touchstart followed by a touchend is not considered to be a click.\r\n     * @param {Number} [params.dblClickThreshold=450] Threshold, in milliseconds beyond which two successive tap events are not considered to be a click.\r\n     * @param {Boolean} [params.smartClicks=false] If true, won\'t fire click events if the mouse has moved between mousedown and mouseup. Note that this functionality\r\n     * requires that Mottle consume the mousedown event, and so may not be viable in all use cases.\r\n     */root.Mottle=function(params){params=params||{};var clickThreshold=params.clickThreshold||250,dblClickThreshold=params.dblClickThreshold||450,mouseEnterExitHandler=new MouseEnterExitHandler(),tapHandler=new TapHandler(clickThreshold,dblClickThreshold),_smartClicks=params.smartClicks,_doBind=function _doBind(obj,evt,fn,children){if(fn==null)return;_each(obj,function(){var _el=_gel(this);if(_smartClicks&&evt==="click")SmartClickHandler(_el,evt,fn,children);else if(evt==="tap"||evt==="dbltap"||evt==="contextmenu"){tapHandler(_el,evt,fn,children);}else if(evt==="mouseenter"||evt=="mouseexit")mouseEnterExitHandler(_el,evt,fn,children);else DefaultHandler(_el,evt,fn,children);});};/**\r\n         * Removes an element from the DOM, and deregisters all event handlers for it. You should use this\r\n         * to ensure you don\'t leak memory.\r\n         * @method remove\r\n         * @param {String|Element} el Element, or id of the element, to remove.\r\n         * @return {Mottle} The current Mottle instance; you can chain this method.\r\n         */this.remove=function(el){_each(el,function(){var _el=_gel(this);if(_el.__ta){for(var evt in _el.__ta){if(_el.__ta.hasOwnProperty(evt)){for(var h in _el.__ta[evt]){if(_el.__ta[evt].hasOwnProperty(h))_unbind(_el,evt,_el.__ta[evt][h]);}}}}_el.parentNode&&_el.parentNode.removeChild(_el);});return this;};/**\r\n         * Register an event handler, optionally as a delegate for some set of descendant elements. Note\r\n         * that this method takes either 3 or 4 arguments - if you supply 3 arguments it is assumed you have\r\n         * omitted the `children` parameter, and that the event handler should be bound directly to the given element.\r\n         * @method on\r\n         * @param {Element[]|Element|String} el Either an Element, or a CSS spec for a list of elements, or an array of Elements.\r\n         * @param {String} [children] Comma-delimited list of selectors identifying allowed children.\r\n         * @param {String} event Event ID.\r\n         * @param {Function} fn Event handler function.\r\n         * @return {Mottle} The current Mottle instance; you can chain this method.\r\n         */this.on=function(el,event,children,fn){var _el=arguments[0],_c=arguments.length==4?arguments[2]:null,_e=arguments[1],_f=arguments[arguments.length-1];_doBind(_el,_e,_f,_c);return this;};/**\r\n         * Cancel delegate event handling for the given function. Note that unlike with \'on\' you do not supply\r\n         * a list of child selectors here: it removes event delegation from all of the child selectors for which the\r\n         * given function was registered (if any).\r\n         * @method off\r\n         * @param {Element[]|Element|String} el Element - or ID of element - from which to remove event listener.\r\n         * @param {String} event Event ID.\r\n         * @param {Function} fn Event handler function.\r\n         * @return {Mottle} The current Mottle instance; you can chain this method.\r\n         */this.off=function(el,event,fn){_unbind(el,event,fn);return this;};/**\r\n         * Triggers some event for a given element.\r\n         * @method trigger\r\n         * @param {Element} el Element for which to trigger the event.\r\n         * @param {String} event Event ID.\r\n         * @param {Event} originalEvent The original event. Should be optional of course, but currently is not, due\r\n         * to the jsPlumb use case that caused this method to be added.\r\n         * @param {Object} [payload] Optional object to set as `payload` on the generated event; useful for message passing.\r\n         * @return {Mottle} The current Mottle instance; you can chain this method.\r\n         */this.trigger=function(el,event,originalEvent,payload){// MouseEvent undefined in old IE; that\'s how we know it\'s a mouse event.  A fine Microsoft paradox.\nvar originalIsMouse=isMouseDevice&&(typeof MouseEvent==="undefined"||originalEvent==null||originalEvent.constructor===MouseEvent);var eventToBind=isTouchDevice&&!isMouseDevice&&touchMap[event]?touchMap[event]:event,bindingAMouseEvent=!(isTouchDevice&&!isMouseDevice&&touchMap[event]);var pl=_pageLocation(originalEvent),sl=_screenLocation(originalEvent),cl=_clientLocation(originalEvent);_each(el,function(){var _el=_gel(this),evt;originalEvent=originalEvent||{screenX:sl[0],screenY:sl[1],clientX:cl[0],clientY:cl[1]};var _decorate=function _decorate(_evt){if(payload)_evt.payload=payload;};var eventGenerators={"TouchEvent":function TouchEvent(evt){var touch=document.createTouch(window,_el,0,pl[0],pl[1],sl[0],sl[1],cl[0],cl[1],0,0,0,0);// https://gist.github.com/sstephenson/448808\nvar touches=document.createTouchList(touch);var targetTouches=document.createTouchList(touch);var changedTouches=document.createTouchList(touch);evt.initTouchEvent(eventToBind,true,true,window,null,sl[0],sl[1],cl[0],cl[1],false,false,false,false,touches,targetTouches,changedTouches,1,0);},"MouseEvents":function MouseEvents(evt){evt.initMouseEvent(eventToBind,true,true,window,0,sl[0],sl[1],cl[0],cl[1],false,false,false,false,1,_el);if(Sniff.android){// Android\'s touch events are not standard.\nvar t=document.createTouch(window,_el,0,pl[0],pl[1],sl[0],sl[1],cl[0],cl[1],0,0,0,0);evt.touches=evt.targetTouches=evt.changedTouches=document.createTouchList(t);}}};if(document.createEvent){var ite=!bindingAMouseEvent&&!originalIsMouse&&isTouchDevice&&touchMap[event]&&!Sniff.android,evtName=ite?"TouchEvent":"MouseEvents";evt=document.createEvent(evtName);eventGenerators[evtName](evt);_decorate(evt);_el.dispatchEvent(evt);}else if(document.createEventObject){evt=document.createEventObject();evt.eventType=evt.eventName=eventToBind;evt.screenX=sl[0];evt.screenY=sl[1];evt.clientX=cl[0];evt.clientY=cl[1];_decorate(evt);_el.fireEvent(\'on\'+eventToBind,evt);}});return this;};};/**\r\n     * Static method to assist in \'consuming\' an element: uses `stopPropagation` where available, or sets\r\n     * `e.returnValue=false` where it is not.\r\n     * @method Mottle.consume\r\n     * @param {Event} e Event to consume\r\n     * @param {Boolean} [doNotPreventDefault=false] If true, does not call `preventDefault()` on the event.\r\n     */root.Mottle.consume=function(e,doNotPreventDefault){if(e.stopPropagation)e.stopPropagation();else e.returnValue=false;if(!doNotPreventDefault&&e.preventDefault)e.preventDefault();};/**\r\n     * Gets the page location corresponding to the given event. For touch events this means get the page location of the first touch.\r\n     * @method Mottle.pageLocation\r\n     * @param {Event} e Event to get page location for.\r\n     * @return {Number[]} [left, top] for the given event.\r\n     */root.Mottle.pageLocation=_pageLocation;/**\r\n     * Forces touch events to be turned "on". Useful for testing: even if you don\'t have a touch device, you can still\r\n     * trigger a touch event when this is switched on and it will be captured and acted on.\r\n     * @method setForceTouchEvents\r\n     * @param {Boolean} value If true, force touch events to be on.\r\n     */root.Mottle.setForceTouchEvents=function(value){isTouchDevice=value;};/**\r\n     * Forces mouse events to be turned "on". Useful for testing: even if you don\'t have a mouse, you can still\r\n     * trigger a mouse event when this is switched on and it will be captured and acted on.\r\n     * @method setForceMouseEvents\r\n     * @param {Boolean} value If true, force mouse events to be on.\r\n     */root.Mottle.setForceMouseEvents=function(value){isMouseDevice=value;};root.Mottle.version="0.8.0";if(true){exports.Mottle=root.Mottle;}}).call(typeof window==="undefined"?this:window);/**\r\n drag/drop functionality for use with jsPlumb but with\r\n no knowledge of jsPlumb. supports multiple scopes (separated by whitespace), dragging\r\n multiple elements, constrain to parent, drop filters, drag start filters, custom\r\n css classes.\r\n\r\n a lot of the functionality of this script is expected to be plugged in:\r\n\r\n addClass\r\n removeClass\r\n\r\n addEvent\r\n removeEvent\r\n\r\n getPosition\r\n setPosition\r\n getSize\r\n\r\n indexOf\r\n intersects\r\n\r\n the name came from here:\r\n\r\n http://mrsharpoblunto.github.io/foswig.js/\r\n\r\n copyright 2016 jsPlumb\r\n */;(function(){"use strict";var root=this;var _suggest=function _suggest(list,item,head){if(list.indexOf(item)===-1){head?list.unshift(item):list.push(item);return true;}return false;};var _vanquish=function _vanquish(list,item){var idx=list.indexOf(item);if(idx!==-1)list.splice(idx,1);};var _difference=function _difference(l1,l2){var d=[];for(var i=0;i<l1.length;i++){if(l2.indexOf(l1[i])===-1)d.push(l1[i]);}return d;};var _isString=function _isString(f){return f==null?false:typeof f==="string"||f.constructor===String;};var getOffsetRect=function getOffsetRect(elem){// (1)\nvar box=elem.getBoundingClientRect(),body=document.body,docElem=document.documentElement,// (2)\nscrollTop=window.pageYOffset||docElem.scrollTop||body.scrollTop,scrollLeft=window.pageXOffset||docElem.scrollLeft||body.scrollLeft,// (3)\nclientTop=docElem.clientTop||body.clientTop||0,clientLeft=docElem.clientLeft||body.clientLeft||0,// (4)\ntop=box.top+scrollTop-clientTop,left=box.left+scrollLeft-clientLeft;return{top:Math.round(top),left:Math.round(left)};};var matchesSelector=function matchesSelector(el,selector,ctx){ctx=ctx||el.parentNode;var possibles=ctx.querySelectorAll(selector);for(var i=0;i<possibles.length;i++){if(possibles[i]===el)return true;}return false;};var iev=function(){var rv=-1;if(navigator.appName===\'Microsoft Internet Explorer\'){var ua=navigator.userAgent,re=new RegExp("MSIE ([0-9]{1,}[\\.0-9]{0,})");if(re.exec(ua)!=null)rv=parseFloat(RegExp.$1);}return rv;}(),DEFAULT_GRID_X=10,DEFAULT_GRID_Y=10,isIELT9=iev>-1&&iev<9,isIE9=iev===9,_pl=function _pl(e){if(isIELT9){return[e.clientX+document.documentElement.scrollLeft,e.clientY+document.documentElement.scrollTop];}else{var ts=_touches(e),t=_getTouch(ts,0);// for IE9 pageX might be null if the event was synthesized. We try for pageX/pageY first,\n// falling back to clientX/clientY if necessary. In every other browser we want to use pageX/pageY.\nreturn isIE9?[t.pageX||t.clientX,t.pageY||t.clientY]:[t.pageX,t.pageY];}},_getTouch=function _getTouch(touches,idx){return touches.item?touches.item(idx):touches[idx];},_touches=function _touches(e){return e.touches&&e.touches.length>0?e.touches:e.changedTouches&&e.changedTouches.length>0?e.changedTouches:e.targetTouches&&e.targetTouches.length>0?e.targetTouches:[e];},_classes={draggable:"katavorio-draggable",// draggable elements\ndroppable:"katavorio-droppable",// droppable elements\ndrag:"katavorio-drag",// elements currently being dragged\nselected:"katavorio-drag-selected",// elements in current drag selection\nactive:"katavorio-drag-active",// droppables that are targets of a currently dragged element\nhover:"katavorio-drag-hover",// droppables over which a matching drag element is hovering\nnoSelect:"katavorio-drag-no-select",// added to the body to provide a hook to suppress text selection\nghostProxy:"katavorio-ghost-proxy",// added to a ghost proxy element in use when a drag has exited the bounds of its parent.\nclonedDrag:"katavorio-clone-drag"// added to a node that is a clone of an element created at the start of a drag\n},_defaultScope="katavorio-drag-scope",_events=["stop","start","drag","drop","over","out","beforeStart"],_devNull=function _devNull(){},_true=function _true(){return true;},_foreach=function _foreach(l,fn,from){for(var i=0;i<l.length;i++){if(l[i]!=from)fn(l[i]);}},_setDroppablesActive=function _setDroppablesActive(dd,val,andHover,drag){_foreach(dd,function(e){e.setActive(val);if(val)e.updatePosition();if(andHover)e.setHover(drag,val);});},_each=function _each(obj,fn){if(obj==null)return;obj=!_isString(obj)&&obj.tagName==null&&obj.length!=null?obj:[obj];for(var i=0;i<obj.length;i++){fn.apply(obj[i],[obj[i]]);}},_consume=function _consume(e){if(e.stopPropagation){e.stopPropagation();e.preventDefault();}else{e.returnValue=false;}},_defaultInputFilterSelector="input,textarea,select,button,option",//\n// filters out events on all input elements, like textarea, checkbox, input, select.\n_inputFilter=function _inputFilter(e,el,_katavorio){var t=e.srcElement||e.target;return!matchesSelector(t,_katavorio.getInputFilterSelector(),el);};var Super=function Super(el,params,css,scope){this.params=params||{};this.el=el;this.params.addClass(this.el,this._class);this.uuid=_uuid();var enabled=true;this.setEnabled=function(e){enabled=e;};this.isEnabled=function(){return enabled;};this.toggleEnabled=function(){enabled=!enabled;};this.setScope=function(scopes){this.scopes=scopes?scopes.split(/\\s+/):[scope];};this.addScope=function(scopes){var m={};_each(this.scopes,function(s){m[s]=true;});_each(scopes?scopes.split(/\\s+/):[],function(s){m[s]=true;});this.scopes=[];for(var i in m){this.scopes.push(i);}};this.removeScope=function(scopes){var m={};_each(this.scopes,function(s){m[s]=true;});_each(scopes?scopes.split(/\\s+/):[],function(s){delete m[s];});this.scopes=[];for(var i in m){this.scopes.push(i);}};this.toggleScope=function(scopes){var m={};_each(this.scopes,function(s){m[s]=true;});_each(scopes?scopes.split(/\\s+/):[],function(s){if(m[s])delete m[s];else m[s]=true;});this.scopes=[];for(var i in m){this.scopes.push(i);}};this.setScope(params.scope);this.k=params.katavorio;return params.katavorio;};var TRUE=function TRUE(){return true;};var FALSE=function FALSE(){return false;};var Drag=function Drag(el,params,css,scope){this._class=css.draggable;var k=Super.apply(this,arguments);this.rightButtonCanDrag=this.params.rightButtonCanDrag;var downAt=[0,0],posAtDown=null,pagePosAtDown=null,pageDelta=[0,0],moving=false,consumeStartEvent=this.params.consumeStartEvent!==false,dragEl=this.el,clone=this.params.clone,scroll=this.params.scroll,_multipleDrop=params.multipleDrop!==false,isConstrained=false,useGhostProxy=params.ghostProxy===true?TRUE:params.ghostProxy&&typeof params.ghostProxy==="function"?params.ghostProxy:FALSE,ghostProxy=function ghostProxy(el){return el.cloneNode(true);};var snapThreshold=params.snapThreshold,_snap=function _snap(pos,gridX,gridY,thresholdX,thresholdY){var _dx=Math.floor(pos[0]/gridX),_dxl=gridX*_dx,_dxt=_dxl+gridX,_x=Math.abs(pos[0]-_dxl)<=thresholdX?_dxl:Math.abs(_dxt-pos[0])<=thresholdX?_dxt:pos[0];var _dy=Math.floor(pos[1]/gridY),_dyl=gridY*_dy,_dyt=_dyl+gridY,_y=Math.abs(pos[1]-_dyl)<=thresholdY?_dyl:Math.abs(_dyt-pos[1])<=thresholdY?_dyt:pos[1];return[_x,_y];};this.posses=[];this.posseRoles={};this.toGrid=function(pos){if(this.params.grid==null){return pos;}else{var tx=this.params.grid?this.params.grid[0]/2:snapThreshold?snapThreshold:DEFAULT_GRID_X/2,ty=this.params.grid?this.params.grid[1]/2:snapThreshold?snapThreshold:DEFAULT_GRID_Y/2;return _snap(pos,this.params.grid[0],this.params.grid[1],tx,ty);}};this.snap=function(x,y){if(dragEl==null)return;x=x||(this.params.grid?this.params.grid[0]:DEFAULT_GRID_X);y=y||(this.params.grid?this.params.grid[1]:DEFAULT_GRID_Y);var p=this.params.getPosition(dragEl),tx=this.params.grid?this.params.grid[0]/2:snapThreshold,ty=this.params.grid?this.params.grid[1]/2:snapThreshold;this.params.setPosition(dragEl,_snap(p,x,y,tx,ty));};this.setUseGhostProxy=function(val){useGhostProxy=val?TRUE:FALSE;};var constrain;var negativeFilter=function negativeFilter(pos){return params.allowNegative===false?[Math.max(0,pos[0]),Math.max(0,pos[1])]:pos;};var _setConstrain=function(value){constrain=typeof value==="function"?value:value?function(pos){return negativeFilter([Math.max(0,Math.min(constrainRect.w-this.size[0],pos[0])),Math.max(0,Math.min(constrainRect.h-this.size[1],pos[1]))]);}.bind(this):function(pos){return negativeFilter(pos);};}.bind(this);_setConstrain(typeof this.params.constrain==="function"?this.params.constrain:this.params.constrain||this.params.containment);/**\r\n         * Sets whether or not the Drag is constrained. A value of \'true\' means constrain to parent bounds; a function\r\n         * will be executed and returns true if the position is allowed.\r\n         * @param value\r\n         */this.setConstrain=function(value){_setConstrain(value);};var revertFunction;/**\r\n         * Sets a function to call on drag stop, which, if it returns true, indicates that the given element should\r\n         * revert to its position before the previous drag.\r\n         * @param fn\r\n         */this.setRevert=function(fn){revertFunction=fn;};var _assignId=function _assignId(obj){if(typeof obj==="function"){obj._katavorioId=_uuid();return obj._katavorioId;}else{return obj;}},// a map of { spec -> [ fn, exclusion ] } entries.\n_filters={},_testFilter=function _testFilter(e){for(var key in _filters){var f=_filters[key];var rv=f[0](e);if(f[1])rv=!rv;if(!rv)return false;}return true;},_setFilter=this.setFilter=function(f,_exclude){if(f){var key=_assignId(f);_filters[key]=[function(e){var t=e.srcElement||e.target,m;if(_isString(f)){m=matchesSelector(t,f,el);}else if(typeof f==="function"){m=f(e,el);}return m;},_exclude!==false];}},_addFilter=this.addFilter=_setFilter,_removeFilter=this.removeFilter=function(f){var key=typeof f==="function"?f._katavorioId:f;delete _filters[key];};this.clearAllFilters=function(){_filters={};};this.canDrag=this.params.canDrag||_true;var constrainRect,matchingDroppables=[],intersectingDroppables=[];this.downListener=function(e){var isNotRightClick=this.rightButtonCanDrag||e.which!==3&&e.button!==2;if(isNotRightClick&&this.isEnabled()&&this.canDrag()){var _f=_testFilter(e)&&_inputFilter(e,this.el,this.k);if(_f){if(!clone)dragEl=this.el;else{dragEl=this.el.cloneNode(true);dragEl.setAttribute("id",null);dragEl.style.position="absolute";// the clone node is added to the body; getOffsetRect gives us a value\n// relative to the body.\nvar b=getOffsetRect(this.el);dragEl.style.left=b.left+"px";dragEl.style.top=b.top+"px";this.params.addClass(dragEl,_classes.clonedDrag);document.body.appendChild(dragEl);}consumeStartEvent&&_consume(e);downAt=_pl(e);//\nthis.params.bind(document,"mousemove",this.moveListener);this.params.bind(document,"mouseup",this.upListener);k.markSelection(this);k.markPosses(this);this.params.addClass(document.body,css.noSelect);_dispatch("beforeStart",{el:this.el,pos:posAtDown,e:e,drag:this});}else if(this.params.consumeFilteredEvents){_consume(e);}}}.bind(this);this.moveListener=function(e){if(downAt){if(!moving){var _continue=_dispatch("start",{el:this.el,pos:posAtDown,e:e,drag:this});if(_continue!==false){if(!downAt){return;}this.mark(true);moving=true;}else{this.abort();}}// it is possible that the start event caused the drag to be aborted. So we check\n// again that we are currently dragging.\nif(downAt){intersectingDroppables.length=0;var pos=_pl(e),dx=pos[0]-downAt[0],dy=pos[1]-downAt[1],z=this.params.ignoreZoom?1:k.getZoom();dx/=z;dy/=z;this.moveBy(dx,dy,e);k.updateSelection(dx,dy,this);k.updatePosses(dx,dy,this);}}}.bind(this);this.upListener=function(e){if(downAt){downAt=null;this.params.unbind(document,"mousemove",this.moveListener);this.params.unbind(document,"mouseup",this.upListener);this.params.removeClass(document.body,css.noSelect);this.unmark(e);k.unmarkSelection(this,e);k.unmarkPosses(this,e);this.stop(e);k.notifySelectionDragStop(this,e);k.notifyPosseDragStop(this,e);moving=false;if(clone){dragEl&&dragEl.parentNode&&dragEl.parentNode.removeChild(dragEl);dragEl=null;}intersectingDroppables.length=0;if(revertFunction&&revertFunction(this.el,this.params.getPosition(this.el))===true){this.params.setPosition(this.el,posAtDown);_dispatch("revert",this.el);}}}.bind(this);this.getFilters=function(){return _filters;};this.abort=function(){if(downAt!=null)this.upListener();};this.getDragElement=function(){return dragEl||this.el;};var listeners={"start":[],"drag":[],"stop":[],"over":[],"out":[],"beforeStart":[],"revert":[]};if(params.events.start)listeners.start.push(params.events.start);if(params.events.beforeStart)listeners.beforeStart.push(params.events.beforeStart);if(params.events.stop)listeners.stop.push(params.events.stop);if(params.events.drag)listeners.drag.push(params.events.drag);if(params.events.revert)listeners.revert.push(params.events.revert);this.on=function(evt,fn){if(listeners[evt])listeners[evt].push(fn);};this.off=function(evt,fn){if(listeners[evt]){var l=[];for(var i=0;i<listeners[evt].length;i++){if(listeners[evt][i]!==fn)l.push(listeners[evt][i]);}listeners[evt]=l;}};var _dispatch=function _dispatch(evt,value){var result=null;if(listeners[evt]){for(var i=0;i<listeners[evt].length;i++){try{var v=listeners[evt][i](value);if(v!=null){result=v;}}catch(e){}}}return result;};this.notifyStart=function(e){_dispatch("start",{el:this.el,pos:this.params.getPosition(dragEl),e:e,drag:this});};this.stop=function(e,force){if(force||moving){var positions=[],sel=k.getSelection(),dPos=this.params.getPosition(dragEl);if(sel.length>1){for(var i=0;i<sel.length;i++){var p=this.params.getPosition(sel[i].el);positions.push([sel[i].el,{left:p[0],top:p[1]},sel[i]]);}}else{positions.push([dragEl,{left:dPos[0],top:dPos[1]},this]);}_dispatch("stop",{el:dragEl,pos:ghostProxyOffsets||dPos,finalPos:dPos,e:e,drag:this,selection:positions});}};this.mark=function(andNotify){posAtDown=this.params.getPosition(dragEl);pagePosAtDown=this.params.getPosition(dragEl,true);pageDelta=[pagePosAtDown[0]-posAtDown[0],pagePosAtDown[1]-posAtDown[1]];this.size=this.params.getSize(dragEl);matchingDroppables=k.getMatchingDroppables(this);_setDroppablesActive(matchingDroppables,true,false,this);this.params.addClass(dragEl,this.params.dragClass||css.drag);var cs;if(this.params.getConstrainingRectangle){cs=this.params.getConstrainingRectangle(dragEl);}else{cs=this.params.getSize(dragEl.parentNode);}constrainRect={w:cs[0],h:cs[1]};if(andNotify){k.notifySelectionDragStart(this);}};var ghostProxyOffsets;this.unmark=function(e,doNotCheckDroppables){_setDroppablesActive(matchingDroppables,false,true,this);if(isConstrained&&useGhostProxy(this.el)){ghostProxyOffsets=[dragEl.offsetLeft,dragEl.offsetTop];this.el.parentNode.removeChild(dragEl);dragEl=this.el;}else{ghostProxyOffsets=null;}this.params.removeClass(dragEl,this.params.dragClass||css.drag);matchingDroppables.length=0;isConstrained=false;if(!doNotCheckDroppables){if(intersectingDroppables.length>0&&ghostProxyOffsets){params.setPosition(this.el,ghostProxyOffsets);}intersectingDroppables.sort(_rankSort);for(var i=0;i<intersectingDroppables.length;i++){var retVal=intersectingDroppables[i].drop(this,e);if(retVal===true)break;}}};this.moveBy=function(dx,dy,e){intersectingDroppables.length=0;var desiredLoc=this.toGrid([posAtDown[0]+dx,posAtDown[1]+dy]),cPos=constrain(desiredLoc,dragEl);if(useGhostProxy(this.el)){if(desiredLoc[0]!==cPos[0]||desiredLoc[1]!==cPos[1]){if(!isConstrained){var gp=ghostProxy(this.el);params.addClass(gp,_classes.ghostProxy);this.el.parentNode.appendChild(gp);dragEl=gp;isConstrained=true;}cPos=desiredLoc;}else{if(isConstrained){this.el.parentNode.removeChild(dragEl);dragEl=this.el;isConstrained=false;}}}var rect={x:cPos[0],y:cPos[1],w:this.size[0],h:this.size[1]},pageRect={x:rect.x+pageDelta[0],y:rect.y+pageDelta[1],w:rect.w,h:rect.h},focusDropElement=null;this.params.setPosition(dragEl,cPos);for(var i=0;i<matchingDroppables.length;i++){var r2={x:matchingDroppables[i].pagePosition[0],y:matchingDroppables[i].pagePosition[1],w:matchingDroppables[i].size[0],h:matchingDroppables[i].size[1]};if(this.params.intersects(pageRect,r2)&&(_multipleDrop||focusDropElement==null||focusDropElement===matchingDroppables[i].el)&&matchingDroppables[i].canDrop(this)){if(!focusDropElement)focusDropElement=matchingDroppables[i].el;intersectingDroppables.push(matchingDroppables[i]);matchingDroppables[i].setHover(this,true,e);}else if(matchingDroppables[i].isHover()){matchingDroppables[i].setHover(this,false,e);}}_dispatch("drag",{el:this.el,pos:cPos,e:e,drag:this});/* test to see if the parent needs to be scrolled (future)\r\n             if (scroll) {\r\n             var pnsl = dragEl.parentNode.scrollLeft, pnst = dragEl.parentNode.scrollTop;\r\n             console.log("scroll!", pnsl, pnst);\r\n             }*/};this.destroy=function(){this.params.unbind(this.el,"mousedown",this.downListener);this.params.unbind(document,"mousemove",this.moveListener);this.params.unbind(document,"mouseup",this.upListener);this.downListener=null;this.upListener=null;this.moveListener=null;};// init:register mousedown, and perhaps set a filter\nthis.params.bind(this.el,"mousedown",this.downListener);// if handle provded, use that.  otherwise, try to set a filter.\n// note that a `handle` selector always results in filterExclude being set to false, ie.\n// the selector defines the handle element(s).\nif(this.params.handle)_setFilter(this.params.handle,false);else _setFilter(this.params.filter,this.params.filterExclude);};var Drop=function Drop(el,params,css,scope){this._class=css.droppable;this.params=params||{};this.rank=params.rank||0;this._activeClass=this.params.activeClass||css.active;this._hoverClass=this.params.hoverClass||css.hover;Super.apply(this,arguments);var hover=false;this.allowLoopback=this.params.allowLoopback!==false;this.setActive=function(val){this.params[val?"addClass":"removeClass"](this.el,this._activeClass);};this.updatePosition=function(){this.position=this.params.getPosition(this.el);this.pagePosition=this.params.getPosition(this.el,true);this.size=this.params.getSize(this.el);};this.canDrop=this.params.canDrop||function(drag){return true;};this.isHover=function(){return hover;};this.setHover=function(drag,val,e){// if turning off hover but this was not the drag that caused the hover, ignore.\nif(val||this.el._katavorioDragHover==null||this.el._katavorioDragHover===drag.el._katavorio){this.params[val?"addClass":"removeClass"](this.el,this._hoverClass);//this.el._katavorioDragHover = val ? drag.el._katavorio : null;\nthis.el._katavorioDragHover=val?drag.el._katavorio:null;if(hover!==val)this.params.events[val?"over":"out"]({el:this.el,e:e,drag:drag,drop:this});hover=val;}};this.drop=function(drag,event){return this.params.events["drop"]({drag:drag,e:event,drop:this});};this.destroy=function(){this._class=null;this._activeClass=null;this._hoverClass=null;//this.params = null;\nhover=null;//this.el = null;\n};};var _uuid=function _uuid(){return\'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\'.replace(/[xy]/g,function(c){var r=Math.random()*16|0,v=c===\'x\'?r:r&0x3|0x8;return v.toString(16);});};var _rankSort=function _rankSort(a,b){return a.rank<b.rank?1:a.rank>b.rank?-1:0;};var _gel=function _gel(el){if(el==null)return null;el=typeof el==="string"||el.constructor===String?document.getElementById(el):el;if(el==null)return null;el._katavorio=el._katavorio||_uuid();return el;};root.Katavorio=function(katavorioParams){var _selection=[],_selectionMap={};this._dragsByScope={};this._dropsByScope={};var _zoom=1,_reg=function _reg(obj,map){_each(obj,function(_obj){for(var i=0;i<_obj.scopes.length;i++){map[_obj.scopes[i]]=map[_obj.scopes[i]]||[];map[_obj.scopes[i]].push(_obj);}});},_unreg=function _unreg(obj,map){var c=0;_each(obj,function(_obj){for(var i=0;i<_obj.scopes.length;i++){if(map[_obj.scopes[i]]){var idx=katavorioParams.indexOf(map[_obj.scopes[i]],_obj);if(idx!==-1){map[_obj.scopes[i]].splice(idx,1);c++;}}}});return c>0;},_getMatchingDroppables=this.getMatchingDroppables=function(drag){var dd=[],_m={};for(var i=0;i<drag.scopes.length;i++){var _dd=this._dropsByScope[drag.scopes[i]];if(_dd){for(var j=0;j<_dd.length;j++){if(_dd[j].canDrop(drag)&&!_m[_dd[j].uuid]&&(_dd[j].allowLoopback||_dd[j].el!==drag.el)){_m[_dd[j].uuid]=true;dd.push(_dd[j]);}}}}dd.sort(_rankSort);return dd;},_prepareParams=function(p){p=p||{};var _p={events:{}},i;for(i in katavorioParams){_p[i]=katavorioParams[i];}for(i in p){_p[i]=p[i];}// events\nfor(i=0;i<_events.length;i++){_p.events[_events[i]]=p[_events[i]]||_devNull;}_p.katavorio=this;return _p;}.bind(this),_mistletoe=function(existingDrag,params){for(var i=0;i<_events.length;i++){if(params[_events[i]]){existingDrag.on(_events[i],params[_events[i]]);}}}.bind(this),_css={},overrideCss=katavorioParams.css||{},_scope=katavorioParams.scope||_defaultScope;// prepare map of css classes based on defaults frst, then optional overrides\nfor(var i in _classes){_css[i]=_classes[i];}for(var i in overrideCss){_css[i]=overrideCss[i];}var inputFilterSelector=katavorioParams.inputFilterSelector||_defaultInputFilterSelector;/**\r\n         * Gets the selector identifying which input elements to filter from drag events.\r\n         * @method getInputFilterSelector\r\n         * @return {String} Current input filter selector.\r\n         */this.getInputFilterSelector=function(){return inputFilterSelector;};/**\r\n         * Sets the selector identifying which input elements to filter from drag events.\r\n         * @method setInputFilterSelector\r\n         * @param {String} selector Input filter selector to set.\r\n         * @return {Katavorio} Current instance; method may be chained.\r\n         */this.setInputFilterSelector=function(selector){inputFilterSelector=selector;return this;};this.draggable=function(el,params){var o=[];_each(el,function(_el){_el=_gel(_el);if(_el!=null){if(_el._katavorioDrag==null){var p=_prepareParams(params);_el._katavorioDrag=new Drag(_el,p,_css,_scope);_reg(_el._katavorioDrag,this._dragsByScope);o.push(_el._katavorioDrag);katavorioParams.addClass(_el,_css.draggable);}else{_mistletoe(_el._katavorioDrag,params);}}}.bind(this));return o;};this.droppable=function(el,params){var o=[];_each(el,function(_el){_el=_gel(_el);if(_el!=null){var drop=new Drop(_el,_prepareParams(params),_css,_scope);_el._katavorioDrop=_el._katavorioDrop||[];_el._katavorioDrop.push(drop);_reg(drop,this._dropsByScope);o.push(drop);katavorioParams.addClass(_el,_css.droppable);}}.bind(this));return o;};/**\r\n         * @name Katavorio#select\r\n         * @function\r\n         * @desc Adds an element to the current selection (for multiple node drag)\r\n         * @param {Element|String} DOM element - or id of the element - to add.\r\n         */this.select=function(el){_each(el,function(){var _el=_gel(this);if(_el&&_el._katavorioDrag){if(!_selectionMap[_el._katavorio]){_selection.push(_el._katavorioDrag);_selectionMap[_el._katavorio]=[_el,_selection.length-1];katavorioParams.addClass(_el,_css.selected);}}});return this;};/**\r\n         * @name Katavorio#deselect\r\n         * @function\r\n         * @desc Removes an element from the current selection (for multiple node drag)\r\n         * @param {Element|String} DOM element - or id of the element - to remove.\r\n         */this.deselect=function(el){_each(el,function(){var _el=_gel(this);if(_el&&_el._katavorio){var e=_selectionMap[_el._katavorio];if(e){var _s=[];for(var i=0;i<_selection.length;i++){if(_selection[i].el!==_el)_s.push(_selection[i]);}_selection=_s;delete _selectionMap[_el._katavorio];katavorioParams.removeClass(_el,_css.selected);}}});return this;};this.deselectAll=function(){for(var i in _selectionMap){var d=_selectionMap[i];katavorioParams.removeClass(d[0],_css.selected);}_selection.length=0;_selectionMap={};};this.markSelection=function(drag){_foreach(_selection,function(e){e.mark();},drag);};this.markPosses=function(drag){if(drag.posses){_each(drag.posses,function(p){if(drag.posseRoles[p]&&_posses[p]){_foreach(_posses[p].members,function(d){d.mark();},drag);}});}};this.unmarkSelection=function(drag,event){_foreach(_selection,function(e){e.unmark(event);},drag);};this.unmarkPosses=function(drag,event){if(drag.posses){_each(drag.posses,function(p){if(drag.posseRoles[p]&&_posses[p]){_foreach(_posses[p].members,function(d){d.unmark(event,true);},drag);}});}};this.getSelection=function(){return _selection.slice(0);};this.updateSelection=function(dx,dy,drag){_foreach(_selection,function(e){e.moveBy(dx,dy);},drag);};var _posseAction=function _posseAction(fn,drag){if(drag.posses){_each(drag.posses,function(p){if(drag.posseRoles[p]&&_posses[p]){_foreach(_posses[p].members,function(e){fn(e);},drag);}});}};this.updatePosses=function(dx,dy,drag){_posseAction(function(e){e.moveBy(dx,dy);},drag);};this.notifyPosseDragStop=function(drag,evt){_posseAction(function(e){e.stop(evt,true);},drag);};this.notifySelectionDragStop=function(drag,evt){_foreach(_selection,function(e){e.stop(evt,true);},drag);};this.notifySelectionDragStart=function(drag,evt){_foreach(_selection,function(e){e.notifyStart(evt);},drag);};this.setZoom=function(z){_zoom=z;};this.getZoom=function(){return _zoom;};// does the work of changing scopes\nvar _scopeManip=function _scopeManip(kObj,scopes,map,fn){_each(kObj,function(_kObj){_unreg(_kObj,map);// deregister existing scopes\n_kObj[fn](scopes);// set scopes\n_reg(_kObj,map);// register new ones\n});};_each(["set","add","remove","toggle"],function(v){this[v+"Scope"]=function(el,scopes){_scopeManip(el._katavorioDrag,scopes,this._dragsByScope,v+"Scope");_scopeManip(el._katavorioDrop,scopes,this._dropsByScope,v+"Scope");}.bind(this);this[v+"DragScope"]=function(el,scopes){_scopeManip(el.constructor===Drag?el:el._katavorioDrag,scopes,this._dragsByScope,v+"Scope");}.bind(this);this[v+"DropScope"]=function(el,scopes){_scopeManip(el.constructor===Drop?el:el._katavorioDrop,scopes,this._dropsByScope,v+"Scope");}.bind(this);}.bind(this));this.snapToGrid=function(x,y){for(var s in this._dragsByScope){_foreach(this._dragsByScope[s],function(d){d.snap(x,y);});}};this.getDragsForScope=function(s){return this._dragsByScope[s];};this.getDropsForScope=function(s){return this._dropsByScope[s];};var _destroy=function _destroy(el,type,map){el=_gel(el);if(el[type]){// remove from selection, if present.\nvar selIdx=_selection.indexOf(el[type]);if(selIdx>=0){_selection.splice(selIdx,1);}if(_unreg(el[type],map)){_each(el[type],function(kObj){kObj.destroy();});}delete el[type];}};var _removeListener=function _removeListener(el,type,evt,fn){el=_gel(el);if(el[type]){el[type].off(evt,fn);}};this.elementRemoved=function(el){this.destroyDraggable(el);this.destroyDroppable(el);};/**\r\n         * Either completely remove drag functionality from the given element, or remove a specific event handler. If you\r\n         * call this method with a single argument - the element - all drag functionality is removed from it. Otherwise, if\r\n         * you provide an event name and listener function, this function is de-registered (if found).\r\n         * @param el Element to update\r\n         * @param {string} [evt] Optional event name to unsubscribe\r\n         * @param {Function} [fn] Optional function to unsubscribe\r\n         */this.destroyDraggable=function(el,evt,fn){if(arguments.length===1){_destroy(el,"_katavorioDrag",this._dragsByScope);}else{_removeListener(el,"_katavorioDrag",evt,fn);}};/**\r\n         * Either completely remove drop functionality from the given element, or remove a specific event handler. If you\r\n         * call this method with a single argument - the element - all drop functionality is removed from it. Otherwise, if\r\n         * you provide an event name and listener function, this function is de-registered (if found).\r\n         * @param el Element to update\r\n         * @param {string} [evt] Optional event name to unsubscribe\r\n         * @param {Function} [fn] Optional function to unsubscribe\r\n         */this.destroyDroppable=function(el,evt,fn){if(arguments.length===1){_destroy(el,"_katavorioDrop",this._dropsByScope);}else{_removeListener(el,"_katavorioDrop",evt,fn);}};this.reset=function(){this._dragsByScope={};this._dropsByScope={};_selection=[];_selectionMap={};_posses={};};// ----- groups\nvar _posses={};var _processOneSpec=function _processOneSpec(el,_spec,dontAddExisting){var posseId=_isString(_spec)?_spec:_spec.id;var active=_isString(_spec)?true:_spec.active!==false;var posse=_posses[posseId]||function(){var g={name:posseId,members:[]};_posses[posseId]=g;return g;}();_each(el,function(_el){if(_el._katavorioDrag){if(dontAddExisting&&_el._katavorioDrag.posseRoles[posse.name]!=null)return;_suggest(posse.members,_el._katavorioDrag);_suggest(_el._katavorioDrag.posses,posse.name);_el._katavorioDrag.posseRoles[posse.name]=active;}});return posse;};/**\r\n         * Add the given element to the posse with the given id, creating the group if it at first does not exist.\r\n         * @method addToPosse\r\n         * @param {Element} el Element to add.\r\n         * @param {String...|Object...} spec Variable args parameters. Each argument can be a either a String, indicating\r\n         * the ID of a Posse to which the element should be added as an active participant, or an Object containing\r\n         * `{ id:"posseId", active:false/true}`. In the latter case, if `active` is not provided it is assumed to be\r\n         * true.\r\n         * @returns {Posse|Posse[]} The Posse(s) to which the element(s) was/were added.\r\n         */this.addToPosse=function(el,spec){var posses=[];for(var i=1;i<arguments.length;i++){posses.push(_processOneSpec(el,arguments[i]));}return posses.length===1?posses[0]:posses;};/**\r\n         * Sets the posse(s) for the element with the given id, creating those that do not yet exist, and removing from\r\n         * the element any current Posses that are not specified by this method call. This method will not change the\r\n         * active/passive state if it is given a posse in which the element is already a member.\r\n         * @method setPosse\r\n         * @param {Element} el Element to set posse(s) on.\r\n         * @param {String...|Object...} spec Variable args parameters. Each argument can be a either a String, indicating\r\n         * the ID of a Posse to which the element should be added as an active participant, or an Object containing\r\n         * `{ id:"posseId", active:false/true}`. In the latter case, if `active` is not provided it is assumed to be\r\n         * true.\r\n         * @returns {Posse|Posse[]} The Posse(s) to which the element(s) now belongs.\r\n         */this.setPosse=function(el,spec){var posses=[];for(var i=1;i<arguments.length;i++){posses.push(_processOneSpec(el,arguments[i],true).name);}_each(el,function(_el){if(_el._katavorioDrag){var diff=_difference(_el._katavorioDrag.posses,posses);var p=[];Array.prototype.push.apply(p,_el._katavorioDrag.posses);for(var i=0;i<diff.length;i++){this.removeFromPosse(_el,diff[i]);}}}.bind(this));return posses.length===1?posses[0]:posses;};/**\r\n         * Remove the given element from the given posse(s).\r\n         * @method removeFromPosse\r\n         * @param {Element} el Element to remove.\r\n         * @param {String...} posseId Varargs parameter: one value for each posse to remove the element from.\r\n         */this.removeFromPosse=function(el,posseId){if(arguments.length<2)throw new TypeError("No posse id provided for remove operation");for(var i=1;i<arguments.length;i++){posseId=arguments[i];_each(el,function(_el){if(_el._katavorioDrag&&_el._katavorioDrag.posses){var d=_el._katavorioDrag;_each(posseId,function(p){_vanquish(_posses[p].members,d);_vanquish(d.posses,p);delete d.posseRoles[p];});}});}};/**\r\n         * Remove the given element from all Posses to which it belongs.\r\n         * @method removeFromAllPosses\r\n         * @param {Element|Element[]} el Element to remove from Posses.\r\n         */this.removeFromAllPosses=function(el){_each(el,function(_el){if(_el._katavorioDrag&&_el._katavorioDrag.posses){var d=_el._katavorioDrag;_each(d.posses,function(p){_vanquish(_posses[p].members,d);});d.posses.length=0;d.posseRoles={};}});};/**\r\n         * Changes the participation state for the element in the Posse with the given ID.\r\n         * @param {Element|Element[]} el Element(s) to change state for.\r\n         * @param {String} posseId ID of the Posse to change element state for.\r\n         * @param {Boolean} state True to make active, false to make passive.\r\n         */this.setPosseState=function(el,posseId,state){var posse=_posses[posseId];if(posse){_each(el,function(_el){if(_el._katavorioDrag&&_el._katavorioDrag.posses){_el._katavorioDrag.posseRoles[posse.name]=state;}});}};};root.Katavorio.version="0.23.0";if(true){exports.Katavorio=root.Katavorio;}}).call(typeof window!==\'undefined\'?window:this);/*\r\n * This file contains utility functions that run in both browsers and headless.\r\n *\r\n * Copyright (c) 2010 - 2018 jsPlumb (hello@jsplumbtoolkit.com)\r\n *\r\n * https://jsplumbtoolkit.com\r\n * https://github.com/jsplumb/jsplumb\r\n *\r\n * Dual licensed under the MIT and GPL2 licenses.\r\n */;(function(){var _isa=function _isa(a){return Object.prototype.toString.call(a)==="[object Array]";},_isnum=function _isnum(n){return Object.prototype.toString.call(n)==="[object Number]";},_iss=function _iss(s){return typeof s==="string";},_isb=function _isb(s){return typeof s==="boolean";},_isnull=function _isnull(s){return s==null;},_iso=function _iso(o){return o==null?false:Object.prototype.toString.call(o)==="[object Object]";},_isd=function _isd(o){return Object.prototype.toString.call(o)==="[object Date]";},_isf=function _isf(o){return Object.prototype.toString.call(o)==="[object Function]";},_isNamedFunction=function _isNamedFunction(o){return _isf(o)&&o.name!=null&&o.name.length>0;},_ise=function _ise(o){for(var i in o){if(o.hasOwnProperty(i)){return false;}}return true;};var root=this;root.jsPlumbUtil={isArray:_isa,isString:_iss,isBoolean:_isb,isNull:_isnull,isObject:_iso,isDate:_isd,isFunction:_isf,isEmpty:_ise,isNumber:_isnum,clone:function clone(a){if(_iss(a)){return""+a;}else if(_isb(a)){return!!a;}else if(_isd(a)){return new Date(a.getTime());}else if(_isf(a)){return a;}else if(_isa(a)){var b=[];for(var i=0;i<a.length;i++){b.push(this.clone(a[i]));}return b;}else if(_iso(a)){var c={};for(var j in a){c[j]=this.clone(a[j]);}return c;}else{return a;}},merge:function merge(a,b,collations){// first change the collations array - if present - into a lookup table, because its faster.\nvar cMap={},ar,i;collations=collations||[];for(i=0;i<collations.length;i++){cMap[collations[i]]=true;}var c=this.clone(a);for(i in b){if(c[i]==null){c[i]=b[i];}else if(_iss(b[i])||_isb(b[i])){if(!cMap[i]){c[i]=b[i];// if we dont want to collate, just copy it in.\n}else{ar=[];// if c\'s object is also an array we can keep its values.\nar.push.apply(ar,_isa(c[i])?c[i]:[c[i]]);ar.push.apply(ar,_isa(b[i])?b[i]:[b[i]]);c[i]=ar;}}else{if(_isa(b[i])){ar=[];// if c\'s object is also an array we can keep its values.\nif(_isa(c[i])){ar.push.apply(ar,c[i]);}ar.push.apply(ar,b[i]);c[i]=ar;}else if(_iso(b[i])){// overwite c\'s value with an object if it is not already one.\nif(!_iso(c[i])){c[i]={};}for(var j in b[i]){c[i][j]=b[i][j];}}}}return c;},replace:function replace(inObj,path,value){if(inObj==null){return;}var q=inObj,t=q;path.replace(/([^\\.])+/g,function(term,lc,pos,str){var array=term.match(/([^\\[0-9]+){1}(\\[)([0-9+])/),last=pos+term.length>=str.length,_getArray=function _getArray(){return t[array[1]]||function(){t[array[1]]=[];return t[array[1]];}();};if(last){// set term = value on current t, creating term as array if necessary.\nif(array){_getArray()[array[3]]=value;}else{t[term]=value;}}else{// set to current t[term], creating t[term] if necessary.\nif(array){var a=_getArray();t=a[array[3]]||function(){a[array[3]]={};return a[array[3]];}();}else{t=t[term]||function(){t[term]={};return t[term];}();}}});return inObj;},//\n// chain a list of functions, supplied by [ object, method name, args ], and return on the first\n// one that returns the failValue. if none return the failValue, return the successValue.\n//\nfunctionChain:function functionChain(successValue,failValue,fns){for(var i=0;i<fns.length;i++){var o=fns[i][0][fns[i][1]].apply(fns[i][0],fns[i][2]);if(o===failValue){return o;}}return successValue;},// take the given model and expand out any parameters.\n// \'functionPrefix\' is optional, and if present, helps jsplumb figure out what to do if a value is a Function.\n// if you do not provide it, jsplumb will run the given values through any functions it finds, and use the function\'s\n// output as the value in the result. if you do provide the prefix, only functions that are named and have this prefix\n// will be executed; other functions will be passed as values to the output.\npopulate:function populate(model,values,functionPrefix){// for a string, see if it has parameter matches, and if so, try to make the substitutions.\nvar getValue=function getValue(fromString){var matches=fromString.match(/(\\${.*?})/g);if(matches!=null){for(var i=0;i<matches.length;i++){var val=values[matches[i].substring(2,matches[i].length-1)]||"";if(val!=null){fromString=fromString.replace(matches[i],val);}}}return fromString;},// process one entry.\n_one=function _one(d){if(d!=null){if(_iss(d)){return getValue(d);}else if(_isf(d)&&(functionPrefix==null||(d.name||"").indexOf(functionPrefix)===0)){return d(values);}else if(_isa(d)){var r=[];for(var i=0;i<d.length;i++){r.push(_one(d[i]));}return r;}else if(_iso(d)){var s={};for(var j in d){s[j]=_one(d[j]);}return s;}else{return d;}}};return _one(model);},findWithFunction:function findWithFunction(a,f){// CONVERTED\nif(a){for(var i=0;i<a.length;i++){if(f(a[i])){return i;}}}return-1;},removeWithFunction:function removeWithFunction(a,f){// CONVERTED\nvar idx=root.jsPlumbUtil.findWithFunction(a,f);if(idx>-1){a.splice(idx,1);}return idx!==-1;},remove:function remove(l,v){// CONVERTED\nvar idx=l.indexOf(v);if(idx>-1){l.splice(idx,1);}return idx!==-1;},// TODO support insert index\naddWithFunction:function addWithFunction(list,item,hashFunction){if(root.jsPlumbUtil.findWithFunction(list,hashFunction)===-1){list.push(item);}},addToList:function addToList(map,key,value,insertAtStart){var l=map[key];if(l==null){l=[];map[key]=l;}l[insertAtStart?"unshift":"push"](value);return l;},suggest:function suggest(list,item,insertAtHead){if(list.indexOf(item)===-1){if(insertAtHead){list.unshift(item);}else{list.push(item);}return true;}return false;},//\n// extends the given obj (which can be an array) with the given constructor function, prototype functions, and\n// class members, any of which may be null.\n//\nextend:function extend(child,parent,_protoFn){var i;parent=_isa(parent)?parent:[parent];for(i=0;i<parent.length;i++){for(var j in parent[i].prototype){if(parent[i].prototype.hasOwnProperty(j)){child.prototype[j]=parent[i].prototype[j];}}}var _makeFn=function _makeFn(name,protoFn){return function(){for(i=0;i<parent.length;i++){if(parent[i].prototype[name]){parent[i].prototype[name].apply(this,arguments);}}return protoFn.apply(this,arguments);};};var _oneSet=function _oneSet(fns){for(var k in fns){child.prototype[k]=_makeFn(k,fns[k]);}};if(arguments.length>2){for(i=2;i<arguments.length;i++){_oneSet(arguments[i]);}}return child;},uuid:function uuid(){return\'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\'.replace(/[xy]/g,function(c){var r=Math.random()*16|0,v=c===\'x\'?r:r&0x3|0x8;return v.toString(16);});},logEnabled:true,log:function log(){if(root.jsPlumbUtil.logEnabled&&typeof console!=="undefined"){try{var msg=arguments[arguments.length-1];console.log(msg);}catch(e){}}},/**\r\n         * Wraps one function with another, creating a placeholder for the\r\n         * wrapped function if it was null. this is used to wrap the various\r\n         * drag/drop event functions - to allow jsPlumb to be notified of\r\n         * important lifecycle events without imposing itself on the user\'s\r\n         * drag/drop functionality.\r\n         * @method jsPlumbUtil.wrap\r\n         * @param {Function} wrappedFunction original function to wrap; may be null.\r\n         * @param {Function} newFunction function to wrap the original with.\r\n         * @param {Object} [returnOnThisValue] Optional. Indicates that the wrappedFunction should\r\n         * not be executed if the newFunction returns a value matching \'returnOnThisValue\'.\r\n         * note that this is a simple comparison and only works for primitives right now.\r\n         */wrap:function wrap(wrappedFunction,newFunction,returnOnThisValue){return function(){var r=null;try{if(newFunction!=null){r=newFunction.apply(this,arguments);}}catch(e){root.jsPlumbUtil.log("jsPlumb function failed : "+e);}if(wrappedFunction!=null&&(returnOnThisValue==null||r!==returnOnThisValue)){try{r=wrappedFunction.apply(this,arguments);}catch(e){root.jsPlumbUtil.log("wrapped function failed : "+e);}}return r;};}};root.jsPlumbUtil.EventGenerator=function(){var _listeners={},eventsSuspended=false,tick=false,// this is a list of events that should re-throw any errors that occur during their dispatch. it is current private.\neventsToDieOn={"ready":true},queue=[];this.bind=function(event,listener,insertAtStart){var _one=function _one(evt){root.jsPlumbUtil.addToList(_listeners,evt,listener,insertAtStart);listener.__jsPlumb=listener.__jsPlumb||{};listener.__jsPlumb[root.jsPlumbUtil.uuid()]=evt;};if(typeof event==="string"){_one(event);}else if(event.length!=null){for(var i=0;i<event.length;i++){_one(event[i]);}}return this;};this.fire=function(event,value,originalEvent){if(!tick){tick=true;if(!eventsSuspended&&_listeners[event]){var l=_listeners[event].length,i=0,_gone=false,ret=null;if(!this.shouldFireEvent||this.shouldFireEvent(event,value,originalEvent)){while(!_gone&&i<l&&ret!==false){// doing it this way rather than catching and then possibly re-throwing means that an error propagated by this\n// method will have the whole call stack available in the debugger.\nif(eventsToDieOn[event]){_listeners[event][i].apply(this,[value,originalEvent]);}else{try{ret=_listeners[event][i].apply(this,[value,originalEvent]);}catch(e){root.jsPlumbUtil.log("jsPlumb: fire failed for event "+event+" : "+e);}}i++;if(_listeners==null||_listeners[event]==null){_gone=true;}}}}tick=false;_drain();}else{queue.unshift(arguments);}return this;};var _drain=function(){var n=queue.pop();if(n){this.fire.apply(this,n);}}.bind(this);this.unbind=function(eventOrListener,listener){if(arguments.length===0){_listeners={};}else if(arguments.length===1){if(typeof eventOrListener==="string"){delete _listeners[eventOrListener];}else if(eventOrListener.__jsPlumb){var evt;for(var i in eventOrListener.__jsPlumb){evt=eventOrListener.__jsPlumb[i];root.jsPlumbUtil.remove(_listeners[evt]||[],eventOrListener);}}}else if(arguments.length===2){root.jsPlumbUtil.remove(_listeners[eventOrListener]||[],listener);}return this;};this.getListener=function(forEvent){return _listeners[forEvent];};this.setSuspendEvents=function(val){eventsSuspended=val;};this.isSuspendEvents=function(){return eventsSuspended;};this.silently=function(fn){this.setSuspendEvents(true);try{fn();}catch(e){root.jsPlumbUtil.log("Cannot execute silent function "+e);}this.setSuspendEvents(false);};this.cleanupListeners=function(){for(var i in _listeners){_listeners[i]=null;}};};root.jsPlumbUtil.EventGenerator.prototype={cleanup:function cleanup(){this.cleanupListeners();}};if(true){exports.jsPlumbUtil=root.jsPlumbUtil;}}).call(typeof window!==\'undefined\'?window:this);/*\r\n * This file contains utility functions that run in browsers only.\r\n *\r\n * Copyright (c) 2010 - 2018 jsPlumb (hello@jsplumbtoolkit.com)\r\n *\r\n * https://jsplumbtoolkit.com\r\n * https://github.com/jsplumb/jsplumb\r\n *\r\n * Dual licensed under the MIT and GPL2 licenses.\r\n */;(function(){"use strict";var root=this;root.jsPlumbUtil.matchesSelector=function(el,selector,ctx){ctx=ctx||el.parentNode;var possibles=ctx.querySelectorAll(selector);for(var i=0;i<possibles.length;i++){if(possibles[i]===el){return true;}}return false;};root.jsPlumbUtil.consume=function(e,doNotPreventDefault){if(e.stopPropagation){e.stopPropagation();}else{e.returnValue=false;}if(!doNotPreventDefault&&e.preventDefault){e.preventDefault();}};/*\r\n    * Function: sizeElement\r\n    * Helper to size and position an element. You would typically use\r\n    * this when writing your own Connector or Endpoint implementation.\r\n    *\r\n    * Parameters:\r\n    *  x - [int] x position for the element origin\r\n    *  y - [int] y position for the element origin\r\n    *  w - [int] width of the element\r\n    *  h - [int] height of the element\r\n    *\r\n    */root.jsPlumbUtil.sizeElement=function(el,x,y,w,h){if(el){el.style.height=h+"px";el.height=h;el.style.width=w+"px";el.width=w;el.style.left=x+"px";el.style.top=y+"px";}};}).call(typeof window!==\'undefined\'?window:this);/*\r\n * This file contains the core code.\r\n *\r\n * Copyright (c) 2010 - 2018 jsPlumb (hello@jsplumbtoolkit.com)\r\n *\r\n * https://jsplumbtoolkit.com\r\n * https://github.com/jsplumb/jsplumb\r\n *\r\n * Dual licensed under the MIT and GPL2 licenses.\r\n */;(function(){"use strict";var root=this;var _ju=root.jsPlumbUtil,/**\r\n         * creates a timestamp, using milliseconds since 1970, but as a string.\r\n         */_timestamp=function _timestamp(){return""+new Date().getTime();},// helper method to update the hover style whenever it, or paintStyle, changes.\n// we use paintStyle as the foundation and merge hoverPaintStyle over the\n// top.\n_updateHoverStyle=function _updateHoverStyle(component){if(component._jsPlumb.paintStyle&&component._jsPlumb.hoverPaintStyle){var mergedHoverStyle={};jsPlumb.extend(mergedHoverStyle,component._jsPlumb.paintStyle);jsPlumb.extend(mergedHoverStyle,component._jsPlumb.hoverPaintStyle);delete component._jsPlumb.hoverPaintStyle;// we want the fill of paintStyle to override a gradient, if possible.\nif(mergedHoverStyle.gradient&&component._jsPlumb.paintStyle.fill){delete mergedHoverStyle.gradient;}component._jsPlumb.hoverPaintStyle=mergedHoverStyle;}},events=["tap","dbltap","click","dblclick","mouseover","mouseout","mousemove","mousedown","mouseup","contextmenu"],eventFilters={"mouseout":"mouseleave","mouseexit":"mouseleave"},_updateAttachedElements=function _updateAttachedElements(component,state,timestamp,sourceElement){var affectedElements=component.getAttachedElements();if(affectedElements){for(var i=0,j=affectedElements.length;i<j;i++){if(!sourceElement||sourceElement!==affectedElements[i]){affectedElements[i].setHover(state,true,timestamp);// tell the attached elements not to inform their own attached elements.\n}}}},_splitType=function _splitType(t){return t==null?null:t.split(" ");},_mapType=function _mapType(map,obj,typeId){for(var i in obj){map[i]=typeId;}},_each=function _each(fn,obj){obj=_ju.isArray(obj)||obj.length!=null&&!_ju.isString(obj)?obj:[obj];for(var i=0;i<obj.length;i++){try{fn.apply(obj[i],[obj[i]]);}catch(e){_ju.log(".each iteration failed : "+e);}}},_applyTypes=function _applyTypes(component,params,doNotRepaint){if(component.getDefaultType){var td=component.getTypeDescriptor(),map={};var defType=component.getDefaultType();var o=_ju.merge({},defType);_mapType(map,defType,"__default");for(var i=0,j=component._jsPlumb.types.length;i<j;i++){var tid=component._jsPlumb.types[i];if(tid!=="__default"){var _t=component._jsPlumb.instance.getType(tid,td);if(_t!=null){o=_ju.merge(o,_t,["cssClass"]);_mapType(map,_t,tid);}}}if(params){o=_ju.populate(o,params,"_");}component.applyType(o,doNotRepaint,map);if(!doNotRepaint){component.repaint();}}},// ------------------------------ BEGIN jsPlumbUIComponent --------------------------------------------\njsPlumbUIComponent=root.jsPlumbUIComponent=function(params){_ju.EventGenerator.apply(this,arguments);var self=this,a=arguments,idPrefix=self.idPrefix,id=idPrefix+new Date().getTime();this._jsPlumb={instance:params._jsPlumb,parameters:params.parameters||{},paintStyle:null,hoverPaintStyle:null,paintStyleInUse:null,hover:false,beforeDetach:params.beforeDetach,beforeDrop:params.beforeDrop,overlayPlacements:[],hoverClass:params.hoverClass||params._jsPlumb.Defaults.HoverClass,types:[],typeCache:{}};this.cacheTypeItem=function(key,item,typeId){this._jsPlumb.typeCache[typeId]=this._jsPlumb.typeCache[typeId]||{};this._jsPlumb.typeCache[typeId][key]=item;};this.getCachedTypeItem=function(key,typeId){return this._jsPlumb.typeCache[typeId]?this._jsPlumb.typeCache[typeId][key]:null;};this.getId=function(){return id;};// ----------------------------- default type --------------------------------------------\nvar o=params.overlays||[],oo={};if(this.defaultOverlayKeys){for(var i=0;i<this.defaultOverlayKeys.length;i++){Array.prototype.push.apply(o,this._jsPlumb.instance.Defaults[this.defaultOverlayKeys[i]]||[]);}for(i=0;i<o.length;i++){// if a string, convert to object representation so that we can store the typeid on it.\n// also assign an id.\nvar fo=jsPlumb.convertToFullOverlaySpec(o[i]);oo[fo[1].id]=fo;}}var _defaultType={overlays:oo,parameters:params.parameters||{},scope:params.scope||this._jsPlumb.instance.getDefaultScope()};this.getDefaultType=function(){return _defaultType;};this.appendToDefaultType=function(obj){for(var i in obj){_defaultType[i]=obj[i];}};// ----------------------------- end default type --------------------------------------------\n// all components can generate events\nif(params.events){for(var evtName in params.events){self.bind(evtName,params.events[evtName]);}}// all components get this clone function.\n// TODO issue 116 showed a problem with this - it seems \'a\' that is in\n// the clone function\'s scope is shared by all invocations of it, the classic\n// JS closure problem.  for now, jsPlumb does a version of this inline where\n// it used to call clone.  but it would be nice to find some time to look\n// further at this.\nthis.clone=function(){var o=Object.create(this.constructor.prototype);this.constructor.apply(o,a);return o;}.bind(this);// user can supply a beforeDetach callback, which will be executed before a detach\n// is performed; returning false prevents the detach.\nthis.isDetachAllowed=function(connection){var r=true;if(this._jsPlumb.beforeDetach){try{r=this._jsPlumb.beforeDetach(connection);}catch(e){_ju.log("jsPlumb: beforeDetach callback failed",e);}}return r;};// user can supply a beforeDrop callback, which will be executed before a dropped\n// connection is confirmed. user can return false to reject connection.\nthis.isDropAllowed=function(sourceId,targetId,scope,connection,dropEndpoint,source,target){var r=this._jsPlumb.instance.checkCondition("beforeDrop",{sourceId:sourceId,targetId:targetId,scope:scope,connection:connection,dropEndpoint:dropEndpoint,source:source,target:target});if(this._jsPlumb.beforeDrop){try{r=this._jsPlumb.beforeDrop({sourceId:sourceId,targetId:targetId,scope:scope,connection:connection,dropEndpoint:dropEndpoint,source:source,target:target});}catch(e){_ju.log("jsPlumb: beforeDrop callback failed",e);}}return r;};var domListeners=[];// sets the component associated with listener events. for instance, an overlay delegates\n// its events back to a connector. but if the connector is swapped on the underlying connection,\n// then this component must be changed. This is called by setConnector in the Connection class.\nthis.setListenerComponent=function(c){for(var i=0;i<domListeners.length;i++){domListeners[i][3]=c;}};};var _removeTypeCssHelper=function _removeTypeCssHelper(component,typeIndex){var typeId=component._jsPlumb.types[typeIndex],type=component._jsPlumb.instance.getType(typeId,component.getTypeDescriptor());if(type!=null&&type.cssClass&&component.canvas){component._jsPlumb.instance.removeClass(component.canvas,type.cssClass);}};_ju.extend(root.jsPlumbUIComponent,_ju.EventGenerator,{getParameter:function getParameter(name){return this._jsPlumb.parameters[name];},setParameter:function setParameter(name,value){this._jsPlumb.parameters[name]=value;},getParameters:function getParameters(){return this._jsPlumb.parameters;},setParameters:function setParameters(p){this._jsPlumb.parameters=p;},getClass:function getClass(){return jsPlumb.getClass(this.canvas);},hasClass:function hasClass(clazz){return jsPlumb.hasClass(this.canvas,clazz);},addClass:function addClass(clazz){jsPlumb.addClass(this.canvas,clazz);},removeClass:function removeClass(clazz){jsPlumb.removeClass(this.canvas,clazz);},updateClasses:function updateClasses(classesToAdd,classesToRemove){jsPlumb.updateClasses(this.canvas,classesToAdd,classesToRemove);},setType:function setType(typeId,params,doNotRepaint){this.clearTypes();this._jsPlumb.types=_splitType(typeId)||[];_applyTypes(this,params,doNotRepaint);},getType:function getType(){return this._jsPlumb.types;},reapplyTypes:function reapplyTypes(params,doNotRepaint){_applyTypes(this,params,doNotRepaint);},hasType:function hasType(typeId){return this._jsPlumb.types.indexOf(typeId)!==-1;},addType:function addType(typeId,params,doNotRepaint){var t=_splitType(typeId),_cont=false;if(t!=null){for(var i=0,j=t.length;i<j;i++){if(!this.hasType(t[i])){this._jsPlumb.types.push(t[i]);_cont=true;}}if(_cont){_applyTypes(this,params,doNotRepaint);}}},removeType:function removeType(typeId,params,doNotRepaint){var t=_splitType(typeId),_cont=false,_one=function(tt){var idx=this._jsPlumb.types.indexOf(tt);if(idx!==-1){// remove css class if necessary\n_removeTypeCssHelper(this,idx);this._jsPlumb.types.splice(idx,1);return true;}return false;}.bind(this);if(t!=null){for(var i=0,j=t.length;i<j;i++){_cont=_one(t[i])||_cont;}if(_cont){_applyTypes(this,params,doNotRepaint);}}},clearTypes:function clearTypes(params,doNotRepaint){var i=this._jsPlumb.types.length;for(var j=0;j<i;j++){_removeTypeCssHelper(this,0);this._jsPlumb.types.splice(0,1);}_applyTypes(this,params,doNotRepaint);},toggleType:function toggleType(typeId,params,doNotRepaint){var t=_splitType(typeId);if(t!=null){for(var i=0,j=t.length;i<j;i++){var idx=this._jsPlumb.types.indexOf(t[i]);if(idx!==-1){_removeTypeCssHelper(this,idx);this._jsPlumb.types.splice(idx,1);}else{this._jsPlumb.types.push(t[i]);}}_applyTypes(this,params,doNotRepaint);}},applyType:function applyType(t,doNotRepaint){this.setPaintStyle(t.paintStyle,doNotRepaint);this.setHoverPaintStyle(t.hoverPaintStyle,doNotRepaint);if(t.parameters){for(var i in t.parameters){this.setParameter(i,t.parameters[i]);}}this._jsPlumb.paintStyleInUse=this.getPaintStyle();},setPaintStyle:function setPaintStyle(style,doNotRepaint){// this._jsPlumb.paintStyle = jsPlumb.extend({}, style);\n// TODO figure out if we want components to clone paintStyle so as not to share it.\nthis._jsPlumb.paintStyle=style;this._jsPlumb.paintStyleInUse=this._jsPlumb.paintStyle;_updateHoverStyle(this);if(!doNotRepaint){this.repaint();}},getPaintStyle:function getPaintStyle(){return this._jsPlumb.paintStyle;},setHoverPaintStyle:function setHoverPaintStyle(style,doNotRepaint){//this._jsPlumb.hoverPaintStyle = jsPlumb.extend({}, style);\n// TODO figure out if we want components to clone paintStyle so as not to share it.\nthis._jsPlumb.hoverPaintStyle=style;_updateHoverStyle(this);if(!doNotRepaint){this.repaint();}},getHoverPaintStyle:function getHoverPaintStyle(){return this._jsPlumb.hoverPaintStyle;},destroy:function destroy(force){if(force||this.typeId==null){this.cleanupListeners();// this is on EventGenerator\nthis.clone=null;this._jsPlumb=null;}},isHover:function isHover(){return this._jsPlumb.hover;},setHover:function setHover(hover,ignoreAttachedElements,timestamp){// while dragging, we ignore these events.  this keeps the UI from flashing and\n// swishing and whatevering.\nif(this._jsPlumb&&!this._jsPlumb.instance.currentlyDragging&&!this._jsPlumb.instance.isHoverSuspended()){this._jsPlumb.hover=hover;var method=hover?"addClass":"removeClass";if(this.canvas!=null){if(this._jsPlumb.instance.hoverClass!=null){this._jsPlumb.instance[method](this.canvas,this._jsPlumb.instance.hoverClass);}if(this._jsPlumb.hoverClass!=null){this._jsPlumb.instance[method](this.canvas,this._jsPlumb.hoverClass);}}if(this._jsPlumb.hoverPaintStyle!=null){this._jsPlumb.paintStyleInUse=hover?this._jsPlumb.hoverPaintStyle:this._jsPlumb.paintStyle;if(!this._jsPlumb.instance.isSuspendDrawing()){timestamp=timestamp||_timestamp();this.repaint({timestamp:timestamp,recalc:false});}}// get the list of other affected elements, if supported by this component.\n// for a connection, its the endpoints.  for an endpoint, its the connections! surprise.\nif(this.getAttachedElements&&!ignoreAttachedElements){_updateAttachedElements(this,hover,_timestamp(),this);}}}});// ------------------------------ END jsPlumbUIComponent --------------------------------------------\nvar _jsPlumbInstanceIndex=0,getInstanceIndex=function getInstanceIndex(){var i=_jsPlumbInstanceIndex+1;_jsPlumbInstanceIndex++;return i;};var jsPlumbInstance=root.jsPlumbInstance=function(_defaults){this.version="2.6.9";if(_defaults){jsPlumb.extend(this.Defaults,_defaults);}this.logEnabled=this.Defaults.LogEnabled;this._connectionTypes={};this._endpointTypes={};_ju.EventGenerator.apply(this);var _currentInstance=this,_instanceIndex=getInstanceIndex(),_bb=_currentInstance.bind,_initialDefaults={},_zoom=1,_info=function _info(el){if(el==null){return null;}else if(el.nodeType===3||el.nodeType===8){return{el:el,text:true};}else{var _el=_currentInstance.getElement(el);return{el:_el,id:_ju.isString(el)&&_el==null?el:_getId(_el)};}};this.getInstanceIndex=function(){return _instanceIndex;};// CONVERTED\nthis.setZoom=function(z,repaintEverything){_zoom=z;_currentInstance.fire("zoom",_zoom);if(repaintEverything){_currentInstance.repaintEverything();}return true;};// CONVERTED\nthis.getZoom=function(){return _zoom;};for(var i in this.Defaults){_initialDefaults[i]=this.Defaults[i];}var _container,_containerDelegations=[];this.unbindContainer=function(){if(_container!=null&&_containerDelegations.length>0){for(var i=0;i<_containerDelegations.length;i++){_currentInstance.off(_container,_containerDelegations[i][0],_containerDelegations[i][1]);}}};this.setContainer=function(c){this.unbindContainer();// get container as dom element.\nc=this.getElement(c);// move existing connections and endpoints, if any.\nthis.select().each(function(conn){conn.moveParent(c);});this.selectEndpoints().each(function(ep){ep.moveParent(c);});// set container.\nvar previousContainer=_container;_container=c;_containerDelegations.length=0;var eventAliases={"endpointclick":"endpointClick","endpointdblclick":"endpointDblClick"};var _oneDelegateHandler=function _oneDelegateHandler(id,e,componentType){var t=e.srcElement||e.target,jp=(t&&t.parentNode?t.parentNode._jsPlumb:null)||(t?t._jsPlumb:null)||(t&&t.parentNode&&t.parentNode.parentNode?t.parentNode.parentNode._jsPlumb:null);if(jp){jp.fire(id,jp,e);var alias=componentType?eventAliases[componentType+id]||id:id;// jsplumb also fires every event coming from components/overlays. That\'s what the test for `jp.component` is for.\n_currentInstance.fire(alias,jp.component||jp,e);}};var _addOneDelegate=function _addOneDelegate(eventId,selector,fn){_containerDelegations.push([eventId,fn]);_currentInstance.on(_container,eventId,selector,fn);};// delegate one event on the container to jsplumb elements. it might be possible to\n// abstract this out: each of endpoint, connection and overlay could register themselves with\n// jsplumb as "component types" or whatever, and provide a suitable selector. this would be\n// done by the renderer (although admittedly from 2.0 onwards we\'re not supporting vml anymore)\nvar _oneDelegate=function _oneDelegate(id){// connections.\n_addOneDelegate(id,".jtk-connector",function(e){_oneDelegateHandler(id,e);});// endpoints. note they can have an enclosing div, or not.\n_addOneDelegate(id,".jtk-endpoint",function(e){_oneDelegateHandler(id,e,"endpoint");});// overlays\n_addOneDelegate(id,".jtk-overlay",function(e){_oneDelegateHandler(id,e);});};for(var i=0;i<events.length;i++){_oneDelegate(events[i]);}// managed elements\nfor(var elId in managedElements){var el=managedElements[elId].el;if(el.parentNode===previousContainer){previousContainer.removeChild(el);_container.appendChild(el);}}};this.getContainer=function(){return _container;};this.bind=function(event,fn){if("ready"===event&&initialized){fn();}else{_bb.apply(_currentInstance,[event,fn]);}};_currentInstance.importDefaults=function(d){for(var i in d){_currentInstance.Defaults[i]=d[i];}if(d.Container){_currentInstance.setContainer(d.Container);}return _currentInstance;};_currentInstance.restoreDefaults=function(){_currentInstance.Defaults=jsPlumb.extend({},_initialDefaults);return _currentInstance;};var log=null,initialized=false,// TODO remove from window scope\nconnections=[],// map of element id -> endpoint lists. an element can have an arbitrary\n// number of endpoints on it, and not all of them have to be connected\n// to anything.\nendpointsByElement={},endpointsByUUID={},managedElements={},offsets={},offsetTimestamps={},draggableStates={},connectionBeingDragged=false,sizes=[],_suspendDrawing=false,_suspendedAt=null,DEFAULT_SCOPE=this.Defaults.Scope,_curIdStamp=1,_idstamp=function _idstamp(){return""+_curIdStamp++;},//\n// appends an element to some other element, which is calculated as follows:\n//\n// 1. if Container exists, use that element.\n// 2. if the \'parent\' parameter exists, use that.\n// 3. otherwise just use the root element.\n//\n//\n_appendElement=function(el,parent){if(_container){_container.appendChild(el);}else if(!parent){this.appendToRoot(el);}else{this.getElement(parent).appendChild(el);}}.bind(this),//\n// Draws an endpoint and its connections. this is the main entry point into drawing connections as well\n// as endpoints, since jsPlumb is endpoint-centric under the hood.\n//\n// @param element element to draw (of type library specific element object)\n// @param ui UI object from current library\'s event system. optional.\n// @param timestamp timestamp for this paint cycle. used to speed things up a little by cutting down the amount of offset calculations we do.\n// @param clearEdits defaults to false; indicates that mouse edits for connectors should be cleared\n///\n_draw=function _draw(element,ui,timestamp,clearEdits){if(!_suspendDrawing){var id=_getId(element),repaintEls,dm=_currentInstance.getDragManager();if(dm){repaintEls=dm.getElementsForDraggable(id);}if(timestamp==null){timestamp=_timestamp();}// update the offset of everything _before_ we try to draw anything.\nvar o=_updateOffset({elId:id,offset:ui,recalc:false,timestamp:timestamp});if(repaintEls&&o&&o.o){for(var i in repaintEls){_updateOffset({elId:repaintEls[i].id,offset:{left:o.o.left+repaintEls[i].offset.left,top:o.o.top+repaintEls[i].offset.top},recalc:false,timestamp:timestamp});}}_currentInstance.anchorManager.redraw(id,ui,timestamp,null,clearEdits);if(repaintEls){for(var j in repaintEls){_currentInstance.anchorManager.redraw(repaintEls[j].id,ui,timestamp,repaintEls[j].offset,clearEdits,true);}}}},//\n// gets an Endpoint by uuid.\n//\n_getEndpoint=function _getEndpoint(uuid){return endpointsByUUID[uuid];},/**\r\n             * inits a draggable if it\'s not already initialised.\r\n             * TODO: somehow abstract this to the adapter, because the concept of "draggable" has no\r\n             * place on the server.\r\n             */_initDraggableIfNecessary=function _initDraggableIfNecessary(element,isDraggable,dragOptions,id,fireEvent){// move to DragManager?\nif(!jsPlumb.headless){var _draggable=isDraggable==null?false:isDraggable;if(_draggable){if(jsPlumb.isDragSupported(element,_currentInstance)){var options=dragOptions||_currentInstance.Defaults.DragOptions;options=jsPlumb.extend({},options);// make a copy.\nif(!jsPlumb.isAlreadyDraggable(element,_currentInstance)){var dragEvent=jsPlumb.dragEvents.drag,stopEvent=jsPlumb.dragEvents.stop,startEvent=jsPlumb.dragEvents.start,_started=false;_manage(id,element);options[startEvent]=_ju.wrap(options[startEvent],function(){_currentInstance.setHoverSuspended(true);_currentInstance.select({source:element}).addClass(_currentInstance.elementDraggingClass+" "+_currentInstance.sourceElementDraggingClass,true);_currentInstance.select({target:element}).addClass(_currentInstance.elementDraggingClass+" "+_currentInstance.targetElementDraggingClass,true);_currentInstance.setConnectionBeingDragged(true);if(options.canDrag){return dragOptions.canDrag();}},false);options[dragEvent]=_ju.wrap(options[dragEvent],function(){var ui=_currentInstance.getUIPosition(arguments,_currentInstance.getZoom());if(ui!=null){_draw(element,ui,null,true);if(_started){_currentInstance.addClass(element,"jtk-dragged");}_started=true;}});options[stopEvent]=_ju.wrap(options[stopEvent],function(){var elements=arguments[0].selection,uip;var _one=function _one(_e){if(_e[1]!=null){// run the reported offset through the code that takes parent containers\n// into account, to adjust if necessary (issue 554)\nuip=_currentInstance.getUIPosition([{el:_e[2].el,pos:[_e[1].left,_e[1].top]}]);_draw(_e[2].el,uip);}_currentInstance.removeClass(_e[0],"jtk-dragged");_currentInstance.select({source:_e[2].el}).removeClass(_currentInstance.elementDraggingClass+" "+_currentInstance.sourceElementDraggingClass,true);_currentInstance.select({target:_e[2].el}).removeClass(_currentInstance.elementDraggingClass+" "+_currentInstance.targetElementDraggingClass,true);_currentInstance.getDragManager().dragEnded(_e[2].el);};for(var i=0;i<elements.length;i++){_one(elements[i]);}_started=false;_currentInstance.setHoverSuspended(false);_currentInstance.setConnectionBeingDragged(false);});var elId=_getId(element);// need ID\ndraggableStates[elId]=true;var draggable=draggableStates[elId];options.disabled=draggable==null?false:!draggable;_currentInstance.initDraggable(element,options);_currentInstance.getDragManager().register(element);if(fireEvent){_currentInstance.fire("elementDraggable",{el:element,options:options});}}else{// already draggable. attach any start, drag or stop listeners to the current Drag.\nif(dragOptions.force){_currentInstance.initDraggable(element,options);}}}}}},_scopeMatch=function _scopeMatch(e1,e2){var s1=e1.scope.split(/\\s/),s2=e2.scope.split(/\\s/);for(var i=0;i<s1.length;i++){for(var j=0;j<s2.length;j++){if(s2[j]===s1[i]){return true;}}}return false;},_mergeOverrides=function _mergeOverrides(def,values){var m=jsPlumb.extend({},def);for(var i in values){if(values[i]){m[i]=values[i];}}return m;},/*\r\n         * prepares a final params object that can be passed to _newConnection, taking into account defaults, events, etc.\r\n         */_prepareConnectionParams=function(params,referenceParams){var _p=jsPlumb.extend({},params);if(referenceParams){jsPlumb.extend(_p,referenceParams);}// hotwire endpoints passed as source or target to sourceEndpoint/targetEndpoint, respectively.\nif(_p.source){if(_p.source.endpoint){_p.sourceEndpoint=_p.source;}else{_p.source=_currentInstance.getElement(_p.source);}}if(_p.target){if(_p.target.endpoint){_p.targetEndpoint=_p.target;}else{_p.target=_currentInstance.getElement(_p.target);}}// test for endpoint uuids to connect\nif(params.uuids){_p.sourceEndpoint=_getEndpoint(params.uuids[0]);_p.targetEndpoint=_getEndpoint(params.uuids[1]);}// now ensure that if we do have Endpoints already, they\'re not full.\n// source:\nif(_p.sourceEndpoint&&_p.sourceEndpoint.isFull()){_ju.log(_currentInstance,"could not add connection; source endpoint is full");return;}// target:\nif(_p.targetEndpoint&&_p.targetEndpoint.isFull()){_ju.log(_currentInstance,"could not add connection; target endpoint is full");return;}// if source endpoint mandates connection type and nothing specified in our params, use it.\nif(!_p.type&&_p.sourceEndpoint){_p.type=_p.sourceEndpoint.connectionType;}// copy in any connectorOverlays that were specified on the source endpoint.\n// it doesnt copy target endpoint overlays.  i\'m not sure if we want it to or not.\nif(_p.sourceEndpoint&&_p.sourceEndpoint.connectorOverlays){_p.overlays=_p.overlays||[];for(var i=0,j=_p.sourceEndpoint.connectorOverlays.length;i<j;i++){_p.overlays.push(_p.sourceEndpoint.connectorOverlays[i]);}}// scope\nif(_p.sourceEndpoint&&_p.sourceEndpoint.scope){_p.scope=_p.sourceEndpoint.scope;}// pointer events\nif(!_p["pointer-events"]&&_p.sourceEndpoint&&_p.sourceEndpoint.connectorPointerEvents){_p["pointer-events"]=_p.sourceEndpoint.connectorPointerEvents;}var _addEndpoint=function _addEndpoint(el,def,idx){return _currentInstance.addEndpoint(el,_mergeOverrides(def,{anchor:_p.anchors?_p.anchors[idx]:_p.anchor,endpoint:_p.endpoints?_p.endpoints[idx]:_p.endpoint,paintStyle:_p.endpointStyles?_p.endpointStyles[idx]:_p.endpointStyle,hoverPaintStyle:_p.endpointHoverStyles?_p.endpointHoverStyles[idx]:_p.endpointHoverStyle}));};// check for makeSource/makeTarget specs.\nvar _oneElementDef=function _oneElementDef(type,idx,defs,matchType){if(_p[type]&&!_p[type].endpoint&&!_p[type+"Endpoint"]&&!_p.newConnection){var tid=_getId(_p[type]),tep=defs[tid];tep=tep?tep[matchType]:null;if(tep){// if not enabled, return.\nif(!tep.enabled){return false;}var newEndpoint=tep.endpoint!=null&&tep.endpoint._jsPlumb?tep.endpoint:_addEndpoint(_p[type],tep.def,idx);if(newEndpoint.isFull()){return false;}_p[type+"Endpoint"]=newEndpoint;if(!_p.scope&&tep.def.scope){_p.scope=tep.def.scope;}// provide scope if not already provided and endpoint def has one.\nif(tep.uniqueEndpoint){if(!tep.endpoint){tep.endpoint=newEndpoint;newEndpoint.setDeleteOnEmpty(false);}else{newEndpoint.finalEndpoint=tep.endpoint;}}else{newEndpoint.setDeleteOnEmpty(true);}//\n// copy in connector overlays if present on the source definition.\n//\nif(idx===0&&tep.def.connectorOverlays){_p.overlays=_p.overlays||[];Array.prototype.push.apply(_p.overlays,tep.def.connectorOverlays);}}}};if(_oneElementDef("source",0,this.sourceEndpointDefinitions,_p.type||"default")===false){return;}if(_oneElementDef("target",1,this.targetEndpointDefinitions,_p.type||"default")===false){return;}// last, ensure scopes match\nif(_p.sourceEndpoint&&_p.targetEndpoint){if(!_scopeMatch(_p.sourceEndpoint,_p.targetEndpoint)){_p=null;}}return _p;}.bind(_currentInstance),_newConnection=function _newConnection(params){var connectionFunc=_currentInstance.Defaults.ConnectionType||_currentInstance.getDefaultConnectionType();params._jsPlumb=_currentInstance;params.newConnection=_newConnection;params.newEndpoint=_newEndpoint;params.endpointsByUUID=endpointsByUUID;params.endpointsByElement=endpointsByElement;params.finaliseConnection=_finaliseConnection;params.id="con_"+_idstamp();var con=new connectionFunc(params);// if the connection is draggable, then maybe we need to tell the target endpoint to init the\n// dragging code. it won\'t run again if it already configured to be draggable.\nif(con.isDetachable()){con.endpoints[0].initDraggable("_jsPlumbSource");con.endpoints[1].initDraggable("_jsPlumbTarget");}return con;},//\n// adds the connection to the backing model, fires an event if necessary and then redraws\n//\n_finaliseConnection=_currentInstance.finaliseConnection=function(jpc,params,originalEvent,doInformAnchorManager){params=params||{};// add to list of connections (by scope).\nif(!jpc.suspendedEndpoint){connections.push(jpc);}jpc.pending=null;// turn off isTemporarySource on the source endpoint (only viable on first draw)\njpc.endpoints[0].isTemporarySource=false;// always inform the anchor manager\n// except that if jpc has a suspended endpoint it\'s not true to say the\n// connection is new; it has just (possibly) moved. the question is whether\n// to make that call here or in the anchor manager.  i think perhaps here.\nif(doInformAnchorManager!==false){_currentInstance.anchorManager.newConnection(jpc);}// force a paint\n_draw(jpc.source);// fire an event\nif(!params.doNotFireConnectionEvent&&params.fireEvent!==false){var eventArgs={connection:jpc,source:jpc.source,target:jpc.target,sourceId:jpc.sourceId,targetId:jpc.targetId,sourceEndpoint:jpc.endpoints[0],targetEndpoint:jpc.endpoints[1]};_currentInstance.fire("connection",eventArgs,originalEvent);}},/*\r\n         factory method to prepare a new endpoint.  this should always be used instead of creating Endpoints\r\n         manually, since this method attaches event listeners and an id.\r\n         */_newEndpoint=function _newEndpoint(params,id){var endpointFunc=_currentInstance.Defaults.EndpointType||jsPlumb.Endpoint;var _p=jsPlumb.extend({},params);_p._jsPlumb=_currentInstance;_p.newConnection=_newConnection;_p.newEndpoint=_newEndpoint;_p.endpointsByUUID=endpointsByUUID;_p.endpointsByElement=endpointsByElement;_p.fireDetachEvent=fireDetachEvent;_p.elementId=id||_getId(_p.source);var ep=new endpointFunc(_p);ep.id="ep_"+_idstamp();_manage(_p.elementId,_p.source);if(!jsPlumb.headless){_currentInstance.getDragManager().endpointAdded(_p.source,id);}return ep;},/*\r\n         * performs the given function operation on all the connections found\r\n         * for the given element id; this means we find all the endpoints for\r\n         * the given element, and then for each endpoint find the connectors\r\n         * connected to it. then we pass each connection in to the given\r\n         * function.\r\n         */_operation=function _operation(elId,func,endpointFunc){var endpoints=endpointsByElement[elId];if(endpoints&&endpoints.length){for(var i=0,ii=endpoints.length;i<ii;i++){for(var j=0,jj=endpoints[i].connections.length;j<jj;j++){var retVal=func(endpoints[i].connections[j]);// if the function passed in returns true, we exit.\n// most functions return false.\nif(retVal){return;}}if(endpointFunc){endpointFunc(endpoints[i]);}}}},_setDraggable=function _setDraggable(element,draggable){return jsPlumb.each(element,function(el){if(_currentInstance.isDragSupported(el)){draggableStates[_currentInstance.getAttribute(el,"id")]=draggable;_currentInstance.setElementDraggable(el,draggable);}});},/*\r\n         * private method to do the business of hiding/showing.\r\n         *\r\n         * @param el\r\n         *            either Id of the element in question or a library specific\r\n         *            object for the element.\r\n         * @param state\r\n         *            String specifying a value for the css \'display\' property\r\n         *            (\'block\' or \'none\').\r\n         */_setVisible=function _setVisible(el,state,alsoChangeEndpoints){state=state==="block";var endpointFunc=null;if(alsoChangeEndpoints){endpointFunc=function endpointFunc(ep){ep.setVisible(state,true,true);};}var info=_info(el);_operation(info.id,function(jpc){if(state&&alsoChangeEndpoints){// this test is necessary because this functionality is new, and i wanted to maintain backwards compatibility.\n// this block will only set a connection to be visible if the other endpoint in the connection is also visible.\nvar oidx=jpc.sourceId===info.id?1:0;if(jpc.endpoints[oidx].isVisible()){jpc.setVisible(true);}}else{// the default behaviour for show, and what always happens for hide, is to just set the visibility without getting clever.\njpc.setVisible(state);}},endpointFunc);},/*\r\n         * toggles the draggable state of the given element(s).\r\n         * el is either an id, or an element object, or a list of ids/element objects.\r\n         */_toggleDraggable=function _toggleDraggable(el){var state;jsPlumb.each(el,function(el){var elId=_currentInstance.getAttribute(el,"id");state=draggableStates[elId]==null?false:draggableStates[elId];state=!state;draggableStates[elId]=state;_currentInstance.setDraggable(el,state);return state;}.bind(this));return state;},/**\r\n             * private method to do the business of toggling hiding/showing.\r\n             */_toggleVisible=function _toggleVisible(elId,changeEndpoints){var endpointFunc=null;if(changeEndpoints){endpointFunc=function endpointFunc(ep){var state=ep.isVisible();ep.setVisible(!state);};}_operation(elId,function(jpc){var state=jpc.isVisible();jpc.setVisible(!state);},endpointFunc);},// TODO comparison performance\n_getCachedData=function _getCachedData(elId){var o=offsets[elId];if(!o){return _updateOffset({elId:elId});}else{return{o:o,s:sizes[elId]};}},/**\r\n             * gets an id for the given element, creating and setting one if\r\n             * necessary.  the id is of the form\r\n             *\r\n             *    jsPlumb_<instance index>_<index in instance>\r\n             *\r\n             * where "index in instance" is a monotonically increasing integer that starts at 0,\r\n             * for each instance.  this method is used not only to assign ids to elements that do not\r\n             * have them but also to connections and endpoints.\r\n             */_getId=function _getId(element,uuid,doNotCreateIfNotFound){if(_ju.isString(element)){return element;}if(element==null){return null;}var id=_currentInstance.getAttribute(element,"id");if(!id||id==="undefined"){// check if fixed uuid parameter is given\nif(arguments.length===2&&arguments[1]!==undefined){id=uuid;}else if(arguments.length===1||arguments.length===3&&!arguments[2]){id="jsPlumb_"+_instanceIndex+"_"+_idstamp();}if(!doNotCreateIfNotFound){_currentInstance.setAttribute(element,"id",id);}}return id;};this.setConnectionBeingDragged=function(v){connectionBeingDragged=v;};this.isConnectionBeingDragged=function(){return connectionBeingDragged;};/**\r\n         * Returns a map of all the elements this jsPlumbInstance is currently managing.\r\n         * @returns {Object} Map of [id-> {el, endpoint[], connection, position}] information.\r\n         */this.getManagedElements=function(){return managedElements;};this.connectorClass="jtk-connector";this.connectorOutlineClass="jtk-connector-outline";this.connectedClass="jtk-connected";this.hoverClass="jtk-hover";this.endpointClass="jtk-endpoint";this.endpointConnectedClass="jtk-endpoint-connected";this.endpointFullClass="jtk-endpoint-full";this.endpointDropAllowedClass="jtk-endpoint-drop-allowed";this.endpointDropForbiddenClass="jtk-endpoint-drop-forbidden";this.overlayClass="jtk-overlay";this.draggingClass="jtk-dragging";// CONVERTED\nthis.elementDraggingClass="jtk-element-dragging";// CONVERTED\nthis.sourceElementDraggingClass="jtk-source-element-dragging";// CONVERTED\nthis.targetElementDraggingClass="jtk-target-element-dragging";// CONVERTED\nthis.endpointAnchorClassPrefix="jtk-endpoint-anchor";this.hoverSourceClass="jtk-source-hover";this.hoverTargetClass="jtk-target-hover";this.dragSelectClass="jtk-drag-select";this.Anchors={};this.Connectors={"svg":{}};this.Endpoints={"svg":{}};this.Overlays={"svg":{}};this.ConnectorRenderers={};this.SVG="svg";// --------------------------- jsPlumbInstance public API ---------------------------------------------------------\nthis.addEndpoint=function(el,params,referenceParams){referenceParams=referenceParams||{};var p=jsPlumb.extend({},referenceParams);jsPlumb.extend(p,params);p.endpoint=p.endpoint||_currentInstance.Defaults.Endpoint;p.paintStyle=p.paintStyle||_currentInstance.Defaults.EndpointStyle;var results=[],inputs=_ju.isArray(el)||el.length!=null&&!_ju.isString(el)?el:[el];for(var i=0,j=inputs.length;i<j;i++){p.source=_currentInstance.getElement(inputs[i]);_ensureContainer(p.source);var id=_getId(p.source),e=_newEndpoint(p,id);// ensure element is managed.\nvar myOffset=_manage(id,p.source).info.o;_ju.addToList(endpointsByElement,id,e);if(!_suspendDrawing){e.paint({anchorLoc:e.anchor.compute({xy:[myOffset.left,myOffset.top],wh:sizes[id],element:e,timestamp:_suspendedAt}),timestamp:_suspendedAt});}results.push(e);}return results.length===1?results[0]:results;};this.addEndpoints=function(el,endpoints,referenceParams){var results=[];for(var i=0,j=endpoints.length;i<j;i++){var e=_currentInstance.addEndpoint(el,endpoints[i],referenceParams);if(_ju.isArray(e)){Array.prototype.push.apply(results,e);}else{results.push(e);}}return results;};this.animate=function(el,properties,options){if(!this.animationSupported){return false;}options=options||{};var del=_currentInstance.getElement(el),id=_getId(del),stepFunction=jsPlumb.animEvents.step,completeFunction=jsPlumb.animEvents.complete;options[stepFunction]=_ju.wrap(options[stepFunction],function(){_currentInstance.revalidate(id);});// onComplete repaints, just to make sure everything looks good at the end of the animation.\noptions[completeFunction]=_ju.wrap(options[completeFunction],function(){_currentInstance.revalidate(id);});_currentInstance.doAnimate(del,properties,options);};/**\r\n         * checks for a listener for the given condition, executing it if found, passing in the given value.\r\n         * condition listeners would have been attached using "bind" (which is, you could argue, now overloaded, since\r\n         * firing click events etc is a bit different to what this does).  i thought about adding a "bindCondition"\r\n         * or something, but decided against it, for the sake of simplicity. jsPlumb will never fire one of these\r\n         * condition events anyway.\r\n         */this.checkCondition=function(conditionName,args){var l=_currentInstance.getListener(conditionName),r=true;if(l&&l.length>0){var values=Array.prototype.slice.call(arguments,1);try{for(var i=0,j=l.length;i<j;i++){r=r&&l[i].apply(l[i],values);}}catch(e){_ju.log(_currentInstance,"cannot check condition ["+conditionName+"]"+e);}}return r;};this.connect=function(params,referenceParams){// prepare a final set of parameters to create connection with\nvar _p=_prepareConnectionParams(params,referenceParams),jpc;// TODO probably a nicer return value if the connection was not made.  _prepareConnectionParams\n// will return null (and log something) if either endpoint was full.  what would be nicer is to\n// create a dedicated \'error\' object.\nif(_p){if(_p.source==null&&_p.sourceEndpoint==null){_ju.log("Cannot establish connection - source does not exist");return;}if(_p.target==null&&_p.targetEndpoint==null){_ju.log("Cannot establish connection - target does not exist");return;}_ensureContainer(_p.source);// create the connection.  it is not yet registered\njpc=_newConnection(_p);// now add it the model, fire an event, and redraw\n_finaliseConnection(jpc,_p);}return jpc;};var stTypes=[{el:"source",elId:"sourceId",epDefs:"sourceEndpointDefinitions"},{el:"target",elId:"targetId",epDefs:"targetEndpointDefinitions"}];var _set=function(c,el,idx,doNotRepaint){var ep,_st=stTypes[idx],cId=c[_st.elId],cEl=c[_st.el],sid,sep,oldEndpoint=c.endpoints[idx];var evtParams={index:idx,originalSourceId:idx===0?cId:c.sourceId,newSourceId:c.sourceId,originalTargetId:idx===1?cId:c.targetId,newTargetId:c.targetId,connection:c};if(el.constructor===jsPlumb.Endpoint){ep=el;ep.addConnection(c);el=ep.element;}else{sid=_getId(el);sep=this[_st.epDefs][sid];if(sid===c[_st.elId]){ep=null;// dont change source/target if the element is already the one given.\n}else if(sep){for(var t in sep){if(!sep[t].enabled){return;}ep=sep[t].endpoint!=null&&sep[t].endpoint._jsPlumb?sep[t].endpoint:this.addEndpoint(el,sep[t].def);if(sep[t].uniqueEndpoint){sep[t].endpoint=ep;}ep.addConnection(c);}}else{ep=c.makeEndpoint(idx===0,el,sid);}}if(ep!=null){oldEndpoint.detachFromConnection(c);c.endpoints[idx]=ep;c[_st.el]=ep.element;c[_st.elId]=ep.elementId;evtParams[idx===0?"newSourceId":"newTargetId"]=ep.elementId;fireMoveEvent(evtParams);if(!doNotRepaint){c.repaint();}}evtParams.element=el;return evtParams;}.bind(this);this.setSource=function(connection,el,doNotRepaint){var p=_set(connection,el,0,doNotRepaint);this.anchorManager.sourceChanged(p.originalSourceId,p.newSourceId,connection,p.el);};this.setTarget=function(connection,el,doNotRepaint){var p=_set(connection,el,1,doNotRepaint);this.anchorManager.updateOtherEndpoint(p.originalSourceId,p.originalTargetId,p.newTargetId,connection);};this.deleteEndpoint=function(object,dontUpdateHover,deleteAttachedObjects){var endpoint=typeof object==="string"?endpointsByUUID[object]:object;if(endpoint){_currentInstance.deleteObject({endpoint:endpoint,dontUpdateHover:dontUpdateHover,deleteAttachedObjects:deleteAttachedObjects});}return _currentInstance;};this.deleteEveryEndpoint=function(){var _is=_currentInstance.setSuspendDrawing(true);for(var id in endpointsByElement){var endpoints=endpointsByElement[id];if(endpoints&&endpoints.length){for(var i=0,j=endpoints.length;i<j;i++){_currentInstance.deleteEndpoint(endpoints[i],true);}}}endpointsByElement={};managedElements={};endpointsByUUID={};offsets={};offsetTimestamps={};_currentInstance.anchorManager.reset();var dm=_currentInstance.getDragManager();if(dm){dm.reset();}if(!_is){_currentInstance.setSuspendDrawing(false);}return _currentInstance;};var fireDetachEvent=function fireDetachEvent(jpc,doFireEvent,originalEvent){// may have been given a connection, or in special cases, an object\nvar connType=_currentInstance.Defaults.ConnectionType||_currentInstance.getDefaultConnectionType(),argIsConnection=jpc.constructor===connType,params=argIsConnection?{connection:jpc,source:jpc.source,target:jpc.target,sourceId:jpc.sourceId,targetId:jpc.targetId,sourceEndpoint:jpc.endpoints[0],targetEndpoint:jpc.endpoints[1]}:jpc;if(doFireEvent){_currentInstance.fire("connectionDetached",params,originalEvent);}// always fire this. used by internal jsplumb stuff.\n_currentInstance.fire("internal.connectionDetached",params,originalEvent);_currentInstance.anchorManager.connectionDetached(params);};var fireMoveEvent=_currentInstance.fireMoveEvent=function(params,evt){_currentInstance.fire("connectionMoved",params,evt);};this.unregisterEndpoint=function(endpoint){if(endpoint._jsPlumb.uuid){endpointsByUUID[endpoint._jsPlumb.uuid]=null;}_currentInstance.anchorManager.deleteEndpoint(endpoint);// TODO at least replace this with a removeWithFunction call.\nfor(var e in endpointsByElement){var endpoints=endpointsByElement[e];if(endpoints){var newEndpoints=[];for(var i=0,j=endpoints.length;i<j;i++){if(endpoints[i]!==endpoint){newEndpoints.push(endpoints[i]);}}endpointsByElement[e]=newEndpoints;}if(endpointsByElement[e].length<1){delete endpointsByElement[e];}}};var IS_DETACH_ALLOWED="isDetachAllowed";var BEFORE_DETACH="beforeDetach";var CHECK_CONDITION="checkCondition";/**\r\n         * Deletes a Connection.\r\n         * @method deleteConnection\r\n         * @param connection Connection to delete\r\n         * @param {Object} [params] Optional delete parameters\r\n         * @param {Boolean} [params.doNotFireEvent=false] If true, a connection detached event will not be fired. Otherwise one will.\r\n         * @param {Boolean} [params.force=false] If true, the connection will be deleted even if a beforeDetach interceptor tries to stop the deletion.\r\n         * @returns {Boolean} True if the connection was deleted, false otherwise.\r\n         */this.deleteConnection=function(connection,params){if(connection!=null){params=params||{};if(params.force||_ju.functionChain(true,false,[[connection.endpoints[0],IS_DETACH_ALLOWED,[connection]],[connection.endpoints[1],IS_DETACH_ALLOWED,[connection]],[connection,IS_DETACH_ALLOWED,[connection]],[_currentInstance,CHECK_CONDITION,[BEFORE_DETACH,connection]]])){connection.setHover(false);fireDetachEvent(connection,!connection.pending&&params.fireEvent!==false,params.originalEvent);connection.endpoints[0].detachFromConnection(connection);connection.endpoints[1].detachFromConnection(connection);_ju.removeWithFunction(connections,function(_c){return connection.id===_c.id;});connection.cleanup();connection.destroy();return true;}}return false;};/**\r\n         * Remove all Connections from all elements, but leaves Endpoints in place ((unless a connection is set to auto delete its Endpoints).\r\n         * @method deleteEveryConnection\r\n         * @param {Object} [params] optional params object for the call\r\n         * @param {Boolean} [params.fireEvent=true] Whether or not to fire detach events\r\n         * @param {Boolean} [params.forceDetach=false] If true, this call will ignore any `beforeDetach` interceptors.\r\n         * @returns {Number} The number of connections that were deleted.\r\n         */this.deleteEveryConnection=function(params){params=params||{};var count=connections.length,deletedCount=0;_currentInstance.batch(function(){for(var i=0;i<count;i++){deletedCount+=_currentInstance.deleteConnection(connections[0],params)?1:0;}});return deletedCount;};/**\r\n         * Removes all an element\'s Connections.\r\n         * @method deleteConnectionsForElement\r\n         * @param {Object} el Either the id of the element, or a selector for the element.\r\n         * @param {Object} [params] Optional parameters.\r\n         * @param {Boolean} [params.fireEvent=true] Whether or not to fire the detach event.\r\n         * @param {Boolean} [params.forceDetach=false] If true, this call will ignore any `beforeDetach` interceptors.\r\n         * @return {jsPlumbInstance} The current jsPlumb instance.\r\n         */this.deleteConnectionsForElement=function(el,params){params=params||{};el=_currentInstance.getElement(el);var id=_getId(el),endpoints=endpointsByElement[id];if(endpoints&&endpoints.length){for(var i=0,j=endpoints.length;i<j;i++){endpoints[i].deleteEveryConnection(params);}}return _currentInstance;};/// not public.  but of course its exposed. how to change this.\nthis.deleteObject=function(params){var result={endpoints:{},connections:{},endpointCount:0,connectionCount:0},deleteAttachedObjects=params.deleteAttachedObjects!==false;var unravelConnection=function unravelConnection(connection){if(connection!=null&&result.connections[connection.id]==null){if(!params.dontUpdateHover&&connection._jsPlumb!=null){connection.setHover(false);}result.connections[connection.id]=connection;result.connectionCount++;}};var unravelEndpoint=function unravelEndpoint(endpoint){if(endpoint!=null&&result.endpoints[endpoint.id]==null){if(!params.dontUpdateHover&&endpoint._jsPlumb!=null){endpoint.setHover(false);}result.endpoints[endpoint.id]=endpoint;result.endpointCount++;if(deleteAttachedObjects){for(var i=0;i<endpoint.connections.length;i++){var c=endpoint.connections[i];unravelConnection(c);}}}};if(params.connection){unravelConnection(params.connection);}else{unravelEndpoint(params.endpoint);}// loop through connections\nfor(var i in result.connections){var c=result.connections[i];if(c._jsPlumb){_ju.removeWithFunction(connections,function(_c){return c.id===_c.id;});fireDetachEvent(c,params.fireEvent===false?false:!c.pending,params.originalEvent);var doNotCleanup=params.deleteAttachedObjects==null?null:!params.deleteAttachedObjects;c.endpoints[0].detachFromConnection(c,null,doNotCleanup);c.endpoints[1].detachFromConnection(c,null,doNotCleanup);c.cleanup(true);c.destroy(true);}}// loop through endpoints\nfor(var j in result.endpoints){var e=result.endpoints[j];if(e._jsPlumb){_currentInstance.unregisterEndpoint(e);// FIRE some endpoint deleted event?\ne.cleanup(true);e.destroy(true);}}return result;};this.draggable=function(el,options){var info;_each(function(_el){info=_info(_el);if(info.el){_initDraggableIfNecessary(info.el,true,options,info.id,true);}},el);return _currentInstance;};this.droppable=function(el,options){var info;options=options||{};options.allowLoopback=false;_each(function(_el){info=_info(_el);if(info.el){_currentInstance.initDroppable(info.el,options);}},el);return _currentInstance;};// helpers for select/selectEndpoints\nvar _setOperation=function _setOperation(list,func,args,selector){for(var i=0,j=list.length;i<j;i++){list[i][func].apply(list[i],args);}return selector(list);},_getOperation=function _getOperation(list,func,args){var out=[];for(var i=0,j=list.length;i<j;i++){out.push([list[i][func].apply(list[i],args),list[i]]);}return out;},setter=function setter(list,func,selector){return function(){return _setOperation(list,func,arguments,selector);};},getter=function getter(list,func){return function(){return _getOperation(list,func,arguments);};},prepareList=function prepareList(input,doNotGetIds){var r=[];if(input){if(typeof input===\'string\'){if(input==="*"){return input;}r.push(input);}else{if(doNotGetIds){r=input;}else{if(input.length){for(var i=0,j=input.length;i<j;i++){r.push(_info(input[i]).id);}}else{r.push(_info(input).id);}}}}return r;},filterList=function filterList(list,value,missingIsFalse){if(list==="*"){return true;}return list.length>0?list.indexOf(value)!==-1:!missingIsFalse;};// get some connections, specifying source/target/scope\nthis.getConnections=function(options,flat){if(!options){options={};}else if(options.constructor===String){options={"scope":options};}var scope=options.scope||_currentInstance.getDefaultScope(),scopes=prepareList(scope,true),sources=prepareList(options.source),targets=prepareList(options.target),results=!flat&&scopes.length>1?{}:[],_addOne=function _addOne(scope,obj){if(!flat&&scopes.length>1){var ss=results[scope];if(ss==null){ss=results[scope]=[];}ss.push(obj);}else{results.push(obj);}};for(var j=0,jj=connections.length;j<jj;j++){var c=connections[j],sourceId=c.proxies&&c.proxies[0]?c.proxies[0].originalEp.elementId:c.sourceId,targetId=c.proxies&&c.proxies[1]?c.proxies[1].originalEp.elementId:c.targetId;if(filterList(scopes,c.scope)&&filterList(sources,sourceId)&&filterList(targets,targetId)){_addOne(c.scope,c);}}return results;};var _curryEach=function _curryEach(list,executor){return function(f){for(var i=0,ii=list.length;i<ii;i++){f(list[i]);}return executor(list);};},_curryGet=function _curryGet(list){return function(idx){return list[idx];};};var _makeCommonSelectHandler=function _makeCommonSelectHandler(list,executor){var out={length:list.length,each:_curryEach(list,executor),get:_curryGet(list)},setters=["setHover","removeAllOverlays","setLabel","addClass","addOverlay","removeOverlay","removeOverlays","showOverlay","hideOverlay","showOverlays","hideOverlays","setPaintStyle","setHoverPaintStyle","setSuspendEvents","setParameter","setParameters","setVisible","repaint","addType","toggleType","removeType","removeClass","setType","bind","unbind"],getters=["getLabel","getOverlay","isHover","getParameter","getParameters","getPaintStyle","getHoverPaintStyle","isVisible","hasType","getType","isSuspendEvents"],i,ii;for(i=0,ii=setters.length;i<ii;i++){out[setters[i]]=setter(list,setters[i],executor);}for(i=0,ii=getters.length;i<ii;i++){out[getters[i]]=getter(list,getters[i]);}return out;};var _makeConnectionSelectHandler=function _makeConnectionSelectHandler(list){var common=_makeCommonSelectHandler(list,_makeConnectionSelectHandler);return jsPlumb.extend(common,{// setters\nsetDetachable:setter(list,"setDetachable",_makeConnectionSelectHandler),setReattach:setter(list,"setReattach",_makeConnectionSelectHandler),setConnector:setter(list,"setConnector",_makeConnectionSelectHandler),delete:function _delete(){for(var i=0,ii=list.length;i<ii;i++){_currentInstance.deleteConnection(list[i]);}},// getters\nisDetachable:getter(list,"isDetachable"),isReattach:getter(list,"isReattach")});};var _makeEndpointSelectHandler=function _makeEndpointSelectHandler(list){var common=_makeCommonSelectHandler(list,_makeEndpointSelectHandler);return jsPlumb.extend(common,{setEnabled:setter(list,"setEnabled",_makeEndpointSelectHandler),setAnchor:setter(list,"setAnchor",_makeEndpointSelectHandler),isEnabled:getter(list,"isEnabled"),deleteEveryConnection:function deleteEveryConnection(){for(var i=0,ii=list.length;i<ii;i++){list[i].deleteEveryConnection();}},"delete":function _delete(){for(var i=0,ii=list.length;i<ii;i++){_currentInstance.deleteEndpoint(list[i]);}}});};this.select=function(params){params=params||{};params.scope=params.scope||"*";return _makeConnectionSelectHandler(params.connections||_currentInstance.getConnections(params,true));};this.selectEndpoints=function(params){params=params||{};params.scope=params.scope||"*";var noElementFilters=!params.element&&!params.source&&!params.target,elements=noElementFilters?"*":prepareList(params.element),sources=noElementFilters?"*":prepareList(params.source),targets=noElementFilters?"*":prepareList(params.target),scopes=prepareList(params.scope,true);var ep=[];for(var el in endpointsByElement){var either=filterList(elements,el,true),source=filterList(sources,el,true),sourceMatchExact=sources!=="*",target=filterList(targets,el,true),targetMatchExact=targets!=="*";// if they requested \'either\' then just match scope. otherwise if they requested \'source\' (not as a wildcard) then we have to match only endpoints that have isSource set to to true, and the same thing with isTarget.\nif(either||source||target){inner:for(var i=0,ii=endpointsByElement[el].length;i<ii;i++){var _ep=endpointsByElement[el][i];if(filterList(scopes,_ep.scope,true)){var noMatchSource=sourceMatchExact&&sources.length>0&&!_ep.isSource,noMatchTarget=targetMatchExact&&targets.length>0&&!_ep.isTarget;if(noMatchSource||noMatchTarget){continue inner;}ep.push(_ep);}}}}return _makeEndpointSelectHandler(ep);};// get all connections managed by the instance of jsplumb.\nthis.getAllConnections=function(){return connections;};this.getDefaultScope=function(){return DEFAULT_SCOPE;};// get an endpoint by uuid.\nthis.getEndpoint=_getEndpoint;/**\r\n         * Gets the list of Endpoints for a given element.\r\n         * @method getEndpoints\r\n         * @param {String|Element|Selector} el The element to get endpoints for.\r\n         * @return {Endpoint[]} An array of Endpoints for the specified element.\r\n         */this.getEndpoints=function(el){return endpointsByElement[_info(el).id]||[];};// gets the default endpoint type. used when subclassing. see wiki.\nthis.getDefaultEndpointType=function(){return jsPlumb.Endpoint;};// gets the default connection type. used when subclassing.  see wiki.\nthis.getDefaultConnectionType=function(){return jsPlumb.Connection;};/*\r\n         * Gets an element\'s id, creating one if necessary. really only exposed\r\n         * for the lib-specific functionality to access; would be better to pass\r\n         * the current instance into the lib-specific code (even though this is\r\n         * a static call. i just don\'t want to expose it to the public API).\r\n         */this.getId=_getId;this.appendElement=_appendElement;var _hoverSuspended=false;this.isHoverSuspended=function(){return _hoverSuspended;};this.setHoverSuspended=function(s){_hoverSuspended=s;};// set an element\'s connections to be hidden\nthis.hide=function(el,changeEndpoints){_setVisible(el,"none",changeEndpoints);return _currentInstance;};// exposed for other objects to use to get a unique id.\nthis.idstamp=_idstamp;// this.connectorsInitialized = false;\n// this.registerConnectorType = function (connector, name) {\n//     connectorTypes.push([connector, name]);\n// };\n// ensure that, if the current container exists, it is a DOM element and not a selector.\n// if it does not exist and `candidate` is supplied, the offset parent of that element will be set as the Container.\n// this is used to do a better default behaviour for the case that the user has not set a container:\n// addEndpoint, makeSource, makeTarget and connect all call this method with the offsetParent of the\n// element in question (for connect it is the source element). So if no container is set, it is inferred\n// to be the offsetParent of the first element the user tries to connect.\nvar _ensureContainer=function _ensureContainer(candidate){if(!_container&&candidate){var can=_currentInstance.getElement(candidate);if(can.offsetParent){_currentInstance.setContainer(can.offsetParent);}}};var _getContainerFromDefaults=function _getContainerFromDefaults(){if(_currentInstance.Defaults.Container){_currentInstance.setContainer(_currentInstance.Defaults.Container);}};// check if a given element is managed or not. if not, add to our map. if drawing is not suspended then\n// we\'ll also stash its dimensions; otherwise we\'ll do this in a lazy way through updateOffset.\nvar _manage=_currentInstance.manage=function(id,element,_transient){if(!managedElements[id]){managedElements[id]={el:element,endpoints:[],connections:[]};managedElements[id].info=_updateOffset({elId:id,timestamp:_suspendedAt});if(!_transient){_currentInstance.fire("manageElement",{id:id,info:managedElements[id].info,el:element});}}return managedElements[id];};var _unmanage=function _unmanage(id){if(managedElements[id]){delete managedElements[id];_currentInstance.fire("unmanageElement",id);}};/**\r\n         * updates the offset and size for a given element, and stores the\r\n         * values. if \'offset\' is not null we use that (it would have been\r\n         * passed in from a drag call) because it\'s faster; but if it is null,\r\n         * or if \'recalc\' is true in order to force a recalculation, we get the current values.\r\n         */var _updateOffset=this.updateOffset=function(params){var timestamp=params.timestamp,recalc=params.recalc,offset=params.offset,elId=params.elId,s;if(_suspendDrawing&&!timestamp){timestamp=_suspendedAt;}if(!recalc){if(timestamp&&timestamp===offsetTimestamps[elId]){return{o:params.offset||offsets[elId],s:sizes[elId]};}}if(recalc||!offset&&offsets[elId]==null){// if forced repaint or no offset available, we recalculate.\n// get the current size and offset, and store them\ns=managedElements[elId]?managedElements[elId].el:null;if(s!=null){sizes[elId]=_currentInstance.getSize(s);offsets[elId]=_currentInstance.getOffset(s);offsetTimestamps[elId]=timestamp;}}else{offsets[elId]=offset||offsets[elId];if(sizes[elId]==null){s=managedElements[elId].el;if(s!=null){sizes[elId]=_currentInstance.getSize(s);}}offsetTimestamps[elId]=timestamp;}if(offsets[elId]&&!offsets[elId].right){offsets[elId].right=offsets[elId].left+sizes[elId][0];offsets[elId].bottom=offsets[elId].top+sizes[elId][1];offsets[elId].width=sizes[elId][0];offsets[elId].height=sizes[elId][1];offsets[elId].centerx=offsets[elId].left+offsets[elId].width/2;offsets[elId].centery=offsets[elId].top+offsets[elId].height/2;}return{o:offsets[elId],s:sizes[elId]};};/**\r\n         * callback from the current library to tell us to prepare ourselves (attach\r\n         * mouse listeners etc; can\'t do that until the library has provided a bind method)\r\n         */this.init=function(){if(!initialized){_getContainerFromDefaults();_currentInstance.anchorManager=new root.jsPlumb.AnchorManager({jsPlumbInstance:_currentInstance});initialized=true;_currentInstance.fire("ready",_currentInstance);}}.bind(this);this.log=log;this.jsPlumbUIComponent=jsPlumbUIComponent;/*\r\n         * Creates an anchor with the given params.\r\n         *\r\n         *\r\n         * Returns: The newly created Anchor.\r\n         * Throws: an error if a named anchor was not found.\r\n         */this.makeAnchor=function(){var pp,_a=function _a(t,p){if(root.jsPlumb.Anchors[t]){return new root.jsPlumb.Anchors[t](p);}if(!_currentInstance.Defaults.DoNotThrowErrors){throw{msg:"jsPlumb: unknown anchor type \'"+t+"\'"};}};if(arguments.length===0){return null;}var specimen=arguments[0],elementId=arguments[1],jsPlumbInstance=arguments[2],newAnchor=null;// if it appears to be an anchor already...\nif(specimen.compute&&specimen.getOrientation){return specimen;}//TODO hazy here about whether it should be added or is already added somehow.\n// is it the name of an anchor type?\nelse if(typeof specimen==="string"){newAnchor=_a(arguments[0],{elementId:elementId,jsPlumbInstance:_currentInstance});}// is it an array? it will be one of:\n// an array of [spec, params] - this defines a single anchor, which may be dynamic, but has parameters.\n// an array of arrays - this defines some dynamic anchors\n// an array of numbers - this defines a single anchor.\nelse if(_ju.isArray(specimen)){if(_ju.isArray(specimen[0])||_ju.isString(specimen[0])){// if [spec, params] format\nif(specimen.length===2&&_ju.isObject(specimen[1])){// if first arg is a string, its a named anchor with params\nif(_ju.isString(specimen[0])){pp=root.jsPlumb.extend({elementId:elementId,jsPlumbInstance:_currentInstance},specimen[1]);newAnchor=_a(specimen[0],pp);}// otherwise first arg is array, second is params. we treat as a dynamic anchor, which is fine\n// even if the first arg has only one entry. you could argue all anchors should be implicitly dynamic in fact.\nelse{pp=root.jsPlumb.extend({elementId:elementId,jsPlumbInstance:_currentInstance,anchors:specimen[0]},specimen[1]);newAnchor=new root.jsPlumb.DynamicAnchor(pp);}}else{newAnchor=new jsPlumb.DynamicAnchor({anchors:specimen,selector:null,elementId:elementId,jsPlumbInstance:_currentInstance});}}else{var anchorParams={x:specimen[0],y:specimen[1],orientation:specimen.length>=4?[specimen[2],specimen[3]]:[0,0],offsets:specimen.length>=6?[specimen[4],specimen[5]]:[0,0],elementId:elementId,jsPlumbInstance:_currentInstance,cssClass:specimen.length===7?specimen[6]:null};newAnchor=new root.jsPlumb.Anchor(anchorParams);newAnchor.clone=function(){return new root.jsPlumb.Anchor(anchorParams);};}}if(!newAnchor.id){newAnchor.id="anchor_"+_idstamp();}return newAnchor;};/**\r\n         * makes a list of anchors from the given list of types or coords, eg\r\n         * ["TopCenter", "RightMiddle", "BottomCenter", [0, 1, -1, -1] ]\r\n         */this.makeAnchors=function(types,elementId,jsPlumbInstance){var r=[];for(var i=0,ii=types.length;i<ii;i++){if(typeof types[i]==="string"){r.push(root.jsPlumb.Anchors[types[i]]({elementId:elementId,jsPlumbInstance:jsPlumbInstance}));}else if(_ju.isArray(types[i])){r.push(_currentInstance.makeAnchor(types[i],elementId,jsPlumbInstance));}}return r;};/**\r\n         * Makes a dynamic anchor from the given list of anchors (which may be in shorthand notation as strings or dimension arrays, or Anchor\r\n         * objects themselves) and the given, optional, anchorSelector function (jsPlumb uses a default if this is not provided; most people will\r\n         * not need to provide this - i think).\r\n         */this.makeDynamicAnchor=function(anchors,anchorSelector){return new root.jsPlumb.DynamicAnchor({anchors:anchors,selector:anchorSelector,elementId:null,jsPlumbInstance:_currentInstance});};// --------------------- makeSource/makeTarget ---------------------------------------------- \nthis.targetEndpointDefinitions={};this.sourceEndpointDefinitions={};var selectorFilter=function selectorFilter(evt,_el,selector,_instance,negate){var t=evt.target||evt.srcElement,ok=false,sel=_instance.getSelector(_el,selector);for(var j=0;j<sel.length;j++){if(sel[j]===t){ok=true;break;}}return negate?!ok:ok;};var _makeElementDropHandler=function _makeElementDropHandler(elInfo,p,dropOptions,isSource,isTarget){var proxyComponent=new jsPlumbUIComponent(p);var _drop=p._jsPlumb.EndpointDropHandler({jsPlumb:_currentInstance,enabled:function enabled(){return elInfo.def.enabled;},isFull:function isFull(){var targetCount=_currentInstance.select({target:elInfo.id}).length;return elInfo.def.maxConnections>0&&targetCount>=elInfo.def.maxConnections;},element:elInfo.el,elementId:elInfo.id,isSource:isSource,isTarget:isTarget,addClass:function addClass(clazz){_currentInstance.addClass(elInfo.el,clazz);},removeClass:function removeClass(clazz){_currentInstance.removeClass(elInfo.el,clazz);},onDrop:function onDrop(jpc){var source=jpc.endpoints[0];source.anchor.locked=false;},isDropAllowed:function isDropAllowed(){return proxyComponent.isDropAllowed.apply(proxyComponent,arguments);},isRedrop:function isRedrop(jpc){return jpc.suspendedElement!=null&&jpc.suspendedEndpoint!=null&&jpc.suspendedEndpoint.element===elInfo.el;},getEndpoint:function getEndpoint(jpc){// make a new Endpoint for the target, or get it from the cache if uniqueEndpoint\n// is set. if its a redrop the new endpoint will be immediately cleaned up.\nvar newEndpoint=elInfo.def.endpoint;// if no cached endpoint, or there was one but it has been cleaned up\n// (ie. detached), create a new one\nif(newEndpoint==null||newEndpoint._jsPlumb==null){var eps=_currentInstance.deriveEndpointAndAnchorSpec(jpc.getType().join(" "),true);var pp=eps.endpoints?root.jsPlumb.extend(p,{endpoint:elInfo.def.def.endpoint||eps.endpoints[1]}):p;if(eps.anchors){pp=root.jsPlumb.extend(pp,{anchor:elInfo.def.def.anchor||eps.anchors[1]});}newEndpoint=_currentInstance.addEndpoint(elInfo.el,pp);newEndpoint._mtNew=true;}if(p.uniqueEndpoint){elInfo.def.endpoint=newEndpoint;}newEndpoint.setDeleteOnEmpty(true);// if connection is detachable, init the new endpoint to be draggable, to support that happening.\nif(jpc.isDetachable()){newEndpoint.initDraggable();}// if the anchor has a \'positionFinder\' set, then delegate to that function to find\n// out where to locate the anchor.\nif(newEndpoint.anchor.positionFinder!=null){var dropPosition=_currentInstance.getUIPosition(arguments,_currentInstance.getZoom()),elPosition=_currentInstance.getOffset(elInfo.el),elSize=_currentInstance.getSize(elInfo.el),ap=dropPosition==null?[0,0]:newEndpoint.anchor.positionFinder(dropPosition,elPosition,elSize,newEndpoint.anchor.constructorParams);newEndpoint.anchor.x=ap[0];newEndpoint.anchor.y=ap[1];// now figure an orientation for it..kind of hard to know what to do actually. probably the best thing i can do is to\n// support specifying an orientation in the anchor\'s spec. if one is not supplied then i will make the orientation\n// be what will cause the most natural link to the source: it will be pointing at the source, but it needs to be\n// specified in one axis only, and so how to make that choice? i think i will use whichever axis is the one in which\n// the target is furthest away from the source.\n}return newEndpoint;},maybeCleanup:function maybeCleanup(ep){if(ep._mtNew&&ep.connections.length===0){_currentInstance.deleteObject({endpoint:ep});}else{delete ep._mtNew;}}});// wrap drop events as needed and initialise droppable\nvar dropEvent=root.jsPlumb.dragEvents.drop;dropOptions.scope=dropOptions.scope||p.scope||_currentInstance.Defaults.Scope;dropOptions[dropEvent]=_ju.wrap(dropOptions[dropEvent],_drop,true);// if target, return true from the over event. this will cause katavorio to stop setting drops to hover\n// if multipleDrop is set to false.\nif(isTarget){dropOptions[root.jsPlumb.dragEvents.over]=function(){return true;};}// vanilla jsplumb only\nif(p.allowLoopback===false){dropOptions.canDrop=function(_drag){var de=_drag.getDragElement()._jsPlumbRelatedElement;return de!==elInfo.el;};}_currentInstance.initDroppable(elInfo.el,dropOptions,"internal");return _drop;};// see API docs\nthis.makeTarget=function(el,params,referenceParams){// put jsplumb ref into params without altering the params passed in\nvar p=root.jsPlumb.extend({_jsPlumb:this},referenceParams);root.jsPlumb.extend(p,params);var maxConnections=p.maxConnections||-1,_doOne=function(el){// get the element\'s id and store the endpoint definition for it.  jsPlumb.connect calls will look for one of these,\n// and use the endpoint definition if found.\n// decode the info for this element (id and element)\nvar elInfo=_info(el),elid=elInfo.id,dropOptions=root.jsPlumb.extend({},p.dropOptions||{}),type=p.connectionType||"default";this.targetEndpointDefinitions[elid]=this.targetEndpointDefinitions[elid]||{};_ensureContainer(elid);// if this is a group and the user has not mandated a rank, set to -1 so that Nodes takes\n// precedence.\nif(elInfo.el._isJsPlumbGroup&&dropOptions.rank==null){dropOptions.rank=-1;}// store the definition\nvar _def={def:root.jsPlumb.extend({},p),uniqueEndpoint:p.uniqueEndpoint,maxConnections:maxConnections,enabled:true};if(p.createEndpoint){_def.uniqueEndpoint=true;_def.endpoint=_currentInstance.addEndpoint(el,_def.def);_def.endpoint.setDeleteOnEmpty(false);}elInfo.def=_def;this.targetEndpointDefinitions[elid][type]=_def;_makeElementDropHandler(elInfo,p,dropOptions,p.isSource===true,true);// stash the definition on the drop\nelInfo.el._katavorioDrop[elInfo.el._katavorioDrop.length-1].targetDef=_def;}.bind(this);// make an array if only given one element\nvar inputs=el.length&&el.constructor!==String?el:[el];// register each one in the list.\nfor(var i=0,ii=inputs.length;i<ii;i++){_doOne(inputs[i]);}return this;};// see api docs\nthis.unmakeTarget=function(el,doNotClearArrays){var info=_info(el);_currentInstance.destroyDroppable(info.el,"internal");if(!doNotClearArrays){delete this.targetEndpointDefinitions[info.id];}return this;};// see api docs\nthis.makeSource=function(el,params,referenceParams){var p=root.jsPlumb.extend({_jsPlumb:this},referenceParams);root.jsPlumb.extend(p,params);var type=p.connectionType||"default";var aae=_currentInstance.deriveEndpointAndAnchorSpec(type);p.endpoint=p.endpoint||aae.endpoints[0];p.anchor=p.anchor||aae.anchors[0];var maxConnections=p.maxConnections||-1,onMaxConnections=p.onMaxConnections,_doOne=function(elInfo){// get the element\'s id and store the endpoint definition for it.  jsPlumb.connect calls will look for one of these,\n// and use the endpoint definition if found.\nvar elid=elInfo.id,_del=this.getElement(elInfo.el);this.sourceEndpointDefinitions[elid]=this.sourceEndpointDefinitions[elid]||{};_ensureContainer(elid);var _def={def:root.jsPlumb.extend({},p),uniqueEndpoint:p.uniqueEndpoint,maxConnections:maxConnections,enabled:true};if(p.createEndpoint){_def.uniqueEndpoint=true;_def.endpoint=_currentInstance.addEndpoint(el,_def.def);_def.endpoint.setDeleteOnEmpty(false);}this.sourceEndpointDefinitions[elid][type]=_def;elInfo.def=_def;var stopEvent=root.jsPlumb.dragEvents.stop,dragEvent=root.jsPlumb.dragEvents.drag,dragOptions=root.jsPlumb.extend({},p.dragOptions||{}),existingDrag=dragOptions.drag,existingStop=dragOptions.stop,ep=null,endpointAddedButNoDragYet=false;// set scope if its not set in dragOptions but was passed in in params\ndragOptions.scope=dragOptions.scope||p.scope;dragOptions[dragEvent]=_ju.wrap(dragOptions[dragEvent],function(){if(existingDrag){existingDrag.apply(this,arguments);}endpointAddedButNoDragYet=false;});dragOptions[stopEvent]=_ju.wrap(dragOptions[stopEvent],function(){if(existingStop){existingStop.apply(this,arguments);}this.currentlyDragging=false;if(ep._jsPlumb!=null){// if not cleaned up...\n// reset the anchor to the anchor that was initially provided. the one we were using to drag\n// the connection was just a placeholder that was located at the place the user pressed the\n// mouse button to initiate the drag.\nvar anchorDef=p.anchor||this.Defaults.Anchor,oldAnchor=ep.anchor,oldConnection=ep.connections[0];var newAnchor=this.makeAnchor(anchorDef,elid,this),_el=ep.element;// if the anchor has a \'positionFinder\' set, then delegate to that function to find\n// out where to locate the anchor. issue 117.\nif(newAnchor.positionFinder!=null){var elPosition=_currentInstance.getOffset(_el),elSize=this.getSize(_el),dropPosition={left:elPosition.left+oldAnchor.x*elSize[0],top:elPosition.top+oldAnchor.y*elSize[1]},ap=newAnchor.positionFinder(dropPosition,elPosition,elSize,newAnchor.constructorParams);newAnchor.x=ap[0];newAnchor.y=ap[1];}ep.setAnchor(newAnchor,true);ep.repaint();this.repaint(ep.elementId);if(oldConnection!=null){this.repaint(oldConnection.targetId);}}}.bind(this));// when the user presses the mouse, add an Endpoint, if we are enabled.\nvar mouseDownListener=function(e){// on right mouse button, abort.\nif(e.which===3||e.button===2){return;}// TODO store def on element.\nvar def=this.sourceEndpointDefinitions[elid][type];// if disabled, return.\nif(!def.enabled){return;}elid=this.getId(this.getElement(elInfo.el));// elid might have changed since this method was called to configure the element.\n// if a filter was given, run it, and return if it says no.\nif(p.filter){var r=_ju.isString(p.filter)?selectorFilter(e,elInfo.el,p.filter,this,p.filterExclude):p.filter(e,elInfo.el);if(r===false){return;}}// if maxConnections reached\nvar sourceCount=this.select({source:elid}).length;if(def.maxConnections>=0&&sourceCount>=def.maxConnections){if(onMaxConnections){onMaxConnections({element:elInfo.el,maxConnections:maxConnections},e);}return false;}// find the position on the element at which the mouse was pressed; this is where the endpoint\n// will be located.\nvar elxy=root.jsPlumb.getPositionOnElement(e,_del,_zoom);// we need to override the anchor in here, and force \'isSource\', but we don\'t want to mess with\n// the params passed in, because after a connection is established we\'re going to reset the endpoint\n// to have the anchor we were given.\nvar tempEndpointParams={};root.jsPlumb.extend(tempEndpointParams,p);tempEndpointParams.isTemporarySource=true;tempEndpointParams.anchor=[elxy[0],elxy[1],0,0];tempEndpointParams.dragOptions=dragOptions;if(def.def.scope){tempEndpointParams.scope=def.def.scope;}ep=this.addEndpoint(elid,tempEndpointParams);endpointAddedButNoDragYet=true;ep.setDeleteOnEmpty(true);// if unique endpoint and it\'s already been created, push it onto the endpoint we create. at the end\n// of a successful connection we\'ll switch to that endpoint.\n// TODO this is the same code as the programmatic endpoints create on line 1050 ish\nif(def.uniqueEndpoint){if(!def.endpoint){def.endpoint=ep;ep.setDeleteOnEmpty(false);}else{ep.finalEndpoint=def.endpoint;}}var _delTempEndpoint=function _delTempEndpoint(){// this mouseup event is fired only if no dragging occurred, by jquery and yui, but for mootools\n// it is fired even if dragging has occurred, in which case we would blow away a perfectly\n// legitimate endpoint, were it not for this check.  the flag is set after adding an\n// endpoint and cleared in a drag listener we set in the dragOptions above.\n_currentInstance.off(ep.canvas,"mouseup",_delTempEndpoint);_currentInstance.off(elInfo.el,"mouseup",_delTempEndpoint);if(endpointAddedButNoDragYet){endpointAddedButNoDragYet=false;_currentInstance.deleteEndpoint(ep);}};_currentInstance.on(ep.canvas,"mouseup",_delTempEndpoint);_currentInstance.on(elInfo.el,"mouseup",_delTempEndpoint);// optionally check for attributes to extract from the source element\nvar payload={};if(def.def.extract){for(var att in def.def.extract){var v=(e.srcElement||e.target).getAttribute(att);if(v){payload[def.def.extract[att]]=v;}}}// and then trigger its mousedown event, which will kick off a drag, which will start dragging\n// a new connection from this endpoint.\n_currentInstance.trigger(ep.canvas,"mousedown",e,payload);_ju.consume(e);}.bind(this);this.on(elInfo.el,"mousedown",mouseDownListener);_def.trigger=mouseDownListener;// if a filter was provided, set it as a dragFilter on the element,\n// to prevent the element drag function from kicking in when we want to\n// drag a new connection\nif(p.filter&&(_ju.isString(p.filter)||_ju.isFunction(p.filter))){_currentInstance.setDragFilter(elInfo.el,p.filter);}var dropOptions=root.jsPlumb.extend({},p.dropOptions||{});_makeElementDropHandler(elInfo,p,dropOptions,true,p.isTarget===true);}.bind(this);var inputs=el.length&&el.constructor!==String?el:[el];for(var i=0,ii=inputs.length;i<ii;i++){_doOne(_info(inputs[i]));}return this;};// see api docs\nthis.unmakeSource=function(el,connectionType,doNotClearArrays){var info=_info(el);_currentInstance.destroyDroppable(info.el,"internal");var eldefs=this.sourceEndpointDefinitions[info.id];if(eldefs){for(var def in eldefs){if(connectionType==null||connectionType===def){var mouseDownListener=eldefs[def].trigger;if(mouseDownListener){_currentInstance.off(info.el,"mousedown",mouseDownListener);}if(!doNotClearArrays){delete this.sourceEndpointDefinitions[info.id][def];}}}}return this;};// see api docs\nthis.unmakeEverySource=function(){for(var i in this.sourceEndpointDefinitions){_currentInstance.unmakeSource(i,null,true);}this.sourceEndpointDefinitions={};return this;};var _getScope=function(el,types,connectionType){types=_ju.isArray(types)?types:[types];var id=_getId(el);connectionType=connectionType||"default";for(var i=0;i<types.length;i++){var eldefs=this[types[i]][id];if(eldefs&&eldefs[connectionType]){return eldefs[connectionType].def.scope||this.Defaults.Scope;}}}.bind(this);var _setScope=function(el,scope,types,connectionType){types=_ju.isArray(types)?types:[types];var id=_getId(el);connectionType=connectionType||"default";for(var i=0;i<types.length;i++){var eldefs=this[types[i]][id];if(eldefs&&eldefs[connectionType]){eldefs[connectionType].def.scope=scope;}}}.bind(this);this.getScope=function(el,scope){return _getScope(el,["sourceEndpointDefinitions","targetEndpointDefinitions"]);};this.getSourceScope=function(el){return _getScope(el,"sourceEndpointDefinitions");};this.getTargetScope=function(el){return _getScope(el,"targetEndpointDefinitions");};this.setScope=function(el,scope,connectionType){this.setSourceScope(el,scope,connectionType);this.setTargetScope(el,scope,connectionType);};this.setSourceScope=function(el,scope,connectionType){_setScope(el,scope,"sourceEndpointDefinitions",connectionType);// we get the source scope during the mousedown event, but we also want to set this.\nthis.setDragScope(el,scope);};this.setTargetScope=function(el,scope,connectionType){_setScope(el,scope,"targetEndpointDefinitions",connectionType);this.setDropScope(el,scope);};// see api docs\nthis.unmakeEveryTarget=function(){for(var i in this.targetEndpointDefinitions){_currentInstance.unmakeTarget(i,true);}this.targetEndpointDefinitions={};return this;};// does the work of setting a source enabled or disabled.\nvar _setEnabled=function(type,el,state,toggle,connectionType){var a=type==="source"?this.sourceEndpointDefinitions:this.targetEndpointDefinitions,originalState,info,newState;connectionType=connectionType||"default";// a selector or an array\nif(el.length&&!_ju.isString(el)){originalState=[];for(var i=0,ii=el.length;i<ii;i++){info=_info(el[i]);if(a[info.id]&&a[info.id][connectionType]){originalState[i]=a[info.id][connectionType].enabled;newState=toggle?!originalState[i]:state;a[info.id][connectionType].enabled=newState;_currentInstance[newState?"removeClass":"addClass"](info.el,"jtk-"+type+"-disabled");}}}// otherwise a DOM element or a String ID.\nelse{info=_info(el);var id=info.id;if(a[id]&&a[id][connectionType]){originalState=a[id][connectionType].enabled;newState=toggle?!originalState:state;a[id][connectionType].enabled=newState;_currentInstance[newState?"removeClass":"addClass"](info.el,"jtk-"+type+"-disabled");}}return originalState;}.bind(this);var _first=function(el,fn){if(_ju.isString(el)||!el.length){return fn.apply(this,[el]);}else if(el.length){return fn.apply(this,[el[0]]);}}.bind(this);this.toggleSourceEnabled=function(el,connectionType){_setEnabled("source",el,null,true,connectionType);return this.isSourceEnabled(el,connectionType);};this.setSourceEnabled=function(el,state,connectionType){return _setEnabled("source",el,state,null,connectionType);};this.isSource=function(el,connectionType){connectionType=connectionType||"default";return _first(el,function(_el){var eldefs=this.sourceEndpointDefinitions[_info(_el).id];return eldefs!=null&&eldefs[connectionType]!=null;}.bind(this));};this.isSourceEnabled=function(el,connectionType){connectionType=connectionType||"default";return _first(el,function(_el){var sep=this.sourceEndpointDefinitions[_info(_el).id];return sep&&sep[connectionType]&&sep[connectionType].enabled===true;}.bind(this));};this.toggleTargetEnabled=function(el,connectionType){_setEnabled("target",el,null,true,connectionType);return this.isTargetEnabled(el,connectionType);};this.isTarget=function(el,connectionType){connectionType=connectionType||"default";return _first(el,function(_el){var eldefs=this.targetEndpointDefinitions[_info(_el).id];return eldefs!=null&&eldefs[connectionType]!=null;}.bind(this));};this.isTargetEnabled=function(el,connectionType){connectionType=connectionType||"default";return _first(el,function(_el){var tep=this.targetEndpointDefinitions[_info(_el).id];return tep&&tep[connectionType]&&tep[connectionType].enabled===true;}.bind(this));};this.setTargetEnabled=function(el,state,connectionType){return _setEnabled("target",el,state,null,connectionType);};// --------------------- end makeSource/makeTarget ----------------------------------------------\nthis.ready=function(fn){_currentInstance.bind("ready",fn);};var _elEach=function _elEach(el,fn){// support both lists...\nif((typeof el==="undefined"?"undefined":_typeof(el))===\'object\'&&el.length){for(var i=0,ii=el.length;i<ii;i++){fn(el[i]);}}else{// ...and single strings or elements.\nfn(el);}return _currentInstance;};// repaint some element\'s endpoints and connections\nthis.repaint=function(el,ui,timestamp){return _elEach(el,function(_el){_draw(_el,ui,timestamp);});};this.revalidate=function(el,timestamp,isIdAlready){return _elEach(el,function(_el){var elId=isIdAlready?_el:_currentInstance.getId(_el);_currentInstance.updateOffset({elId:elId,recalc:true,timestamp:timestamp});var dm=_currentInstance.getDragManager();if(dm){dm.updateOffsets(elId);}_currentInstance.repaint(_el);});};// repaint every endpoint and connection.\nthis.repaintEverything=function(){// TODO this timestamp causes continuous anchors to not repaint properly.\n// fix this. do not just take out the timestamp. it runs a lot faster with\n// the timestamp included.\nvar timestamp=_timestamp(),elId;for(elId in endpointsByElement){_currentInstance.updateOffset({elId:elId,recalc:true,timestamp:timestamp});}for(elId in endpointsByElement){_draw(elId,null,timestamp);}return this;};this.removeAllEndpoints=function(el,recurse,affectedElements){affectedElements=affectedElements||[];var _one=function _one(_el){var info=_info(_el),ebe=endpointsByElement[info.id],i,ii;if(ebe){affectedElements.push(info);for(i=0,ii=ebe.length;i<ii;i++){_currentInstance.deleteEndpoint(ebe[i],false);}}delete endpointsByElement[info.id];if(recurse){if(info.el&&info.el.nodeType!==3&&info.el.nodeType!==8){for(i=0,ii=info.el.childNodes.length;i<ii;i++){_one(info.el.childNodes[i]);}}}};_one(el);return this;};var _doRemove=function _doRemove(info,affectedElements){_currentInstance.removeAllEndpoints(info.id,true,affectedElements);var dm=_currentInstance.getDragManager();var _one=function _one(_info){if(dm){dm.elementRemoved(_info.id);}_currentInstance.anchorManager.clearFor(_info.id);_currentInstance.anchorManager.removeFloatingConnection(_info.id);if(_currentInstance.isSource(_info.el)){_currentInstance.unmakeSource(_info.el);}if(_currentInstance.isTarget(_info.el)){_currentInstance.unmakeTarget(_info.el);}_currentInstance.destroyDraggable(_info.el);_currentInstance.destroyDroppable(_info.el);delete _currentInstance.floatingConnections[_info.id];delete managedElements[_info.id];delete offsets[_info.id];if(_info.el){_currentInstance.removeElement(_info.el);_info.el._jsPlumb=null;}};// remove all affected child elements\nfor(var ae=1;ae<affectedElements.length;ae++){_one(affectedElements[ae]);}// and always remove the requested one from the dom.\n_one(info);};/**\r\n         * Remove the given element, including cleaning up all endpoints registered for it.\r\n         * This is exposed in the public API but also used internally by jsPlumb when removing the\r\n         * element associated with a connection drag.\r\n         */this.remove=function(el,doNotRepaint){var info=_info(el),affectedElements=[];if(info.text){info.el.parentNode.removeChild(info.el);}else if(info.id){_currentInstance.batch(function(){_doRemove(info,affectedElements);},doNotRepaint===false);}return _currentInstance;};this.empty=function(el,doNotRepaint){var affectedElements=[];var _one=function _one(el,dontRemoveFocus){var info=_info(el);if(info.text){info.el.parentNode.removeChild(info.el);}else if(info.el){while(info.el.childNodes.length>0){_one(info.el.childNodes[0]);}if(!dontRemoveFocus){_doRemove(info,affectedElements);}}};_currentInstance.batch(function(){_one(el,true);},doNotRepaint===false);return _currentInstance;};this.reset=function(doNotUnbindInstanceEventListeners){_currentInstance.silently(function(){_hoverSuspended=false;_currentInstance.removeAllGroups();_currentInstance.removeGroupManager();_currentInstance.deleteEveryEndpoint();if(!doNotUnbindInstanceEventListeners){_currentInstance.unbind();}this.targetEndpointDefinitions={};this.sourceEndpointDefinitions={};connections.length=0;if(this.doReset){this.doReset();}}.bind(this));};var _clearObject=function _clearObject(obj){if(obj.canvas&&obj.canvas.parentNode){obj.canvas.parentNode.removeChild(obj.canvas);}obj.cleanup();obj.destroy();};this.clear=function(){_currentInstance.select().each(_clearObject);_currentInstance.selectEndpoints().each(_clearObject);endpointsByElement={};endpointsByUUID={};};this.setDefaultScope=function(scope){DEFAULT_SCOPE=scope;return _currentInstance;};// sets whether or not some element should be currently draggable.\nthis.setDraggable=_setDraggable;this.deriveEndpointAndAnchorSpec=function(type,dontPrependDefault){var bits=((dontPrependDefault?"":"default ")+type).split(/[\\s]/),eps=null,ep=null,a=null,as=null;for(var i=0;i<bits.length;i++){var _t=_currentInstance.getType(bits[i],"connection");if(_t){if(_t.endpoints){eps=_t.endpoints;}if(_t.endpoint){ep=_t.endpoint;}if(_t.anchors){as=_t.anchors;}if(_t.anchor){a=_t.anchor;}}}return{endpoints:eps?eps:[ep,ep],anchors:as?as:[a,a]};};// sets the id of some element, changing whatever we need to to keep track.\nthis.setId=function(el,newId,doNotSetAttribute){//\nvar id;if(_ju.isString(el)){id=el;}else{el=this.getElement(el);id=this.getId(el);}var sConns=this.getConnections({source:id,scope:\'*\'},true),tConns=this.getConnections({target:id,scope:\'*\'},true);newId=""+newId;if(!doNotSetAttribute){el=this.getElement(id);this.setAttribute(el,"id",newId);}else{el=this.getElement(newId);}endpointsByElement[newId]=endpointsByElement[id]||[];for(var i=0,ii=endpointsByElement[newId].length;i<ii;i++){endpointsByElement[newId][i].setElementId(newId);endpointsByElement[newId][i].setReferenceElement(el);}delete endpointsByElement[id];this.sourceEndpointDefinitions[newId]=this.sourceEndpointDefinitions[id];delete this.sourceEndpointDefinitions[id];this.targetEndpointDefinitions[newId]=this.targetEndpointDefinitions[id];delete this.targetEndpointDefinitions[id];this.anchorManager.changeId(id,newId);var dm=this.getDragManager();if(dm){dm.changeId(id,newId);}managedElements[newId]=managedElements[id];delete managedElements[id];var _conns=function _conns(list,epIdx,type){for(var i=0,ii=list.length;i<ii;i++){list[i].endpoints[epIdx].setElementId(newId);list[i].endpoints[epIdx].setReferenceElement(el);list[i][type+"Id"]=newId;list[i][type]=el;}};_conns(sConns,0,"source");_conns(tConns,1,"target");this.repaint(newId);};this.setDebugLog=function(debugLog){log=debugLog;};this.setSuspendDrawing=function(val,repaintAfterwards){var curVal=_suspendDrawing;_suspendDrawing=val;if(val){_suspendedAt=new Date().getTime();}else{_suspendedAt=null;}if(repaintAfterwards){this.repaintEverything();}return curVal;};// returns whether or not drawing is currently suspended.\nthis.isSuspendDrawing=function(){return _suspendDrawing;};// return timestamp for when drawing was suspended.\nthis.getSuspendedAt=function(){return _suspendedAt;};this.batch=function(fn,doNotRepaintAfterwards){var _wasSuspended=this.isSuspendDrawing();if(!_wasSuspended){this.setSuspendDrawing(true);}try{fn();}catch(e){_ju.log("Function run while suspended failed",e);}if(!_wasSuspended){this.setSuspendDrawing(false,!doNotRepaintAfterwards);}};this.doWhileSuspended=this.batch;this.getCachedData=_getCachedData;this.timestamp=_timestamp;this.show=function(el,changeEndpoints){_setVisible(el,"block",changeEndpoints);return _currentInstance;};// TODO: update this method to return the current state.\nthis.toggleVisible=_toggleVisible;this.toggleDraggable=_toggleDraggable;this.addListener=this.bind;var floatingConnections=[];this.registerFloatingConnection=function(info,conn,ep){floatingConnections[info.id]=conn;// only register for the target endpoint; we will not be dragging the source at any time\n// before this connection is either discarded or made into a permanent connection.\n_ju.addToList(endpointsByElement,info.id,ep);};this.getFloatingConnectionFor=function(id){return floatingConnections[id];};};_ju.extend(root.jsPlumbInstance,_ju.EventGenerator,{setAttribute:function setAttribute(el,a,v){this.setAttribute(el,a,v);},getAttribute:function getAttribute(el,a){return this.getAttribute(root.jsPlumb.getElement(el),a);},convertToFullOverlaySpec:function convertToFullOverlaySpec(spec){if(_ju.isString(spec)){spec=[spec,{}];}spec[1].id=spec[1].id||_ju.uuid();return spec;},registerConnectionType:function registerConnectionType(id,type){this._connectionTypes[id]=root.jsPlumb.extend({},type);if(type.overlays){var to={};for(var i=0;i<type.overlays.length;i++){// if a string, convert to object representation so that we can store the typeid on it.\n// also assign an id.\nvar fo=this.convertToFullOverlaySpec(type.overlays[i]);to[fo[1].id]=fo;}this._connectionTypes[id].overlays=to;}},registerConnectionTypes:function registerConnectionTypes(types){for(var i in types){this.registerConnectionType(i,types[i]);}},registerEndpointType:function registerEndpointType(id,type){this._endpointTypes[id]=root.jsPlumb.extend({},type);if(type.overlays){var to={};for(var i=0;i<type.overlays.length;i++){// if a string, convert to object representation so that we can store the typeid on it.\n// also assign an id.\nvar fo=this.convertToFullOverlaySpec(type.overlays[i]);to[fo[1].id]=fo;}this._endpointTypes[id].overlays=to;}},registerEndpointTypes:function registerEndpointTypes(types){for(var i in types){this.registerEndpointType(i,types[i]);}},getType:function getType(id,typeDescriptor){return typeDescriptor==="connection"?this._connectionTypes[id]:this._endpointTypes[id];},setIdChanged:function setIdChanged(oldId,newId){this.setId(oldId,newId,true);},// set parent: change the parent for some node and update all the registrations we need to.\nsetParent:function setParent(el,newParent){var _dom=this.getElement(el),_id=this.getId(_dom),_pdom=this.getElement(newParent),_pid=this.getId(_pdom),dm=this.getDragManager();_dom.parentNode.removeChild(_dom);_pdom.appendChild(_dom);if(dm){dm.setParent(_dom,_id,_pdom,_pid);}},extend:function extend(o1,o2,names){var i;if(names){for(i=0;i<names.length;i++){o1[names[i]]=o2[names[i]];}}else{for(i in o2){o1[i]=o2[i];}}return o1;},floatingConnections:{},getFloatingAnchorIndex:function getFloatingAnchorIndex(jpc){return jpc.endpoints[0].isFloating()?0:jpc.endpoints[1].isFloating()?1:-1;}});jsPlumbInstance.prototype.Defaults={Anchor:"Bottom",Anchors:[null,null],ConnectionsDetachable:true,ConnectionOverlays:[],Connector:"Bezier",Container:null,DoNotThrowErrors:false,DragOptions:{},DropOptions:{},Endpoint:"Dot",EndpointOverlays:[],Endpoints:[null,null],EndpointStyle:{fill:"#456"},EndpointStyles:[null,null],EndpointHoverStyle:null,EndpointHoverStyles:[null,null],HoverPaintStyle:null,LabelStyle:{color:"black"},LogEnabled:false,Overlays:[],MaxConnections:1,PaintStyle:{"stroke-width":4,stroke:"#456"},ReattachConnections:false,RenderMode:"svg",Scope:"jsPlumb_DefaultScope"};// --------------------- static instance + module registration -------------------------------------------\n// create static instance and assign to window if window exists.\t\nvar jsPlumb=new jsPlumbInstance();// register on \'root\' (lets us run on server or browser)\nroot.jsPlumb=jsPlumb;// add \'getInstance\' method to static instance\njsPlumb.getInstance=function(_defaults,overrideFns){var j=new jsPlumbInstance(_defaults);if(overrideFns){for(var ovf in overrideFns){j[ovf]=overrideFns[ovf];}}j.init();return j;};jsPlumb.each=function(spec,fn){if(spec==null){return;}if(typeof spec==="string"){fn(jsPlumb.getElement(spec));}else if(spec.length!=null){for(var i=0;i<spec.length;i++){fn(jsPlumb.getElement(spec[i]));}}else{fn(spec);}// assume it\'s an element.\n};// CommonJS\nif(true){exports.jsPlumb=jsPlumb;}// --------------------- end static instance + AMD registration -------------------------------------------\t\t\n}).call(typeof window!==\'undefined\'?window:this);/*\r\n * This file contains the base functionality for DOM type adapters.\r\n *\r\n * Copyright (c) 2010 - 2018 jsPlumb (hello@jsplumbtoolkit.com)\r\n *\r\n * https://jsplumbtoolkit.com\r\n * https://github.com/jsplumb/jsplumb\r\n *\r\n * Dual licensed under the MIT and GPL2 licenses.\r\n */;(function(){var root=this,_ju=root.jsPlumbUtil;var _genLoc=function _genLoc(prefix,e){if(e==null){return[0,0];}var ts=_touches(e),t=_getTouch(ts,0);return[t[prefix+"X"],t[prefix+"Y"]];},_pageLocation=_genLoc.bind(this,"page"),_screenLocation=_genLoc.bind(this,"screen"),_clientLocation=_genLoc.bind(this,"client"),_getTouch=function _getTouch(touches,idx){return touches.item?touches.item(idx):touches[idx];},_touches=function _touches(e){return e.touches&&e.touches.length>0?e.touches:e.changedTouches&&e.changedTouches.length>0?e.changedTouches:e.targetTouches&&e.targetTouches.length>0?e.targetTouches:[e];};/**\r\n     Manages dragging for some instance of jsPlumb.\r\n\r\n     TODO instead of this being accessed directly, it should subscribe to events on the jsPlumb instance: every method\r\n     in here is called directly by jsPlumb. But what should happen is that we have unpublished events that this listens\r\n     to.  The only trick is getting one of these instantiated with every jsPlumb instance: it needs to have a hook somehow.\r\n     Basically the general idea is to pull ALL the drag code out (prototype method registrations plus this) into a\r\n     dedicated drag script), that does not necessarily need to be included.\r\n\r\n\r\n     */var DragManager=function DragManager(_currentInstance){var _draggables={},_dlist=[],_delements={},_elementsWithEndpoints={},// elementids mapped to the draggable to which they belong.\n_draggablesForElements={};/**\r\n         register some element as draggable.  right now the drag init stuff is done elsewhere, and it is\r\n         possible that will continue to be the case.\r\n         */this.register=function(el){var id=_currentInstance.getId(el),parentOffset=_currentInstance.getOffset(el);if(!_draggables[id]){_draggables[id]=el;_dlist.push(el);_delements[id]={};}// look for child elements that have endpoints and register them against this draggable.\nvar _oneLevel=function _oneLevel(p){if(p){for(var i=0;i<p.childNodes.length;i++){if(p.childNodes[i].nodeType!==3&&p.childNodes[i].nodeType!==8){var cEl=jsPlumb.getElement(p.childNodes[i]),cid=_currentInstance.getId(p.childNodes[i],null,true);if(cid&&_elementsWithEndpoints[cid]&&_elementsWithEndpoints[cid]>0){var cOff=_currentInstance.getOffset(cEl);_delements[id][cid]={id:cid,offset:{left:cOff.left-parentOffset.left,top:cOff.top-parentOffset.top}};_draggablesForElements[cid]=id;}_oneLevel(p.childNodes[i]);}}}};_oneLevel(el);};// refresh the offsets for child elements of this element.\nthis.updateOffsets=function(elId,childOffsetOverrides){if(elId!=null){childOffsetOverrides=childOffsetOverrides||{};var domEl=jsPlumb.getElement(elId),id=_currentInstance.getId(domEl),children=_delements[id],parentOffset=_currentInstance.getOffset(domEl);if(children){for(var i in children){if(children.hasOwnProperty(i)){var cel=jsPlumb.getElement(i),cOff=childOffsetOverrides[i]||_currentInstance.getOffset(cel);// do not update if we have a value already and we\'d just be writing 0,0\nif(cel.offsetParent==null&&_delements[id][i]!=null){continue;}_delements[id][i]={id:i,offset:{left:cOff.left-parentOffset.left,top:cOff.top-parentOffset.top}};_draggablesForElements[i]=id;}}}}};/**\r\n         notification that an endpoint was added to the given el.  we go up from that el\'s parent\r\n         node, looking for a parent that has been registered as a draggable. if we find one, we add this\r\n         el to that parent\'s list of elements to update on drag (if it is not there already)\r\n         */this.endpointAdded=function(el,id){id=id||_currentInstance.getId(el);var b=document.body,p=el.parentNode;_elementsWithEndpoints[id]=_elementsWithEndpoints[id]?_elementsWithEndpoints[id]+1:1;while(p!=null&&p!==b){var pid=_currentInstance.getId(p,null,true);if(pid&&_draggables[pid]){var pLoc=_currentInstance.getOffset(p);if(_delements[pid][id]==null){var cLoc=_currentInstance.getOffset(el);_delements[pid][id]={id:id,offset:{left:cLoc.left-pLoc.left,top:cLoc.top-pLoc.top}};_draggablesForElements[id]=pid;}break;}p=p.parentNode;}};this.endpointDeleted=function(endpoint){if(_elementsWithEndpoints[endpoint.elementId]){_elementsWithEndpoints[endpoint.elementId]--;if(_elementsWithEndpoints[endpoint.elementId]<=0){for(var i in _delements){if(_delements.hasOwnProperty(i)&&_delements[i]){delete _delements[i][endpoint.elementId];delete _draggablesForElements[endpoint.elementId];}}}}};this.changeId=function(oldId,newId){_delements[newId]=_delements[oldId];_delements[oldId]={};_draggablesForElements[newId]=_draggablesForElements[oldId];_draggablesForElements[oldId]=null;};this.getElementsForDraggable=function(id){return _delements[id];};this.elementRemoved=function(elementId){var elId=_draggablesForElements[elementId];if(elId){delete _delements[elId][elementId];delete _draggablesForElements[elementId];}};this.reset=function(){_draggables={};_dlist=[];_delements={};_elementsWithEndpoints={};};//\n// notification drag ended. We check automatically if need to update some\n// ancestor\'s offsets.\n//\nthis.dragEnded=function(el){if(el.offsetParent!=null){var id=_currentInstance.getId(el),ancestor=_draggablesForElements[id];if(ancestor){this.updateOffsets(ancestor);}}};this.setParent=function(el,elId,p,pId,currentChildLocation){var current=_draggablesForElements[elId];if(!_delements[pId]){_delements[pId]={};}var pLoc=_currentInstance.getOffset(p),cLoc=currentChildLocation||_currentInstance.getOffset(el);if(current&&_delements[current]){delete _delements[current][elId];}_delements[pId][elId]={id:elId,offset:{left:cLoc.left-pLoc.left,top:cLoc.top-pLoc.top}};_draggablesForElements[elId]=pId;};this.clearParent=function(el,elId){var current=_draggablesForElements[elId];if(current){delete _delements[current][elId];delete _draggablesForElements[elId];}};this.revalidateParent=function(el,elId,childOffset){var current=_draggablesForElements[elId];if(current){var co={};co[elId]=childOffset;this.updateOffsets(current,co);_currentInstance.revalidate(current);}};this.getDragAncestor=function(el){var de=jsPlumb.getElement(el),id=_currentInstance.getId(de),aid=_draggablesForElements[id];if(aid){return jsPlumb.getElement(aid);}else{return null;}};};var trim=function trim(str){return str==null?null:str.replace(/^\\s\\s*/,\'\').replace(/\\s\\s*$/,\'\');},_setClassName=function _setClassName(el,cn,classList){cn=trim(cn);if(typeof el.className.baseVal!=="undefined"){el.className.baseVal=cn;}else{el.className=cn;}// recent (i currently have  61.0.3163.100) version of chrome do not update classList when you set the base val\n// of an svg element\'s className. in the long run we\'d like to move to just using classList anyway\ntry{var cl=el.classList;while(cl.length>0){cl.remove(cl.item(0));}for(var i=0;i<classList.length;i++){if(classList[i]){cl.add(classList[i]);}}}catch(e){// not fatal\nconsole.log("JSPLUMB: cannot set class list",e);}},_getClassName=function _getClassName(el){return typeof el.className.baseVal==="undefined"?el.className:el.className.baseVal;},_classManip=function _classManip(el,classesToAdd,classesToRemove){classesToAdd=classesToAdd==null?[]:_ju.isArray(classesToAdd)?classesToAdd:classesToAdd.split(/\\s+/);classesToRemove=classesToRemove==null?[]:_ju.isArray(classesToRemove)?classesToRemove:classesToRemove.split(/\\s+/);var className=_getClassName(el),curClasses=className.split(/\\s+/);var _oneSet=function _oneSet(add,classes){for(var i=0;i<classes.length;i++){if(add){if(curClasses.indexOf(classes[i])===-1){curClasses.push(classes[i]);}}else{var idx=curClasses.indexOf(classes[i]);if(idx!==-1){curClasses.splice(idx,1);}}}};_oneSet(true,classesToAdd);_oneSet(false,classesToRemove);_setClassName(el,curClasses.join(" "),curClasses);};root.jsPlumb.extend(root.jsPlumbInstance.prototype,{headless:false,pageLocation:_pageLocation,screenLocation:_screenLocation,clientLocation:_clientLocation,getDragManager:function getDragManager(){if(this.dragManager==null){this.dragManager=new DragManager(this);}return this.dragManager;},// NEVER CALLED IN THE CURRENT JS\nrecalculateOffsets:function recalculateOffsets(elId){this.getDragManager().updateOffsets(elId);},// CONVERTED\ncreateElement:function createElement(tag,style,clazz,atts){return this.createElementNS(null,tag,style,clazz,atts);},// CONVERTED\ncreateElementNS:function createElementNS(ns,tag,style,clazz,atts){var e=ns==null?document.createElement(tag):document.createElementNS(ns,tag);var i;style=style||{};for(i in style){e.style[i]=style[i];}if(clazz){e.className=clazz;}atts=atts||{};for(i in atts){e.setAttribute(i,""+atts[i]);}return e;},// CONVERTED\ngetAttribute:function getAttribute(el,attName){return el.getAttribute!=null?el.getAttribute(attName):null;},// CONVERTED\nsetAttribute:function setAttribute(el,a,v){if(el.setAttribute!=null){el.setAttribute(a,v);}},// CONVERTED\nsetAttributes:function setAttributes(el,atts){for(var i in atts){if(atts.hasOwnProperty(i)){el.setAttribute(i,atts[i]);}}},appendToRoot:function appendToRoot(node){document.body.appendChild(node);},// NOT CONVERTING\ngetRenderModes:function getRenderModes(){return["svg"];},// CONVERTED\ngetClass:_getClassName,// CONVERTED\naddClass:function addClass(el,clazz){jsPlumb.each(el,function(e){_classManip(e,clazz);});},// CONVERTED\nhasClass:function hasClass(el,clazz){el=jsPlumb.getElement(el);if(el.classList){return el.classList.contains(clazz);}else{return _getClassName(el).indexOf(clazz)!==-1;}},// CONVERTED\nremoveClass:function removeClass(el,clazz){jsPlumb.each(el,function(e){_classManip(e,null,clazz);});},// CONVERTED\nupdateClasses:function updateClasses(el,toAdd,toRemove){jsPlumb.each(el,function(e){_classManip(e,toAdd,toRemove);});},// CONVERTED\nsetClass:function setClass(el,clazz){if(clazz!=null){jsPlumb.each(el,function(e){_setClassName(e,clazz,clazz.split(/\\s+/));});}},// CONVERTED\nsetPosition:function setPosition(el,p){el.style.left=p.left+"px";el.style.top=p.top+"px";},// CONVERTED\ngetPosition:function getPosition(el){var _one=function _one(prop){var v=el.style[prop];return v?v.substring(0,v.length-2):0;};return{left:_one("left"),top:_one("top")};},// CONVERTED\ngetStyle:function getStyle(el,prop){if(typeof window.getComputedStyle!==\'undefined\'){return getComputedStyle(el,null).getPropertyValue(prop);}else{return el.currentStyle[prop];}},// CONVERTED\ngetSelector:function getSelector(ctx,spec){var sel=null;if(arguments.length===1){sel=ctx.nodeType!=null?ctx:document.querySelectorAll(ctx);}else{sel=ctx.querySelectorAll(spec);}return sel;},// CONVERTED\ngetOffset:function getOffset(el,relativeToRoot,container){el=jsPlumb.getElement(el);container=container||this.getContainer();var out={left:el.offsetLeft,top:el.offsetTop},op=relativeToRoot||container!=null&&el!==container&&el.offsetParent!==container?el.offsetParent:null,_maybeAdjustScroll=function(offsetParent){if(offsetParent!=null&&offsetParent!==document.body&&(offsetParent.scrollTop>0||offsetParent.scrollLeft>0)){out.left-=offsetParent.scrollLeft;out.top-=offsetParent.scrollTop;}}.bind(this);while(op!=null){out.left+=op.offsetLeft;out.top+=op.offsetTop;_maybeAdjustScroll(op);op=relativeToRoot?op.offsetParent:op.offsetParent===container?null:op.offsetParent;}// if container is scrolled and the element (or its offset parent) is not absolute or fixed, adjust accordingly.\nif(container!=null&&!relativeToRoot&&(container.scrollTop>0||container.scrollLeft>0)){var pp=el.offsetParent!=null?this.getStyle(el.offsetParent,"position"):"static",p=this.getStyle(el,"position");if(p!=="absolute"&&p!=="fixed"&&pp!=="absolute"&&pp!=="fixed"){out.left-=container.scrollLeft;out.top-=container.scrollTop;}}return out;},//\n// return x+y proportion of the given element\'s size corresponding to the location of the given event.\n//\ngetPositionOnElement:function getPositionOnElement(evt,el,zoom){var box=typeof el.getBoundingClientRect!=="undefined"?el.getBoundingClientRect():{left:0,top:0,width:0,height:0},body=document.body,docElem=document.documentElement,scrollTop=window.pageYOffset||docElem.scrollTop||body.scrollTop,scrollLeft=window.pageXOffset||docElem.scrollLeft||body.scrollLeft,clientTop=docElem.clientTop||body.clientTop||0,clientLeft=docElem.clientLeft||body.clientLeft||0,pst=0,psl=0,top=box.top+scrollTop-clientTop+pst*zoom,left=box.left+scrollLeft-clientLeft+psl*zoom,cl=jsPlumb.pageLocation(evt),w=box.width||el.offsetWidth*zoom,h=box.height||el.offsetHeight*zoom,x=(cl[0]-left)/w,y=(cl[1]-top)/h;return[x,y];},/**\r\n         * Gets the absolute position of some element as read from the left/top properties in its style.\r\n         * @method getAbsolutePosition\r\n         * @param {Element} el The element to retrieve the absolute coordinates from. **Note** this is a DOM element, not a selector from the underlying library.\r\n         * @return {Number[]} [left, top] pixel values.\r\n         */getAbsolutePosition:function getAbsolutePosition(el){var _one=function _one(s){var ss=el.style[s];if(ss){return parseFloat(ss.substring(0,ss.length-2));}};return[_one("left"),_one("top")];},/**\r\n         * Sets the absolute position of some element by setting the left/top properties in its style.\r\n         * @method setAbsolutePosition\r\n         * @param {Element} el The element to set the absolute coordinates on. **Note** this is a DOM element, not a selector from the underlying library.\r\n         * @param {Number[]} xy x and y coordinates\r\n         * @param {Number[]} [animateFrom] Optional previous xy to animate from.\r\n         * @param {Object} [animateOptions] Options for the animation.\r\n         */setAbsolutePosition:function setAbsolutePosition(el,xy,animateFrom,animateOptions){if(animateFrom){this.animate(el,{left:"+="+(xy[0]-animateFrom[0]),top:"+="+(xy[1]-animateFrom[1])},animateOptions);}else{el.style.left=xy[0]+"px";el.style.top=xy[1]+"px";}},/**\r\n         * gets the size for the element, in an array : [ width, height ].\r\n         */// CONVERTED\ngetSize:function getSize(el){return[el.offsetWidth,el.offsetHeight];},// CONVERTED\ngetWidth:function getWidth(el){return el.offsetWidth;},// CONVERTED\ngetHeight:function getHeight(el){return el.offsetHeight;},getRenderMode:function getRenderMode(){return"svg";}});}).call(typeof window!==\'undefined\'?window:this);/*\r\n * 2010 - 2018 jsPlumb (hello@jsplumbtoolkit.com)\r\n *\r\n * https://jsplumbtoolkit.com\r\n * https://github.com/jsplumb/jsplumb\r\n *\r\n * Dual licensed under the MIT and GPL2 licenses.\r\n */;(function(){"use strict";var root=this,_jp=root.jsPlumb,_ju=root.jsPlumbUtil;// ------------------------------ BEGIN OverlayCapablejsPlumbUIComponent --------------------------------------------\nvar _internalLabelOverlayId="__label",// this is a shortcut helper method to let people add a label as\n// overlay.\n_makeLabelOverlay=function _makeLabelOverlay(component,params){var _params={cssClass:params.cssClass,labelStyle:component.labelStyle,id:_internalLabelOverlayId,component:component,_jsPlumb:component._jsPlumb.instance// TODO not necessary, since the instance can be accessed through the component.\n},mergedParams=_jp.extend(_params,params);return new _jp.Overlays[component._jsPlumb.instance.getRenderMode()].Label(mergedParams);},_processOverlay=function _processOverlay(component,o){var _newOverlay=null;if(_ju.isArray(o)){// this is for the shorthand ["Arrow", { width:50 }] syntax\n// there\'s also a three arg version:\n// ["Arrow", { width:50 }, {location:0.7}]\n// which merges the 3rd arg into the 2nd.\nvar type=o[0],// make a copy of the object so as not to mess up anyone else\'s reference...\np=_jp.extend({component:component,_jsPlumb:component._jsPlumb.instance},o[1]);if(o.length===3){_jp.extend(p,o[2]);}_newOverlay=new _jp.Overlays[component._jsPlumb.instance.getRenderMode()][type](p);}else if(o.constructor===String){_newOverlay=new _jp.Overlays[component._jsPlumb.instance.getRenderMode()][o]({component:component,_jsPlumb:component._jsPlumb.instance});}else{_newOverlay=o;}_newOverlay.id=_newOverlay.id||_ju.uuid();component.cacheTypeItem("overlay",_newOverlay,_newOverlay.id);component._jsPlumb.overlays[_newOverlay.id]=_newOverlay;return _newOverlay;};_jp.OverlayCapableJsPlumbUIComponent=function(params){root.jsPlumbUIComponent.apply(this,arguments);this._jsPlumb.overlays={};this._jsPlumb.overlayPositions={};if(params.label){this.getDefaultType().overlays[_internalLabelOverlayId]=["Label",{label:params.label,location:params.labelLocation||this.defaultLabelLocation||0.5,labelStyle:params.labelStyle||this._jsPlumb.instance.Defaults.LabelStyle,id:_internalLabelOverlayId}];}this.setListenerComponent=function(c){if(this._jsPlumb){for(var i in this._jsPlumb.overlays){this._jsPlumb.overlays[i].setListenerComponent(c);}}};};_jp.OverlayCapableJsPlumbUIComponent.applyType=function(component,t){if(t.overlays){// loop through the ones in the type. if already present on the component,\n// dont remove or re-add.\nvar keep={},i;for(i in t.overlays){var existing=component._jsPlumb.overlays[t.overlays[i][1].id];if(existing){// maybe update from data, if there were parameterised values for instance.\nexisting.updateFrom(t.overlays[i][1]);keep[t.overlays[i][1].id]=true;}else{var c=component.getCachedTypeItem("overlay",t.overlays[i][1].id);if(c!=null){c.reattach(component._jsPlumb.instance,component);c.setVisible(true);// maybe update from data, if there were parameterised values for instance.\nc.updateFrom(t.overlays[i][1]);component._jsPlumb.overlays[c.id]=c;}else{c=component.addOverlay(t.overlays[i],true);}keep[c.id]=true;}}// now loop through the full overlays and remove those that we dont want to keep\nfor(i in component._jsPlumb.overlays){if(keep[component._jsPlumb.overlays[i].id]==null){component.removeOverlay(component._jsPlumb.overlays[i].id,true);// remove overlay but dont clean it up.\n// that would remove event listeners etc; overlays are never discarded by the types stuff, they are\n// just detached/reattached.\n}}}};_ju.extend(_jp.OverlayCapableJsPlumbUIComponent,root.jsPlumbUIComponent,{setHover:function setHover(hover,ignoreAttachedElements){if(this._jsPlumb&&!this._jsPlumb.instance.isConnectionBeingDragged()){for(var i in this._jsPlumb.overlays){this._jsPlumb.overlays[i][hover?"addClass":"removeClass"](this._jsPlumb.instance.hoverClass);}}},addOverlay:function addOverlay(overlay,doNotRepaint){var o=_processOverlay(this,overlay);if(!doNotRepaint){this.repaint();}return o;},getOverlay:function getOverlay(id){return this._jsPlumb.overlays[id];},getOverlays:function getOverlays(){return this._jsPlumb.overlays;},hideOverlay:function hideOverlay(id){var o=this.getOverlay(id);if(o){o.hide();}},hideOverlays:function hideOverlays(){for(var i in this._jsPlumb.overlays){this._jsPlumb.overlays[i].hide();}},showOverlay:function showOverlay(id){var o=this.getOverlay(id);if(o){o.show();}},showOverlays:function showOverlays(){for(var i in this._jsPlumb.overlays){this._jsPlumb.overlays[i].show();}},removeAllOverlays:function removeAllOverlays(doNotRepaint){for(var i in this._jsPlumb.overlays){if(this._jsPlumb.overlays[i].cleanup){this._jsPlumb.overlays[i].cleanup();}}this._jsPlumb.overlays={};this._jsPlumb.overlayPositions=null;if(!doNotRepaint){this.repaint();}},removeOverlay:function removeOverlay(overlayId,dontCleanup){var o=this._jsPlumb.overlays[overlayId];if(o){o.setVisible(false);if(!dontCleanup&&o.cleanup){o.cleanup();}delete this._jsPlumb.overlays[overlayId];if(this._jsPlumb.overlayPositions){delete this._jsPlumb.overlayPositions[overlayId];}}},removeOverlays:function removeOverlays(){for(var i=0,j=arguments.length;i<j;i++){this.removeOverlay(arguments[i]);}},moveParent:function moveParent(newParent){if(this.bgCanvas){this.bgCanvas.parentNode.removeChild(this.bgCanvas);newParent.appendChild(this.bgCanvas);}if(this.canvas&&this.canvas.parentNode){this.canvas.parentNode.removeChild(this.canvas);newParent.appendChild(this.canvas);for(var i in this._jsPlumb.overlays){if(this._jsPlumb.overlays[i].isAppendedAtTopLevel){var el=this._jsPlumb.overlays[i].getElement();el.parentNode.removeChild(el);newParent.appendChild(el);}}}},getLabel:function getLabel(){var lo=this.getOverlay(_internalLabelOverlayId);return lo!=null?lo.getLabel():null;},getLabelOverlay:function getLabelOverlay(){return this.getOverlay(_internalLabelOverlayId);},setLabel:function setLabel(l){var lo=this.getOverlay(_internalLabelOverlayId);if(!lo){var params=l.constructor===String||l.constructor===Function?{label:l}:l;lo=_makeLabelOverlay(this,params);this._jsPlumb.overlays[_internalLabelOverlayId]=lo;}else{if(l.constructor===String||l.constructor===Function){lo.setLabel(l);}else{if(l.label){lo.setLabel(l.label);}if(l.location){lo.setLocation(l.location);}}}if(!this._jsPlumb.instance.isSuspendDrawing()){this.repaint();}},cleanup:function cleanup(force){for(var i in this._jsPlumb.overlays){this._jsPlumb.overlays[i].cleanup(force);this._jsPlumb.overlays[i].destroy(force);}if(force){this._jsPlumb.overlays={};this._jsPlumb.overlayPositions=null;}},setVisible:function setVisible(v){this[v?"showOverlays":"hideOverlays"]();},setAbsoluteOverlayPosition:function setAbsoluteOverlayPosition(overlay,xy){this._jsPlumb.overlayPositions[overlay.id]=xy;},getAbsoluteOverlayPosition:function getAbsoluteOverlayPosition(overlay){return this._jsPlumb.overlayPositions?this._jsPlumb.overlayPositions[overlay.id]:null;},_clazzManip:function _clazzManip(action,clazz,dontUpdateOverlays){if(!dontUpdateOverlays){for(var i in this._jsPlumb.overlays){this._jsPlumb.overlays[i][action+"Class"](clazz);}}},addClass:function addClass(clazz,dontUpdateOverlays){this._clazzManip("add",clazz,dontUpdateOverlays);},removeClass:function removeClass(clazz,dontUpdateOverlays){this._clazzManip("remove",clazz,dontUpdateOverlays);}});// ------------------------------ END OverlayCapablejsPlumbUIComponent --------------------------------------------\n}).call(typeof window!==\'undefined\'?window:this);/*\r\n * This file contains the code for Endpoints.\r\n *\r\n * Copyright (c) 2010 - 2018 jsPlumb (hello@jsplumbtoolkit.com)\r\n * \r\n * https://jsplumbtoolkit.com\r\n * https://github.com/jsplumb/jsplumb\r\n * \r\n * Dual licensed under the MIT and GPL2 licenses.\r\n */;(function(){"use strict";var root=this,_jp=root.jsPlumb,_ju=root.jsPlumbUtil;// create the drag handler for a connection\nvar _makeConnectionDragHandler=function _makeConnectionDragHandler(endpoint,placeholder,_jsPlumb){var stopped=false;return{drag:function drag(){if(stopped){stopped=false;return true;}if(placeholder.element){var _ui=_jsPlumb.getUIPosition(arguments,_jsPlumb.getZoom());if(_ui!=null){_jsPlumb.setPosition(placeholder.element,_ui);}_jsPlumb.repaint(placeholder.element,_ui);// always repaint the source endpoint, because only continuous/dynamic anchors cause the endpoint\n// to be repainted, so static anchors need to be told (or the endpoint gets dragged around)\nendpoint.paint({anchorPoint:endpoint.anchor.getCurrentLocation({element:endpoint})});}},stopDrag:function stopDrag(){stopped=true;}};};// creates a placeholder div for dragging purposes, adds it, and pre-computes its offset.\nvar _makeDraggablePlaceholder=function _makeDraggablePlaceholder(placeholder,_jsPlumb,ipco,ips){var n=_jsPlumb.createElement("div",{position:"absolute"});_jsPlumb.appendElement(n);var id=_jsPlumb.getId(n);_jsPlumb.setPosition(n,ipco);n.style.width=ips[0]+"px";n.style.height=ips[1]+"px";_jsPlumb.manage(id,n,true);// TRANSIENT MANAGE\n// create and assign an id, and initialize the offset.\nplaceholder.id=id;placeholder.element=n;};// create a floating endpoint (for drag connections)\nvar _makeFloatingEndpoint=function _makeFloatingEndpoint(paintStyle,referenceAnchor,endpoint,referenceCanvas,sourceElement,_jsPlumb,_newEndpoint,scope){var floatingAnchor=new _jp.FloatingAnchor({reference:referenceAnchor,referenceCanvas:referenceCanvas,jsPlumbInstance:_jsPlumb});//setting the scope here should not be the way to fix that mootools issue.  it should be fixed by not\n// adding the floating endpoint as a droppable.  that makes more sense anyway!\n// TRANSIENT MANAGE\nreturn _newEndpoint({paintStyle:paintStyle,endpoint:endpoint,anchor:floatingAnchor,source:sourceElement,scope:scope});};var typeParameters=["connectorStyle","connectorHoverStyle","connectorOverlays","connector","connectionType","connectorClass","connectorHoverClass"];// a helper function that tries to find a connection to the given element, and returns it if so. if elementWithPrecedence is null,\n// or no connection to it is found, we return the first connection in our list.\nvar findConnectionToUseForDynamicAnchor=function findConnectionToUseForDynamicAnchor(ep,elementWithPrecedence){var idx=0;if(elementWithPrecedence!=null){for(var i=0;i<ep.connections.length;i++){if(ep.connections[i].sourceId===elementWithPrecedence||ep.connections[i].targetId===elementWithPrecedence){idx=i;break;}}}return ep.connections[idx];};_jp.Endpoint=function(params){var _jsPlumb=params._jsPlumb,_newConnection=params.newConnection,_newEndpoint=params.newEndpoint;this.idPrefix="_jsplumb_e_";this.defaultLabelLocation=[0.5,0.5];this.defaultOverlayKeys=["Overlays","EndpointOverlays"];_jp.OverlayCapableJsPlumbUIComponent.apply(this,arguments);// TYPE\nthis.appendToDefaultType({connectionType:params.connectionType,maxConnections:params.maxConnections==null?this._jsPlumb.instance.Defaults.MaxConnections:params.maxConnections,// maximum number of connections this endpoint can be the source of.,\npaintStyle:params.endpointStyle||params.paintStyle||params.style||this._jsPlumb.instance.Defaults.EndpointStyle||_jp.Defaults.EndpointStyle,hoverPaintStyle:params.endpointHoverStyle||params.hoverPaintStyle||this._jsPlumb.instance.Defaults.EndpointHoverStyle||_jp.Defaults.EndpointHoverStyle,connectorStyle:params.connectorStyle,connectorHoverStyle:params.connectorHoverStyle,connectorClass:params.connectorClass,connectorHoverClass:params.connectorHoverClass,connectorOverlays:params.connectorOverlays,connector:params.connector,connectorTooltip:params.connectorTooltip});// END TYPE\nthis._jsPlumb.enabled=!(params.enabled===false);this._jsPlumb.visible=true;this.element=_jp.getElement(params.source);this._jsPlumb.uuid=params.uuid;this._jsPlumb.floatingEndpoint=null;var inPlaceCopy=null;if(this._jsPlumb.uuid){params.endpointsByUUID[this._jsPlumb.uuid]=this;}this.elementId=params.elementId;this.dragProxy=params.dragProxy;this._jsPlumb.connectionCost=params.connectionCost;this._jsPlumb.connectionsDirected=params.connectionsDirected;this._jsPlumb.currentAnchorClass="";this._jsPlumb.events={};var deleteOnEmpty=params.deleteOnEmpty===true;this.setDeleteOnEmpty=function(d){deleteOnEmpty=d;};var _updateAnchorClass=function(){// stash old, get new\nvar oldAnchorClass=_jsPlumb.endpointAnchorClassPrefix+"-"+this._jsPlumb.currentAnchorClass;this._jsPlumb.currentAnchorClass=this.anchor.getCssClass();var anchorClass=_jsPlumb.endpointAnchorClassPrefix+(this._jsPlumb.currentAnchorClass?"-"+this._jsPlumb.currentAnchorClass:"");this.removeClass(oldAnchorClass);this.addClass(anchorClass);// add and remove at the same time to reduce the number of reflows.\n_jp.updateClasses(this.element,anchorClass,oldAnchorClass);}.bind(this);this.prepareAnchor=function(anchorParams){var a=this._jsPlumb.instance.makeAnchor(anchorParams,this.elementId,_jsPlumb);a.bind("anchorChanged",function(currentAnchor){this.fire("anchorChanged",{endpoint:this,anchor:currentAnchor});_updateAnchorClass();}.bind(this));return a;};this.setPreparedAnchor=function(anchor,doNotRepaint){this._jsPlumb.instance.continuousAnchorFactory.clear(this.elementId);this.anchor=anchor;_updateAnchorClass();if(!doNotRepaint){this._jsPlumb.instance.repaint(this.elementId);}return this;};this.setAnchor=function(anchorParams,doNotRepaint){var a=this.prepareAnchor(anchorParams);this.setPreparedAnchor(a,doNotRepaint);return this;};var internalHover=function(state){if(this.connections.length>0){for(var i=0;i<this.connections.length;i++){this.connections[i].setHover(state,false);}}else{this.setHover(state);}}.bind(this);this.bind("mouseover",function(){internalHover(true);});this.bind("mouseout",function(){internalHover(false);});// ANCHOR MANAGER\nif(!params._transient){// in place copies, for example, are transient.  they will never need to be retrieved during a paint cycle, because they dont move, and then they are deleted.\nthis._jsPlumb.instance.anchorManager.add(this,this.elementId);}this.prepareEndpoint=function(ep,typeId){var _e=function _e(t,p){var rm=_jsPlumb.getRenderMode();if(_jp.Endpoints[rm][t]){return new _jp.Endpoints[rm][t](p);}if(!_jsPlumb.Defaults.DoNotThrowErrors){throw{msg:"jsPlumb: unknown endpoint type \'"+t+"\'"};}};var endpointArgs={_jsPlumb:this._jsPlumb.instance,cssClass:params.cssClass,container:params.container,tooltip:params.tooltip,connectorTooltip:params.connectorTooltip,endpoint:this};var endpoint;if(_ju.isString(ep)){endpoint=_e(ep,endpointArgs);}else if(_ju.isArray(ep)){endpointArgs=_ju.merge(ep[1],endpointArgs);endpoint=_e(ep[0],endpointArgs);}else{endpoint=ep.clone();}// assign a clone function using a copy of endpointArgs. this is used when a drag starts: the endpoint that was dragged is cloned,\n// and the clone is left in its place while the original one goes off on a magical journey.\n// the copy is to get around a closure problem, in which endpointArgs ends up getting shared by\n// the whole world.\n//var argsForClone = jsPlumb.extend({}, endpointArgs);\nendpoint.clone=function(){// TODO this, and the code above, can be refactored to be more dry.\nif(_ju.isString(ep)){return _e(ep,endpointArgs);}else if(_ju.isArray(ep)){endpointArgs=_ju.merge(ep[1],endpointArgs);return _e(ep[0],endpointArgs);}}.bind(this);endpoint.typeId=typeId;return endpoint;};this.setEndpoint=function(ep,doNotRepaint){var _ep=this.prepareEndpoint(ep);this.setPreparedEndpoint(_ep,true);};this.setPreparedEndpoint=function(ep,doNotRepaint){if(this.endpoint!=null){this.endpoint.cleanup();this.endpoint.destroy();}this.endpoint=ep;this.type=this.endpoint.type;this.canvas=this.endpoint.canvas;};_jp.extend(this,params,typeParameters);this.isSource=params.isSource||false;this.isTemporarySource=params.isTemporarySource||false;this.isTarget=params.isTarget||false;this.connections=params.connections||[];this.connectorPointerEvents=params["connector-pointer-events"];this.scope=params.scope||_jsPlumb.getDefaultScope();this.timestamp=null;this.reattachConnections=params.reattach||_jsPlumb.Defaults.ReattachConnections;this.connectionsDetachable=_jsPlumb.Defaults.ConnectionsDetachable;if(params.connectionsDetachable===false||params.detachable===false){this.connectionsDetachable=false;}this.dragAllowedWhenFull=params.dragAllowedWhenFull!==false;if(params.onMaxConnections){this.bind("maxConnections",params.onMaxConnections);}//\n// add a connection. not part of public API.\n//\nthis.addConnection=function(connection){this.connections.push(connection);this[(this.connections.length>0?"add":"remove")+"Class"](_jsPlumb.endpointConnectedClass);this[(this.isFull()?"add":"remove")+"Class"](_jsPlumb.endpointFullClass);};this.detachFromConnection=function(connection,idx,doNotCleanup){idx=idx==null?this.connections.indexOf(connection):idx;if(idx>=0){this.connections.splice(idx,1);this[(this.connections.length>0?"add":"remove")+"Class"](_jsPlumb.endpointConnectedClass);this[(this.isFull()?"add":"remove")+"Class"](_jsPlumb.endpointFullClass);}if(!doNotCleanup&&deleteOnEmpty&&this.connections.length===0){_jsPlumb.deleteObject({endpoint:this,fireEvent:false,deleteAttachedObjects:doNotCleanup!==true});}};this.deleteEveryConnection=function(params){var c=this.connections.length;for(var i=0;i<c;i++){_jsPlumb.deleteConnection(this.connections[0],params);}};this.detachFrom=function(targetEndpoint,fireEvent,originalEvent){var c=[];for(var i=0;i<this.connections.length;i++){if(this.connections[i].endpoints[1]===targetEndpoint||this.connections[i].endpoints[0]===targetEndpoint){c.push(this.connections[i]);}}for(var j=0,count=c.length;j<count;j++){_jsPlumb.deleteConnection(c[0]);}return this;};this.getElement=function(){return this.element;};this.setElement=function(el){var parentId=this._jsPlumb.instance.getId(el),curId=this.elementId;// remove the endpoint from the list for the current endpoint\'s element\n_ju.removeWithFunction(params.endpointsByElement[this.elementId],function(e){return e.id===this.id;}.bind(this));this.element=_jp.getElement(el);this.elementId=_jsPlumb.getId(this.element);_jsPlumb.anchorManager.rehomeEndpoint(this,curId,this.element);_jsPlumb.dragManager.endpointAdded(this.element);_ju.addToList(params.endpointsByElement,parentId,this);return this;};/**\r\n         * private but must be exposed.\r\n         */this.makeInPlaceCopy=function(){var loc=this.anchor.getCurrentLocation({element:this}),o=this.anchor.getOrientation(this),acc=this.anchor.getCssClass(),inPlaceAnchor={bind:function bind(){},compute:function compute(){return[loc[0],loc[1]];},getCurrentLocation:function getCurrentLocation(){return[loc[0],loc[1]];},getOrientation:function getOrientation(){return o;},getCssClass:function getCssClass(){return acc;}};return _newEndpoint({dropOptions:params.dropOptions,anchor:inPlaceAnchor,source:this.element,paintStyle:this.getPaintStyle(),endpoint:params.hideOnDrag?"Blank":this.endpoint,_transient:true,scope:this.scope,reference:this});};/**\r\n         * returns a connection from the pool; used when dragging starts.  just gets the head of the array if it can.\r\n         */this.connectorSelector=function(){return this.connections[0];};this.setStyle=this.setPaintStyle;this.paint=function(params){params=params||{};var timestamp=params.timestamp,recalc=!(params.recalc===false);if(!timestamp||this.timestamp!==timestamp){var info=_jsPlumb.updateOffset({elId:this.elementId,timestamp:timestamp});var xy=params.offset?params.offset.o:info.o;if(xy!=null){var ap=params.anchorPoint,connectorPaintStyle=params.connectorPaintStyle;if(ap==null){var wh=params.dimensions||info.s,anchorParams={xy:[xy.left,xy.top],wh:wh,element:this,timestamp:timestamp};if(recalc&&this.anchor.isDynamic&&this.connections.length>0){var c=findConnectionToUseForDynamicAnchor(this,params.elementWithPrecedence),oIdx=c.endpoints[0]===this?1:0,oId=oIdx===0?c.sourceId:c.targetId,oInfo=_jsPlumb.getCachedData(oId),oOffset=oInfo.o,oWH=oInfo.s;anchorParams.index=oIdx===0?1:0;anchorParams.connection=c;anchorParams.txy=[oOffset.left,oOffset.top];anchorParams.twh=oWH;anchorParams.tElement=c.endpoints[oIdx];}else if(this.connections.length>0){anchorParams.connection=this.connections[0];}ap=this.anchor.compute(anchorParams);}this.endpoint.compute(ap,this.anchor.getOrientation(this),this._jsPlumb.paintStyleInUse,connectorPaintStyle||this.paintStyleInUse);this.endpoint.paint(this._jsPlumb.paintStyleInUse,this.anchor);this.timestamp=timestamp;// paint overlays\nfor(var i in this._jsPlumb.overlays){if(this._jsPlumb.overlays.hasOwnProperty(i)){var o=this._jsPlumb.overlays[i];if(o.isVisible()){this._jsPlumb.overlayPlacements[i]=o.draw(this.endpoint,this._jsPlumb.paintStyleInUse);o.paint(this._jsPlumb.overlayPlacements[i]);}}}}}};this.getTypeDescriptor=function(){return"endpoint";};this.isVisible=function(){return this._jsPlumb.visible;};this.repaint=this.paint;var draggingInitialised=false;this.initDraggable=function(){// is this a connection source? we make it draggable and have the\n// drag listener maintain a connection with a floating endpoint.\nif(!draggingInitialised&&_jp.isDragSupported(this.element)){var placeholderInfo={id:null,element:null},jpc=null,existingJpc=false,existingJpcParams=null,_dragHandler=_makeConnectionDragHandler(this,placeholderInfo,_jsPlumb),dragOptions=params.dragOptions||{},defaultOpts={},startEvent=_jp.dragEvents.start,stopEvent=_jp.dragEvents.stop,dragEvent=_jp.dragEvents.drag,beforeStartEvent=_jp.dragEvents.beforeStart,payload;// respond to beforeStart from katavorio; this will have, optionally, a payload of attribute values\n// that were placed there by the makeSource mousedown listener.\nvar beforeStart=function beforeStart(beforeStartParams){payload=beforeStartParams.e.payload||{};};var start=function(startParams){// -------------   first, get a connection to drag. this may be null, in which case we are dragging a new one.\njpc=this.connectorSelector();// -------------------------------- now a bunch of tests about whether or not to proceed -------------------------\nvar _continue=true;// if not enabled, return\nif(!this.isEnabled()){_continue=false;}// if no connection and we\'re not a source - or temporarily a source, as is the case with makeSource - return.\nif(jpc==null&&!this.isSource&&!this.isTemporarySource){_continue=false;}// otherwise if we\'re full and not allowed to drag, also return false.\nif(this.isSource&&this.isFull()&&!(jpc!=null&&this.dragAllowedWhenFull)){_continue=false;}// if the connection was setup as not detachable or one of its endpoints\n// was setup as connectionsDetachable = false, or Defaults.ConnectionsDetachable\n// is set to false...\nif(jpc!=null&&!jpc.isDetachable(this)){_continue=false;}var beforeDrag=_jsPlumb.checkCondition(jpc==null?"beforeDrag":"beforeStartDetach",{endpoint:this,source:this.element,sourceId:this.elementId,connection:jpc});if(beforeDrag===false){_continue=false;}// else we might have been given some data. we\'ll pass it in to a new connection as \'data\'.\n// here we also merge in the optional payload we were given on mousedown.\nelse if((typeof beforeDrag==="undefined"?"undefined":_typeof(beforeDrag))==="object"){_jp.extend(beforeDrag,payload||{});}else{// or if no beforeDrag data, maybe use the payload on its own.\nbeforeDrag=payload||{};}if(_continue===false){// this is for mootools and yui. returning false from this causes jquery to stop drag.\n// the events are wrapped in both mootools and yui anyway, but i don\'t think returning\n// false from the start callback would stop a drag.\nif(_jsPlumb.stopDrag){_jsPlumb.stopDrag(this.canvas);}_dragHandler.stopDrag();return false;}// ---------------------------------------------------------------------------------------------------------------------\n// ok to proceed.\n// clear hover for all connections for this endpoint before continuing.\nfor(var i=0;i<this.connections.length;i++){this.connections[i].setHover(false);}this.addClass("endpointDrag");_jsPlumb.setConnectionBeingDragged(true);// if we\'re not full but there was a connection, make it null. we\'ll create a new one.\nif(jpc&&!this.isFull()&&this.isSource){jpc=null;}_jsPlumb.updateOffset({elId:this.elementId});// ----------------    make the element we will drag around, and position it -----------------------------\nvar ipco=this._jsPlumb.instance.getOffset(this.canvas),canvasElement=this.canvas,ips=this._jsPlumb.instance.getSize(this.canvas);_makeDraggablePlaceholder(placeholderInfo,_jsPlumb,ipco,ips);// store the id of the dragging div and the source element. the drop function will pick these up.                   \n_jsPlumb.setAttributes(this.canvas,{"dragId":placeholderInfo.id,"elId":this.elementId});// ------------------- create an endpoint that will be our floating endpoint ------------------------------------\nvar endpointToFloat=this.dragProxy||this.endpoint;if(this.dragProxy==null&&this.connectionType!=null){var aae=this._jsPlumb.instance.deriveEndpointAndAnchorSpec(this.connectionType);if(aae.endpoints[1]){endpointToFloat=aae.endpoints[1];}}var centerAnchor=this._jsPlumb.instance.makeAnchor("Center");centerAnchor.isFloating=true;this._jsPlumb.floatingEndpoint=_makeFloatingEndpoint(this.getPaintStyle(),centerAnchor,endpointToFloat,this.canvas,placeholderInfo.element,_jsPlumb,_newEndpoint,this.scope);var _savedAnchor=this._jsPlumb.floatingEndpoint.anchor;if(jpc==null){this.setHover(false,false);// create a connection. one end is this endpoint, the other is a floating endpoint.                    \njpc=_newConnection({sourceEndpoint:this,targetEndpoint:this._jsPlumb.floatingEndpoint,source:this.element,// for makeSource with parent option.  ensure source element is represented correctly.\ntarget:placeholderInfo.element,anchors:[this.anchor,this._jsPlumb.floatingEndpoint.anchor],paintStyle:params.connectorStyle,// this can be null. Connection will use the default.\nhoverPaintStyle:params.connectorHoverStyle,connector:params.connector,// this can also be null. Connection will use the default.\noverlays:params.connectorOverlays,type:this.connectionType,cssClass:this.connectorClass,hoverClass:this.connectorHoverClass,scope:params.scope,data:beforeDrag});jpc.pending=true;jpc.addClass(_jsPlumb.draggingClass);this._jsPlumb.floatingEndpoint.addClass(_jsPlumb.draggingClass);this._jsPlumb.floatingEndpoint.anchor=_savedAnchor;// fire an event that informs that a connection is being dragged\n_jsPlumb.fire("connectionDrag",jpc);// register the new connection on the drag manager. This connection, at this point, is \'pending\',\n// and has as its target a temporary element (the \'placeholder\'). If the connection subsequently\n// becomes established, the anchor manager is informed that the target of the connection has\n// changed.\n_jsPlumb.anchorManager.newConnection(jpc);}else{existingJpc=true;jpc.setHover(false);// new anchor idx\nvar anchorIdx=jpc.endpoints[0].id===this.id?0:1;this.detachFromConnection(jpc,null,true);// detach from the connection while dragging is occurring. but dont cleanup automatically.\n// store the original scope (issue 57)\nvar dragScope=_jsPlumb.getDragScope(canvasElement);_jsPlumb.setAttribute(this.canvas,"originalScope",dragScope);// fire an event that informs that a connection is being dragged. we do this before\n// replacing the original target with the floating element info.\n_jsPlumb.fire("connectionDrag",jpc);// now we replace ourselves with the temporary div we created above:\nif(anchorIdx===0){existingJpcParams=[jpc.source,jpc.sourceId,canvasElement,dragScope];_jsPlumb.anchorManager.sourceChanged(jpc.endpoints[anchorIdx].elementId,placeholderInfo.id,jpc,placeholderInfo.element);}else{existingJpcParams=[jpc.target,jpc.targetId,canvasElement,dragScope];jpc.target=placeholderInfo.element;jpc.targetId=placeholderInfo.id;_jsPlumb.anchorManager.updateOtherEndpoint(jpc.sourceId,jpc.endpoints[anchorIdx].elementId,jpc.targetId,jpc);}// store the original endpoint and assign the new floating endpoint for the drag.\njpc.suspendedEndpoint=jpc.endpoints[anchorIdx];// PROVIDE THE SUSPENDED ELEMENT, BE IT A SOURCE OR TARGET (ISSUE 39)\njpc.suspendedElement=jpc.endpoints[anchorIdx].getElement();jpc.suspendedElementId=jpc.endpoints[anchorIdx].elementId;jpc.suspendedElementType=anchorIdx===0?"source":"target";jpc.suspendedEndpoint.setHover(false);this._jsPlumb.floatingEndpoint.referenceEndpoint=jpc.suspendedEndpoint;jpc.endpoints[anchorIdx]=this._jsPlumb.floatingEndpoint;jpc.addClass(_jsPlumb.draggingClass);this._jsPlumb.floatingEndpoint.addClass(_jsPlumb.draggingClass);}_jsPlumb.registerFloatingConnection(placeholderInfo,jpc,this._jsPlumb.floatingEndpoint);// // register it and register connection on it.\n// _jsPlumb.floatingConnections[placeholderInfo.id] = jpc;\n//\n// // only register for the target endpoint; we will not be dragging the source at any time\n// // before this connection is either discarded or made into a permanent connection.\n// _ju.addToList(params.endpointsByElement, placeholderInfo.id, this._jsPlumb.floatingEndpoint);\n// tell jsplumb about it\n_jsPlumb.currentlyDragging=true;}.bind(this);var stop=function(){_jsPlumb.setConnectionBeingDragged(false);if(jpc&&jpc.endpoints!=null){// get the actual drop event (decode from library args to stop function)\nvar originalEvent=_jsPlumb.getDropEvent(arguments);// unlock the other endpoint (if it is dynamic, it would have been locked at drag start)\nvar idx=_jsPlumb.getFloatingAnchorIndex(jpc);jpc.endpoints[idx===0?1:0].anchor.locked=false;// TODO: Dont want to know about css classes inside jsplumb, ideally.\njpc.removeClass(_jsPlumb.draggingClass);// if we have the floating endpoint then the connection has not been dropped\n// on another endpoint.  If it is a new connection we throw it away. If it is an\n// existing connection we check to see if we should reattach it, throwing it away\n// if not.\nif(this._jsPlumb&&(jpc.deleteConnectionNow||jpc.endpoints[idx]===this._jsPlumb.floatingEndpoint)){// 6a. if the connection was an existing one...\nif(existingJpc&&jpc.suspendedEndpoint){// fix for issue35, thanks Sylvain Gizard: when firing the detach event make sure the\n// floating endpoint has been replaced.\nif(idx===0){jpc.floatingElement=jpc.source;jpc.floatingId=jpc.sourceId;jpc.floatingEndpoint=jpc.endpoints[0];jpc.floatingIndex=0;jpc.source=existingJpcParams[0];jpc.sourceId=existingJpcParams[1];}else{// keep a copy of the floating element; the anchor manager will want to clean up.\njpc.floatingElement=jpc.target;jpc.floatingId=jpc.targetId;jpc.floatingEndpoint=jpc.endpoints[1];jpc.floatingIndex=1;jpc.target=existingJpcParams[0];jpc.targetId=existingJpcParams[1];}var fe=this._jsPlumb.floatingEndpoint;// store for later removal.\n// restore the original scope (issue 57)\n_jsPlumb.setDragScope(existingJpcParams[2],existingJpcParams[3]);jpc.endpoints[idx]=jpc.suspendedEndpoint;// if the connection should be reattached, or the other endpoint refuses detach, then\n// reset the connection to its original state\nif(jpc.isReattach()||jpc._forceReattach||jpc._forceDetach||!_jsPlumb.deleteConnection(jpc,{originalEvent:originalEvent})){jpc.setHover(false);jpc._forceDetach=null;jpc._forceReattach=null;this._jsPlumb.floatingEndpoint.detachFromConnection(jpc);jpc.suspendedEndpoint.addConnection(jpc);// TODO this code is duplicated in lots of places...and there is nothing external\n// in the code; it all refers to the connection itself. we could add a\n// `checkSanity(connection)` method to anchorManager that did this.\nif(idx===1){_jsPlumb.anchorManager.updateOtherEndpoint(jpc.sourceId,jpc.floatingId,jpc.targetId,jpc);}else{_jsPlumb.anchorManager.sourceChanged(jpc.floatingId,jpc.sourceId,jpc,jpc.source);}_jsPlumb.repaint(existingJpcParams[1]);}else{_jsPlumb.deleteObject({endpoint:fe});}}}// makeTargets sets this flag, to tell us we have been replaced and should delete this object.\nif(this.deleteAfterDragStop){_jsPlumb.deleteObject({endpoint:this});}else{if(this._jsPlumb){this.paint({recalc:false});}}// although the connection is no longer valid, there are use cases where this is useful.\n_jsPlumb.fire("connectionDragStop",jpc,originalEvent);// fire this event to give people more fine-grained control (connectionDragStop fires a lot)\nif(jpc.pending){_jsPlumb.fire("connectionAborted",jpc,originalEvent);}// tell jsplumb that dragging is finished.\n_jsPlumb.currentlyDragging=false;jpc.suspendedElement=null;jpc.suspendedEndpoint=null;jpc=null;}// if no endpoints, jpc already cleaned up. but still we want to ensure we\'re reset properly.\n// remove the element associated with the floating endpoint\n// (and its associated floating endpoint and visual artefacts)\nif(placeholderInfo&&placeholderInfo.element){_jsPlumb.remove(placeholderInfo.element,false,false);}// remove the inplace copy\nif(inPlaceCopy){_jsPlumb.deleteObject({endpoint:inPlaceCopy});}if(this._jsPlumb){// make our canvas visible (TODO: hand off to library; we should not know about DOM)\nthis.canvas.style.visibility="visible";// unlock our anchor\nthis.anchor.locked=false;// clear floating anchor.\nthis._jsPlumb.floatingEndpoint=null;}}.bind(this);dragOptions=_jp.extend(defaultOpts,dragOptions);dragOptions.scope=this.scope||dragOptions.scope;dragOptions[beforeStartEvent]=_ju.wrap(dragOptions[beforeStartEvent],beforeStart,false);dragOptions[startEvent]=_ju.wrap(dragOptions[startEvent],start,false);// extracted drag handler function so can be used by makeSource\ndragOptions[dragEvent]=_ju.wrap(dragOptions[dragEvent],_dragHandler.drag);dragOptions[stopEvent]=_ju.wrap(dragOptions[stopEvent],stop);dragOptions.multipleDrop=false;dragOptions.canDrag=function(){return this.isSource||this.isTemporarySource||/*(this.isTarget && */this.connections.length>0/*)*/;}.bind(this);_jsPlumb.initDraggable(this.canvas,dragOptions,"internal");this.canvas._jsPlumbRelatedElement=this.element;draggingInitialised=true;}};var ep=params.endpoint||this._jsPlumb.instance.Defaults.Endpoint||_jp.Defaults.Endpoint;this.setEndpoint(ep,true);var anchorParamsToUse=params.anchor?params.anchor:params.anchors?params.anchors:_jsPlumb.Defaults.Anchor||"Top";this.setAnchor(anchorParamsToUse,true);// finally, set type if it was provided\nvar type=["default",params.type||""].join(" ");this.addType(type,params.data,true);this.canvas=this.endpoint.canvas;this.canvas._jsPlumb=this;this.initDraggable();// pulled this out into a function so we can reuse it for the inPlaceCopy canvas; you can now drop detached connections\n// back onto the endpoint you detached it from.\nvar _initDropTarget=function(canvas,isTransient,endpoint,referenceEndpoint){if(_jp.isDropSupported(this.element)){var dropOptions=params.dropOptions||_jsPlumb.Defaults.DropOptions||_jp.Defaults.DropOptions;dropOptions=_jp.extend({},dropOptions);dropOptions.scope=dropOptions.scope||this.scope;var dropEvent=_jp.dragEvents.drop,overEvent=_jp.dragEvents.over,outEvent=_jp.dragEvents.out,_ep=this,drop=_jsPlumb.EndpointDropHandler({getEndpoint:function getEndpoint(){return _ep;},jsPlumb:_jsPlumb,enabled:function enabled(){return endpoint!=null?endpoint.isEnabled():true;},isFull:function isFull(){return endpoint.isFull();},element:this.element,elementId:this.elementId,isSource:this.isSource,isTarget:this.isTarget,addClass:function addClass(clazz){_ep.addClass(clazz);},removeClass:function removeClass(clazz){_ep.removeClass(clazz);},isDropAllowed:function isDropAllowed(){return _ep.isDropAllowed.apply(_ep,arguments);},reference:referenceEndpoint,isRedrop:function isRedrop(jpc,dhParams){return jpc.suspendedEndpoint&&dhParams.reference&&jpc.suspendedEndpoint.id===dhParams.reference.id;}});dropOptions[dropEvent]=_ju.wrap(dropOptions[dropEvent],drop,true);dropOptions[overEvent]=_ju.wrap(dropOptions[overEvent],function(){var draggable=_jp.getDragObject(arguments),id=_jsPlumb.getAttribute(_jp.getElement(draggable),"dragId"),_jpc=_jsPlumb.getFloatingConnectionFor(id);//_jsPlumb.floatingConnections[id];\nif(_jpc!=null){var idx=_jsPlumb.getFloatingAnchorIndex(_jpc);// here we should fire the \'over\' event if we are a target and this is a new connection,\n// or we are the same as the floating endpoint.\nvar _cont=this.isTarget&&idx!==0||_jpc.suspendedEndpoint&&this.referenceEndpoint&&this.referenceEndpoint.id===_jpc.suspendedEndpoint.id;if(_cont){var bb=_jsPlumb.checkCondition("checkDropAllowed",{sourceEndpoint:_jpc.endpoints[idx],targetEndpoint:this,connection:_jpc});this[(bb?"add":"remove")+"Class"](_jsPlumb.endpointDropAllowedClass);this[(bb?"remove":"add")+"Class"](_jsPlumb.endpointDropForbiddenClass);_jpc.endpoints[idx].anchor.over(this.anchor,this);}}}.bind(this));dropOptions[outEvent]=_ju.wrap(dropOptions[outEvent],function(){var draggable=_jp.getDragObject(arguments),id=draggable==null?null:_jsPlumb.getAttribute(_jp.getElement(draggable),"dragId"),_jpc=id?_jsPlumb.getFloatingConnectionFor(id):null;if(_jpc!=null){var idx=_jsPlumb.getFloatingAnchorIndex(_jpc);var _cont=this.isTarget&&idx!==0||_jpc.suspendedEndpoint&&this.referenceEndpoint&&this.referenceEndpoint.id===_jpc.suspendedEndpoint.id;if(_cont){this.removeClass(_jsPlumb.endpointDropAllowedClass);this.removeClass(_jsPlumb.endpointDropForbiddenClass);_jpc.endpoints[idx].anchor.out();}}}.bind(this));_jsPlumb.initDroppable(canvas,dropOptions,"internal",isTransient);}}.bind(this);// Initialise the endpoint\'s canvas as a drop target. The drop handler will take care of the logic of whether\n// something can actually be dropped.\nif(!this.anchor.isFloating){_initDropTarget(this.canvas,!(params._transient||this.anchor.isFloating),this,params.reference);}return this;};_ju.extend(_jp.Endpoint,_jp.OverlayCapableJsPlumbUIComponent,{setVisible:function setVisible(v,doNotChangeConnections,doNotNotifyOtherEndpoint){this._jsPlumb.visible=v;if(this.canvas){this.canvas.style.display=v?"block":"none";}this[v?"showOverlays":"hideOverlays"]();if(!doNotChangeConnections){for(var i=0;i<this.connections.length;i++){this.connections[i].setVisible(v);if(!doNotNotifyOtherEndpoint){var oIdx=this===this.connections[i].endpoints[0]?1:0;// only change the other endpoint if this is its only connection.\nif(this.connections[i].endpoints[oIdx].connections.length===1){this.connections[i].endpoints[oIdx].setVisible(v,true,true);}}}}},getAttachedElements:function getAttachedElements(){return this.connections;},applyType:function applyType(t,doNotRepaint){this.setPaintStyle(t.endpointStyle||t.paintStyle,doNotRepaint);this.setHoverPaintStyle(t.endpointHoverStyle||t.hoverPaintStyle,doNotRepaint);if(t.maxConnections!=null){this._jsPlumb.maxConnections=t.maxConnections;}if(t.scope){this.scope=t.scope;}_jp.extend(this,t,typeParameters);if(t.cssClass!=null&&this.canvas){this._jsPlumb.instance.addClass(this.canvas,t.cssClass);}_jp.OverlayCapableJsPlumbUIComponent.applyType(this,t);},isEnabled:function isEnabled(){return this._jsPlumb.enabled;},setEnabled:function setEnabled(e){this._jsPlumb.enabled=e;},cleanup:function cleanup(){var anchorClass=this._jsPlumb.instance.endpointAnchorClassPrefix+(this._jsPlumb.currentAnchorClass?"-"+this._jsPlumb.currentAnchorClass:"");_jp.removeClass(this.element,anchorClass);this.anchor=null;this.endpoint.cleanup(true);this.endpoint.destroy();this.endpoint=null;// drag/drop\nthis._jsPlumb.instance.destroyDraggable(this.canvas,"internal");this._jsPlumb.instance.destroyDroppable(this.canvas,"internal");},setHover:function setHover(h){if(this.endpoint&&this._jsPlumb&&!this._jsPlumb.instance.isConnectionBeingDragged()){this.endpoint.setHover(h);}},isFull:function isFull(){return this._jsPlumb.maxConnections===0?true:!(this.isFloating()||this._jsPlumb.maxConnections<0||this.connections.length<this._jsPlumb.maxConnections);},/**\r\n         * private but needs to be exposed.\r\n         */isFloating:function isFloating(){return this.anchor!=null&&this.anchor.isFloating;},isConnectedTo:function isConnectedTo(endpoint){var found=false;if(endpoint){for(var i=0;i<this.connections.length;i++){if(this.connections[i].endpoints[1]===endpoint||this.connections[i].endpoints[0]===endpoint){found=true;break;}}}return found;},getConnectionCost:function getConnectionCost(){return this._jsPlumb.connectionCost;},setConnectionCost:function setConnectionCost(c){this._jsPlumb.connectionCost=c;},areConnectionsDirected:function areConnectionsDirected(){return this._jsPlumb.connectionsDirected;},setConnectionsDirected:function setConnectionsDirected(b){this._jsPlumb.connectionsDirected=b;},setElementId:function setElementId(_elId){this.elementId=_elId;this.anchor.elementId=_elId;},setReferenceElement:function setReferenceElement(_el){this.element=_jp.getElement(_el);},setDragAllowedWhenFull:function setDragAllowedWhenFull(allowed){this.dragAllowedWhenFull=allowed;},equals:function equals(endpoint){return this.anchor.equals(endpoint.anchor);},getUuid:function getUuid(){return this._jsPlumb.uuid;},computeAnchor:function computeAnchor(params){return this.anchor.compute(params);}});root.jsPlumbInstance.prototype.EndpointDropHandler=function(dhParams){return function(e){var _jsPlumb=dhParams.jsPlumb;// remove the classes that are added dynamically. drop is neither forbidden nor allowed now that\n// the drop is finishing.\ndhParams.removeClass(_jsPlumb.endpointDropAllowedClass);dhParams.removeClass(_jsPlumb.endpointDropForbiddenClass);var originalEvent=_jsPlumb.getDropEvent(arguments),draggable=_jsPlumb.getDragObject(arguments),id=_jsPlumb.getAttribute(draggable,"dragId"),elId=_jsPlumb.getAttribute(draggable,"elId"),scope=_jsPlumb.getAttribute(draggable,"originalScope"),jpc=_jsPlumb.getFloatingConnectionFor(id);// if no active connection, bail.\nif(jpc==null){return;}// calculate if this is an existing connection.\nvar existingConnection=jpc.suspendedEndpoint!=null;// if suspended endpoint exists but has been cleaned up, bail. This means it\'s an existing connection\n// that has been detached and will shortly be discarded.\nif(existingConnection&&jpc.suspendedEndpoint._jsPlumb==null){return;}// get the drop endpoint. for a normal connection this is just the one that would replace the currently\n// floating endpoint. for a makeTarget this is a new endpoint that is created on drop. But we leave that to\n// the handler to figure out.\nvar _ep=dhParams.getEndpoint(jpc);// If we\'re not given an endpoint to use, bail.\nif(_ep==null){return;}// if this is a drop back where the connection came from, mark it force reattach and\n// return; the stop handler will reattach. without firing an event.\nif(dhParams.isRedrop(jpc,dhParams)){jpc._forceReattach=true;jpc.setHover(false);if(dhParams.maybeCleanup){dhParams.maybeCleanup(_ep);}return;}// ensure we dont bother trying to drop sources on non-source eps, and same for target.\nvar idx=_jsPlumb.getFloatingAnchorIndex(jpc);if(idx===0&&!dhParams.isSource||idx===1&&!dhParams.isTarget){if(dhParams.maybeCleanup){dhParams.maybeCleanup(_ep);}return;}if(dhParams.onDrop){dhParams.onDrop(jpc);}// restore the original scope if necessary (issue 57)\nif(scope){_jsPlumb.setDragScope(draggable,scope);}// if the target of the drop is full, fire an event (we abort below)\n// makeTarget: keep.\nvar isFull=dhParams.isFull(e);if(isFull){_ep.fire("maxConnections",{endpoint:this,connection:jpc,maxConnections:_ep._jsPlumb.maxConnections},originalEvent);}//\n// if endpoint enabled, not full, and matches the index of the floating endpoint...\nif(!isFull&&dhParams.enabled()){var _doContinue=true;// before testing for beforeDrop, reset the connection\'s source/target to be the actual DOM elements\n// involved (that is, stash any temporary stuff used for dragging. but we need to keep it around in\n// order that the anchor manager can clean things up properly).\nif(idx===0){jpc.floatingElement=jpc.source;jpc.floatingId=jpc.sourceId;jpc.floatingEndpoint=jpc.endpoints[0];jpc.floatingIndex=0;jpc.source=dhParams.element;jpc.sourceId=dhParams.elementId;}else{jpc.floatingElement=jpc.target;jpc.floatingId=jpc.targetId;jpc.floatingEndpoint=jpc.endpoints[1];jpc.floatingIndex=1;jpc.target=dhParams.element;jpc.targetId=dhParams.elementId;}// if this is an existing connection and detach is not allowed we won\'t continue. The connection\'s\n// endpoints have been reinstated; everything is back to how it was.\nif(existingConnection&&jpc.suspendedEndpoint.id!==_ep.id){if(!jpc.isDetachAllowed(jpc)||!jpc.endpoints[idx].isDetachAllowed(jpc)||!jpc.suspendedEndpoint.isDetachAllowed(jpc)||!_jsPlumb.checkCondition("beforeDetach",jpc)){_doContinue=false;}}// ------------ wrap the execution path in a function so we can support asynchronous beforeDrop\nvar continueFunction=function(optionalData){// remove this jpc from the current endpoint, which is a floating endpoint that we will\n// subsequently discard.\njpc.endpoints[idx].detachFromConnection(jpc);// if there\'s a suspended endpoint, detach it from the connection.\nif(jpc.suspendedEndpoint){jpc.suspendedEndpoint.detachFromConnection(jpc);}jpc.endpoints[idx]=_ep;_ep.addConnection(jpc);// copy our parameters in to the connection:\nvar params=_ep.getParameters();for(var aParam in params){jpc.setParameter(aParam,params[aParam]);}if(!existingConnection){// if not an existing connection and\nif(params.draggable){_jsPlumb.initDraggable(this.element,dhParams.dragOptions,"internal",_jsPlumb);}}else{var suspendedElementId=jpc.suspendedEndpoint.elementId;_jsPlumb.fireMoveEvent({index:idx,originalSourceId:idx===0?suspendedElementId:jpc.sourceId,newSourceId:idx===0?_ep.elementId:jpc.sourceId,originalTargetId:idx===1?suspendedElementId:jpc.targetId,newTargetId:idx===1?_ep.elementId:jpc.targetId,originalSourceEndpoint:idx===0?jpc.suspendedEndpoint:jpc.endpoints[0],newSourceEndpoint:idx===0?_ep:jpc.endpoints[0],originalTargetEndpoint:idx===1?jpc.suspendedEndpoint:jpc.endpoints[1],newTargetEndpoint:idx===1?_ep:jpc.endpoints[1],connection:jpc},originalEvent);}if(idx===1){_jsPlumb.anchorManager.updateOtherEndpoint(jpc.sourceId,jpc.floatingId,jpc.targetId,jpc);}else{_jsPlumb.anchorManager.sourceChanged(jpc.floatingId,jpc.sourceId,jpc,jpc.source);}// when makeSource has uniqueEndpoint:true, we want to create connections with new endpoints\n// that are subsequently deleted. So makeSource sets `finalEndpoint`, which is the Endpoint to\n// which the connection should be attached. The `detachFromConnection` call below results in the\n// temporary endpoint being cleaned up.\nif(jpc.endpoints[0].finalEndpoint){var _toDelete=jpc.endpoints[0];_toDelete.detachFromConnection(jpc);jpc.endpoints[0]=jpc.endpoints[0].finalEndpoint;jpc.endpoints[0].addConnection(jpc);}// if optionalData was given, merge it onto the connection\'s data.\nif(_ju.isObject(optionalData)){jpc.mergeData(optionalData);}// finalise will inform the anchor manager and also add to\n// connectionsByScope if necessary.\n_jsPlumb.finaliseConnection(jpc,null,originalEvent,false);jpc.setHover(false);}.bind(this);var dontContinueFunction=function dontContinueFunction(){// otherwise just put it back on the endpoint it was on before the drag.\nif(jpc.suspendedEndpoint){jpc.endpoints[idx]=jpc.suspendedEndpoint;jpc.setHover(false);jpc._forceDetach=true;if(idx===0){jpc.source=jpc.suspendedEndpoint.element;jpc.sourceId=jpc.suspendedEndpoint.elementId;}else{jpc.target=jpc.suspendedEndpoint.element;jpc.targetId=jpc.suspendedEndpoint.elementId;}jpc.suspendedEndpoint.addConnection(jpc);// TODO checkSanity\nif(idx===1){_jsPlumb.anchorManager.updateOtherEndpoint(jpc.sourceId,jpc.floatingId,jpc.targetId,jpc);}else{_jsPlumb.anchorManager.sourceChanged(jpc.floatingId,jpc.sourceId,jpc,jpc.source);}_jsPlumb.repaint(jpc.sourceId);jpc._forceDetach=false;}};// --------------------------------------\n// now check beforeDrop.  this will be available only on Endpoints that are setup to\n// have a beforeDrop condition (although, secretly, under the hood all Endpoints and\n// the Connection have them, because they are on jsPlumbUIComponent.  shhh!), because\n// it only makes sense to have it on a target endpoint.\n_doContinue=_doContinue&&dhParams.isDropAllowed(jpc.sourceId,jpc.targetId,jpc.scope,jpc,_ep);// && jpc.pending;\nif(_doContinue){continueFunction(_doContinue);return true;}else{dontContinueFunction();}}if(dhParams.maybeCleanup){dhParams.maybeCleanup(_ep);}_jsPlumb.currentlyDragging=false;};};}).call(typeof window!==\'undefined\'?window:this);/*\r\n * This file contains the code for Connections.\r\n *\r\n * Copyright (c) 2010 - 2018 jsPlumb (hello@jsplumbtoolkit.com)\r\n *\r\n * https://jsplumbtoolkit.com\r\n * https://github.com/jsplumb/jsplumb\r\n *\r\n * Dual licensed under the MIT and GPL2 licenses.\r\n */;(function(){"use strict";var root=this,_jp=root.jsPlumb,_ju=root.jsPlumbUtil;var makeConnector=function makeConnector(_jsPlumb,renderMode,connectorName,connectorArgs,forComponent){if(!_jsPlumb.Defaults.DoNotThrowErrors&&_jp.Connectors[renderMode][connectorName]==null){throw{msg:"jsPlumb: unknown connector type \'"+connectorName+"\'"};}return new _jp.Connectors[renderMode][connectorName](connectorArgs,forComponent);},_makeAnchor=function _makeAnchor(anchorParams,elementId,_jsPlumb){return anchorParams?_jsPlumb.makeAnchor(anchorParams,elementId,_jsPlumb):null;},_updateConnectedClass=function _updateConnectedClass(conn,element,_jsPlumb,remove){if(element!=null){element._jsPlumbConnections=element._jsPlumbConnections||{};if(remove){delete element._jsPlumbConnections[conn.id];}else{element._jsPlumbConnections[conn.id]=true;}if(_ju.isEmpty(element._jsPlumbConnections)){_jsPlumb.removeClass(element,_jsPlumb.connectedClass);}else{_jsPlumb.addClass(element,_jsPlumb.connectedClass);}}};_jp.Connection=function(params){var _newEndpoint=params.newEndpoint;this.id=params.id;this.connector=null;this.idPrefix="_jsplumb_c_";this.defaultLabelLocation=0.5;this.defaultOverlayKeys=["Overlays","ConnectionOverlays"];// if a new connection is the result of moving some existing connection, params.previousConnection\n// will have that Connection in it. listeners for the jsPlumbConnection event can look for that\n// member and take action if they need to.\nthis.previousConnection=params.previousConnection;this.source=_jp.getElement(params.source);this.target=_jp.getElement(params.target);_jp.OverlayCapableJsPlumbUIComponent.apply(this,arguments);// sourceEndpoint and targetEndpoint override source/target, if they are present. but \n// source is not overridden if the Endpoint has declared it is not the final target of a connection;\n// instead we use the source that the Endpoint declares will be the final source element.\nif(params.sourceEndpoint){this.source=params.sourceEndpoint.getElement();this.sourceId=params.sourceEndpoint.elementId;}else{this.sourceId=this._jsPlumb.instance.getId(this.source);}if(params.targetEndpoint){this.target=params.targetEndpoint.getElement();this.targetId=params.targetEndpoint.elementId;}else{this.targetId=this._jsPlumb.instance.getId(this.target);}this.scope=params.scope;// scope may have been passed in to the connect call. if it wasn\'t, we will pull it from the source endpoint, after having initialised the endpoints.            \nthis.endpoints=[];this.endpointStyles=[];var _jsPlumb=this._jsPlumb.instance;_jsPlumb.manage(this.sourceId,this.source);_jsPlumb.manage(this.targetId,this.target);this._jsPlumb.visible=true;this._jsPlumb.params={cssClass:params.cssClass,container:params.container,"pointer-events":params["pointer-events"],editorParams:params.editorParams,overlays:params.overlays};this._jsPlumb.lastPaintedAt=null;// listen to mouseover and mouseout events passed from the container delegate.\nthis.bind("mouseover",function(){this.setHover(true);}.bind(this));this.bind("mouseout",function(){this.setHover(false);}.bind(this));// INITIALISATION CODE\nthis.makeEndpoint=function(isSource,el,elId,ep){elId=elId||this._jsPlumb.instance.getId(el);return this.prepareEndpoint(_jsPlumb,_newEndpoint,this,ep,isSource?0:1,params,el,elId);};// if type given, get the endpoint definitions mapping to that type from the jsplumb instance, and use those.\n// we apply types at the end of this constructor but endpoints are only honoured in a type definition at\n// create time.\nif(params.type){params.endpoints=params.endpoints||this._jsPlumb.instance.deriveEndpointAndAnchorSpec(params.type).endpoints;}var eS=this.makeEndpoint(true,this.source,this.sourceId,params.sourceEndpoint),eT=this.makeEndpoint(false,this.target,this.targetId,params.targetEndpoint);if(eS){_ju.addToList(params.endpointsByElement,this.sourceId,eS);}if(eT){_ju.addToList(params.endpointsByElement,this.targetId,eT);}// if scope not set, set it to be the scope for the source endpoint.\nif(!this.scope){this.scope=this.endpoints[0].scope;}// if explicitly told to (or not to) delete endpoints when empty, override endpoint\'s preferences\nif(params.deleteEndpointsOnEmpty!=null){this.endpoints[0].setDeleteOnEmpty(params.deleteEndpointsOnEmpty);this.endpoints[1].setDeleteOnEmpty(params.deleteEndpointsOnEmpty);}// -------------------------- DEFAULT TYPE ---------------------------------------------\n// DETACHABLE\nvar _detachable=_jsPlumb.Defaults.ConnectionsDetachable;if(params.detachable===false){_detachable=false;}if(this.endpoints[0].connectionsDetachable===false){_detachable=false;}if(this.endpoints[1].connectionsDetachable===false){_detachable=false;}// REATTACH\nvar _reattach=params.reattach||this.endpoints[0].reattachConnections||this.endpoints[1].reattachConnections||_jsPlumb.Defaults.ReattachConnections;this.appendToDefaultType({detachable:_detachable,reattach:_reattach,paintStyle:this.endpoints[0].connectorStyle||this.endpoints[1].connectorStyle||params.paintStyle||_jsPlumb.Defaults.PaintStyle||_jp.Defaults.PaintStyle,hoverPaintStyle:this.endpoints[0].connectorHoverStyle||this.endpoints[1].connectorHoverStyle||params.hoverPaintStyle||_jsPlumb.Defaults.HoverPaintStyle||_jp.Defaults.HoverPaintStyle});var _suspendedAt=_jsPlumb.getSuspendedAt();if(!_jsPlumb.isSuspendDrawing()){// paint the endpoints\nvar myInfo=_jsPlumb.getCachedData(this.sourceId),myOffset=myInfo.o,myWH=myInfo.s,otherInfo=_jsPlumb.getCachedData(this.targetId),otherOffset=otherInfo.o,otherWH=otherInfo.s,initialTimestamp=_suspendedAt||_jsPlumb.timestamp(),anchorLoc=this.endpoints[0].anchor.compute({xy:[myOffset.left,myOffset.top],wh:myWH,element:this.endpoints[0],elementId:this.endpoints[0].elementId,txy:[otherOffset.left,otherOffset.top],twh:otherWH,tElement:this.endpoints[1],timestamp:initialTimestamp});this.endpoints[0].paint({anchorLoc:anchorLoc,timestamp:initialTimestamp});anchorLoc=this.endpoints[1].anchor.compute({xy:[otherOffset.left,otherOffset.top],wh:otherWH,element:this.endpoints[1],elementId:this.endpoints[1].elementId,txy:[myOffset.left,myOffset.top],twh:myWH,tElement:this.endpoints[0],timestamp:initialTimestamp});this.endpoints[1].paint({anchorLoc:anchorLoc,timestamp:initialTimestamp});}this.getTypeDescriptor=function(){return"connection";};this.getAttachedElements=function(){return this.endpoints;};this.isDetachable=function(){return this._jsPlumb.detachable===true;};this.setDetachable=function(detachable){this._jsPlumb.detachable=detachable===true;};this.isReattach=function(){return this._jsPlumb.reattach===true||this.endpoints[0].reattachConnections===true||this.endpoints[1].reattachConnections===true;};this.setReattach=function(reattach){this._jsPlumb.reattach=reattach===true;};// END INITIALISATION CODE\n// COST + DIRECTIONALITY\n// if cost not supplied, try to inherit from source endpoint\nthis._jsPlumb.cost=params.cost||this.endpoints[0].getConnectionCost();this._jsPlumb.directed=params.directed;// inherit directed flag if set no source endpoint\nif(params.directed==null){this._jsPlumb.directed=this.endpoints[0].areConnectionsDirected();}// END COST + DIRECTIONALITY\n// PARAMETERS\n// merge all the parameters objects into the connection.  parameters set\n// on the connection take precedence; then source endpoint params, then\n// finally target endpoint params.\nvar _p=_jp.extend({},this.endpoints[1].getParameters());_jp.extend(_p,this.endpoints[0].getParameters());_jp.extend(_p,this.getParameters());this.setParameters(_p);// END PARAMETERS\n// PAINTING\nthis.setConnector(this.endpoints[0].connector||this.endpoints[1].connector||params.connector||_jsPlumb.Defaults.Connector||_jp.Defaults.Connector,true);var data=params.data==null||!_ju.isObject(params.data)?{}:params.data;this.getData=function(){return data;};this.setData=function(d){data=d||{};};this.mergeData=function(d){data=_jp.extend(data,d);};// the very last thing we do is apply types, if there are any.\nvar _types=["default",this.endpoints[0].connectionType,this.endpoints[1].connectionType,params.type].join(" ");if(/[^\\s]/.test(_types)){this.addType(_types,params.data,true);}this.updateConnectedClass();// END PAINTING    \n};_ju.extend(_jp.Connection,_jp.OverlayCapableJsPlumbUIComponent,{applyType:function applyType(t,doNotRepaint,typeMap){var _connector=null;if(t.connector!=null){_connector=this.getCachedTypeItem("connector",typeMap.connector);if(_connector==null){_connector=this.prepareConnector(t.connector,typeMap.connector);this.cacheTypeItem("connector",_connector,typeMap.connector);}this.setPreparedConnector(_connector);}// none of these things result in the creation of objects so can be ignored.\nif(t.detachable!=null){this.setDetachable(t.detachable);}if(t.reattach!=null){this.setReattach(t.reattach);}if(t.scope){this.scope=t.scope;}if(t.cssClass!=null&&this.canvas){this._jsPlumb.instance.addClass(this.canvas,t.cssClass);}var _anchors=null;// this also results in the creation of objects.\nif(t.anchor){// note that even if the param was anchor, we store `anchors`.\n_anchors=this.getCachedTypeItem("anchors",typeMap.anchor);if(_anchors==null){_anchors=[this._jsPlumb.instance.makeAnchor(t.anchor),this._jsPlumb.instance.makeAnchor(t.anchor)];this.cacheTypeItem("anchors",_anchors,typeMap.anchor);}}else if(t.anchors){_anchors=this.getCachedTypeItem("anchors",typeMap.anchors);if(_anchors==null){_anchors=[this._jsPlumb.instance.makeAnchor(t.anchors[0]),this._jsPlumb.instance.makeAnchor(t.anchors[1])];this.cacheTypeItem("anchors",_anchors,typeMap.anchors);}}if(_anchors!=null){this.endpoints[0].anchor=_anchors[0];this.endpoints[1].anchor=_anchors[1];if(this.endpoints[1].anchor.isDynamic){this._jsPlumb.instance.repaint(this.endpoints[1].elementId);}}_jp.OverlayCapableJsPlumbUIComponent.applyType(this,t);},addClass:function addClass(c,informEndpoints){if(informEndpoints){this.endpoints[0].addClass(c);this.endpoints[1].addClass(c);if(this.suspendedEndpoint){this.suspendedEndpoint.addClass(c);}}if(this.connector){this.connector.addClass(c);}},removeClass:function removeClass(c,informEndpoints){if(informEndpoints){this.endpoints[0].removeClass(c);this.endpoints[1].removeClass(c);if(this.suspendedEndpoint){this.suspendedEndpoint.removeClass(c);}}if(this.connector){this.connector.removeClass(c);}},isVisible:function isVisible(){return this._jsPlumb.visible;},setVisible:function setVisible(v){this._jsPlumb.visible=v;if(this.connector){this.connector.setVisible(v);}this.repaint();},cleanup:function cleanup(){this.updateConnectedClass(true);this.endpoints=null;this.source=null;this.target=null;if(this.connector!=null){this.connector.cleanup(true);this.connector.destroy(true);}this.connector=null;},updateConnectedClass:function updateConnectedClass(remove){if(this._jsPlumb){_updateConnectedClass(this,this.source,this._jsPlumb.instance,remove);_updateConnectedClass(this,this.target,this._jsPlumb.instance,remove);}},setHover:function setHover(state){if(this.connector&&this._jsPlumb&&!this._jsPlumb.instance.isConnectionBeingDragged()){this.connector.setHover(state);root.jsPlumb[state?"addClass":"removeClass"](this.source,this._jsPlumb.instance.hoverSourceClass);root.jsPlumb[state?"addClass":"removeClass"](this.target,this._jsPlumb.instance.hoverTargetClass);}},getUuids:function getUuids(){return[this.endpoints[0].getUuid(),this.endpoints[1].getUuid()];},getCost:function getCost(){return this._jsPlumb?this._jsPlumb.cost:-Infinity;},setCost:function setCost(c){this._jsPlumb.cost=c;},isDirected:function isDirected(){return this._jsPlumb.directed;},getConnector:function getConnector(){return this.connector;},prepareConnector:function prepareConnector(connectorSpec,typeId){var connectorArgs={_jsPlumb:this._jsPlumb.instance,cssClass:this._jsPlumb.params.cssClass||"",container:this._jsPlumb.params.container,"pointer-events":this._jsPlumb.params["pointer-events"]},renderMode=this._jsPlumb.instance.getRenderMode(),connector;if(_ju.isString(connectorSpec)){connector=makeConnector(this._jsPlumb.instance,renderMode,connectorSpec,connectorArgs,this);}// lets you use a string as shorthand.\nelse if(_ju.isArray(connectorSpec)){if(connectorSpec.length===1){connector=makeConnector(this._jsPlumb.instance,renderMode,connectorSpec[0],connectorArgs,this);}else{connector=makeConnector(this._jsPlumb.instance,renderMode,connectorSpec[0],_ju.merge(connectorSpec[1],connectorArgs),this);}}if(typeId!=null){connector.typeId=typeId;}return connector;},setPreparedConnector:function setPreparedConnector(connector,doNotRepaint,doNotChangeListenerComponent,typeId){if(this.connector!==connector){var previous,previousClasses="";// the connector will not be cleaned up if it was set as part of a type, because `typeId` will be set on it\n// and we havent passed in `true` for "force" here.\nif(this.connector!=null){previous=this.connector;previousClasses=previous.getClass();this.connector.cleanup();this.connector.destroy();}this.connector=connector;if(typeId){this.cacheTypeItem("connector",connector,typeId);}this.canvas=this.connector.canvas;this.bgCanvas=this.connector.bgCanvas;// put classes from prior connector onto the canvas\nthis.addClass(previousClasses);// new: instead of binding listeners per connector, we now just have one delegate on the container.\n// so for that handler we set the connection as the \'_jsPlumb\' member of the canvas element, and\n// bgCanvas, if it exists, which it does right now in the VML renderer, so it won\'t from v 2.0.0 onwards.\nif(this.canvas){this.canvas._jsPlumb=this;}if(this.bgCanvas){this.bgCanvas._jsPlumb=this;}if(previous!=null){var o=this.getOverlays();for(var i=0;i<o.length;i++){if(o[i].transfer){o[i].transfer(this.connector);}}}if(!doNotChangeListenerComponent){this.setListenerComponent(this.connector);}if(!doNotRepaint){this.repaint();}}},setConnector:function setConnector(connectorSpec,doNotRepaint,doNotChangeListenerComponent,typeId){var connector=this.prepareConnector(connectorSpec,typeId);this.setPreparedConnector(connector,doNotRepaint,doNotChangeListenerComponent,typeId);},paint:function paint(params){if(!this._jsPlumb.instance.isSuspendDrawing()&&this._jsPlumb.visible){params=params||{};var timestamp=params.timestamp,// if the moving object is not the source we must transpose the two references.\nswap=false,tId=swap?this.sourceId:this.targetId,sId=swap?this.targetId:this.sourceId,tIdx=swap?0:1,sIdx=swap?1:0;if(timestamp==null||timestamp!==this._jsPlumb.lastPaintedAt){var sourceInfo=this._jsPlumb.instance.updateOffset({elId:sId}).o,targetInfo=this._jsPlumb.instance.updateOffset({elId:tId}).o,sE=this.endpoints[sIdx],tE=this.endpoints[tIdx];var sAnchorP=sE.anchor.getCurrentLocation({xy:[sourceInfo.left,sourceInfo.top],wh:[sourceInfo.width,sourceInfo.height],element:sE,timestamp:timestamp}),tAnchorP=tE.anchor.getCurrentLocation({xy:[targetInfo.left,targetInfo.top],wh:[targetInfo.width,targetInfo.height],element:tE,timestamp:timestamp});this.connector.resetBounds();this.connector.compute({sourcePos:sAnchorP,targetPos:tAnchorP,sourceEndpoint:this.endpoints[sIdx],targetEndpoint:this.endpoints[tIdx],"stroke-width":this._jsPlumb.paintStyleInUse.strokeWidth,sourceInfo:sourceInfo,targetInfo:targetInfo});var overlayExtents={minX:Infinity,minY:Infinity,maxX:-Infinity,maxY:-Infinity};// compute overlays. we do this first so we can get their placements, and adjust the\n// container if needs be (if an overlay would be clipped)\nfor(var i in this._jsPlumb.overlays){if(this._jsPlumb.overlays.hasOwnProperty(i)){var o=this._jsPlumb.overlays[i];if(o.isVisible()){this._jsPlumb.overlayPlacements[i]=o.draw(this.connector,this._jsPlumb.paintStyleInUse,this.getAbsoluteOverlayPosition(o));overlayExtents.minX=Math.min(overlayExtents.minX,this._jsPlumb.overlayPlacements[i].minX);overlayExtents.maxX=Math.max(overlayExtents.maxX,this._jsPlumb.overlayPlacements[i].maxX);overlayExtents.minY=Math.min(overlayExtents.minY,this._jsPlumb.overlayPlacements[i].minY);overlayExtents.maxY=Math.max(overlayExtents.maxY,this._jsPlumb.overlayPlacements[i].maxY);}}}var lineWidth=parseFloat(this._jsPlumb.paintStyleInUse.strokeWidth||1)/2,outlineWidth=parseFloat(this._jsPlumb.paintStyleInUse.strokeWidth||0),extents={xmin:Math.min(this.connector.bounds.minX-(lineWidth+outlineWidth),overlayExtents.minX),ymin:Math.min(this.connector.bounds.minY-(lineWidth+outlineWidth),overlayExtents.minY),xmax:Math.max(this.connector.bounds.maxX+(lineWidth+outlineWidth),overlayExtents.maxX),ymax:Math.max(this.connector.bounds.maxY+(lineWidth+outlineWidth),overlayExtents.maxY)};// paint the connector.\nthis.connector.paint(this._jsPlumb.paintStyleInUse,null,extents);// and then the overlays\nfor(var j in this._jsPlumb.overlays){if(this._jsPlumb.overlays.hasOwnProperty(j)){var p=this._jsPlumb.overlays[j];if(p.isVisible()){p.paint(this._jsPlumb.overlayPlacements[j],extents);}}}}this._jsPlumb.lastPaintedAt=timestamp;}},repaint:function repaint(params){params=params||{};this.paint({elId:this.sourceId,recalc:!(params.recalc===false),timestamp:params.timestamp});},prepareEndpoint:function prepareEndpoint(_jsPlumb,_newEndpoint,conn,existing,index,params,element,elementId){var e;if(existing){conn.endpoints[index]=existing;existing.addConnection(conn);}else{if(!params.endpoints){params.endpoints=[null,null];}var ep=params.endpoints[index]||params.endpoint||_jsPlumb.Defaults.Endpoints[index]||_jp.Defaults.Endpoints[index]||_jsPlumb.Defaults.Endpoint||_jp.Defaults.Endpoint;if(!params.endpointStyles){params.endpointStyles=[null,null];}if(!params.endpointHoverStyles){params.endpointHoverStyles=[null,null];}var es=params.endpointStyles[index]||params.endpointStyle||_jsPlumb.Defaults.EndpointStyles[index]||_jp.Defaults.EndpointStyles[index]||_jsPlumb.Defaults.EndpointStyle||_jp.Defaults.EndpointStyle;// Endpoints derive their fill from the connector\'s stroke, if no fill was specified.\nif(es.fill==null&&params.paintStyle!=null){es.fill=params.paintStyle.stroke;}if(es.outlineStroke==null&&params.paintStyle!=null){es.outlineStroke=params.paintStyle.outlineStroke;}if(es.outlineWidth==null&&params.paintStyle!=null){es.outlineWidth=params.paintStyle.outlineWidth;}var ehs=params.endpointHoverStyles[index]||params.endpointHoverStyle||_jsPlumb.Defaults.EndpointHoverStyles[index]||_jp.Defaults.EndpointHoverStyles[index]||_jsPlumb.Defaults.EndpointHoverStyle||_jp.Defaults.EndpointHoverStyle;// endpoint hover fill style is derived from connector\'s hover stroke style\nif(params.hoverPaintStyle!=null){if(ehs==null){ehs={};}if(ehs.fill==null){ehs.fill=params.hoverPaintStyle.stroke;}}var a=params.anchors?params.anchors[index]:params.anchor?params.anchor:_makeAnchor(_jsPlumb.Defaults.Anchors[index],elementId,_jsPlumb)||_makeAnchor(_jp.Defaults.Anchors[index],elementId,_jsPlumb)||_makeAnchor(_jsPlumb.Defaults.Anchor,elementId,_jsPlumb)||_makeAnchor(_jp.Defaults.Anchor,elementId,_jsPlumb),u=params.uuids?params.uuids[index]:null;e=_newEndpoint({paintStyle:es,hoverPaintStyle:ehs,endpoint:ep,connections:[conn],uuid:u,anchor:a,source:element,scope:params.scope,reattach:params.reattach||_jsPlumb.Defaults.ReattachConnections,detachable:params.detachable||_jsPlumb.Defaults.ConnectionsDetachable});if(existing==null){e.setDeleteOnEmpty(true);}conn.endpoints[index]=e;if(params.drawEndpoints===false){e.setVisible(false,true,true);}}return e;}});// END Connection class            \n}).call(typeof window!==\'undefined\'?window:this);/*\r\n * This file contains the code for creating and manipulating anchors.\r\n *\r\n * Copyright (c) 2010 - 2018 jsPlumb (hello@jsplumbtoolkit.com)\r\n *\r\n * https://jsplumbtoolkit.com\r\n * https://github.com/jsplumb/jsplumb\r\n *\r\n * Dual licensed under the MIT and GPL2 licenses.\r\n */;(function(){"use strict";var root=this,_ju=root.jsPlumbUtil,_jp=root.jsPlumb;//\n// manages anchors for all elements.\n//\n_jp.AnchorManager=function(params){var _amEndpoints={},continuousAnchorLocations={},userDefinedContinuousAnchorLocations={},continuousAnchorOrientations={},Orientation={HORIZONTAL:"horizontal",VERTICAL:"vertical",DIAGONAL:"diagonal",IDENTITY:"identity"},axes=["left","top","right","bottom"],connectionsByElementId={},self=this,anchorLists={},jsPlumbInstance=params.jsPlumbInstance,floatingConnections={},calculateOrientation=function calculateOrientation(sourceId,targetId,sd,td,sourceAnchor,targetAnchor){if(sourceId===targetId){return{orientation:Orientation.IDENTITY,a:["top","top"]};}var theta=Math.atan2(td.centery-sd.centery,td.centerx-sd.centerx),theta2=Math.atan2(sd.centery-td.centery,sd.centerx-td.centerx);// --------------------------------------------------------------------------------------\n// improved face calculation. get midpoints of each face for source and target, then put in an array with all combinations of\n// source/target faces. sort this array by distance between midpoints. the entry at index 0 is our preferred option. we can\n// go through the array one by one until we find an entry in which each requested face is supported.\nvar candidates=[],midpoints={};(function(types,dim){for(var i=0;i<types.length;i++){midpoints[types[i]]={"left":[dim[i].left,dim[i].centery],"right":[dim[i].right,dim[i].centery],"top":[dim[i].centerx,dim[i].top],"bottom":[dim[i].centerx,dim[i].bottom]};}})(["source","target"],[sd,td]);for(var sf=0;sf<axes.length;sf++){for(var tf=0;tf<axes.length;tf++){candidates.push({source:axes[sf],target:axes[tf],dist:Biltong.lineLength(midpoints.source[axes[sf]],midpoints.target[axes[tf]])});}}candidates.sort(function(a,b){return a.dist<b.dist?-1:a.dist>b.dist?1:0;});// now go through this list and try to get an entry that satisfies both (there will be one, unless one of the anchors\n// declares no available faces)\nvar sourceEdge=candidates[0].source,targetEdge=candidates[0].target;for(var i=0;i<candidates.length;i++){if(!sourceAnchor.isContinuous||sourceAnchor.isEdgeSupported(candidates[i].source)){sourceEdge=candidates[i].source;}else{sourceEdge=null;}if(!targetAnchor.isContinuous||targetAnchor.isEdgeSupported(candidates[i].target)){targetEdge=candidates[i].target;}else{targetEdge=null;}if(sourceEdge!=null&&targetEdge!=null){break;}}if(sourceAnchor.isContinuous){sourceAnchor.setCurrentFace(sourceEdge);}if(targetAnchor.isContinuous){targetAnchor.setCurrentFace(targetEdge);}// --------------------------------------------------------------------------------------\nreturn{a:[sourceEdge,targetEdge],theta:theta,theta2:theta2};},// used by placeAnchors function\nplaceAnchorsOnLine=function placeAnchorsOnLine(desc,elementDimensions,elementPosition,connections,horizontal,otherMultiplier,reverse){var a=[],step=elementDimensions[horizontal?0:1]/(connections.length+1);for(var i=0;i<connections.length;i++){var val=(i+1)*step,other=otherMultiplier*elementDimensions[horizontal?1:0];if(reverse){val=elementDimensions[horizontal?0:1]-val;}var dx=horizontal?val:other,x=elementPosition[0]+dx,xp=dx/elementDimensions[0],dy=horizontal?other:val,y=elementPosition[1]+dy,yp=dy/elementDimensions[1];a.push([x,y,xp,yp,connections[i][1],connections[i][2]]);}return a;},// used by edgeSortFunctions\ncurrySort=function currySort(reverseAngles){return function(a,b){var r=true;if(reverseAngles){r=a[0][0]<b[0][0];}else{r=a[0][0]>b[0][0];}return r===false?-1:1;};},// used by edgeSortFunctions\nleftSort=function leftSort(a,b){// first get adjusted values\nvar p1=a[0][0]<0?-Math.PI-a[0][0]:Math.PI-a[0][0],p2=b[0][0]<0?-Math.PI-b[0][0]:Math.PI-b[0][0];if(p1>p2){return 1;}else{return-1;}},// used by placeAnchors\nedgeSortFunctions={"top":function top(a,b){return a[0]>b[0]?1:-1;},"right":currySort(true),"bottom":currySort(true),"left":leftSort},// used by placeAnchors\n_sortHelper=function _sortHelper(_array,_fn){return _array.sort(_fn);},// used by AnchorManager.redraw\nplaceAnchors=function placeAnchors(elementId,_anchorLists){var cd=jsPlumbInstance.getCachedData(elementId),sS=cd.s,sO=cd.o,placeSomeAnchors=function placeSomeAnchors(desc,elementDimensions,elementPosition,unsortedConnections,isHorizontal,otherMultiplier,orientation){if(unsortedConnections.length>0){var sc=_sortHelper(unsortedConnections,edgeSortFunctions[desc]),// puts them in order based on the target element\'s pos on screen\nreverse=desc==="right"||desc==="top",anchors=placeAnchorsOnLine(desc,elementDimensions,elementPosition,sc,isHorizontal,otherMultiplier,reverse);// takes a computed anchor position and adjusts it for parent offset and scroll, then stores it.\nvar _setAnchorLocation=function _setAnchorLocation(endpoint,anchorPos){continuousAnchorLocations[endpoint.id]=[anchorPos[0],anchorPos[1],anchorPos[2],anchorPos[3]];continuousAnchorOrientations[endpoint.id]=orientation;};for(var i=0;i<anchors.length;i++){var c=anchors[i][4],weAreSource=c.endpoints[0].elementId===elementId,weAreTarget=c.endpoints[1].elementId===elementId;if(weAreSource){_setAnchorLocation(c.endpoints[0],anchors[i]);}if(weAreTarget){_setAnchorLocation(c.endpoints[1],anchors[i]);}}}};placeSomeAnchors("bottom",sS,[sO.left,sO.top],_anchorLists.bottom,true,1,[0,1]);placeSomeAnchors("top",sS,[sO.left,sO.top],_anchorLists.top,true,0,[0,-1]);placeSomeAnchors("left",sS,[sO.left,sO.top],_anchorLists.left,false,0,[-1,0]);placeSomeAnchors("right",sS,[sO.left,sO.top],_anchorLists.right,false,1,[1,0]);};this.reset=function(){_amEndpoints={};connectionsByElementId={};anchorLists={};};this.addFloatingConnection=function(key,conn){floatingConnections[key]=conn;};this.removeFloatingConnection=function(key){delete floatingConnections[key];};this.newConnection=function(conn){var sourceId=conn.sourceId,targetId=conn.targetId,ep=conn.endpoints,doRegisterTarget=true,registerConnection=function registerConnection(otherIndex,otherEndpoint,otherAnchor,elId,c){if(sourceId===targetId&&otherAnchor.isContinuous){// remove the target endpoint\'s canvas.  we dont need it.\nconn._jsPlumb.instance.removeElement(ep[1].canvas);doRegisterTarget=false;}_ju.addToList(connectionsByElementId,elId,[c,otherEndpoint,otherAnchor.constructor===_jp.DynamicAnchor]);};registerConnection(0,ep[0],ep[0].anchor,targetId,conn);if(doRegisterTarget){registerConnection(1,ep[1],ep[1].anchor,sourceId,conn);}};var removeEndpointFromAnchorLists=function removeEndpointFromAnchorLists(endpoint){(function(list,eId){if(list){// transient anchors dont get entries in this list.\nvar f=function f(e){return e[4]===eId;};_ju.removeWithFunction(list.top,f);_ju.removeWithFunction(list.left,f);_ju.removeWithFunction(list.bottom,f);_ju.removeWithFunction(list.right,f);}})(anchorLists[endpoint.elementId],endpoint.id);};this.connectionDetached=function(connInfo,doNotRedraw){var connection=connInfo.connection||connInfo,sourceId=connInfo.sourceId,targetId=connInfo.targetId,ep=connection.endpoints,removeConnection=function removeConnection(otherIndex,otherEndpoint,otherAnchor,elId,c){_ju.removeWithFunction(connectionsByElementId[elId],function(_c){return _c[0].id===c.id;});};removeConnection(1,ep[1],ep[1].anchor,sourceId,connection);removeConnection(0,ep[0],ep[0].anchor,targetId,connection);if(connection.floatingId){removeConnection(connection.floatingIndex,connection.floatingEndpoint,connection.floatingEndpoint.anchor,connection.floatingId,connection);removeEndpointFromAnchorLists(connection.floatingEndpoint);}// remove from anchorLists            \nremoveEndpointFromAnchorLists(connection.endpoints[0]);removeEndpointFromAnchorLists(connection.endpoints[1]);if(!doNotRedraw){self.redraw(connection.sourceId);if(connection.targetId!==connection.sourceId){self.redraw(connection.targetId);}}};this.add=function(endpoint,elementId){_ju.addToList(_amEndpoints,elementId,endpoint);};this.changeId=function(oldId,newId){connectionsByElementId[newId]=connectionsByElementId[oldId];_amEndpoints[newId]=_amEndpoints[oldId];delete connectionsByElementId[oldId];delete _amEndpoints[oldId];};this.getConnectionsFor=function(elementId){return connectionsByElementId[elementId]||[];};this.getEndpointsFor=function(elementId){return _amEndpoints[elementId]||[];};this.deleteEndpoint=function(endpoint){_ju.removeWithFunction(_amEndpoints[endpoint.elementId],function(e){return e.id===endpoint.id;});removeEndpointFromAnchorLists(endpoint);};this.clearFor=function(elementId){delete _amEndpoints[elementId];_amEndpoints[elementId]=[];};// updates the given anchor list by either updating an existing anchor\'s info, or adding it. this function\n// also removes the anchor from its previous list, if the edge it is on has changed.\n// all connections found along the way (those that are connected to one of the faces this function\n// operates on) are added to the connsToPaint list, as are their endpoints. in this way we know to repaint\n// them wthout having to calculate anything else about them.\nvar _updateAnchorList=function _updateAnchorList(lists,theta,order,conn,aBoolean,otherElId,idx,reverse,edgeId,elId,connsToPaint,endpointsToPaint){// first try to find the exact match, but keep track of the first index of a matching element id along the way.s\nvar exactIdx=-1,firstMatchingElIdx=-1,endpoint=conn.endpoints[idx],endpointId=endpoint.id,oIdx=[1,0][idx],values=[[theta,order],conn,aBoolean,otherElId,endpointId],listToAddTo=lists[edgeId],listToRemoveFrom=endpoint._continuousAnchorEdge?lists[endpoint._continuousAnchorEdge]:null,i,candidate;if(listToRemoveFrom){var rIdx=_ju.findWithFunction(listToRemoveFrom,function(e){return e[4]===endpointId;});if(rIdx!==-1){listToRemoveFrom.splice(rIdx,1);// get all connections from this list\nfor(i=0;i<listToRemoveFrom.length;i++){candidate=listToRemoveFrom[i][1];_ju.addWithFunction(connsToPaint,candidate,function(c){return c.id===candidate.id;});_ju.addWithFunction(endpointsToPaint,listToRemoveFrom[i][1].endpoints[idx],function(e){return e.id===candidate.endpoints[idx].id;});_ju.addWithFunction(endpointsToPaint,listToRemoveFrom[i][1].endpoints[oIdx],function(e){return e.id===candidate.endpoints[oIdx].id;});}}}for(i=0;i<listToAddTo.length;i++){candidate=listToAddTo[i][1];if(params.idx===1&&listToAddTo[i][3]===otherElId&&firstMatchingElIdx===-1){firstMatchingElIdx=i;}_ju.addWithFunction(connsToPaint,candidate,function(c){return c.id===candidate.id;});_ju.addWithFunction(endpointsToPaint,listToAddTo[i][1].endpoints[idx],function(e){return e.id===candidate.endpoints[idx].id;});_ju.addWithFunction(endpointsToPaint,listToAddTo[i][1].endpoints[oIdx],function(e){return e.id===candidate.endpoints[oIdx].id;});}if(exactIdx!==-1){listToAddTo[exactIdx]=values;}else{var insertIdx=reverse?firstMatchingElIdx!==-1?firstMatchingElIdx:0:listToAddTo.length;// of course we will get this from having looked through the array shortly.\nlistToAddTo.splice(insertIdx,0,values);}// store this for next time.\nendpoint._continuousAnchorEdge=edgeId;};//\n// find the entry in an endpoint\'s list for this connection and update its target endpoint\n// with the current target in the connection.\n// This method and sourceChanged need to be folder into one.\n//\nthis.updateOtherEndpoint=function(sourceElId,oldTargetId,newTargetId,connection){var sIndex=_ju.findWithFunction(connectionsByElementId[sourceElId],function(i){return i[0].id===connection.id;}),tIndex=_ju.findWithFunction(connectionsByElementId[oldTargetId],function(i){return i[0].id===connection.id;});// update or add data for source\nif(sIndex!==-1){connectionsByElementId[sourceElId][sIndex][0]=connection;connectionsByElementId[sourceElId][sIndex][1]=connection.endpoints[1];connectionsByElementId[sourceElId][sIndex][2]=connection.endpoints[1].anchor.constructor===_jp.DynamicAnchor;}// remove entry for previous target (if there)\nif(tIndex>-1){connectionsByElementId[oldTargetId].splice(tIndex,1);// add entry for new target\n_ju.addToList(connectionsByElementId,newTargetId,[connection,connection.endpoints[0],connection.endpoints[0].anchor.constructor===_jp.DynamicAnchor]);}connection.updateConnectedClass();};//\n// notification that the connection given has changed source from the originalId to the newId.\n// This involves:\n// 1. removing the connection from the list of connections stored for the originalId\n// 2. updating the source information for the target of the connection\n// 3. re-registering the connection in connectionsByElementId with the newId\n//\nthis.sourceChanged=function(originalId,newId,connection,newElement){if(originalId!==newId){connection.sourceId=newId;connection.source=newElement;// remove the entry that points from the old source to the target\n_ju.removeWithFunction(connectionsByElementId[originalId],function(info){return info[0].id===connection.id;});// find entry for target and update it\nvar tIdx=_ju.findWithFunction(connectionsByElementId[connection.targetId],function(i){return i[0].id===connection.id;});if(tIdx>-1){connectionsByElementId[connection.targetId][tIdx][0]=connection;connectionsByElementId[connection.targetId][tIdx][1]=connection.endpoints[0];connectionsByElementId[connection.targetId][tIdx][2]=connection.endpoints[0].anchor.constructor===_jp.DynamicAnchor;}// add entry for new source\n_ju.addToList(connectionsByElementId,newId,[connection,connection.endpoints[1],connection.endpoints[1].anchor.constructor===_jp.DynamicAnchor]);// TODO SP not final on this yet. when a user drags an existing connection and it turns into a self\n// loop, then this code hides the target endpoint (by removing it from the DOM) But I think this should\n// occur only if the anchor is Continuous\nif(connection.endpoints[1].anchor.isContinuous){if(connection.source===connection.target){connection._jsPlumb.instance.removeElement(connection.endpoints[1].canvas);}else{if(connection.endpoints[1].canvas.parentNode==null){connection._jsPlumb.instance.appendElement(connection.endpoints[1].canvas);}}}connection.updateConnectedClass();}};//\n// moves the given endpoint from `currentId` to `element`.\n// This involves:\n//\n// 1. changing the key in _amEndpoints under which the endpoint is stored\n// 2. changing the source or target values in all of the endpoint\'s connections\n// 3. changing the array in connectionsByElementId in which the endpoint\'s connections\n//    are stored (done by either sourceChanged or updateOtherEndpoint)\n//\nthis.rehomeEndpoint=function(ep,currentId,element){var eps=_amEndpoints[currentId]||[],elementId=jsPlumbInstance.getId(element);if(elementId!==currentId){var idx=eps.indexOf(ep);if(idx>-1){var _ep=eps.splice(idx,1)[0];self.add(_ep,elementId);}}for(var i=0;i<ep.connections.length;i++){if(ep.connections[i].sourceId===currentId){self.sourceChanged(currentId,ep.elementId,ep.connections[i],ep.element);}else if(ep.connections[i].targetId===currentId){ep.connections[i].targetId=ep.elementId;ep.connections[i].target=ep.element;self.updateOtherEndpoint(ep.connections[i].sourceId,currentId,ep.elementId,ep.connections[i]);}}};this.redraw=function(elementId,ui,timestamp,offsetToUI,clearEdits,doNotRecalcEndpoint){if(!jsPlumbInstance.isSuspendDrawing()){// get all the endpoints for this element\nvar ep=_amEndpoints[elementId]||[],endpointConnections=connectionsByElementId[elementId]||[],connectionsToPaint=[],endpointsToPaint=[],anchorsToUpdate=[];timestamp=timestamp||jsPlumbInstance.timestamp();// offsetToUI are values that would have been calculated in the dragManager when registering\n// an endpoint for an element that had a parent (somewhere in the hierarchy) that had been\n// registered as draggable.\noffsetToUI=offsetToUI||{left:0,top:0};if(ui){ui={left:ui.left+offsetToUI.left,top:ui.top+offsetToUI.top};}// valid for one paint cycle.\nvar myOffset=jsPlumbInstance.updateOffset({elId:elementId,offset:ui,recalc:false,timestamp:timestamp}),orientationCache={};// actually, first we should compute the orientation of this element to all other elements to which\n// this element is connected with a continuous anchor (whether both ends of the connection have\n// a continuous anchor or just one)\nfor(var i=0;i<endpointConnections.length;i++){var conn=endpointConnections[i][0],sourceId=conn.sourceId,targetId=conn.targetId,sourceContinuous=conn.endpoints[0].anchor.isContinuous,targetContinuous=conn.endpoints[1].anchor.isContinuous;if(sourceContinuous||targetContinuous){var oKey=sourceId+"_"+targetId,o=orientationCache[oKey],oIdx=conn.sourceId===elementId?1:0;if(sourceContinuous&&!anchorLists[sourceId]){anchorLists[sourceId]={top:[],right:[],bottom:[],left:[]};}if(targetContinuous&&!anchorLists[targetId]){anchorLists[targetId]={top:[],right:[],bottom:[],left:[]};}if(elementId!==targetId){jsPlumbInstance.updateOffset({elId:targetId,timestamp:timestamp});}if(elementId!==sourceId){jsPlumbInstance.updateOffset({elId:sourceId,timestamp:timestamp});}var td=jsPlumbInstance.getCachedData(targetId),sd=jsPlumbInstance.getCachedData(sourceId);if(targetId===sourceId&&(sourceContinuous||targetContinuous)){// here we may want to improve this by somehow determining the face we\'d like\n// to put the connector on.  ideally, when drawing, the face should be calculated\n// by determining which face is closest to the point at which the mouse button\n// was released.  for now, we\'re putting it on the top face.\n_updateAnchorList(anchorLists[sourceId],-Math.PI/2,0,conn,false,targetId,0,false,"top",sourceId,connectionsToPaint,endpointsToPaint);_updateAnchorList(anchorLists[targetId],-Math.PI/2,0,conn,false,sourceId,1,false,"top",targetId,connectionsToPaint,endpointsToPaint);}else{if(!o){o=calculateOrientation(sourceId,targetId,sd.o,td.o,conn.endpoints[0].anchor,conn.endpoints[1].anchor);orientationCache[oKey]=o;// this would be a performance enhancement, but the computed angles need to be clamped to\n//the (-PI/2 -> PI/2) range in order for the sorting to work properly.\n/*  orientationCache[oKey2] = {\r\n                                 orientation:o.orientation,\r\n                                 a:[o.a[1], o.a[0]],\r\n                                 theta:o.theta + Math.PI,\r\n                                 theta2:o.theta2 + Math.PI\r\n                                 };*/}if(sourceContinuous){_updateAnchorList(anchorLists[sourceId],o.theta,0,conn,false,targetId,0,false,o.a[0],sourceId,connectionsToPaint,endpointsToPaint);}if(targetContinuous){_updateAnchorList(anchorLists[targetId],o.theta2,-1,conn,true,sourceId,1,true,o.a[1],targetId,connectionsToPaint,endpointsToPaint);}}if(sourceContinuous){_ju.addWithFunction(anchorsToUpdate,sourceId,function(a){return a===sourceId;});}if(targetContinuous){_ju.addWithFunction(anchorsToUpdate,targetId,function(a){return a===targetId;});}_ju.addWithFunction(connectionsToPaint,conn,function(c){return c.id===conn.id;});if(sourceContinuous&&oIdx===0||targetContinuous&&oIdx===1){_ju.addWithFunction(endpointsToPaint,conn.endpoints[oIdx],function(e){return e.id===conn.endpoints[oIdx].id;});}}}// place Endpoints whose anchors are continuous but have no Connections\nfor(i=0;i<ep.length;i++){if(ep[i].connections.length===0&&ep[i].anchor.isContinuous){if(!anchorLists[elementId]){anchorLists[elementId]={top:[],right:[],bottom:[],left:[]};}_updateAnchorList(anchorLists[elementId],-Math.PI/2,0,{endpoints:[ep[i],ep[i]],paint:function paint(){}},false,elementId,0,false,ep[i].anchor.getDefaultFace(),elementId,connectionsToPaint,endpointsToPaint);_ju.addWithFunction(anchorsToUpdate,elementId,function(a){return a===elementId;});}}// now place all the continuous anchors we need to;\nfor(i=0;i<anchorsToUpdate.length;i++){placeAnchors(anchorsToUpdate[i],anchorLists[anchorsToUpdate[i]]);}// now that continuous anchors have been placed, paint all the endpoints for this element\n// TODO performance: add the endpoint ids to a temp array, and then when iterating in the next\n// loop, check that we didn\'t just paint that endpoint. we can probably shave off a few more milliseconds this way.\nfor(i=0;i<ep.length;i++){ep[i].paint({timestamp:timestamp,offset:myOffset,dimensions:myOffset.s,recalc:doNotRecalcEndpoint!==true});}// ... and any other endpoints we came across as a result of the continuous anchors.\nfor(i=0;i<endpointsToPaint.length;i++){var cd=jsPlumbInstance.getCachedData(endpointsToPaint[i].elementId);endpointsToPaint[i].paint({timestamp:timestamp,offset:cd,dimensions:cd.s});}// paint all the standard and "dynamic connections", which are connections whose other anchor is\n// static and therefore does need to be recomputed; we make sure that happens only one time.\n// TODO we could have compiled a list of these in the first pass through connections; might save some time.\nfor(i=0;i<endpointConnections.length;i++){var otherEndpoint=endpointConnections[i][1];if(otherEndpoint.anchor.constructor===_jp.DynamicAnchor){otherEndpoint.paint({elementWithPrecedence:elementId,timestamp:timestamp});_ju.addWithFunction(connectionsToPaint,endpointConnections[i][0],function(c){return c.id===endpointConnections[i][0].id;});// all the connections for the other endpoint now need to be repainted\nfor(var k=0;k<otherEndpoint.connections.length;k++){if(otherEndpoint.connections[k]!==endpointConnections[i][0]){_ju.addWithFunction(connectionsToPaint,otherEndpoint.connections[k],function(c){return c.id===otherEndpoint.connections[k].id;});}}}else{_ju.addWithFunction(connectionsToPaint,endpointConnections[i][0],function(c){return c.id===endpointConnections[i][0].id;});}}// paint current floating connection for this element, if there is one.\nvar fc=floatingConnections[elementId];if(fc){fc.paint({timestamp:timestamp,recalc:false,elId:elementId});}// paint all the connections\nfor(i=0;i<connectionsToPaint.length;i++){connectionsToPaint[i].paint({elId:elementId,timestamp:timestamp,recalc:false,clearEdits:clearEdits});}}};var ContinuousAnchor=function ContinuousAnchor(anchorParams){_ju.EventGenerator.apply(this);this.type="Continuous";this.isDynamic=true;this.isContinuous=true;var faces=anchorParams.faces||["top","right","bottom","left"],clockwise=!(anchorParams.clockwise===false),availableFaces={},opposites={"top":"bottom","right":"left","left":"right","bottom":"top"},clockwiseOptions={"top":"right","right":"bottom","left":"top","bottom":"left"},antiClockwiseOptions={"top":"left","right":"top","left":"bottom","bottom":"right"},secondBest=clockwise?clockwiseOptions:antiClockwiseOptions,lastChoice=clockwise?antiClockwiseOptions:clockwiseOptions,cssClass=anchorParams.cssClass||"",_currentFace=null,_lockedFace=null,X_AXIS_FACES=["left","right"],Y_AXIS_FACES=["top","bottom"],_lockedAxis=null;for(var i=0;i<faces.length;i++){availableFaces[faces[i]]=true;}this.getDefaultFace=function(){return faces.length===0?"top":faces[0];};// if the given edge is supported, returns it. otherwise looks for a substitute that _is_\n// supported. if none supported we also return the request edge.\nthis.verifyEdge=function(edge){if(availableFaces[edge]){return edge;}else if(availableFaces[opposites[edge]]){return opposites[edge];}else if(availableFaces[secondBest[edge]]){return secondBest[edge];}else if(availableFaces[lastChoice[edge]]){return lastChoice[edge];}return edge;// we have to give them something.\n};this.isEdgeSupported=function(edge){return _lockedAxis==null?_lockedFace==null?availableFaces[edge]===true:_lockedFace===edge:_lockedAxis.indexOf(edge)!==-1;};this.setCurrentFace=function(face){_currentFace=face;};this.getCurrentFace=function(){return _currentFace;};this.lockCurrentFace=function(){_lockedFace=_currentFace;};this.unlockCurrentFace=function(){_lockedFace=null;};this.lockCurrentAxis=function(){if(_currentFace!=null){_lockedAxis=_currentFace==="left"||_currentFace==="right"?X_AXIS_FACES:Y_AXIS_FACES;}};this.unlockCurrentAxis=function(){_lockedAxis=null;};this.compute=function(params){return userDefinedContinuousAnchorLocations[params.element.id]||continuousAnchorLocations[params.element.id]||[0,0];};this.getCurrentLocation=function(params){return userDefinedContinuousAnchorLocations[params.element.id]||continuousAnchorLocations[params.element.id]||[0,0];};this.getOrientation=function(endpoint){return continuousAnchorOrientations[endpoint.id]||[0,0];};this.clearUserDefinedLocation=function(){delete userDefinedContinuousAnchorLocations[anchorParams.elementId];};this.setUserDefinedLocation=function(loc){userDefinedContinuousAnchorLocations[anchorParams.elementId]=loc;};this.getCssClass=function(){return cssClass;};};// continuous anchors\njsPlumbInstance.continuousAnchorFactory={get:function get(params){return new ContinuousAnchor(params);},clear:function clear(elementId){delete userDefinedContinuousAnchorLocations[elementId];delete continuousAnchorLocations[elementId];}};};/**\r\n     * Anchors model a position on some element at which an Endpoint may be located.  They began as a first class citizen of jsPlumb, ie. a user\r\n     * was required to create these themselves, but over time this has been replaced by the concept of referring to them either by name (eg. "TopMiddle"),\r\n     * or by an array describing their coordinates (eg. [ 0, 0.5, 0, -1 ], which is the same as "TopMiddle").  jsPlumb now handles all of the\r\n     * creation of Anchors without user intervention.\r\n     */_jp.Anchor=function(params){this.x=params.x||0;this.y=params.y||0;this.elementId=params.elementId;this.cssClass=params.cssClass||"";this.userDefinedLocation=null;this.orientation=params.orientation||[0,0];this.lastReturnValue=null;this.offsets=params.offsets||[0,0];this.timestamp=null;_ju.EventGenerator.apply(this);this.compute=function(params){var xy=params.xy,wh=params.wh,timestamp=params.timestamp;if(params.clearUserDefinedLocation){this.userDefinedLocation=null;}if(timestamp&&timestamp===this.timestamp){return this.lastReturnValue;}if(this.userDefinedLocation!=null){this.lastReturnValue=this.userDefinedLocation;}else{this.lastReturnValue=[xy[0]+this.x*wh[0]+this.offsets[0],xy[1]+this.y*wh[1]+this.offsets[1]];}this.timestamp=timestamp;return this.lastReturnValue;};this.getCurrentLocation=function(params){params=params||{};return this.lastReturnValue==null||params.timestamp!=null&&this.timestamp!==params.timestamp?this.compute(params):this.lastReturnValue;};};_ju.extend(_jp.Anchor,_ju.EventGenerator,{equals:function equals(anchor){if(!anchor){return false;}var ao=anchor.getOrientation(),o=this.getOrientation();return this.x===anchor.x&&this.y===anchor.y&&this.offsets[0]===anchor.offsets[0]&&this.offsets[1]===anchor.offsets[1]&&o[0]===ao[0]&&o[1]===ao[1];},getUserDefinedLocation:function getUserDefinedLocation(){return this.userDefinedLocation;},setUserDefinedLocation:function setUserDefinedLocation(l){this.userDefinedLocation=l;},clearUserDefinedLocation:function clearUserDefinedLocation(){this.userDefinedLocation=null;},getOrientation:function getOrientation(){return this.orientation;},getCssClass:function getCssClass(){return this.cssClass;}});/**\r\n     * An Anchor that floats. its orientation is computed dynamically from\r\n     * its position relative to the anchor it is floating relative to.  It is used when creating\r\n     * a connection through drag and drop.\r\n     *\r\n     * TODO FloatingAnchor could totally be refactored to extend Anchor just slightly.\r\n     */_jp.FloatingAnchor=function(params){_jp.Anchor.apply(this,arguments);// this is the anchor that this floating anchor is referenced to for\n// purposes of calculating the orientation.\nvar ref=params.reference,// the canvas this refers to.\nrefCanvas=params.referenceCanvas,size=_jp.getSize(refCanvas),// these are used to store the current relative position of our\n// anchor wrt the reference anchor. they only indicate\n// direction, so have a value of 1 or -1 (or, very rarely, 0). these\n// values are written by the compute method, and read\n// by the getOrientation method.\nxDir=0,yDir=0,// temporary member used to store an orientation when the floating\n// anchor is hovering over another anchor.\norientation=null,_lastResult=null;// clear from parent. we want floating anchor orientation to always be computed.\nthis.orientation=null;// set these to 0 each; they are used by certain types of connectors in the loopback case,\n// when the connector is trying to clear the element it is on. but for floating anchor it\'s not\n// very important.\nthis.x=0;this.y=0;this.isFloating=true;this.compute=function(params){var xy=params.xy,result=[xy[0]+size[0]/2,xy[1]+size[1]/2];// return origin of the element. we may wish to improve this so that any object can be the drag proxy.\n_lastResult=result;return result;};this.getOrientation=function(_endpoint){if(orientation){return orientation;}else{var o=ref.getOrientation(_endpoint);// here we take into account the orientation of the other\n// anchor: if it declares zero for some direction, we declare zero too. this might not be the most awesome. perhaps we can come\n// up with a better way. it\'s just so that the line we draw looks like it makes sense. maybe this wont make sense.\nreturn[Math.abs(o[0])*xDir*-1,Math.abs(o[1])*yDir*-1];}};/**\r\n         * notification the endpoint associated with this anchor is hovering\r\n         * over another anchor; we want to assume that anchor\'s orientation\r\n         * for the duration of the hover.\r\n         */this.over=function(anchor,endpoint){orientation=anchor.getOrientation(endpoint);};/**\r\n         * notification the endpoint associated with this anchor is no\r\n         * longer hovering over another anchor; we should resume calculating\r\n         * orientation as we normally do.\r\n         */this.out=function(){orientation=null;};this.getCurrentLocation=function(params){return _lastResult==null?this.compute(params):_lastResult;};};_ju.extend(_jp.FloatingAnchor,_jp.Anchor);var _convertAnchor=function _convertAnchor(anchor,jsPlumbInstance,elementId){return anchor.constructor===_jp.Anchor?anchor:jsPlumbInstance.makeAnchor(anchor,elementId,jsPlumbInstance);};/* \r\n     * A DynamicAnchor is an Anchor that contains a list of other Anchors, which it cycles\r\n     * through at compute time to find the one that is located closest to\r\n     * the center of the target element, and returns that Anchor\'s compute\r\n     * method result. this causes endpoints to follow each other with\r\n     * respect to the orientation of their target elements, which is a useful\r\n     * feature for some applications.\r\n     * \r\n     */_jp.DynamicAnchor=function(params){_jp.Anchor.apply(this,arguments);this.isDynamic=true;this.anchors=[];this.elementId=params.elementId;this.jsPlumbInstance=params.jsPlumbInstance;for(var i=0;i<params.anchors.length;i++){this.anchors[i]=_convertAnchor(params.anchors[i],this.jsPlumbInstance,this.elementId);}this.getAnchors=function(){return this.anchors;};this.locked=false;var _curAnchor=this.anchors.length>0?this.anchors[0]:null,_lastAnchor=_curAnchor,self=this,// helper method to calculate the distance between the centers of the two elements.\n_distance=function _distance(anchor,cx,cy,xy,wh){var ax=xy[0]+anchor.x*wh[0],ay=xy[1]+anchor.y*wh[1],acx=xy[0]+wh[0]/2,acy=xy[1]+wh[1]/2;return Math.sqrt(Math.pow(cx-ax,2)+Math.pow(cy-ay,2))+Math.sqrt(Math.pow(acx-ax,2)+Math.pow(acy-ay,2));},// default method uses distance between element centers.  you can provide your own method in the dynamic anchor\n// constructor (and also to jsPlumb.makeDynamicAnchor). the arguments to it are four arrays:\n// xy - xy loc of the anchor\'s element\n// wh - anchor\'s element\'s dimensions\n// txy - xy loc of the element of the other anchor in the connection\n// twh - dimensions of the element of the other anchor in the connection.\n// anchors - the list of selectable anchors\n_anchorSelector=params.selector||function(xy,wh,txy,twh,anchors){var cx=txy[0]+twh[0]/2,cy=txy[1]+twh[1]/2;var minIdx=-1,minDist=Infinity;for(var i=0;i<anchors.length;i++){var d=_distance(anchors[i],cx,cy,xy,wh);if(d<minDist){minIdx=i+0;minDist=d;}}return anchors[minIdx];};this.compute=function(params){var xy=params.xy,wh=params.wh,txy=params.txy,twh=params.twh;this.timestamp=params.timestamp;var udl=self.getUserDefinedLocation();if(udl!=null){return udl;}// if anchor is locked or an opposite element was not given, we\n// maintain our state. anchor will be locked\n// if it is the source of a drag and drop.\nif(this.locked||txy==null||twh==null){return _curAnchor.compute(params);}else{params.timestamp=null;// otherwise clear this, i think. we want the anchor to compute.\n}_curAnchor=_anchorSelector(xy,wh,txy,twh,this.anchors);this.x=_curAnchor.x;this.y=_curAnchor.y;if(_curAnchor!==_lastAnchor){this.fire("anchorChanged",_curAnchor);}_lastAnchor=_curAnchor;return _curAnchor.compute(params);};this.getCurrentLocation=function(params){return this.getUserDefinedLocation()||(_curAnchor!=null?_curAnchor.getCurrentLocation(params):null);};this.getOrientation=function(_endpoint){return _curAnchor!=null?_curAnchor.getOrientation(_endpoint):[0,0];};this.over=function(anchor,endpoint){if(_curAnchor!=null){_curAnchor.over(anchor,endpoint);}};this.out=function(){if(_curAnchor!=null){_curAnchor.out();}};this.getCssClass=function(){return _curAnchor&&_curAnchor.getCssClass()||"";};};_ju.extend(_jp.DynamicAnchor,_jp.Anchor);// -------- basic anchors ------------------    \nvar _curryAnchor=function _curryAnchor(x,y,ox,oy,type,fnInit){_jp.Anchors[type]=function(params){var a=params.jsPlumbInstance.makeAnchor([x,y,ox,oy,0,0],params.elementId,params.jsPlumbInstance);a.type=type;if(fnInit){fnInit(a,params);}return a;};};_curryAnchor(0.5,0,0,-1,"TopCenter");_curryAnchor(0.5,1,0,1,"BottomCenter");_curryAnchor(0,0.5,-1,0,"LeftMiddle");_curryAnchor(1,0.5,1,0,"RightMiddle");_curryAnchor(0.5,0,0,-1,"Top");_curryAnchor(0.5,1,0,1,"Bottom");_curryAnchor(0,0.5,-1,0,"Left");_curryAnchor(1,0.5,1,0,"Right");_curryAnchor(0.5,0.5,0,0,"Center");_curryAnchor(1,0,0,-1,"TopRight");_curryAnchor(1,1,0,1,"BottomRight");_curryAnchor(0,0,0,-1,"TopLeft");_curryAnchor(0,1,0,1,"BottomLeft");// ------- dynamic anchors -------------------    \n// default dynamic anchors chooses from Top, Right, Bottom, Left\n_jp.Defaults.DynamicAnchors=function(params){return params.jsPlumbInstance.makeAnchors(["TopCenter","RightMiddle","BottomCenter","LeftMiddle"],params.elementId,params.jsPlumbInstance);};// default dynamic anchors bound to name \'AutoDefault\'\n_jp.Anchors.AutoDefault=function(params){var a=params.jsPlumbInstance.makeDynamicAnchor(_jp.Defaults.DynamicAnchors(params));a.type="AutoDefault";return a;};// ------- continuous anchors -------------------    \nvar _curryContinuousAnchor=function _curryContinuousAnchor(type,faces){_jp.Anchors[type]=function(params){var a=params.jsPlumbInstance.makeAnchor(["Continuous",{faces:faces}],params.elementId,params.jsPlumbInstance);a.type=type;return a;};};_jp.Anchors.Continuous=function(params){return params.jsPlumbInstance.continuousAnchorFactory.get(params);};_curryContinuousAnchor("ContinuousLeft",["left"]);_curryContinuousAnchor("ContinuousTop",["top"]);_curryContinuousAnchor("ContinuousBottom",["bottom"]);_curryContinuousAnchor("ContinuousRight",["right"]);// ------- position assign anchors -------------------    \n// this anchor type lets you assign the position at connection time.\n_curryAnchor(0,0,0,0,"Assign",function(anchor,params){// find what to use as the "position finder". the user may have supplied a String which represents\n// the id of a position finder in jsPlumb.AnchorPositionFinders, or the user may have supplied the\n// position finder as a function.  we find out what to use and then set it on the anchor.\nvar pf=params.position||"Fixed";anchor.positionFinder=pf.constructor===String?params.jsPlumbInstance.AnchorPositionFinders[pf]:pf;// always set the constructor params; the position finder might need them later (the Grid one does,\n// for example)\nanchor.constructorParams=params;});// these are the default anchor positions finders, which are used by the makeTarget function.  supplying\n// a position finder argument to that function allows you to specify where the resulting anchor will\n// be located\nroot.jsPlumbInstance.prototype.AnchorPositionFinders={"Fixed":function Fixed(dp,ep,es){return[(dp.left-ep.left)/es[0],(dp.top-ep.top)/es[1]];},"Grid":function Grid(dp,ep,es,params){var dx=dp.left-ep.left,dy=dp.top-ep.top,gx=es[0]/params.grid[0],gy=es[1]/params.grid[1],mx=Math.floor(dx/gx),my=Math.floor(dy/gy);return[(mx*gx+gx/2)/es[0],(my*gy+gy/2)/es[1]];}};// ------- perimeter anchors -------------------    \n_jp.Anchors.Perimeter=function(params){params=params||{};var anchorCount=params.anchorCount||60,shape=params.shape;if(!shape){throw new Error("no shape supplied to Perimeter Anchor type");}var _circle=function _circle(){var r=0.5,step=Math.PI*2/anchorCount,current=0,a=[];for(var i=0;i<anchorCount;i++){var x=r+r*Math.sin(current),y=r+r*Math.cos(current);a.push([x,y,0,0]);current+=step;}return a;},_path=function _path(segments){var anchorsPerFace=anchorCount/segments.length,a=[],_computeFace=function _computeFace(x1,y1,x2,y2,fractionalLength){anchorsPerFace=anchorCount*fractionalLength;var dx=(x2-x1)/anchorsPerFace,dy=(y2-y1)/anchorsPerFace;for(var i=0;i<anchorsPerFace;i++){a.push([x1+dx*i,y1+dy*i,0,0]);}};for(var i=0;i<segments.length;i++){_computeFace.apply(null,segments[i]);}return a;},_shape=function _shape(faces){var s=[];for(var i=0;i<faces.length;i++){s.push([faces[i][0],faces[i][1],faces[i][2],faces[i][3],1/faces.length]);}return _path(s);},_rectangle=function _rectangle(){return _shape([[0,0,1,0],[1,0,1,1],[1,1,0,1],[0,1,0,0]]);};var _shapes={"Circle":_circle,"Ellipse":_circle,"Diamond":function Diamond(){return _shape([[0.5,0,1,0.5],[1,0.5,0.5,1],[0.5,1,0,0.5],[0,0.5,0.5,0]]);},"Rectangle":_rectangle,"Square":_rectangle,"Triangle":function Triangle(){return _shape([[0.5,0,1,1],[1,1,0,1],[0,1,0.5,0]]);},"Path":function Path(params){var points=params.points,p=[],tl=0;for(var i=0;i<points.length-1;i++){var l=Math.sqrt(Math.pow(points[i][2]-points[i][0])+Math.pow(points[i][3]-points[i][1]));tl+=l;p.push([points[i][0],points[i][1],points[i+1][0],points[i+1][1],l]);}for(var j=0;j<p.length;j++){p[j][4]=p[j][4]/tl;}return _path(p);}},_rotate=function _rotate(points,amountInDegrees){var o=[],theta=amountInDegrees/180*Math.PI;for(var i=0;i<points.length;i++){var _x=points[i][0]-0.5,_y=points[i][1]-0.5;o.push([0.5+(_x*Math.cos(theta)-_y*Math.sin(theta)),0.5+(_x*Math.sin(theta)+_y*Math.cos(theta)),points[i][2],points[i][3]]);}return o;};if(!_shapes[shape]){throw new Error("Shape ["+shape+"] is unknown by Perimeter Anchor type");}var da=_shapes[shape](params);if(params.rotation){da=_rotate(da,params.rotation);}var a=params.jsPlumbInstance.makeDynamicAnchor(da);a.type="Perimeter";return a;};}).call(typeof window!==\'undefined\'?window:this);/*\r\n * This file contains the default Connectors, Endpoint and Overlay definitions.\r\n *\r\n * Copyright (c) 2010 - 2018 jsPlumb (hello@jsplumbtoolkit.com)\r\n * \r\n * https://jsplumbtoolkit.com\r\n * https://github.com/jsplumb/jsplumb\r\n * \r\n * Dual licensed under the MIT and GPL2 licenses.\r\n */;(function(){"use strict";var root=this,_jp=root.jsPlumb,_ju=root.jsPlumbUtil,_jg=root.Biltong;_jp.Segments={/*\r\n         * Class: AbstractSegment\r\n         * A Connector is made up of 1..N Segments, each of which has a Type, such as \'Straight\', \'Arc\',\r\n         * \'Bezier\'. This is new from 1.4.2, and gives us a lot more flexibility when drawing connections: things such\r\n         * as rounded corners for flowchart connectors, for example, or a straight line stub for Bezier connections, are\r\n         * much easier to do now.\r\n         *\r\n         * A Segment is responsible for providing coordinates for painting it, and also must be able to report its length.\r\n         * \r\n         */AbstractSegment:function AbstractSegment(params){this.params=params;/**\r\n             * Function: findClosestPointOnPath\r\n             * Finds the closest point on this segment to the given [x, y],\r\n             * returning both the x and y of the point plus its distance from\r\n             * the supplied point, and its location along the length of the\r\n             * path inscribed by the segment.  This implementation returns\r\n             * Infinity for distance and null values for everything else;\r\n             * subclasses are expected to override.\r\n             */this.findClosestPointOnPath=function(x,y){return{d:Infinity,x:null,y:null,l:null};};this.getBounds=function(){return{minX:Math.min(params.x1,params.x2),minY:Math.min(params.y1,params.y2),maxX:Math.max(params.x1,params.x2),maxY:Math.max(params.y1,params.y2)};};},Straight:function Straight(params){var _super=_jp.Segments.AbstractSegment.apply(this,arguments),length,m,m2,x1,x2,y1,y2,_recalc=function _recalc(){length=Math.sqrt(Math.pow(x2-x1,2)+Math.pow(y2-y1,2));m=_jg.gradient({x:x1,y:y1},{x:x2,y:y2});m2=-1/m;};this.type="Straight";this.getLength=function(){return length;};this.getGradient=function(){return m;};this.getCoordinates=function(){return{x1:x1,y1:y1,x2:x2,y2:y2};};this.setCoordinates=function(coords){x1=coords.x1;y1=coords.y1;x2=coords.x2;y2=coords.y2;_recalc();};this.setCoordinates({x1:params.x1,y1:params.y1,x2:params.x2,y2:params.y2});this.getBounds=function(){return{minX:Math.min(x1,x2),minY:Math.min(y1,y2),maxX:Math.max(x1,x2),maxY:Math.max(y1,y2)};};/**\r\n             * returns the point on the segment\'s path that is \'location\' along the length of the path, where \'location\' is a decimal from\r\n             * 0 to 1 inclusive. for the straight line segment this is simple maths.\r\n             */this.pointOnPath=function(location,absolute){if(location===0&&!absolute){return{x:x1,y:y1};}else if(location===1&&!absolute){return{x:x2,y:y2};}else{var l=absolute?location>0?location:length+location:location*length;return _jg.pointOnLine({x:x1,y:y1},{x:x2,y:y2},l);}};/**\r\n             * returns the gradient of the segment at the given point - which for us is constant.\r\n             */this.gradientAtPoint=function(_){return m;};/**\r\n             * returns the point on the segment\'s path that is \'distance\' along the length of the path from \'location\', where\r\n             * \'location\' is a decimal from 0 to 1 inclusive, and \'distance\' is a number of pixels.\r\n             * this hands off to jsPlumbUtil to do the maths, supplying two points and the distance.\r\n             */this.pointAlongPathFrom=function(location,distance,absolute){var p=this.pointOnPath(location,absolute),farAwayPoint=distance<=0?{x:x1,y:y1}:{x:x2,y:y2};/*\r\n                 location == 1 ? {\r\n                 x:x1 + ((x2 - x1) * 10),\r\n                 y:y1 + ((y1 - y2) * 10)\r\n                 } :\r\n                 */if(distance<=0&&Math.abs(distance)>1){distance*=-1;}return _jg.pointOnLine(p,farAwayPoint,distance);};// is c between a and b?\nvar within=function within(a,b,c){return c>=Math.min(a,b)&&c<=Math.max(a,b);};// find which of a and b is closest to c\nvar closest=function closest(a,b,c){return Math.abs(c-a)<Math.abs(c-b)?a:b;};/**\r\n             Function: findClosestPointOnPath\r\n             Finds the closest point on this segment to [x,y]. See\r\n             notes on this method in AbstractSegment.\r\n             */this.findClosestPointOnPath=function(x,y){var out={d:Infinity,x:null,y:null,l:null,x1:x1,x2:x2,y1:y1,y2:y2};if(m===0){out.y=y1;out.x=within(x1,x2,x)?x:closest(x1,x2,x);}else if(m===Infinity||m===-Infinity){out.x=x1;out.y=within(y1,y2,y)?y:closest(y1,y2,y);}else{// closest point lies on normal from given point to this line.  \nvar b=y1-m*x1,b2=y-m2*x,// y1 = m.x1 + b and y1 = m2.x1 + b2\n// so m.x1 + b = m2.x1 + b2\n// x1(m - m2) = b2 - b\n// x1 = (b2 - b) / (m - m2)\n_x1=(b2-b)/(m-m2),_y1=m*_x1+b;out.x=within(x1,x2,_x1)?_x1:closest(x1,x2,_x1);//_x1;\nout.y=within(y1,y2,_y1)?_y1:closest(y1,y2,_y1);//_y1;\n}var fractionInSegment=_jg.lineLength([out.x,out.y],[x1,y1]);out.d=_jg.lineLength([x,y],[out.x,out.y]);out.l=fractionInSegment/length;return out;};},/*\r\n         Arc Segment. You need to supply:\r\n\r\n         r   -   radius\r\n         cx  -   center x for the arc\r\n         cy  -   center y for the arc\r\n         ac  -   whether the arc is anticlockwise or not. default is clockwise.\r\n\r\n         and then either:\r\n\r\n         startAngle  -   startAngle for the arc.\r\n         endAngle    -   endAngle for the arc.\r\n\r\n         or:\r\n\r\n         x1          -   x for start point\r\n         y1          -   y for start point\r\n         x2          -   x for end point\r\n         y2          -   y for end point\r\n\r\n         */Arc:function Arc(params){var _super=_jp.Segments.AbstractSegment.apply(this,arguments),_calcAngle=function _calcAngle(_x,_y){return _jg.theta([params.cx,params.cy],[_x,_y]);},_calcAngleForLocation=function _calcAngleForLocation(segment,location){if(segment.anticlockwise){var sa=segment.startAngle<segment.endAngle?segment.startAngle+TWO_PI:segment.startAngle,s=Math.abs(sa-segment.endAngle);return sa-s*location;}else{var ea=segment.endAngle<segment.startAngle?segment.endAngle+TWO_PI:segment.endAngle,ss=Math.abs(ea-segment.startAngle);return segment.startAngle+ss*location;}},TWO_PI=2*Math.PI;this.radius=params.r;this.anticlockwise=params.ac;this.type="Arc";if(params.startAngle&&params.endAngle){this.startAngle=params.startAngle;this.endAngle=params.endAngle;this.x1=params.cx+this.radius*Math.cos(params.startAngle);this.y1=params.cy+this.radius*Math.sin(params.startAngle);this.x2=params.cx+this.radius*Math.cos(params.endAngle);this.y2=params.cy+this.radius*Math.sin(params.endAngle);}else{this.startAngle=_calcAngle(params.x1,params.y1);this.endAngle=_calcAngle(params.x2,params.y2);this.x1=params.x1;this.y1=params.y1;this.x2=params.x2;this.y2=params.y2;}if(this.endAngle<0){this.endAngle+=TWO_PI;}if(this.startAngle<0){this.startAngle+=TWO_PI;}// segment is used by vml     \n//this.segment = _jg.quadrant([this.x1, this.y1], [this.x2, this.y2]);\n// we now have startAngle and endAngle as positive numbers, meaning the\n// absolute difference (|d|) between them is the sweep (s) of this arc, unless the\n// arc is \'anticlockwise\' in which case \'s\' is given by 2PI - |d|.\nvar ea=this.endAngle<this.startAngle?this.endAngle+TWO_PI:this.endAngle;this.sweep=Math.abs(ea-this.startAngle);if(this.anticlockwise){this.sweep=TWO_PI-this.sweep;}var circumference=2*Math.PI*this.radius,frac=this.sweep/TWO_PI,length=circumference*frac;this.getLength=function(){return length;};this.getBounds=function(){return{minX:params.cx-params.r,maxX:params.cx+params.r,minY:params.cy-params.r,maxY:params.cy+params.r};};var VERY_SMALL_VALUE=0.0000000001,gentleRound=function gentleRound(n){var f=Math.floor(n),r=Math.ceil(n);if(n-f<VERY_SMALL_VALUE){return f;}else if(r-n<VERY_SMALL_VALUE){return r;}return n;};/**\r\n             * returns the point on the segment\'s path that is \'location\' along the length of the path, where \'location\' is a decimal from\r\n             * 0 to 1 inclusive.\r\n             */this.pointOnPath=function(location,absolute){if(location===0){return{x:this.x1,y:this.y1,theta:this.startAngle};}else if(location===1){return{x:this.x2,y:this.y2,theta:this.endAngle};}if(absolute){location=location/length;}var angle=_calcAngleForLocation(this,location),_x=params.cx+params.r*Math.cos(angle),_y=params.cy+params.r*Math.sin(angle);return{x:gentleRound(_x),y:gentleRound(_y),theta:angle};};/**\r\n             * returns the gradient of the segment at the given point.\r\n             */this.gradientAtPoint=function(location,absolute){var p=this.pointOnPath(location,absolute);var m=_jg.normal([params.cx,params.cy],[p.x,p.y]);if(!this.anticlockwise&&(m===Infinity||m===-Infinity)){m*=-1;}return m;};this.pointAlongPathFrom=function(location,distance,absolute){var p=this.pointOnPath(location,absolute),arcSpan=distance/circumference*2*Math.PI,dir=this.anticlockwise?-1:1,startAngle=p.theta+dir*arcSpan,startX=params.cx+this.radius*Math.cos(startAngle),startY=params.cy+this.radius*Math.sin(startAngle);return{x:startX,y:startY};};},Bezier:function Bezier(params){this.curve=[{x:params.x1,y:params.y1},{x:params.cp1x,y:params.cp1y},{x:params.cp2x,y:params.cp2y},{x:params.x2,y:params.y2}];var _super=_jp.Segments.AbstractSegment.apply(this,arguments);// although this is not a strictly rigorous determination of bounds\n// of a bezier curve, it works for the types of curves that this segment\n// type produces.\nthis.bounds={minX:Math.min(params.x1,params.x2,params.cp1x,params.cp2x),minY:Math.min(params.y1,params.y2,params.cp1y,params.cp2y),maxX:Math.max(params.x1,params.x2,params.cp1x,params.cp2x),maxY:Math.max(params.y1,params.y2,params.cp1y,params.cp2y)};this.type="Bezier";var _translateLocation=function _translateLocation(_curve,location,absolute){if(absolute){location=root.jsBezier.locationAlongCurveFrom(_curve,location>0?0:1,location);}return location;};/**\r\n             * returns the point on the segment\'s path that is \'location\' along the length of the path, where \'location\' is a decimal from\r\n             * 0 to 1 inclusive.\r\n             */this.pointOnPath=function(location,absolute){location=_translateLocation(this.curve,location,absolute);return root.jsBezier.pointOnCurve(this.curve,location);};/**\r\n             * returns the gradient of the segment at the given point.\r\n             */this.gradientAtPoint=function(location,absolute){location=_translateLocation(this.curve,location,absolute);return root.jsBezier.gradientAtPoint(this.curve,location);};this.pointAlongPathFrom=function(location,distance,absolute){location=_translateLocation(this.curve,location,absolute);return root.jsBezier.pointAlongCurveFrom(this.curve,location,distance);};this.getLength=function(){return root.jsBezier.getLength(this.curve);};this.getBounds=function(){return this.bounds;};}};_jp.SegmentRenderer={getPath:function getPath(segment){return{"Straight":function Straight(){var d=segment.getCoordinates();return"M "+d.x1+" "+d.y1+" L "+d.x2+" "+d.y2;},"Bezier":function Bezier(){var d=segment.params;return"M "+d.x1+" "+d.y1+" C "+d.cp1x+" "+d.cp1y+" "+d.cp2x+" "+d.cp2y+" "+d.x2+" "+d.y2;},"Arc":function Arc(){var d=segment.params,laf=segment.sweep>Math.PI?1:0,sf=segment.anticlockwise?0:1;return"M"+segment.x1+" "+segment.y1+" A "+segment.radius+" "+d.r+" 0 "+laf+","+sf+" "+segment.x2+" "+segment.y2;}}[segment.type]();}};/*\r\n     Class: UIComponent\r\n     Superclass for Connector and AbstractEndpoint.\r\n     */var AbstractComponent=function AbstractComponent(){this.resetBounds=function(){this.bounds={minX:Infinity,minY:Infinity,maxX:-Infinity,maxY:-Infinity};};this.resetBounds();};/*\r\n     * Class: Connector\r\n     * Superclass for all Connectors; here is where Segments are managed.  This is exposed on jsPlumb just so it\r\n     * can be accessed from other files. You should not try to instantiate one of these directly.\r\n     *\r\n     * When this class is asked for a pointOnPath, or gradient etc, it must first figure out which segment to dispatch\r\n     * that request to. This is done by keeping track of the total connector length as segments are added, and also\r\n     * their cumulative ratios to the total length.  Then when the right segment is found it is a simple case of dispatching\r\n     * the request to it (and adjusting \'location\' so that it is relative to the beginning of that segment.)\r\n     */_jp.Connectors.AbstractConnector=function(params){AbstractComponent.apply(this,arguments);var segments=[],totalLength=0,segmentProportions=[],segmentProportionalLengths=[],stub=params.stub||0,sourceStub=_ju.isArray(stub)?stub[0]:stub,targetStub=_ju.isArray(stub)?stub[1]:stub,gap=params.gap||0,sourceGap=_ju.isArray(gap)?gap[0]:gap,targetGap=_ju.isArray(gap)?gap[1]:gap,userProvidedSegments=null,paintInfo=null;this.getPathData=function(){var p="";for(var i=0;i<segments.length;i++){p+=_jp.SegmentRenderer.getPath(segments[i]);p+=" ";}return p;};/**\r\n         * Function: findSegmentForPoint\r\n         * Returns the segment that is closest to the given [x,y],\r\n         * null if nothing found.  This function returns a JS\r\n         * object with:\r\n         *\r\n         *   d   -   distance from segment\r\n         *   l   -   proportional location in segment\r\n         *   x   -   x point on the segment\r\n         *   y   -   y point on the segment\r\n         *   s   -   the segment itself.\r\n         */this.findSegmentForPoint=function(x,y){var out={d:Infinity,s:null,x:null,y:null,l:null};for(var i=0;i<segments.length;i++){var _s=segments[i].findClosestPointOnPath(x,y);if(_s.d<out.d){out.d=_s.d;out.l=_s.l;out.x=_s.x;out.y=_s.y;out.s=segments[i];out.x1=_s.x1;out.x2=_s.x2;out.y1=_s.y1;out.y2=_s.y2;out.index=i;}}return out;};var _updateSegmentProportions=function _updateSegmentProportions(){var curLoc=0;for(var i=0;i<segments.length;i++){var sl=segments[i].getLength();segmentProportionalLengths[i]=sl/totalLength;segmentProportions[i]=[curLoc,curLoc+=sl/totalLength];}},/**\r\n             * returns [segment, proportion of travel in segment, segment index] for the segment\r\n             * that contains the point which is \'location\' distance along the entire path, where\r\n             * \'location\' is a decimal between 0 and 1 inclusive. in this connector type, paths\r\n             * are made up of a list of segments, each of which contributes some fraction to\r\n             * the total length.\r\n             * From 1.3.10 this also supports the \'absolute\' property, which lets us specify a location\r\n             * as the absolute distance in pixels, rather than a proportion of the total path.\r\n             */_findSegmentForLocation=function _findSegmentForLocation(location,absolute){if(absolute){location=location>0?location/totalLength:(totalLength+location)/totalLength;}var idx=segmentProportions.length-1,inSegmentProportion=1;for(var i=0;i<segmentProportions.length;i++){if(segmentProportions[i][1]>=location){idx=i;// todo is this correct for all connector path types?\ninSegmentProportion=location===1?1:location===0?0:(location-segmentProportions[i][0])/segmentProportionalLengths[i];break;}}return{segment:segments[idx],proportion:inSegmentProportion,index:idx};},_addSegment=function _addSegment(conn,type,params){if(params.x1===params.x2&&params.y1===params.y2){return;}var s=new _jp.Segments[type](params);segments.push(s);totalLength+=s.getLength();conn.updateBounds(s);},_clearSegments=function _clearSegments(){totalLength=segments.length=segmentProportions.length=segmentProportionalLengths.length=0;};this.setSegments=function(_segs){userProvidedSegments=[];totalLength=0;for(var i=0;i<_segs.length;i++){userProvidedSegments.push(_segs[i]);totalLength+=_segs[i].getLength();}};this.getLength=function(){return totalLength;};var _prepareCompute=function _prepareCompute(params){this.strokeWidth=params.strokeWidth;var segment=_jg.quadrant(params.sourcePos,params.targetPos),swapX=params.targetPos[0]<params.sourcePos[0],swapY=params.targetPos[1]<params.sourcePos[1],lw=params.strokeWidth||1,so=params.sourceEndpoint.anchor.getOrientation(params.sourceEndpoint),to=params.targetEndpoint.anchor.getOrientation(params.targetEndpoint),x=swapX?params.targetPos[0]:params.sourcePos[0],y=swapY?params.targetPos[1]:params.sourcePos[1],w=Math.abs(params.targetPos[0]-params.sourcePos[0]),h=Math.abs(params.targetPos[1]-params.sourcePos[1]);// if either anchor does not have an orientation set, we derive one from their relative\n// positions.  we fix the axis to be the one in which the two elements are further apart, and\n// point each anchor at the other element.  this is also used when dragging a new connection.\nif(so[0]===0&&so[1]===0||to[0]===0&&to[1]===0){var index=w>h?0:1,oIndex=[1,0][index];so=[];to=[];so[index]=params.sourcePos[index]>params.targetPos[index]?-1:1;to[index]=params.sourcePos[index]>params.targetPos[index]?1:-1;so[oIndex]=0;to[oIndex]=0;}var sx=swapX?w+sourceGap*so[0]:sourceGap*so[0],sy=swapY?h+sourceGap*so[1]:sourceGap*so[1],tx=swapX?targetGap*to[0]:w+targetGap*to[0],ty=swapY?targetGap*to[1]:h+targetGap*to[1],oProduct=so[0]*to[0]+so[1]*to[1];var result={sx:sx,sy:sy,tx:tx,ty:ty,lw:lw,xSpan:Math.abs(tx-sx),ySpan:Math.abs(ty-sy),mx:(sx+tx)/2,my:(sy+ty)/2,so:so,to:to,x:x,y:y,w:w,h:h,segment:segment,startStubX:sx+so[0]*sourceStub,startStubY:sy+so[1]*sourceStub,endStubX:tx+to[0]*targetStub,endStubY:ty+to[1]*targetStub,isXGreaterThanStubTimes2:Math.abs(sx-tx)>sourceStub+targetStub,isYGreaterThanStubTimes2:Math.abs(sy-ty)>sourceStub+targetStub,opposite:oProduct===-1,perpendicular:oProduct===0,orthogonal:oProduct===1,sourceAxis:so[0]===0?"y":"x",points:[x,y,w,h,sx,sy,tx,ty],stubs:[sourceStub,targetStub]};result.anchorOrientation=result.opposite?"opposite":result.orthogonal?"orthogonal":"perpendicular";return result;};this.getSegments=function(){return segments;};this.updateBounds=function(segment){var segBounds=segment.getBounds();this.bounds.minX=Math.min(this.bounds.minX,segBounds.minX);this.bounds.maxX=Math.max(this.bounds.maxX,segBounds.maxX);this.bounds.minY=Math.min(this.bounds.minY,segBounds.minY);this.bounds.maxY=Math.max(this.bounds.maxY,segBounds.maxY);};var dumpSegmentsToConsole=function dumpSegmentsToConsole(){console.log("SEGMENTS:");for(var i=0;i<segments.length;i++){console.log(segments[i].type,segments[i].getLength(),segmentProportions[i]);}};this.pointOnPath=function(location,absolute){var seg=_findSegmentForLocation(location,absolute);return seg.segment&&seg.segment.pointOnPath(seg.proportion,false)||[0,0];};this.gradientAtPoint=function(location,absolute){var seg=_findSegmentForLocation(location,absolute);return seg.segment&&seg.segment.gradientAtPoint(seg.proportion,false)||0;};this.pointAlongPathFrom=function(location,distance,absolute){var seg=_findSegmentForLocation(location,absolute);// TODO what happens if this crosses to the next segment?\nreturn seg.segment&&seg.segment.pointAlongPathFrom(seg.proportion,distance,false)||[0,0];};this.compute=function(params){paintInfo=_prepareCompute.call(this,params);_clearSegments();this._compute(paintInfo,params);this.x=paintInfo.points[0];this.y=paintInfo.points[1];this.w=paintInfo.points[2];this.h=paintInfo.points[3];this.segment=paintInfo.segment;_updateSegmentProportions();};return{addSegment:_addSegment,prepareCompute:_prepareCompute,sourceStub:sourceStub,targetStub:targetStub,maxStub:Math.max(sourceStub,targetStub),sourceGap:sourceGap,targetGap:targetGap,maxGap:Math.max(sourceGap,targetGap)};};_ju.extend(_jp.Connectors.AbstractConnector,AbstractComponent);// ********************************* END OF CONNECTOR TYPES *******************************************************************\n// ********************************* ENDPOINT TYPES *******************************************************************\n_jp.Endpoints.AbstractEndpoint=function(params){AbstractComponent.apply(this,arguments);var compute=this.compute=function(anchorPoint,orientation,endpointStyle,connectorPaintStyle){var out=this._compute.apply(this,arguments);this.x=out[0];this.y=out[1];this.w=out[2];this.h=out[3];this.bounds.minX=this.x;this.bounds.minY=this.y;this.bounds.maxX=this.x+this.w;this.bounds.maxY=this.y+this.h;return out;};return{compute:compute,cssClass:params.cssClass};};_ju.extend(_jp.Endpoints.AbstractEndpoint,AbstractComponent);/**\r\n     * Class: Endpoints.Dot\r\n     * A round endpoint, with default radius 10 pixels.\r\n     *//**\r\n     * Function: Constructor\r\n     *\r\n     * Parameters:\r\n     *\r\n     *    radius    -    radius of the endpoint.  defaults to 10 pixels.\r\n     */_jp.Endpoints.Dot=function(params){this.type="Dot";var _super=_jp.Endpoints.AbstractEndpoint.apply(this,arguments);params=params||{};this.radius=params.radius||10;this.defaultOffset=0.5*this.radius;this.defaultInnerRadius=this.radius/3;this._compute=function(anchorPoint,orientation,endpointStyle,connectorPaintStyle){this.radius=endpointStyle.radius||this.radius;var x=anchorPoint[0]-this.radius,y=anchorPoint[1]-this.radius,w=this.radius*2,h=this.radius*2;if(endpointStyle.stroke){var lw=endpointStyle.strokeWidth||1;x-=lw;y-=lw;w+=lw*2;h+=lw*2;}return[x,y,w,h,this.radius];};};_ju.extend(_jp.Endpoints.Dot,_jp.Endpoints.AbstractEndpoint);_jp.Endpoints.Rectangle=function(params){this.type="Rectangle";var _super=_jp.Endpoints.AbstractEndpoint.apply(this,arguments);params=params||{};this.width=params.width||20;this.height=params.height||20;this._compute=function(anchorPoint,orientation,endpointStyle,connectorPaintStyle){var width=endpointStyle.width||this.width,height=endpointStyle.height||this.height,x=anchorPoint[0]-width/2,y=anchorPoint[1]-height/2;return[x,y,width,height];};};_ju.extend(_jp.Endpoints.Rectangle,_jp.Endpoints.AbstractEndpoint);var DOMElementEndpoint=function DOMElementEndpoint(params){_jp.jsPlumbUIComponent.apply(this,arguments);this._jsPlumb.displayElements=[];};_ju.extend(DOMElementEndpoint,_jp.jsPlumbUIComponent,{getDisplayElements:function getDisplayElements(){return this._jsPlumb.displayElements;},appendDisplayElement:function appendDisplayElement(el){this._jsPlumb.displayElements.push(el);}});/**\r\n     * Class: Endpoints.Image\r\n     * Draws an image as the Endpoint.\r\n     *//**\r\n     * Function: Constructor\r\n     *\r\n     * Parameters:\r\n     *\r\n     *    src    -    location of the image to use.\r\n\r\n     TODO: multiple references to self. not sure quite how to get rid of them entirely. perhaps self = null in the cleanup\r\n     function will suffice\r\n\r\n     TODO this class still might leak memory.\r\n\r\n     */_jp.Endpoints.Image=function(params){this.type="Image";DOMElementEndpoint.apply(this,arguments);_jp.Endpoints.AbstractEndpoint.apply(this,arguments);var _onload=params.onload,src=params.src||params.url,clazz=params.cssClass?" "+params.cssClass:"";this._jsPlumb.img=new Image();this._jsPlumb.ready=false;this._jsPlumb.initialized=false;this._jsPlumb.deleted=false;this._jsPlumb.widthToUse=params.width;this._jsPlumb.heightToUse=params.height;this._jsPlumb.endpoint=params.endpoint;this._jsPlumb.img.onload=function(){if(this._jsPlumb!=null){this._jsPlumb.ready=true;this._jsPlumb.widthToUse=this._jsPlumb.widthToUse||this._jsPlumb.img.width;this._jsPlumb.heightToUse=this._jsPlumb.heightToUse||this._jsPlumb.img.height;if(_onload){_onload(this);}}}.bind(this);/*\r\n         Function: setImage\r\n         Sets the Image to use in this Endpoint.\r\n\r\n         Parameters:\r\n         img         -   may be a URL or an Image object\r\n         onload      -   optional; a callback to execute once the image has loaded.\r\n         */this._jsPlumb.endpoint.setImage=function(_img,onload){var s=_img.constructor===String?_img:_img.src;_onload=onload;this._jsPlumb.img.src=s;if(this.canvas!=null){this.canvas.setAttribute("src",this._jsPlumb.img.src);}}.bind(this);this._jsPlumb.endpoint.setImage(src,_onload);this._compute=function(anchorPoint,orientation,endpointStyle,connectorPaintStyle){this.anchorPoint=anchorPoint;if(this._jsPlumb.ready){return[anchorPoint[0]-this._jsPlumb.widthToUse/2,anchorPoint[1]-this._jsPlumb.heightToUse/2,this._jsPlumb.widthToUse,this._jsPlumb.heightToUse];}else{return[0,0,0,0];}};this.canvas=_jp.createElement("img",{position:"absolute",margin:0,padding:0,outline:0},this._jsPlumb.instance.endpointClass+clazz);if(this._jsPlumb.widthToUse){this.canvas.setAttribute("width",this._jsPlumb.widthToUse);}if(this._jsPlumb.heightToUse){this.canvas.setAttribute("height",this._jsPlumb.heightToUse);}this._jsPlumb.instance.appendElement(this.canvas);this.actuallyPaint=function(d,style,anchor){if(!this._jsPlumb.deleted){if(!this._jsPlumb.initialized){this.canvas.setAttribute("src",this._jsPlumb.img.src);this.appendDisplayElement(this.canvas);this._jsPlumb.initialized=true;}var x=this.anchorPoint[0]-this._jsPlumb.widthToUse/2,y=this.anchorPoint[1]-this._jsPlumb.heightToUse/2;_ju.sizeElement(this.canvas,x,y,this._jsPlumb.widthToUse,this._jsPlumb.heightToUse);}};this.paint=function(style,anchor){if(this._jsPlumb!=null){// may have been deleted\nif(this._jsPlumb.ready){this.actuallyPaint(style,anchor);}else{root.setTimeout(function(){this.paint(style,anchor);}.bind(this),200);}}};};_ju.extend(_jp.Endpoints.Image,[DOMElementEndpoint,_jp.Endpoints.AbstractEndpoint],{cleanup:function cleanup(force){if(force){this._jsPlumb.deleted=true;if(this.canvas){this.canvas.parentNode.removeChild(this.canvas);}this.canvas=null;}}});/*\r\n     * Class: Endpoints.Blank\r\n     * An Endpoint that paints nothing (visible) on the screen.  Supports cssClass and hoverClass parameters like all Endpoints.\r\n     */_jp.Endpoints.Blank=function(params){var _super=_jp.Endpoints.AbstractEndpoint.apply(this,arguments);this.type="Blank";DOMElementEndpoint.apply(this,arguments);this._compute=function(anchorPoint,orientation,endpointStyle,connectorPaintStyle){return[anchorPoint[0],anchorPoint[1],10,0];};var clazz=params.cssClass?" "+params.cssClass:"";this.canvas=_jp.createElement("div",{display:"block",width:"1px",height:"1px",background:"transparent",position:"absolute"},this._jsPlumb.instance.endpointClass+clazz);this._jsPlumb.instance.appendElement(this.canvas);this.paint=function(style,anchor){_ju.sizeElement(this.canvas,this.x,this.y,this.w,this.h);};};_ju.extend(_jp.Endpoints.Blank,[_jp.Endpoints.AbstractEndpoint,DOMElementEndpoint],{cleanup:function cleanup(){if(this.canvas&&this.canvas.parentNode){this.canvas.parentNode.removeChild(this.canvas);}}});/*\r\n     * Class: Endpoints.Triangle\r\n     * A triangular Endpoint.\r\n     *//*\r\n     * Function: Constructor\r\n     *\r\n     * Parameters:\r\n     *\r\n     * width   width of the triangle\'s base.  defaults to 55 pixels.\r\n     * height  height of the triangle from base to apex.  defaults to 55 pixels.\r\n     */_jp.Endpoints.Triangle=function(params){this.type="Triangle";_jp.Endpoints.AbstractEndpoint.apply(this,arguments);var self=this;params=params||{};params.width=params.width||55;params.height=params.height||55;this.width=params.width;this.height=params.height;this._compute=function(anchorPoint,orientation,endpointStyle,connectorPaintStyle){var width=endpointStyle.width||self.width,height=endpointStyle.height||self.height,x=anchorPoint[0]-width/2,y=anchorPoint[1]-height/2;return[x,y,width,height];};};// ********************************* END OF ENDPOINT TYPES *******************************************************************\n// ********************************* OVERLAY DEFINITIONS ***********************************************************************    \nvar AbstractOverlay=_jp.Overlays.AbstractOverlay=function(params){this.visible=true;this.isAppendedAtTopLevel=true;this.component=params.component;this.loc=params.location==null?0.5:params.location;this.endpointLoc=params.endpointLocation==null?[0.5,0.5]:params.endpointLocation;this.visible=params.visible!==false;};AbstractOverlay.prototype={cleanup:function cleanup(force){if(force){this.component=null;this.canvas=null;this.endpointLoc=null;}},reattach:function reattach(instance,component){},setVisible:function setVisible(val){this.visible=val;this.component.repaint();},isVisible:function isVisible(){return this.visible;},hide:function hide(){this.setVisible(false);},show:function show(){this.setVisible(true);},incrementLocation:function incrementLocation(amount){this.loc+=amount;this.component.repaint();},setLocation:function setLocation(l){this.loc=l;this.component.repaint();},getLocation:function getLocation(){return this.loc;},updateFrom:function updateFrom(){}};/*\r\n     * Class: Overlays.Arrow\r\n     *\r\n     * An arrow overlay, defined by four points: the head, the two sides of the tail, and a \'foldback\' point at some distance along the length\r\n     * of the arrow that lines from each tail point converge into.  The foldback point is defined using a decimal that indicates some fraction\r\n     * of the length of the arrow and has a default value of 0.623.  A foldback point value of 1 would mean that the arrow had a straight line\r\n     * across the tail.\r\n     *//*\r\n     * @constructor\r\n     *\r\n     * @param {Object} params Constructor params.\r\n     * @param {Number} [params.length] Distance in pixels from head to tail baseline. default 20.\r\n     * @param {Number} [params.width] Width in pixels of the tail baseline. default 20.\r\n     * @param {String} [params.fill] Style to use when filling the arrow.  defaults to "black".\r\n     * @param {String} [params.stroke] Style to use when stroking the arrow. defaults to null, which means the arrow is not stroked.\r\n     * @param {Number} [params.stroke-width] Line width to use when stroking the arrow. defaults to 1, but only used if stroke is not null.\r\n     * @param {Number} [params.foldback] Distance (as a decimal from 0 to 1 inclusive) along the length of the arrow marking the point the tail points should fold back to.  defaults to 0.623.\r\n     * @param {Number} [params.location] Distance (as a decimal from 0 to 1 inclusive) marking where the arrow should sit on the connector. defaults to 0.5.\r\n     * @param {NUmber} [params.direction] Indicates the direction the arrow points in. valid values are -1 and 1; 1 is default.\r\n     */_jp.Overlays.Arrow=function(params){this.type="Arrow";AbstractOverlay.apply(this,arguments);this.isAppendedAtTopLevel=false;params=params||{};var self=this;this.length=params.length||20;this.width=params.width||20;this.id=params.id;var direction=(params.direction||1)<0?-1:1,paintStyle=params.paintStyle||{"stroke-width":1},// how far along the arrow the lines folding back in come to. default is 62.3%.\nfoldback=params.foldback||0.623;this.computeMaxSize=function(){return self.width*1.5;};this.elementCreated=function(p,component){this.path=p;if(params.events){for(var i in params.events){_jp.on(p,i,params.events[i]);}}};this.draw=function(component,currentConnectionPaintStyle){var hxy,mid,txy,tail,cxy;if(component.pointAlongPathFrom){if(_ju.isString(this.loc)||this.loc>1||this.loc<0){var l=parseInt(this.loc,10),fromLoc=this.loc<0?1:0;hxy=component.pointAlongPathFrom(fromLoc,l,false);mid=component.pointAlongPathFrom(fromLoc,l-direction*this.length/2,false);txy=_jg.pointOnLine(hxy,mid,this.length);}else if(this.loc===1){hxy=component.pointOnPath(this.loc);mid=component.pointAlongPathFrom(this.loc,-this.length);txy=_jg.pointOnLine(hxy,mid,this.length);if(direction===-1){var _=txy;txy=hxy;hxy=_;}}else if(this.loc===0){txy=component.pointOnPath(this.loc);mid=component.pointAlongPathFrom(this.loc,this.length);hxy=_jg.pointOnLine(txy,mid,this.length);if(direction===-1){var __=txy;txy=hxy;hxy=__;}}else{hxy=component.pointAlongPathFrom(this.loc,direction*this.length/2);mid=component.pointOnPath(this.loc);txy=_jg.pointOnLine(hxy,mid,this.length);}tail=_jg.perpendicularLineTo(hxy,txy,this.width);cxy=_jg.pointOnLine(hxy,txy,foldback*this.length);var d={hxy:hxy,tail:tail,cxy:cxy},stroke=paintStyle.stroke||currentConnectionPaintStyle.stroke,fill=paintStyle.fill||currentConnectionPaintStyle.stroke,lineWidth=paintStyle.strokeWidth||currentConnectionPaintStyle.strokeWidth;return{component:component,d:d,"stroke-width":lineWidth,stroke:stroke,fill:fill,minX:Math.min(hxy.x,tail[0].x,tail[1].x),maxX:Math.max(hxy.x,tail[0].x,tail[1].x),minY:Math.min(hxy.y,tail[0].y,tail[1].y),maxY:Math.max(hxy.y,tail[0].y,tail[1].y)};}else{return{component:component,minX:0,maxX:0,minY:0,maxY:0};}};};_ju.extend(_jp.Overlays.Arrow,AbstractOverlay,{updateFrom:function updateFrom(d){this.length=d.length||this.length;this.width=d.width||this.width;this.direction=d.direction!=null?d.direction:this.direction;this.foldback=d.foldback||this.foldback;}});/*\r\n     * Class: Overlays.PlainArrow\r\n     *\r\n     * A basic arrow.  This is in fact just one instance of the more generic case in which the tail folds back on itself to some\r\n     * point along the length of the arrow: in this case, that foldback point is the full length of the arrow.  so it just does\r\n     * a \'call\' to Arrow with foldback set appropriately.\r\n     *//*\r\n     * Function: Constructor\r\n     * See <Overlays.Arrow> for allowed parameters for this overlay.\r\n     */_jp.Overlays.PlainArrow=function(params){params=params||{};var p=_jp.extend(params,{foldback:1});_jp.Overlays.Arrow.call(this,p);this.type="PlainArrow";};_ju.extend(_jp.Overlays.PlainArrow,_jp.Overlays.Arrow);/*\r\n     * Class: Overlays.Diamond\r\n     * \r\n     * A diamond. Like PlainArrow, this is a concrete case of the more generic case of the tail points converging on some point...it just\r\n     * happens that in this case, that point is greater than the length of the the arrow.\r\n     *\r\n     *      this could probably do with some help with positioning...due to the way it reuses the Arrow paint code, what Arrow thinks is the\r\n     *      center is actually 1/4 of the way along for this guy.  but we don\'t have any knowledge of pixels at this point, so we\'re kind of\r\n     *      stuck when it comes to helping out the Arrow class. possibly we could pass in a \'transpose\' parameter or something. the value\r\n     *      would be -l/4 in this case - move along one quarter of the total length.\r\n     *//*\r\n     * Function: Constructor\r\n     * See <Overlays.Arrow> for allowed parameters for this overlay.\r\n     */_jp.Overlays.Diamond=function(params){params=params||{};var l=params.length||40,p=_jp.extend(params,{length:l/2,foldback:2});_jp.Overlays.Arrow.call(this,p);this.type="Diamond";};_ju.extend(_jp.Overlays.Diamond,_jp.Overlays.Arrow);var _getDimensions=function _getDimensions(component,forceRefresh){if(component._jsPlumb.cachedDimensions==null||forceRefresh){component._jsPlumb.cachedDimensions=component.getDimensions();}return component._jsPlumb.cachedDimensions;};// abstract superclass for overlays that add an element to the DOM.\nvar AbstractDOMOverlay=function AbstractDOMOverlay(params){_jp.jsPlumbUIComponent.apply(this,arguments);AbstractOverlay.apply(this,arguments);// hand off fired events to associated component.\nvar _f=this.fire;this.fire=function(){_f.apply(this,arguments);if(this.component){this.component.fire.apply(this.component,arguments);}};this.detached=false;this.id=params.id;this._jsPlumb.div=null;this._jsPlumb.initialised=false;this._jsPlumb.component=params.component;this._jsPlumb.cachedDimensions=null;this._jsPlumb.create=params.create;this._jsPlumb.initiallyInvisible=params.visible===false;this.getElement=function(){if(this._jsPlumb.div==null){var div=this._jsPlumb.div=_jp.getElement(this._jsPlumb.create(this._jsPlumb.component));div.style.position="absolute";div.className=this._jsPlumb.instance.overlayClass+" "+(this.cssClass?this.cssClass:params.cssClass?params.cssClass:"");this._jsPlumb.instance.appendElement(div);this._jsPlumb.instance.getId(div);this.canvas=div;// in IE the top left corner is what it placed at the desired location.  This will not\n// be fixed. IE8 is not going to be supported for much longer.\nvar ts="translate(-50%, -50%)";div.style.webkitTransform=ts;div.style.mozTransform=ts;div.style.msTransform=ts;div.style.oTransform=ts;div.style.transform=ts;// write the related component into the created element\ndiv._jsPlumb=this;if(params.visible===false){div.style.display="none";}}return this._jsPlumb.div;};this.draw=function(component,currentConnectionPaintStyle,absolutePosition){var td=_getDimensions(this);if(td!=null&&td.length===2){var cxy={x:0,y:0};// absolutePosition would have been set by a call to connection.setAbsoluteOverlayPosition.\nif(absolutePosition){cxy={x:absolutePosition[0],y:absolutePosition[1]};}else if(component.pointOnPath){var loc=this.loc,absolute=false;if(_ju.isString(this.loc)||this.loc<0||this.loc>1){loc=parseInt(this.loc,10);absolute=true;}cxy=component.pointOnPath(loc,absolute);// a connection\n}else{var locToUse=this.loc.constructor===Array?this.loc:this.endpointLoc;cxy={x:locToUse[0]*component.w,y:locToUse[1]*component.h};}var minx=cxy.x-td[0]/2,miny=cxy.y-td[1]/2;return{component:component,d:{minx:minx,miny:miny,td:td,cxy:cxy},minX:minx,maxX:minx+td[0],minY:miny,maxY:miny+td[1]};}else{return{minX:0,maxX:0,minY:0,maxY:0};}};};_ju.extend(AbstractDOMOverlay,[_jp.jsPlumbUIComponent,AbstractOverlay],{getDimensions:function getDimensions(){return[1,1];},setVisible:function setVisible(state){if(this._jsPlumb.div){this._jsPlumb.div.style.display=state?"block":"none";// if initially invisible, dimensions are 0,0 and never get updated\nif(state&&this._jsPlumb.initiallyInvisible){_getDimensions(this,true);this.component.repaint();this._jsPlumb.initiallyInvisible=false;}}},/*\r\n         * Function: clearCachedDimensions\r\n         * Clears the cached dimensions for the label. As a performance enhancement, label dimensions are\r\n         * cached from 1.3.12 onwards. The cache is cleared when you change the label text, of course, but\r\n         * there are other reasons why the text dimensions might change - if you make a change through CSS, for\r\n         * example, you might change the font size.  in that case you should explicitly call this method.\r\n         */clearCachedDimensions:function clearCachedDimensions(){this._jsPlumb.cachedDimensions=null;},cleanup:function cleanup(force){if(force){if(this._jsPlumb.div!=null){this._jsPlumb.div._jsPlumb=null;this._jsPlumb.instance.removeElement(this._jsPlumb.div);}}else{// if not a forced cleanup, just detach child from parent for now.\nif(this._jsPlumb&&this._jsPlumb.div&&this._jsPlumb.div.parentNode){this._jsPlumb.div.parentNode.removeChild(this._jsPlumb.div);}this.detached=true;}},reattach:function reattach(instance,component){if(this._jsPlumb.div!=null){instance.getContainer().appendChild(this._jsPlumb.div);}this.detached=false;},computeMaxSize:function computeMaxSize(){var td=_getDimensions(this);return Math.max(td[0],td[1]);},paint:function paint(p,containerExtents){if(!this._jsPlumb.initialised){this.getElement();p.component.appendDisplayElement(this._jsPlumb.div);this._jsPlumb.initialised=true;if(this.detached){this._jsPlumb.div.parentNode.removeChild(this._jsPlumb.div);}}this._jsPlumb.div.style.left=p.component.x+p.d.minx+"px";this._jsPlumb.div.style.top=p.component.y+p.d.miny+"px";}});/*\r\n     * Class: Overlays.Custom\r\n     * A Custom overlay. You supply a \'create\' function which returns some DOM element, and jsPlumb positions it.\r\n     * The \'create\' function is passed a Connection or Endpoint.\r\n     *//*\r\n     * Function: Constructor\r\n     * \r\n     * Parameters:\r\n     * create - function for jsPlumb to call that returns a DOM element.\r\n     * location - distance (as a decimal from 0 to 1 inclusive) marking where the label should sit on the connector. defaults to 0.5.\r\n     * id - optional id to use for later retrieval of this overlay.\r\n     *\r\n     */_jp.Overlays.Custom=function(params){this.type="Custom";AbstractDOMOverlay.apply(this,arguments);};_ju.extend(_jp.Overlays.Custom,AbstractDOMOverlay);_jp.Overlays.GuideLines=function(){var self=this;self.length=50;self.strokeWidth=5;this.type="GuideLines";AbstractOverlay.apply(this,arguments);_jp.jsPlumbUIComponent.apply(this,arguments);this.draw=function(connector,currentConnectionPaintStyle){var head=connector.pointAlongPathFrom(self.loc,self.length/2),mid=connector.pointOnPath(self.loc),tail=_jg.pointOnLine(head,mid,self.length),tailLine=_jg.perpendicularLineTo(head,tail,40),headLine=_jg.perpendicularLineTo(tail,head,20);return{connector:connector,head:head,tail:tail,headLine:headLine,tailLine:tailLine,minX:Math.min(head.x,tail.x,headLine[0].x,headLine[1].x),minY:Math.min(head.y,tail.y,headLine[0].y,headLine[1].y),maxX:Math.max(head.x,tail.x,headLine[0].x,headLine[1].x),maxY:Math.max(head.y,tail.y,headLine[0].y,headLine[1].y)};};// this.cleanup = function() { };  // nothing to clean up for GuideLines\n};/*\r\n     * Class: Overlays.Label\r\n\r\n     *//*\r\n     * Function: Constructor\r\n     * \r\n     * Parameters:\r\n     * cssClass - optional css class string to append to css class. This string is appended "as-is", so you can of course have multiple classes\r\n     *             defined.  This parameter is preferred to using labelStyle, borderWidth and borderStyle.\r\n     * label - the label to paint.  May be a string or a function that returns a string.  Nothing will be painted if your label is null or your\r\n     *         label function returns null.  empty strings _will_ be painted.\r\n     * location - distance (as a decimal from 0 to 1 inclusive) marking where the label should sit on the connector. defaults to 0.5.\r\n     * id - optional id to use for later retrieval of this overlay.\r\n     * \r\n     *\r\n     */_jp.Overlays.Label=function(params){this.labelStyle=params.labelStyle;var labelWidth=null,labelHeight=null,labelText=null,labelPadding=null;this.cssClass=this.labelStyle!=null?this.labelStyle.cssClass:null;var p=_jp.extend({create:function create(){return _jp.createElement("div");}},params);_jp.Overlays.Custom.call(this,p);this.type="Label";this.label=params.label||"";this.labelText=null;if(this.labelStyle){var el=this.getElement();this.labelStyle.font=this.labelStyle.font||"12px sans-serif";el.style.font=this.labelStyle.font;el.style.color=this.labelStyle.color||"black";if(this.labelStyle.fill){el.style.background=this.labelStyle.fill;}if(this.labelStyle.borderWidth>0){var dStyle=this.labelStyle.borderStyle?this.labelStyle.borderStyle:"black";el.style.border=this.labelStyle.borderWidth+"px solid "+dStyle;}if(this.labelStyle.padding){el.style.padding=this.labelStyle.padding;}}};_ju.extend(_jp.Overlays.Label,_jp.Overlays.Custom,{cleanup:function cleanup(force){if(force){this.div=null;this.label=null;this.labelText=null;this.cssClass=null;this.labelStyle=null;}},getLabel:function getLabel(){return this.label;},/*\r\n         * Function: setLabel\r\n         * sets the label\'s, um, label.  you would think i\'d call this function\r\n         * \'setText\', but you can pass either a Function or a String to this, so\r\n         * it makes more sense as \'setLabel\'. This uses innerHTML on the label div, so keep\r\n         * that in mind if you need escaped HTML.\r\n         */setLabel:function setLabel(l){this.label=l;this.labelText=null;this.clearCachedDimensions();this.update();this.component.repaint();},getDimensions:function getDimensions(){this.update();return AbstractDOMOverlay.prototype.getDimensions.apply(this,arguments);},update:function update(){if(typeof this.label==="function"){var lt=this.label(this);this.getElement().innerHTML=lt.replace(/\\r\\n/g,"<br/>");}else{if(this.labelText==null){this.labelText=this.label;this.getElement().innerHTML=this.labelText.replace(/\\r\\n/g,"<br/>");}}},updateFrom:function updateFrom(d){if(d.label!=null){this.setLabel(d.label);}}});// ********************************* END OF OVERLAY DEFINITIONS ***********************************************************************\n}).call(typeof window!==\'undefined\'?window:this);/*\r\n * This file contains the base class for library adapters.\r\n *\r\n * Copyright (c) 2010 - 2018 jsPlumb (hello@jsplumbtoolkit.com)\r\n *\r\n * https://jsplumbtoolkit.com\r\n * https://github.com/jsplumb/jsplumb\r\n *\r\n * Dual licensed under the MIT and GPL2 licenses.\r\n */;(function(){"use strict";var root=this,_jp=root.jsPlumb;var _getEventManager=function _getEventManager(instance){var e=instance._mottle;if(!e){e=instance._mottle=new root.Mottle();}return e;};_jp.extend(root.jsPlumbInstance.prototype,{getEventManager:function getEventManager(){return _getEventManager(this);},on:function on(el,event,callback){// TODO: here we would like to map the tap event if we know its\n// an internal bind to a click. we have to know its internal because only\n// then can we be sure that the UP event wont be consumed (tap is a synthesized\n// event from a mousedown followed by a mouseup).\n//event = { "click":"tap", "dblclick":"dbltap"}[event] || event;\nthis.getEventManager().on.apply(this,arguments);return this;},off:function off(el,event,callback){this.getEventManager().off.apply(this,arguments);return this;}});}).call(typeof window!==\'undefined\'?window:this);/*\r\n * Copyright (c) 2010 - 2018 jsPlumb (hello@jsplumbtoolkit.com)\r\n *\r\n * https://jsplumbtoolkit.com\r\n * https://github.com/jsplumb/jsplumb\r\n *\r\n * Dual licensed under the MIT and GPL2 licenses.\r\n */;(function(){"use strict";var root=this,_ju=root.jsPlumbUtil,_jpi=root.jsPlumbInstance;var GROUP_COLLAPSED_CLASS="jtk-group-collapsed";var GROUP_EXPANDED_CLASS="jtk-group-expanded";var GROUP_CONTAINER_SELECTOR="[jtk-group-content]";var ELEMENT_DRAGGABLE_EVENT="elementDraggable";var STOP="stop";var REVERT="revert";var GROUP_MANAGER="_groupManager";var GROUP="_jsPlumbGroup";var GROUP_DRAG_SCOPE="_jsPlumbGroupDrag";var EVT_CHILD_ADDED="group:addMember";var EVT_CHILD_REMOVED="group:removeMember";var EVT_GROUP_ADDED="group:add";var EVT_GROUP_REMOVED="group:remove";var EVT_EXPAND="group:expand";var EVT_COLLAPSE="group:collapse";var EVT_GROUP_DRAG_STOP="groupDragStop";var EVT_CONNECTION_MOVED="connectionMoved";var EVT_INTERNAL_CONNECTION_DETACHED="internal.connectionDetached";var CMD_REMOVE_ALL="removeAll";var CMD_ORPHAN_ALL="orphanAll";var CMD_SHOW="show";var CMD_HIDE="hide";var GroupManager=function GroupManager(_jsPlumb){var _managedGroups={},_connectionSourceMap={},_connectionTargetMap={},self=this;_jsPlumb.bind("connection",function(p){if(p.source[GROUP]!=null&&p.target[GROUP]!=null&&p.source[GROUP]===p.target[GROUP]){_connectionSourceMap[p.connection.id]=p.source[GROUP];_connectionTargetMap[p.connection.id]=p.source[GROUP];}else{if(p.source[GROUP]!=null){_ju.suggest(p.source[GROUP].connections.source,p.connection);_connectionSourceMap[p.connection.id]=p.source[GROUP];}if(p.target[GROUP]!=null){_ju.suggest(p.target[GROUP].connections.target,p.connection);_connectionTargetMap[p.connection.id]=p.target[GROUP];}}});function _cleanupDetachedConnection(conn){delete conn.proxies;var group=_connectionSourceMap[conn.id],f;if(group!=null){f=function f(c){return c.id===conn.id;};_ju.removeWithFunction(group.connections.source,f);_ju.removeWithFunction(group.connections.target,f);delete _connectionSourceMap[conn.id];}group=_connectionTargetMap[conn.id];if(group!=null){f=function f(c){return c.id===conn.id;};_ju.removeWithFunction(group.connections.source,f);_ju.removeWithFunction(group.connections.target,f);delete _connectionTargetMap[conn.id];}}_jsPlumb.bind(EVT_INTERNAL_CONNECTION_DETACHED,function(p){_cleanupDetachedConnection(p.connection);});_jsPlumb.bind(EVT_CONNECTION_MOVED,function(p){var connMap=p.index===0?_connectionSourceMap:_connectionTargetMap;var group=connMap[p.connection.id];if(group){var list=group.connections[p.index===0?"source":"target"];var idx=list.indexOf(p.connection);if(idx!==-1){list.splice(idx,1);}}});this.addGroup=function(group){_jsPlumb.addClass(group.getEl(),GROUP_EXPANDED_CLASS);_managedGroups[group.id]=group;group.manager=this;_updateConnectionsForGroup(group);_jsPlumb.fire(EVT_GROUP_ADDED,{group:group});};this.addToGroup=function(group,el,doNotFireEvent){group=this.getGroup(group);if(group){//group.add(el, doNotFireEvent);\nvar groupEl=group.getEl();if(el._isJsPlumbGroup){return;}var currentGroup=el._jsPlumbGroup;// if already a member of this group, do nothing\nif(currentGroup!==group){var elpos=_jsPlumb.getOffset(el,true);var cpos=group.collapsed?_jsPlumb.getOffset(groupEl,true):_jsPlumb.getOffset(group.getDragArea(),true);// otherwise, transfer to this group.\nif(currentGroup!=null){currentGroup.remove(el,doNotFireEvent);self.updateConnectionsForGroup(currentGroup);}group.add(el,doNotFireEvent);var handleDroppedConnections=function handleDroppedConnections(list,index){var oidx=index===0?1:0;list.each(function(c){c.setVisible(false);if(c.endpoints[oidx].element._jsPlumbGroup===group){c.endpoints[oidx].setVisible(false);self.expandConnection(c,oidx,group);}else{c.endpoints[index].setVisible(false);self.collapseConnection(c,index,group);}});};if(group.collapsed){handleDroppedConnections(_jsPlumb.select({source:el}),0);handleDroppedConnections(_jsPlumb.select({target:el}),1);}var elId=_jsPlumb.getId(el);_jsPlumb.dragManager.setParent(el,elId,groupEl,_jsPlumb.getId(groupEl),elpos);var newPosition={left:elpos.left-cpos.left,top:elpos.top-cpos.top};_jsPlumb.setPosition(el,newPosition);_jsPlumb.dragManager.revalidateParent(el,elId,elpos);self.updateConnectionsForGroup(group);_jsPlumb.revalidate(elId);setTimeout(function(){_jsPlumb.fire(EVT_CHILD_ADDED,{group:group,el:el});},0);}}};this.removeFromGroup=function(group,el,doNotFireEvent){group=this.getGroup(group);if(group){group.remove(el,null,doNotFireEvent);}};this.getGroup=function(groupId){var group=groupId;if(_ju.isString(groupId)){group=_managedGroups[groupId];if(group==null){throw new TypeError("No such group ["+groupId+"]");}}return group;};this.getGroups=function(){var o=[];for(var g in _managedGroups){o.push(_managedGroups[g]);}return o;};this.removeGroup=function(group,deleteMembers,manipulateDOM,doNotFireEvent){group=this.getGroup(group);this.expandGroup(group,true);// this reinstates any original connections and removes all proxies, but does not fire an event.\ngroup[deleteMembers?CMD_REMOVE_ALL:CMD_ORPHAN_ALL](manipulateDOM,doNotFireEvent);_jsPlumb.remove(group.getEl());delete _managedGroups[group.id];delete _jsPlumb._groups[group.id];_jsPlumb.fire(EVT_GROUP_REMOVED,{group:group});};this.removeAllGroups=function(deleteMembers,manipulateDOM,doNotFireEvent){for(var g in _managedGroups){this.removeGroup(_managedGroups[g],deleteMembers,manipulateDOM,doNotFireEvent);}};function _setVisible(group,state){var m=group.getMembers();for(var i=0;i<m.length;i++){_jsPlumb[state?CMD_SHOW:CMD_HIDE](m[i],true);}}var _collapseConnection=this.collapseConnection=function(c,index,group){var proxyEp,groupEl=group.getEl(),groupElId=_jsPlumb.getId(groupEl),originalElementId=c.endpoints[index].elementId;var otherEl=c.endpoints[index===0?1:0].element;if(otherEl[GROUP]&&!otherEl[GROUP].shouldProxy()&&otherEl[GROUP].collapsed){return;}c.proxies=c.proxies||[];if(c.proxies[index]){proxyEp=c.proxies[index].ep;}else{proxyEp=_jsPlumb.addEndpoint(groupEl,{endpoint:group.getEndpoint(c,index),anchor:group.getAnchor(c,index),parameters:{isProxyEndpoint:true}});}proxyEp.setDeleteOnEmpty(true);// for this index, stash proxy info: the new EP, the original EP.\nc.proxies[index]={ep:proxyEp,originalEp:c.endpoints[index]};// and advise the anchor manager\nif(index===0){// TODO why are there two differently named methods? Why is there not one method that says "some end of this\n// connection changed (you give the index), and here\'s the new element and element id."\n_jsPlumb.anchorManager.sourceChanged(originalElementId,groupElId,c,groupEl);}else{_jsPlumb.anchorManager.updateOtherEndpoint(c.endpoints[0].elementId,originalElementId,groupElId,c);c.target=groupEl;c.targetId=groupElId;}// detach the original EP from the connection.\nc.proxies[index].originalEp.detachFromConnection(c,null,true);// set the proxy as the new ep\nproxyEp.connections=[c];c.endpoints[index]=proxyEp;c.setVisible(true);};this.collapseGroup=function(group){group=this.getGroup(group);if(group==null||group.collapsed){return;}var groupEl=group.getEl();// todo remove old proxy endpoints first, just in case?\n//group.proxies.length = 0;\n// hide all connections\n_setVisible(group,false);if(group.shouldProxy()){// collapses all connections in a group.\nvar _collapseSet=function _collapseSet(conns,index){for(var i=0;i<conns.length;i++){var c=conns[i];_collapseConnection(c,index,group);}};// setup proxies for sources and targets\n_collapseSet(group.connections.source,0);_collapseSet(group.connections.target,1);}group.collapsed=true;_jsPlumb.removeClass(groupEl,GROUP_EXPANDED_CLASS);_jsPlumb.addClass(groupEl,GROUP_COLLAPSED_CLASS);_jsPlumb.revalidate(groupEl);_jsPlumb.fire(EVT_COLLAPSE,{group:group});};var _expandConnection=this.expandConnection=function(c,index,group){// if no proxies or none for this end of the connection, abort.\nif(c.proxies==null||c.proxies[index]==null){return;}var groupElId=_jsPlumb.getId(group.getEl()),originalElement=c.proxies[index].originalEp.element,originalElementId=c.proxies[index].originalEp.elementId;c.endpoints[index]=c.proxies[index].originalEp;// and advise the anchor manager\nif(index===0){// TODO why are there two differently named methods? Why is there not one method that says "some end of this\n// connection changed (you give the index), and here\'s the new element and element id."\n_jsPlumb.anchorManager.sourceChanged(groupElId,originalElementId,c,originalElement);}else{_jsPlumb.anchorManager.updateOtherEndpoint(c.endpoints[0].elementId,groupElId,originalElementId,c);c.target=originalElement;c.targetId=originalElementId;}// detach the proxy EP from the connection (which will cause it to be removed as we no longer need it)\nc.proxies[index].ep.detachFromConnection(c,null);c.proxies[index].originalEp.addConnection(c);// cleanup\ndelete c.proxies[index];};this.expandGroup=function(group,doNotFireEvent){group=this.getGroup(group);if(group==null||!group.collapsed){return;}var groupEl=group.getEl();_setVisible(group,true);if(group.shouldProxy()){// collapses all connections in a group.\nvar _expandSet=function _expandSet(conns,index){for(var i=0;i<conns.length;i++){var c=conns[i];_expandConnection(c,index,group);}};// setup proxies for sources and targets\n_expandSet(group.connections.source,0);_expandSet(group.connections.target,1);}group.collapsed=false;_jsPlumb.addClass(groupEl,GROUP_EXPANDED_CLASS);_jsPlumb.removeClass(groupEl,GROUP_COLLAPSED_CLASS);_jsPlumb.revalidate(groupEl);this.repaintGroup(group);if(!doNotFireEvent){_jsPlumb.fire(EVT_EXPAND,{group:group});}};this.repaintGroup=function(group){group=this.getGroup(group);var m=group.getMembers();for(var i=0;i<m.length;i++){_jsPlumb.revalidate(m[i]);}};// TODO refactor this with the code that responds to `connection` events.\nfunction _updateConnectionsForGroup(group){var members=group.getMembers();var c1=_jsPlumb.getConnections({source:members,scope:"*"},true);var c2=_jsPlumb.getConnections({target:members,scope:"*"},true);var processed={};group.connections.source.length=0;group.connections.target.length=0;var oneSet=function oneSet(c){for(var i=0;i<c.length;i++){if(processed[c[i].id]){continue;}processed[c[i].id]=true;if(c[i].source._jsPlumbGroup===group){if(c[i].target._jsPlumbGroup!==group){group.connections.source.push(c[i]);}_connectionSourceMap[c[i].id]=group;}else if(c[i].target._jsPlumbGroup===group){group.connections.target.push(c[i]);_connectionTargetMap[c[i].id]=group;}}};oneSet(c1);oneSet(c2);}this.updateConnectionsForGroup=_updateConnectionsForGroup;this.refreshAllGroups=function(){for(var g in _managedGroups){_updateConnectionsForGroup(_managedGroups[g]);_jsPlumb.dragManager.updateOffsets(_jsPlumb.getId(_managedGroups[g].getEl()));}};};/**\r\n     *\r\n     * @param {jsPlumbInstance} _jsPlumb Associated jsPlumb instance.\r\n     * @param {Object} params\r\n     * @param {Element} params.el The DOM element representing the Group.\r\n     * @param {String} [params.id] Optional ID for the Group. A UUID will be assigned as the Group\'s ID if you do not provide one.\r\n     * @param {Boolean} [params.constrain=false] If true, child elements will not be able to be dragged outside of the Group container.\r\n     * @param {Boolean} [params.revert=true] By default, child elements revert to the container if dragged outside. You can change this by setting `revert:false`. This behaviour is also overridden if you set `orphan` or `prune`.\r\n     * @param {Boolean} [params.orphan=false] If true, child elements dropped outside of the Group container will be removed from the Group (but not from the DOM).\r\n     * @param {Boolean} [params.prune=false] If true, child elements dropped outside of the Group container will be removed from the Group and also from the DOM.\r\n     * @param {Boolean} [params.dropOverride=false] If true, a child element that has been dropped onto some other Group will not be subject to the controls imposed by `prune`, `revert` or `orphan`.\r\n     * @constructor\r\n     */var Group=function Group(_jsPlumb,params){var self=this;var el=params.el;this.getEl=function(){return el;};this.id=params.id||_ju.uuid();el._isJsPlumbGroup=true;var getDragArea=this.getDragArea=function(){var da=_jsPlumb.getSelector(el,GROUP_CONTAINER_SELECTOR);return da&&da.length>0?da[0]:el;};var ghost=params.ghost===true;var constrain=ghost||params.constrain===true;var revert=params.revert!==false;var orphan=params.orphan===true;var prune=params.prune===true;var dropOverride=params.dropOverride===true;var proxied=params.proxied!==false;var elements=[];this.connections={source:[],target:[],internal:[]};// this function, and getEndpoint below, are stubs for a future setup in which we can choose endpoint\n// and anchor based upon the connection and the index (source/target) of the endpoint to be proxied.\nthis.getAnchor=function(conn,endpointIndex){return params.anchor||"Continuous";};this.getEndpoint=function(conn,endpointIndex){return params.endpoint||["Dot",{radius:10}];};this.collapsed=false;if(params.draggable!==false){var opts={stop:function stop(params){_jsPlumb.fire(EVT_GROUP_DRAG_STOP,jsPlumb.extend(params,{group:self}));},scope:GROUP_DRAG_SCOPE};if(params.dragOptions){root.jsPlumb.extend(opts,params.dragOptions);}_jsPlumb.draggable(params.el,opts);}if(params.droppable!==false){_jsPlumb.droppable(params.el,{drop:function drop(p){var el=p.drag.el;if(el._isJsPlumbGroup){return;}var currentGroup=el._jsPlumbGroup;if(currentGroup!==self){if(currentGroup!=null){if(currentGroup.overrideDrop(el,self)){return;}}_jsPlumb.getGroupManager().addToGroup(self,el,false);}}});}var _each=function _each(_el,fn){var els=_el.nodeType==null?_el:[_el];for(var i=0;i<els.length;i++){fn(els[i]);}};this.overrideDrop=function(_el,targetGroup){return dropOverride&&(revert||prune||orphan);};this.add=function(_el,doNotFireEvent){var dragArea=getDragArea();_each(_el,function(__el){if(__el._jsPlumbGroup!=null){if(__el._jsPlumbGroup===self){return;}else{__el._jsPlumbGroup.remove(__el,true,doNotFireEvent,false);}}__el._jsPlumbGroup=self;elements.push(__el);// test if draggable and add handlers if so.\nif(_jsPlumb.isAlreadyDraggable(__el)){_bindDragHandlers(__el);}if(__el.parentNode!==dragArea){dragArea.appendChild(__el);}if(!doNotFireEvent){_jsPlumb.fire(EVT_CHILD_ADDED,{group:self,el:__el});}});_jsPlumb.getGroupManager().updateConnectionsForGroup(self);};this.remove=function(el,manipulateDOM,doNotFireEvent,doNotUpdateConnections){_each(el,function(__el){delete __el._jsPlumbGroup;_ju.removeWithFunction(elements,function(e){return e===__el;});if(manipulateDOM){try{self.getDragArea().removeChild(__el);}catch(e){jsPlumbUtil.log("Could not remove element from Group "+e);}}_unbindDragHandlers(__el);if(!doNotFireEvent){_jsPlumb.fire(EVT_CHILD_REMOVED,{group:self,el:__el});}});if(!doNotUpdateConnections){_jsPlumb.getGroupManager().updateConnectionsForGroup(self);}};this.removeAll=function(manipulateDOM,doNotFireEvent){for(var i=0,l=elements.length;i<l;i++){self.remove(elements[0],manipulateDOM,doNotFireEvent,true);}elements.length=0;_jsPlumb.getGroupManager().updateConnectionsForGroup(self);};this.orphanAll=function(){for(var i=0;i<elements.length;i++){_orphan(elements[i]);}elements.length=0;};this.getMembers=function(){return elements;};el[GROUP]=this;_jsPlumb.bind(ELEMENT_DRAGGABLE_EVENT,function(dragParams){// if its for the current group,\nif(dragParams.el._jsPlumbGroup===this){_bindDragHandlers(dragParams.el);}}.bind(this));function _findParent(_el){return _el.offsetParent;}function _isInsideParent(_el,pos){var p=_findParent(_el),s=_jsPlumb.getSize(p),ss=_jsPlumb.getSize(_el),leftEdge=pos[0],rightEdge=leftEdge+ss[0],topEdge=pos[1],bottomEdge=topEdge+ss[1];return rightEdge>0&&leftEdge<s[0]&&bottomEdge>0&&topEdge<s[1];}//\n// orphaning an element means taking it out of the group and adding it to the main jsplumb container.\n//\nfunction _orphan(_el){var id=_jsPlumb.getId(_el);var pos=_jsPlumb.getOffset(_el);_el.parentNode.removeChild(_el);_jsPlumb.getContainer().appendChild(_el);_jsPlumb.setPosition(_el,pos);delete _el._jsPlumbGroup;_unbindDragHandlers(_el);_jsPlumb.dragManager.clearParent(_el,id);}//\n// remove an element from the group, then either prune it from the jsplumb instance, or just orphan it.\n//\nfunction _pruneOrOrphan(p){if(!_isInsideParent(p.el,p.pos)){var group=p.el._jsPlumbGroup;if(prune){_jsPlumb.remove(p.el);}else{_orphan(p.el);}group.remove(p.el);}}//\n// redraws the element\n//\nfunction _revalidate(_el){var id=_jsPlumb.getId(_el);_jsPlumb.revalidate(_el);_jsPlumb.dragManager.revalidateParent(_el,id);}//\n// unbind the group specific drag/revert handlers.\n//\nfunction _unbindDragHandlers(_el){if(!_el._katavorioDrag){return;}if(prune||orphan){_el._katavorioDrag.off(STOP,_pruneOrOrphan);}if(!prune&&!orphan&&revert){_el._katavorioDrag.off(REVERT,_revalidate);_el._katavorioDrag.setRevert(null);}}function _bindDragHandlers(_el){if(!_el._katavorioDrag){return;}if(prune||orphan){_el._katavorioDrag.on(STOP,_pruneOrOrphan);}if(constrain){_el._katavorioDrag.setConstrain(true);}if(ghost){_el._katavorioDrag.setUseGhostProxy(true);}if(!prune&&!orphan&&revert){_el._katavorioDrag.on(REVERT,_revalidate);_el._katavorioDrag.setRevert(function(__el,pos){return!_isInsideParent(__el,pos);});}}this.shouldProxy=function(){return proxied;};_jsPlumb.getGroupManager().addGroup(this);};/**\r\n     * Adds a group to the jsPlumb instance.\r\n     * @method addGroup\r\n     * @param {Object} params\r\n     * @return {Group} The newly created Group.\r\n     */_jpi.prototype.addGroup=function(params){var j=this;j._groups=j._groups||{};if(j._groups[params.id]!=null){throw new TypeError("cannot create Group ["+params.id+"]; a Group with that ID exists");}if(params.el[GROUP]!=null){throw new TypeError("cannot create Group ["+params.id+"]; the given element is already a Group");}var group=new Group(j,params);j._groups[group.id]=group;if(params.collapsed){this.collapseGroup(group);}return group;};/**\r\n     * Add an element to a group.\r\n     * @method addToGroup\r\n     * @param {String} group Group, or ID of the group, to add the element to.\r\n     * @param {Element} el Element to add to the group.\r\n     */_jpi.prototype.addToGroup=function(group,el,doNotFireEvent){var _one=function(_el){var id=this.getId(_el);this.manage(id,_el);this.getGroupManager().addToGroup(group,_el,doNotFireEvent);}.bind(this);if(Array.isArray(el)){for(var i=0;i<el.length;i++){_one(el[i]);}}else{_one(el);}};/**\r\n     * Remove an element from a group.\r\n     * @method removeFromGroup\r\n     * @param {String} group Group, or ID of the group, to remove the element from.\r\n     * @param {Element} el Element to add to the group.\r\n     */_jpi.prototype.removeFromGroup=function(group,el,doNotFireEvent){this.getGroupManager().removeFromGroup(group,el,doNotFireEvent);};/**\r\n     * Remove a group, and optionally remove its members from the jsPlumb instance.\r\n     * @method removeGroup\r\n     * @param {String|Group} group Group to delete, or ID of Group to delete.\r\n     * @param {Boolean} [deleteMembers=false] If true, group members will be removed along with the group. Otherwise they will\r\n     * just be \'orphaned\' (returned to the main container).\r\n     */_jpi.prototype.removeGroup=function(group,deleteMembers,manipulateDOM,doNotFireEvent){this.getGroupManager().removeGroup(group,deleteMembers,manipulateDOM,doNotFireEvent);};/**\r\n     * Remove all groups, and optionally remove their members from the jsPlumb instance.\r\n     * @method removeAllGroup\r\n     * @param {Boolean} [deleteMembers=false] If true, group members will be removed along with the groups. Otherwise they will\r\n     * just be \'orphaned\' (returned to the main container).\r\n     */_jpi.prototype.removeAllGroups=function(deleteMembers,manipulateDOM,doNotFireEvent){this.getGroupManager().removeAllGroups(deleteMembers,manipulateDOM,doNotFireEvent);};/**\r\n     * Get a Group\r\n     * @method getGroup\r\n     * @param {String} groupId ID of the group to get\r\n     * @return {Group} Group with the given ID, null if not found.\r\n     */_jpi.prototype.getGroup=function(groupId){return this.getGroupManager().getGroup(groupId);};/**\r\n     * Gets all the Groups managed by the jsPlumb instance.\r\n     * @returns {Group[]} List of Groups. Empty if none.\r\n     */_jpi.prototype.getGroups=function(){return this.getGroupManager().getGroups();};/**\r\n     * Expands a group element. jsPlumb doesn\'t do "everything" for you here, because what it means to expand a Group\r\n     * will vary from application to application. jsPlumb does these things:\r\n     *\r\n     * - Hides any connections that are internal to the group (connections between members, and connections from member of\r\n     * the group to the group itself)\r\n     * - Proxies all connections for which the source or target is a member of the group.\r\n     * - Hides the proxied connections.\r\n     * - Adds the jtk-group-expanded class to the group\'s element\r\n     * - Removes the jtk-group-collapsed class from the group\'s element.\r\n     *\r\n     * @method expandGroup\r\n     * @param {String|Group} group Group to expand, or ID of Group to expand.\r\n     */_jpi.prototype.expandGroup=function(group){this.getGroupManager().expandGroup(group);};/**\r\n     * Collapses a group element. jsPlumb doesn\'t do "everything" for you here, because what it means to collapse a Group\r\n     * will vary from application to application. jsPlumb does these things:\r\n     *\r\n     * - Shows any connections that are internal to the group (connections between members, and connections from member of\r\n     * the group to the group itself)\r\n     * - Removes proxies for all connections for which the source or target is a member of the group.\r\n     * - Shows the previously proxied connections.\r\n     * - Adds the jtk-group-collapsed class to the group\'s element\r\n     * - Removes the jtk-group-expanded class from the group\'s element.\r\n     *\r\n     * @method expandGroup\r\n     * @param {String|Group} group Group to expand, or ID of Group to expand.\r\n     */_jpi.prototype.collapseGroup=function(groupId){this.getGroupManager().collapseGroup(groupId);};_jpi.prototype.repaintGroup=function(group){this.getGroupManager().repaintGroup(group);};/**\r\n     * Collapses or expands a group element depending on its current state. See notes in the collapseGroup and expandGroup method.\r\n     *\r\n     * @method toggleGroup\r\n     * @param {String|Group} group Group to expand/collapse, or ID of Group to expand/collapse.\r\n     */_jpi.prototype.toggleGroup=function(group){group=this.getGroupManager().getGroup(group);if(group!=null){this.getGroupManager()[group.collapsed?"expandGroup":"collapseGroup"](group);}};//\n// lazy init a group manager for the given jsplumb instance.\n//\n_jpi.prototype.getGroupManager=function(){var mgr=this[GROUP_MANAGER];if(mgr==null){mgr=this[GROUP_MANAGER]=new GroupManager(this);}return mgr;};_jpi.prototype.removeGroupManager=function(){delete this[GROUP_MANAGER];};/**\r\n     * Gets the Group that the given element belongs to, null if none.\r\n     * @method getGroupFor\r\n     * @param {String|Element} el Element, or element ID.\r\n     * @returns {Group} A Group, if found, or null.\r\n     */_jpi.prototype.getGroupFor=function(el){el=this.getElement(el);if(el){return el[GROUP];}};}).call(typeof window!==\'undefined\'?window:this);/*\r\n * This file contains the \'flowchart\' connectors, consisting of vertical and horizontal line segments.\r\n *\r\n * Copyright (c) 2010 - 2018 jsPlumb (hello@jsplumbtoolkit.com)\r\n *\r\n * https://jsplumbtoolkit.com\r\n * https://github.com/jsplumb/jsplumb\r\n *\r\n * Dual licensed under the MIT and GPL2 licenses.\r\n */;(function(){"use strict";var root=this,_jp=root.jsPlumb,_ju=root.jsPlumbUtil;var STRAIGHT="Straight";var ARC="Arc";var Flowchart=function Flowchart(params){this.type="Flowchart";params=params||{};params.stub=params.stub==null?30:params.stub;var segments,_super=_jp.Connectors.AbstractConnector.apply(this,arguments),midpoint=params.midpoint==null?0.5:params.midpoint,alwaysRespectStubs=params.alwaysRespectStubs===true,lastx=null,lasty=null,lastOrientation,cornerRadius=params.cornerRadius!=null?params.cornerRadius:0,// TODO now common between this and AbstractBezierEditor; refactor into superclass?\nloopbackRadius=params.loopbackRadius||25,isLoopbackCurrently=false,sgn=function sgn(n){return n<0?-1:n===0?0:1;},segmentDirections=function segmentDirections(segment){return[sgn(segment[2]-segment[0]),sgn(segment[3]-segment[1])];},/**\r\n             * helper method to add a segment.\r\n             */addSegment=function addSegment(segments,x,y,paintInfo){if(lastx===x&&lasty===y){return;}var lx=lastx==null?paintInfo.sx:lastx,ly=lasty==null?paintInfo.sy:lasty,o=lx===x?"v":"h";lastx=x;lasty=y;segments.push([lx,ly,x,y,o]);},segLength=function segLength(s){return Math.sqrt(Math.pow(s[0]-s[2],2)+Math.pow(s[1]-s[3],2));},_cloneArray=function _cloneArray(a){var _a=[];_a.push.apply(_a,a);return _a;},writeSegments=function writeSegments(conn,segments,paintInfo){var current=null,next,currentDirection,nextDirection;for(var i=0;i<segments.length-1;i++){current=current||_cloneArray(segments[i]);next=_cloneArray(segments[i+1]);currentDirection=segmentDirections(current);nextDirection=segmentDirections(next);if(cornerRadius>0&&current[4]!==next[4]){var radiusToUse=Math.min(cornerRadius,segLength(current),segLength(next));current[2]-=currentDirection[0]*radiusToUse;current[3]-=currentDirection[1]*radiusToUse;next[0]+=nextDirection[0]*radiusToUse;next[1]+=nextDirection[1]*radiusToUse;var ac=currentDirection[1]===nextDirection[0]&&nextDirection[0]===1||currentDirection[1]===nextDirection[0]&&nextDirection[0]===0&&currentDirection[0]!==nextDirection[1]||currentDirection[1]===nextDirection[0]&&nextDirection[0]===-1,sgny=next[1]>current[3]?1:-1,sgnx=next[0]>current[2]?1:-1,sgnEqual=sgny===sgnx,cx=sgnEqual&&ac||!sgnEqual&&!ac?next[0]:current[2],cy=sgnEqual&&ac||!sgnEqual&&!ac?current[3]:next[1];_super.addSegment(conn,STRAIGHT,{x1:current[0],y1:current[1],x2:current[2],y2:current[3]});_super.addSegment(conn,ARC,{r:radiusToUse,x1:current[2],y1:current[3],x2:next[0],y2:next[1],cx:cx,cy:cy,ac:ac});}else{// dx + dy are used to adjust for line width.\nvar dx=current[2]===current[0]?0:current[2]>current[0]?paintInfo.lw/2:-(paintInfo.lw/2),dy=current[3]===current[1]?0:current[3]>current[1]?paintInfo.lw/2:-(paintInfo.lw/2);_super.addSegment(conn,STRAIGHT,{x1:current[0]-dx,y1:current[1]-dy,x2:current[2]+dx,y2:current[3]+dy});}current=next;}if(next!=null){// last segment\n_super.addSegment(conn,STRAIGHT,{x1:next[0],y1:next[1],x2:next[2],y2:next[3]});}};this._compute=function(paintInfo,params){segments=[];lastx=null;lasty=null;lastOrientation=null;var commonStubCalculator=function commonStubCalculator(){return[paintInfo.startStubX,paintInfo.startStubY,paintInfo.endStubX,paintInfo.endStubY];},stubCalculators={perpendicular:commonStubCalculator,orthogonal:commonStubCalculator,opposite:function opposite(axis){var pi=paintInfo,idx=axis==="x"?0:1,areInProximity={"x":function x(){return pi.so[idx]===1&&(pi.startStubX>pi.endStubX&&pi.tx>pi.startStubX||pi.sx>pi.endStubX&&pi.tx>pi.sx)||pi.so[idx]===-1&&(pi.startStubX<pi.endStubX&&pi.tx<pi.startStubX||pi.sx<pi.endStubX&&pi.tx<pi.sx);},"y":function y(){return pi.so[idx]===1&&(pi.startStubY>pi.endStubY&&pi.ty>pi.startStubY||pi.sy>pi.endStubY&&pi.ty>pi.sy)||pi.so[idx]===-1&&(pi.startStubY<pi.endStubY&&pi.ty<pi.startStubY||pi.sy<pi.endStubY&&pi.ty<pi.sy);}};if(!alwaysRespectStubs&&areInProximity[axis]()){return{"x":[(paintInfo.sx+paintInfo.tx)/2,paintInfo.startStubY,(paintInfo.sx+paintInfo.tx)/2,paintInfo.endStubY],"y":[paintInfo.startStubX,(paintInfo.sy+paintInfo.ty)/2,paintInfo.endStubX,(paintInfo.sy+paintInfo.ty)/2]}[axis];}else{return[paintInfo.startStubX,paintInfo.startStubY,paintInfo.endStubX,paintInfo.endStubY];}}};// calculate Stubs.\nvar stubs=stubCalculators[paintInfo.anchorOrientation](paintInfo.sourceAxis),idx=paintInfo.sourceAxis==="x"?0:1,oidx=paintInfo.sourceAxis==="x"?1:0,ss=stubs[idx],oss=stubs[oidx],es=stubs[idx+2],oes=stubs[oidx+2];// add the start stub segment. use stubs for loopback as it will look better, with the loop spaced\n// away from the element.\naddSegment(segments,stubs[0],stubs[1],paintInfo);// if its a loopback and we should treat it differently.\n// if (false && params.sourcePos[0] === params.targetPos[0] && params.sourcePos[1] === params.targetPos[1]) {\n//\n//     // we use loopbackRadius here, as statemachine connectors do.\n//     // so we go radius to the left from stubs[0], then upwards by 2*radius, to the right by 2*radius,\n//     // down by 2*radius, left by radius.\n//     addSegment(segments, stubs[0] - loopbackRadius, stubs[1], paintInfo);\n//     addSegment(segments, stubs[0] - loopbackRadius, stubs[1] - (2 * loopbackRadius), paintInfo);\n//     addSegment(segments, stubs[0] + loopbackRadius, stubs[1] - (2 * loopbackRadius), paintInfo);\n//     addSegment(segments, stubs[0] + loopbackRadius, stubs[1], paintInfo);\n//     addSegment(segments, stubs[0], stubs[1], paintInfo);\n//\n// }\n// else {\nvar midx=paintInfo.startStubX+(paintInfo.endStubX-paintInfo.startStubX)*midpoint,midy=paintInfo.startStubY+(paintInfo.endStubY-paintInfo.startStubY)*midpoint;var orientations={x:[0,1],y:[1,0]},lineCalculators={perpendicular:function perpendicular(axis){var pi=paintInfo,sis={x:[[[1,2,3,4],null,[2,1,4,3]],null,[[4,3,2,1],null,[3,4,1,2]]],y:[[[3,2,1,4],null,[2,3,4,1]],null,[[4,1,2,3],null,[1,4,3,2]]]},stubs={x:[[pi.startStubX,pi.endStubX],null,[pi.endStubX,pi.startStubX]],y:[[pi.startStubY,pi.endStubY],null,[pi.endStubY,pi.startStubY]]},midLines={x:[[midx,pi.startStubY],[midx,pi.endStubY]],y:[[pi.startStubX,midy],[pi.endStubX,midy]]},linesToEnd={x:[[pi.endStubX,pi.startStubY]],y:[[pi.startStubX,pi.endStubY]]},startToEnd={x:[[pi.startStubX,pi.endStubY],[pi.endStubX,pi.endStubY]],y:[[pi.endStubX,pi.startStubY],[pi.endStubX,pi.endStubY]]},startToMidToEnd={x:[[pi.startStubX,midy],[pi.endStubX,midy],[pi.endStubX,pi.endStubY]],y:[[midx,pi.startStubY],[midx,pi.endStubY],[pi.endStubX,pi.endStubY]]},otherStubs={x:[pi.startStubY,pi.endStubY],y:[pi.startStubX,pi.endStubX]},soIdx=orientations[axis][0],toIdx=orientations[axis][1],_so=pi.so[soIdx]+1,_to=pi.to[toIdx]+1,otherFlipped=pi.to[toIdx]===-1&&otherStubs[axis][1]<otherStubs[axis][0]||pi.to[toIdx]===1&&otherStubs[axis][1]>otherStubs[axis][0],stub1=stubs[axis][_so][0],stub2=stubs[axis][_so][1],segmentIndexes=sis[axis][_so][_to];if(pi.segment===segmentIndexes[3]||pi.segment===segmentIndexes[2]&&otherFlipped){return midLines[axis];}else if(pi.segment===segmentIndexes[2]&&stub2<stub1){return linesToEnd[axis];}else if(pi.segment===segmentIndexes[2]&&stub2>=stub1||pi.segment===segmentIndexes[1]&&!otherFlipped){return startToMidToEnd[axis];}else if(pi.segment===segmentIndexes[0]||pi.segment===segmentIndexes[1]&&otherFlipped){return startToEnd[axis];}},orthogonal:function orthogonal(axis,startStub,otherStartStub,endStub,otherEndStub){var pi=paintInfo,extent={"x":pi.so[0]===-1?Math.min(startStub,endStub):Math.max(startStub,endStub),"y":pi.so[1]===-1?Math.min(startStub,endStub):Math.max(startStub,endStub)}[axis];return{"x":[[extent,otherStartStub],[extent,otherEndStub],[endStub,otherEndStub]],"y":[[otherStartStub,extent],[otherEndStub,extent],[otherEndStub,endStub]]}[axis];},opposite:function opposite(axis,ss,oss,es){var pi=paintInfo,otherAxis={"x":"y","y":"x"}[axis],dim={"x":"height","y":"width"}[axis],comparator=pi["is"+axis.toUpperCase()+"GreaterThanStubTimes2"];if(params.sourceEndpoint.elementId===params.targetEndpoint.elementId){var _val=oss+(1-params.sourceEndpoint.anchor[otherAxis])*params.sourceInfo[dim]+_super.maxStub;return{"x":[[ss,_val],[es,_val]],"y":[[_val,ss],[_val,es]]}[axis];}else if(!comparator||pi.so[idx]===1&&ss>es||pi.so[idx]===-1&&ss<es){return{"x":[[ss,midy],[es,midy]],"y":[[midx,ss],[midx,es]]}[axis];}else if(pi.so[idx]===1&&ss<es||pi.so[idx]===-1&&ss>es){return{"x":[[midx,pi.sy],[midx,pi.ty]],"y":[[pi.sx,midy],[pi.tx,midy]]}[axis];}}};// compute the rest of the line\nvar p=lineCalculators[paintInfo.anchorOrientation](paintInfo.sourceAxis,ss,oss,es,oes);if(p){for(var i=0;i<p.length;i++){addSegment(segments,p[i][0],p[i][1],paintInfo);}}// line to end stub\naddSegment(segments,stubs[2],stubs[3],paintInfo);//}\n// end stub to end (common)\naddSegment(segments,paintInfo.tx,paintInfo.ty,paintInfo);// write out the segments.\nwriteSegments(this,segments,paintInfo);};};_jp.Connectors.Flowchart=Flowchart;_ju.extend(_jp.Connectors.Flowchart,_jp.Connectors.AbstractConnector);}).call(typeof window!==\'undefined\'?window:this);/*\r\n * This file contains the code for the Bezier connector type.\r\n *\r\n * Copyright (c) 2010 - 2018 jsPlumb (hello@jsplumbtoolkit.com)\r\n *\r\n * https://jsplumbtoolkit.com\r\n * https://github.com/jsplumb/jsplumb\r\n *\r\n * Dual licensed under the MIT and GPL2 licenses.\r\n */;(function(){"use strict";var root=this,_jp=root.jsPlumb,_ju=root.jsPlumbUtil;_jp.Connectors.AbstractBezierConnector=function(params){params=params||{};var showLoopback=params.showLoopback!==false,curviness=params.curviness||10,margin=params.margin||5,proximityLimit=params.proximityLimit||80,clockwise=params.orientation&&params.orientation==="clockwise",loopbackRadius=params.loopbackRadius||25,isLoopbackCurrently=false,_super;this._compute=function(paintInfo,p){var sp=p.sourcePos,tp=p.targetPos,_w=Math.abs(sp[0]-tp[0]),_h=Math.abs(sp[1]-tp[1]);if(!showLoopback||p.sourceEndpoint.elementId!==p.targetEndpoint.elementId){isLoopbackCurrently=false;this._computeBezier(paintInfo,p,sp,tp,_w,_h);}else{isLoopbackCurrently=true;// a loopback connector.  draw an arc from one anchor to the other.\nvar x1=p.sourcePos[0],y1=p.sourcePos[1]-margin,cx=x1,cy=y1-loopbackRadius,// canvas sizing stuff, to ensure the whole painted area is visible.\n_x=cx-loopbackRadius,_y=cy-loopbackRadius;_w=2*loopbackRadius;_h=2*loopbackRadius;paintInfo.points[0]=_x;paintInfo.points[1]=_y;paintInfo.points[2]=_w;paintInfo.points[3]=_h;// ADD AN ARC SEGMENT.\n_super.addSegment(this,"Arc",{loopback:true,x1:x1-_x+4,y1:y1-_y,startAngle:0,endAngle:2*Math.PI,r:loopbackRadius,ac:!clockwise,x2:x1-_x-4,y2:y1-_y,cx:cx-_x,cy:cy-_y});}};_super=_jp.Connectors.AbstractConnector.apply(this,arguments);return _super;};_ju.extend(_jp.Connectors.AbstractBezierConnector,_jp.Connectors.AbstractConnector);var Bezier=function Bezier(params){params=params||{};this.type="Bezier";var _super=_jp.Connectors.AbstractBezierConnector.apply(this,arguments),majorAnchor=params.curviness||150,minorAnchor=10;this.getCurviness=function(){return majorAnchor;};this._findControlPoint=function(point,sourceAnchorPosition,targetAnchorPosition,sourceEndpoint,targetEndpoint,soo,too){// determine if the two anchors are perpendicular to each other in their orientation.  we swap the control\n// points around if so (code could be tightened up)\nvar perpendicular=soo[0]!==too[0]||soo[1]===too[1],p=[];if(!perpendicular){if(soo[0]===0){p.push(sourceAnchorPosition[0]<targetAnchorPosition[0]?point[0]+minorAnchor:point[0]-minorAnchor);}else{p.push(point[0]-majorAnchor*soo[0]);}if(soo[1]===0){p.push(sourceAnchorPosition[1]<targetAnchorPosition[1]?point[1]+minorAnchor:point[1]-minorAnchor);}else{p.push(point[1]+majorAnchor*too[1]);}}else{if(too[0]===0){p.push(targetAnchorPosition[0]<sourceAnchorPosition[0]?point[0]+minorAnchor:point[0]-minorAnchor);}else{p.push(point[0]+majorAnchor*too[0]);}if(too[1]===0){p.push(targetAnchorPosition[1]<sourceAnchorPosition[1]?point[1]+minorAnchor:point[1]-minorAnchor);}else{p.push(point[1]+majorAnchor*soo[1]);}}return p;};this._computeBezier=function(paintInfo,p,sp,tp,_w,_h){var _CP,_CP2,_sx=sp[0]<tp[0]?_w:0,_sy=sp[1]<tp[1]?_h:0,_tx=sp[0]<tp[0]?0:_w,_ty=sp[1]<tp[1]?0:_h;_CP=this._findControlPoint([_sx,_sy],sp,tp,p.sourceEndpoint,p.targetEndpoint,paintInfo.so,paintInfo.to);_CP2=this._findControlPoint([_tx,_ty],tp,sp,p.targetEndpoint,p.sourceEndpoint,paintInfo.to,paintInfo.so);_super.addSegment(this,"Bezier",{x1:_sx,y1:_sy,x2:_tx,y2:_ty,cp1x:_CP[0],cp1y:_CP[1],cp2x:_CP2[0],cp2y:_CP2[1]});};};_jp.Connectors.Bezier=Bezier;_ju.extend(Bezier,_jp.Connectors.AbstractBezierConnector);}).call(typeof window!==\'undefined\'?window:this);/*\r\n * This file contains the state machine connectors, which extend AbstractBezierConnector.\r\n *\r\n * Copyright (c) 2010 - 2018 jsPlumb (hello@jsplumbtoolkit.com)\r\n *\r\n * https://jsplumbtoolkit.com\r\n * https://github.com/jsplumb/jsplumb\r\n * \r\n * Dual licensed under the MIT and GPL2 licenses.\r\n */;(function(){"use strict";var root=this,_jp=root.jsPlumb,_ju=root.jsPlumbUtil;var _segment=function _segment(x1,y1,x2,y2){if(x1<=x2&&y2<=y1){return 1;}else if(x1<=x2&&y1<=y2){return 2;}else if(x2<=x1&&y2>=y1){return 3;}return 4;},// the control point we will use depends on the faces to which each end of the connection is assigned, specifically whether or not the\n// two faces are parallel or perpendicular.  if they are parallel then the control point lies on the midpoint of the axis in which they\n// are parellel and varies only in the other axis; this variation is proportional to the distance that the anchor points lie from the\n// center of that face.  if the two faces are perpendicular then the control point is at some distance from both the midpoints; the amount and\n// direction are dependent on the orientation of the two elements. \'seg\', passed in to this method, tells you which segment the target element\n// lies in with respect to the source: 1 is top right, 2 is bottom right, 3 is bottom left, 4 is top left.\n//\n// sourcePos and targetPos are arrays of info about where on the source and target each anchor is located.  their contents are:\n//\n// 0 - absolute x\n// 1 - absolute y\n// 2 - proportional x in element (0 is left edge, 1 is right edge)\n// 3 - proportional y in element (0 is top edge, 1 is bottom edge)\n//\n_findControlPoint=function _findControlPoint(midx,midy,segment,sourceEdge,targetEdge,dx,dy,distance,proximityLimit){// TODO (maybe)\n// - if anchor pos is 0.5, make the control point take into account the relative position of the elements.\nif(distance<=proximityLimit){return[midx,midy];}if(segment===1){if(sourceEdge[3]<=0&&targetEdge[3]>=1){return[midx+(sourceEdge[2]<0.5?-1*dx:dx),midy];}else if(sourceEdge[2]>=1&&targetEdge[2]<=0){return[midx,midy+(sourceEdge[3]<0.5?-1*dy:dy)];}else{return[midx+-1*dx,midy+-1*dy];}}else if(segment===2){if(sourceEdge[3]>=1&&targetEdge[3]<=0){return[midx+(sourceEdge[2]<0.5?-1*dx:dx),midy];}else if(sourceEdge[2]>=1&&targetEdge[2]<=0){return[midx,midy+(sourceEdge[3]<0.5?-1*dy:dy)];}else{return[midx+dx,midy+-1*dy];}}else if(segment===3){if(sourceEdge[3]>=1&&targetEdge[3]<=0){return[midx+(sourceEdge[2]<0.5?-1*dx:dx),midy];}else if(sourceEdge[2]<=0&&targetEdge[2]>=1){return[midx,midy+(sourceEdge[3]<0.5?-1*dy:dy)];}else{return[midx+-1*dx,midy+-1*dy];}}else if(segment===4){if(sourceEdge[3]<=0&&targetEdge[3]>=1){return[midx+(sourceEdge[2]<0.5?-1*dx:dx),midy];}else if(sourceEdge[2]<=0&&targetEdge[2]>=1){return[midx,midy+(sourceEdge[3]<0.5?-1*dy:dy)];}else{return[midx+dx,midy+-1*dy];}}};var StateMachine=function StateMachine(params){params=params||{};this.type="StateMachine";var _super=_jp.Connectors.AbstractBezierConnector.apply(this,arguments),curviness=params.curviness||10,margin=params.margin||5,proximityLimit=params.proximityLimit||80,clockwise=params.orientation&&params.orientation==="clockwise",_controlPoint;this._computeBezier=function(paintInfo,params,sp,tp,w,h){var _sx=params.sourcePos[0]<params.targetPos[0]?0:w,_sy=params.sourcePos[1]<params.targetPos[1]?0:h,_tx=params.sourcePos[0]<params.targetPos[0]?w:0,_ty=params.sourcePos[1]<params.targetPos[1]?h:0;// now adjust for the margin\nif(params.sourcePos[2]===0){_sx-=margin;}if(params.sourcePos[2]===1){_sx+=margin;}if(params.sourcePos[3]===0){_sy-=margin;}if(params.sourcePos[3]===1){_sy+=margin;}if(params.targetPos[2]===0){_tx-=margin;}if(params.targetPos[2]===1){_tx+=margin;}if(params.targetPos[3]===0){_ty-=margin;}if(params.targetPos[3]===1){_ty+=margin;}//\n// these connectors are quadratic bezier curves, having a single control point. if both anchors\n// are located at 0.5 on their respective faces, the control point is set to the midpoint and you\n// get a straight line.  this is also the case if the two anchors are within \'proximityLimit\', since\n// it seems to make good aesthetic sense to do that. outside of that, the control point is positioned\n// at \'curviness\' pixels away along the normal to the straight line connecting the two anchors.\n//\n// there may be two improvements to this.  firstly, we might actually support the notion of avoiding nodes\n// in the UI, or at least making a good effort at doing so.  if a connection would pass underneath some node,\n// for example, we might increase the distance the control point is away from the midpoint in a bid to\n// steer it around that node.  this will work within limits, but i think those limits would also be the likely\n// limits for, once again, aesthetic good sense in the layout of a chart using these connectors.\n//\n// the second possible change is actually two possible changes: firstly, it is possible we should gradually\n// decrease the \'curviness\' as the distance between the anchors decreases; start tailing it off to 0 at some\n// point (which should be configurable).  secondly, we might slightly increase the \'curviness\' for connectors\n// with respect to how far their anchor is from the center of its respective face. this could either look cool,\n// or stupid, and may indeed work only in a way that is so subtle as to have been a waste of time.\n//\nvar _midx=(_sx+_tx)/2,_midy=(_sy+_ty)/2,segment=_segment(_sx,_sy,_tx,_ty),distance=Math.sqrt(Math.pow(_tx-_sx,2)+Math.pow(_ty-_sy,2)),cp1x,cp2x,cp1y,cp2y;// calculate the control point.  this code will be where we\'ll put in a rudimentary element avoidance scheme; it\n// will work by extending the control point to force the curve to be, um, curvier.\n_controlPoint=_findControlPoint(_midx,_midy,segment,params.sourcePos,params.targetPos,curviness,curviness,distance,proximityLimit);cp1x=_controlPoint[0];cp2x=_controlPoint[0];cp1y=_controlPoint[1];cp2y=_controlPoint[1];_super.addSegment(this,"Bezier",{x1:_tx,y1:_ty,x2:_sx,y2:_sy,cp1x:cp1x,cp1y:cp1y,cp2x:cp2x,cp2y:cp2y});};};_jp.Connectors.StateMachine=StateMachine;_ju.extend(StateMachine,_jp.Connectors.AbstractBezierConnector);}).call(typeof window!==\'undefined\'?window:this);/*\r\n * This file contains the \'flowchart\' connectors, consisting of vertical and horizontal line segments.\r\n *\r\n * Copyright (c) 2010 - 2018 jsPlumb (hello@jsplumbtoolkit.com)\r\n *\r\n * https://jsplumbtoolkit.com\r\n * https://github.com/jsplumb/jsplumb\r\n *\r\n * Dual licensed under the MIT and GPL2 licenses.\r\n */;(function(){"use strict";var root=this,_jp=root.jsPlumb,_ju=root.jsPlumbUtil;var STRAIGHT="Straight";var Straight=function Straight(params){this.type=STRAIGHT;var _super=_jp.Connectors.AbstractConnector.apply(this,arguments);this._compute=function(paintInfo,_){_super.addSegment(this,STRAIGHT,{x1:paintInfo.sx,y1:paintInfo.sy,x2:paintInfo.startStubX,y2:paintInfo.startStubY});_super.addSegment(this,STRAIGHT,{x1:paintInfo.startStubX,y1:paintInfo.startStubY,x2:paintInfo.endStubX,y2:paintInfo.endStubY});_super.addSegment(this,STRAIGHT,{x1:paintInfo.endStubX,y1:paintInfo.endStubY,x2:paintInfo.tx,y2:paintInfo.ty});};};_jp.Connectors.Straight=Straight;_ju.extend(Straight,_jp.Connectors.AbstractConnector);}).call(typeof window!==\'undefined\'?window:this);/*\r\n * This file contains the SVG renderers.\r\n *\r\n * Copyright (c) 2010 - 2018 jsPlumb (hello@jsplumbtoolkit.com)\r\n * \r\n * https://jsplumbtoolkit.com\r\n * https://github.com/jsplumb/jsplumb\r\n * \r\n * Dual licensed under the MIT and GPL2 licenses.\r\n */;(function(){// ************************** SVG utility methods ********************************************\t\n"use strict";var root=this,_jp=root.jsPlumb,_ju=root.jsPlumbUtil;var svgAttributeMap={"stroke-linejoin":"stroke-linejoin","stroke-dashoffset":"stroke-dashoffset","stroke-linecap":"stroke-linecap"},STROKE_DASHARRAY="stroke-dasharray",DASHSTYLE="dashstyle",LINEAR_GRADIENT="linearGradient",RADIAL_GRADIENT="radialGradient",DEFS="defs",FILL="fill",STOP="stop",STROKE="stroke",STROKE_WIDTH="stroke-width",STYLE="style",NONE="none",JSPLUMB_GRADIENT="jsplumb_gradient_",LINE_WIDTH="strokeWidth",ns={svg:"http://www.w3.org/2000/svg"},_attr=function _attr(node,attributes){for(var i in attributes){node.setAttribute(i,""+attributes[i]);}},_node=function _node(name,attributes){attributes=attributes||{};attributes.version="1.1";attributes.xmlns=ns.svg;return _jp.createElementNS(ns.svg,name,null,null,attributes);},_pos=function _pos(d){return"position:absolute;left:"+d[0]+"px;top:"+d[1]+"px";},_clearGradient=function _clearGradient(parent){var els=parent.querySelectorAll(" defs,linearGradient,radialGradient");for(var i=0;i<els.length;i++){els[i].parentNode.removeChild(els[i]);}},_updateGradient=function _updateGradient(parent,node,style,dimensions,uiComponent){var id=JSPLUMB_GRADIENT+uiComponent._jsPlumb.instance.idstamp();// first clear out any existing gradient\n_clearGradient(parent);// this checks for an \'offset\' property in the gradient, and in the absence of it, assumes\n// we want a linear gradient. if it\'s there, we create a radial gradient.\n// it is possible that a more explicit means of defining the gradient type would be\n// better. relying on \'offset\' means that we can never have a radial gradient that uses\n// some default offset, for instance.\n// issue 244 suggested the \'gradientUnits\' attribute; without this, straight/flowchart connectors with gradients would\n// not show gradients when the line was perfectly horizontal or vertical.\nvar g;if(!style.gradient.offset){g=_node(LINEAR_GRADIENT,{id:id,gradientUnits:"userSpaceOnUse"});}else{g=_node(RADIAL_GRADIENT,{id:id});}var defs=_node(DEFS);parent.appendChild(defs);defs.appendChild(g);// the svg radial gradient seems to treat stops in the reverse\n// order to how canvas does it.  so we want to keep all the maths the same, but\n// iterate the actual style declarations in reverse order, if the x indexes are not in order.\nfor(var i=0;i<style.gradient.stops.length;i++){var styleToUse=uiComponent.segment===1||uiComponent.segment===2?i:style.gradient.stops.length-1-i,stopColor=style.gradient.stops[styleToUse][1],s=_node(STOP,{"offset":Math.floor(style.gradient.stops[i][0]*100)+"%","stop-color":stopColor});g.appendChild(s);}var applyGradientTo=style.stroke?STROKE:FILL;node.setAttribute(applyGradientTo,"url(#"+id+")");},_applyStyles=function _applyStyles(parent,node,style,dimensions,uiComponent){node.setAttribute(FILL,style.fill?style.fill:NONE);node.setAttribute(STROKE,style.stroke?style.stroke:NONE);if(style.gradient){_updateGradient(parent,node,style,dimensions,uiComponent);}else{// make sure we clear any existing gradient\n_clearGradient(parent);node.setAttribute(STYLE,"");}if(style.strokeWidth){node.setAttribute(STROKE_WIDTH,style.strokeWidth);}// in SVG there is a stroke-dasharray attribute we can set, and its syntax looks like\n// the syntax in VML but is actually kind of nasty: values are given in the pixel\n// coordinate space, whereas in VML they are multiples of the width of the stroked\n// line, which makes a lot more sense.  for that reason, jsPlumb is supporting both\n// the native svg \'stroke-dasharray\' attribute, and also the \'dashstyle\' concept from\n// VML, which will be the preferred method.  the code below this converts a dashstyle\n// attribute given in terms of stroke width into a pixel representation, by using the\n// stroke\'s lineWidth.\nif(style[DASHSTYLE]&&style[LINE_WIDTH]&&!style[STROKE_DASHARRAY]){var sep=style[DASHSTYLE].indexOf(",")===-1?" ":",",parts=style[DASHSTYLE].split(sep),styleToUse="";parts.forEach(function(p){styleToUse+=Math.floor(p*style.strokeWidth)+sep;});node.setAttribute(STROKE_DASHARRAY,styleToUse);}else if(style[STROKE_DASHARRAY]){node.setAttribute(STROKE_DASHARRAY,style[STROKE_DASHARRAY]);}// extra attributes such as join type, dash offset.\nfor(var i in svgAttributeMap){if(style[i]){node.setAttribute(svgAttributeMap[i],style[i]);}}},_appendAtIndex=function _appendAtIndex(svg,path,idx){if(svg.childNodes.length>idx){svg.insertBefore(path,svg.childNodes[idx]);}else{svg.appendChild(path);}};/**\r\n     utility methods for other objects to use.\r\n     */_ju.svg={node:_node,attr:_attr,pos:_pos};// ************************** / SVG utility methods ********************************************\n/*\r\n     * Base class for SVG components.\r\n     */var SvgComponent=function SvgComponent(params){var pointerEventsSpec=params.pointerEventsSpec||"all",renderer={};_jp.jsPlumbUIComponent.apply(this,params.originalArgs);this.canvas=null;this.path=null;this.svg=null;this.bgCanvas=null;var clazz=params.cssClass+" "+(params.originalArgs[0].cssClass||""),svgParams={"style":"","width":0,"height":0,"pointer-events":pointerEventsSpec,"position":"absolute"};this.svg=_node("svg",svgParams);if(params.useDivWrapper){this.canvas=_jp.createElement("div",{position:"absolute"});_ju.sizeElement(this.canvas,0,0,1,1);this.canvas.className=clazz;}else{_attr(this.svg,{"class":clazz});this.canvas=this.svg;}params._jsPlumb.appendElement(this.canvas,params.originalArgs[0].parent);if(params.useDivWrapper){this.canvas.appendChild(this.svg);}var displayElements=[this.canvas];this.getDisplayElements=function(){return displayElements;};this.appendDisplayElement=function(el){displayElements.push(el);};this.paint=function(style,anchor,extents){if(style!=null){var xy=[this.x,this.y],wh=[this.w,this.h],p;if(extents!=null){if(extents.xmin<0){xy[0]+=extents.xmin;}if(extents.ymin<0){xy[1]+=extents.ymin;}wh[0]=extents.xmax+(extents.xmin<0?-extents.xmin:0);wh[1]=extents.ymax+(extents.ymin<0?-extents.ymin:0);}if(params.useDivWrapper){_ju.sizeElement(this.canvas,xy[0],xy[1],wh[0],wh[1]);xy[0]=0;xy[1]=0;p=_pos([0,0]);}else{p=_pos([xy[0],xy[1]]);}renderer.paint.apply(this,arguments);_attr(this.svg,{"style":p,"width":wh[0]||0,"height":wh[1]||0});}};return{renderer:renderer};};_ju.extend(SvgComponent,_jp.jsPlumbUIComponent,{cleanup:function cleanup(force){if(force||this.typeId==null){if(this.canvas){this.canvas._jsPlumb=null;}if(this.svg){this.svg._jsPlumb=null;}if(this.bgCanvas){this.bgCanvas._jsPlumb=null;}if(this.canvas&&this.canvas.parentNode){this.canvas.parentNode.removeChild(this.canvas);}if(this.bgCanvas&&this.bgCanvas.parentNode){this.canvas.parentNode.removeChild(this.canvas);}this.svg=null;this.canvas=null;this.path=null;this.group=null;}else{// if not a forced cleanup, just detach from DOM for now.\nif(this.canvas&&this.canvas.parentNode){this.canvas.parentNode.removeChild(this.canvas);}if(this.bgCanvas&&this.bgCanvas.parentNode){this.bgCanvas.parentNode.removeChild(this.bgCanvas);}}},reattach:function reattach(instance){var c=instance.getContainer();if(this.canvas&&this.canvas.parentNode==null){c.appendChild(this.canvas);}if(this.bgCanvas&&this.bgCanvas.parentNode==null){c.appendChild(this.bgCanvas);}},setVisible:function setVisible(v){if(this.canvas){this.canvas.style.display=v?"block":"none";}}});/*\r\n     * Base class for SVG connectors.\r\n     */_jp.ConnectorRenderers.svg=function(params){var self=this,_super=SvgComponent.apply(this,[{cssClass:params._jsPlumb.connectorClass,originalArgs:arguments,pointerEventsSpec:"none",_jsPlumb:params._jsPlumb}]);_super.renderer.paint=function(style,anchor,extents){var segments=self.getSegments(),p="",offset=[0,0];if(extents.xmin<0){offset[0]=-extents.xmin;}if(extents.ymin<0){offset[1]=-extents.ymin;}if(segments.length>0){p=self.getPathData();var a={d:p,transform:"translate("+offset[0]+","+offset[1]+")","pointer-events":params["pointer-events"]||"visibleStroke"},outlineStyle=null,d=[self.x,self.y,self.w,self.h];// outline style.  actually means drawing an svg object underneath the main one.\nif(style.outlineStroke){var outlineWidth=style.outlineWidth||1,outlineStrokeWidth=style.strokeWidth+2*outlineWidth;outlineStyle=_jp.extend({},style);delete outlineStyle.gradient;outlineStyle.stroke=style.outlineStroke;outlineStyle.strokeWidth=outlineStrokeWidth;if(self.bgPath==null){self.bgPath=_node("path",a);_jp.addClass(self.bgPath,_jp.connectorOutlineClass);_appendAtIndex(self.svg,self.bgPath,0);}else{_attr(self.bgPath,a);}_applyStyles(self.svg,self.bgPath,outlineStyle,d,self);}if(self.path==null){self.path=_node("path",a);_appendAtIndex(self.svg,self.path,style.outlineStroke?1:0);}else{_attr(self.path,a);}_applyStyles(self.svg,self.path,style,d,self);}};};_ju.extend(_jp.ConnectorRenderers.svg,SvgComponent);// ******************************* svg segment renderer *****************************************************\t\n// ******************************* /svg segments *****************************************************\n/*\r\n     * Base class for SVG endpoints.\r\n     */var SvgEndpoint=_jp.SvgEndpoint=function(params){var _super=SvgComponent.apply(this,[{cssClass:params._jsPlumb.endpointClass,originalArgs:arguments,pointerEventsSpec:"all",useDivWrapper:true,_jsPlumb:params._jsPlumb}]);_super.renderer.paint=function(style){var s=_jp.extend({},style);if(s.outlineStroke){s.stroke=s.outlineStroke;}if(this.node==null){this.node=this.makeNode(s);this.svg.appendChild(this.node);}else if(this.updateNode!=null){this.updateNode(this.node);}_applyStyles(this.svg,this.node,s,[this.x,this.y,this.w,this.h],this);_pos(this.node,[this.x,this.y]);}.bind(this);};_ju.extend(SvgEndpoint,SvgComponent);/*\r\n     * SVG Dot Endpoint\r\n     */_jp.Endpoints.svg.Dot=function(){_jp.Endpoints.Dot.apply(this,arguments);SvgEndpoint.apply(this,arguments);this.makeNode=function(style){return _node("circle",{"cx":this.w/2,"cy":this.h/2,"r":this.radius});};this.updateNode=function(node){_attr(node,{"cx":this.w/2,"cy":this.h/2,"r":this.radius});};};_ju.extend(_jp.Endpoints.svg.Dot,[_jp.Endpoints.Dot,SvgEndpoint]);/*\r\n     * SVG Rectangle Endpoint\r\n     */_jp.Endpoints.svg.Rectangle=function(){_jp.Endpoints.Rectangle.apply(this,arguments);SvgEndpoint.apply(this,arguments);this.makeNode=function(style){return _node("rect",{"width":this.w,"height":this.h});};this.updateNode=function(node){_attr(node,{"width":this.w,"height":this.h});};};_ju.extend(_jp.Endpoints.svg.Rectangle,[_jp.Endpoints.Rectangle,SvgEndpoint]);// ---------------------------------- Connectors ------------------------------------------------------------\n_jp.Connectors.svg.Flowchart=function(){_jp.Connectors.Flowchart.apply(this,arguments);_jp.ConnectorRenderers.svg.apply(this,arguments);};_ju.extend(_jp.Connectors.svg.Flowchart,[_jp.Connectors.Flowchart,_jp.ConnectorRenderers.svg]);_jp.Connectors.svg.Bezier=function(){_jp.Connectors.Bezier.apply(this,arguments);_jp.ConnectorRenderers.svg.apply(this,arguments);};_ju.extend(_jp.Connectors.svg.Bezier,[_jp.Connectors.Bezier,_jp.ConnectorRenderers.svg]);_jp.Connectors.svg.Straight=function(){_jp.Connectors.Straight.apply(this,arguments);_jp.ConnectorRenderers.svg.apply(this,arguments);};_ju.extend(_jp.Connectors.svg.Straight,[_jp.Connectors.Straight,_jp.ConnectorRenderers.svg]);_jp.Connectors.svg.StateMachine=function(){_jp.Connectors.StateMachine.apply(this,arguments);_jp.ConnectorRenderers.svg.apply(this,arguments);};_ju.extend(_jp.Connectors.svg.StateMachine,[_jp.Connectors.StateMachine,_jp.ConnectorRenderers.svg]);// ------------------------------------------ / Connectors -----------------------------------------\n/*\r\n     * SVG Image Endpoint is the default image endpoint.\r\n     */_jp.Endpoints.svg.Image=_jp.Endpoints.Image;/*\r\n     * Blank endpoint in svg renderer is the default Blank endpoint.\r\n     */_jp.Endpoints.svg.Blank=_jp.Endpoints.Blank;/*\r\n     * Label overlay in svg renderer is the default Label overlay.\r\n     */_jp.Overlays.svg.Label=_jp.Overlays.Label;/*\r\n     * Custom overlay in svg renderer is the default Custom overlay.\r\n     */_jp.Overlays.svg.Custom=_jp.Overlays.Custom;var AbstractSvgArrowOverlay=function AbstractSvgArrowOverlay(superclass,originalArgs){superclass.apply(this,originalArgs);_jp.jsPlumbUIComponent.apply(this,originalArgs);this.isAppendedAtTopLevel=false;var self=this;this.path=null;this.paint=function(params,containerExtents){// only draws on connections, not endpoints.\nif(params.component.svg&&containerExtents){if(this.path==null){this.path=_node("path",{"pointer-events":"all"});params.component.svg.appendChild(this.path);if(this.elementCreated){this.elementCreated(this.path,params.component);}this.canvas=params.component.svg;// for the sake of completeness; this behaves the same as other overlays\n}var clazz=originalArgs&&originalArgs.length===1?originalArgs[0].cssClass||"":"",offset=[0,0];if(containerExtents.xmin<0){offset[0]=-containerExtents.xmin;}if(containerExtents.ymin<0){offset[1]=-containerExtents.ymin;}_attr(this.path,{"d":makePath(params.d),"class":clazz,stroke:params.stroke?params.stroke:null,fill:params.fill?params.fill:null,transform:"translate("+offset[0]+","+offset[1]+")"});}};var makePath=function makePath(d){return isNaN(d.cxy.x)||isNaN(d.cxy.y)?"":"M"+d.hxy.x+","+d.hxy.y+" L"+d.tail[0].x+","+d.tail[0].y+" L"+d.cxy.x+","+d.cxy.y+" L"+d.tail[1].x+","+d.tail[1].y+" L"+d.hxy.x+","+d.hxy.y;};this.transfer=function(target){if(target.canvas&&this.path&&this.path.parentNode){this.path.parentNode.removeChild(this.path);target.canvas.appendChild(this.path);}};};_ju.extend(AbstractSvgArrowOverlay,[_jp.jsPlumbUIComponent,_jp.Overlays.AbstractOverlay],{cleanup:function cleanup(force){if(this.path!=null){if(force){this._jsPlumb.instance.removeElement(this.path);}else{if(this.path.parentNode){this.path.parentNode.removeChild(this.path);}}}},reattach:function reattach(instance,component){if(this.path&&component.canvas){component.canvas.appendChild(this.path);}},setVisible:function setVisible(v){if(this.path!=null){this.path.style.display=v?"block":"none";}}});_jp.Overlays.svg.Arrow=function(){AbstractSvgArrowOverlay.apply(this,[_jp.Overlays.Arrow,arguments]);};_ju.extend(_jp.Overlays.svg.Arrow,[_jp.Overlays.Arrow,AbstractSvgArrowOverlay]);_jp.Overlays.svg.PlainArrow=function(){AbstractSvgArrowOverlay.apply(this,[_jp.Overlays.PlainArrow,arguments]);};_ju.extend(_jp.Overlays.svg.PlainArrow,[_jp.Overlays.PlainArrow,AbstractSvgArrowOverlay]);_jp.Overlays.svg.Diamond=function(){AbstractSvgArrowOverlay.apply(this,[_jp.Overlays.Diamond,arguments]);};_ju.extend(_jp.Overlays.svg.Diamond,[_jp.Overlays.Diamond,AbstractSvgArrowOverlay]);// a test\n_jp.Overlays.svg.GuideLines=function(){var path=null,self=this,p1_1,p1_2;_jp.Overlays.GuideLines.apply(this,arguments);this.paint=function(params,containerExtents){if(path==null){path=_node("path");params.connector.svg.appendChild(path);self.attachListeners(path,params.connector);self.attachListeners(path,self);p1_1=_node("path");params.connector.svg.appendChild(p1_1);self.attachListeners(p1_1,params.connector);self.attachListeners(p1_1,self);p1_2=_node("path");params.connector.svg.appendChild(p1_2);self.attachListeners(p1_2,params.connector);self.attachListeners(p1_2,self);}var offset=[0,0];if(containerExtents.xmin<0){offset[0]=-containerExtents.xmin;}if(containerExtents.ymin<0){offset[1]=-containerExtents.ymin;}_attr(path,{"d":makePath(params.head,params.tail),stroke:"red",fill:null,transform:"translate("+offset[0]+","+offset[1]+")"});_attr(p1_1,{"d":makePath(params.tailLine[0],params.tailLine[1]),stroke:"blue",fill:null,transform:"translate("+offset[0]+","+offset[1]+")"});_attr(p1_2,{"d":makePath(params.headLine[0],params.headLine[1]),stroke:"green",fill:null,transform:"translate("+offset[0]+","+offset[1]+")"});};var makePath=function makePath(d1,d2){return"M "+d1.x+","+d1.y+" L"+d2.x+","+d2.y;};};_ju.extend(_jp.Overlays.svg.GuideLines,_jp.Overlays.GuideLines);}).call(typeof window!==\'undefined\'?window:this);/*\r\n * This file contains the \'vanilla\' adapter - having no external dependencies other than bundled libs.\r\n *\r\n * Copyright (c) 2010 - 2018 jsPlumb (hello@jsplumbtoolkit.com)\r\n * \r\n * https://jsplumbtoolkit.com\r\n * https://github.com/jsplumb/jsplumb\r\n * \r\n * Dual licensed under the MIT and GPL2 licenses.\r\n */;(function(){"use strict";var root=this,_jp=root.jsPlumb,_ju=root.jsPlumbUtil,_jk=root.Katavorio,_jg=root.Biltong;var _getDragManager=function _getDragManager(instance,category){category=category||"main";var key="_katavorio_"+category;var k=instance[key],e=instance.getEventManager();if(!k){k=new _jk({bind:e.on,unbind:e.off,getSize:_jp.getSize,getConstrainingRectangle:function getConstrainingRectangle(el){return[el.parentNode.scrollWidth,el.parentNode.scrollHeight];},getPosition:function getPosition(el,relativeToRoot){// if this is a nested draggable then compute the offset against its own offsetParent, otherwise\n// compute against the Container\'s origin. see also the getUIPosition method below.\nvar o=instance.getOffset(el,relativeToRoot,el._katavorioDrag?el.offsetParent:null);return[o.left,o.top];},setPosition:function setPosition(el,xy){el.style.left=xy[0]+"px";el.style.top=xy[1]+"px";},addClass:_jp.addClass,removeClass:_jp.removeClass,intersects:_jg.intersects,indexOf:function indexOf(l,i){return l.indexOf(i);},scope:instance.getDefaultScope(),css:{noSelect:instance.dragSelectClass,droppable:"jtk-droppable",draggable:"jtk-draggable",drag:"jtk-drag",selected:"jtk-drag-selected",active:"jtk-drag-active",hover:"jtk-drag-hover",ghostProxy:"jtk-ghost-proxy"}});k.setZoom(instance.getZoom());instance[key]=k;instance.bind("zoom",k.setZoom);}return k;};var _animProps=function _animProps(o,p){var _one=function _one(pName){if(p[pName]!=null){if(_ju.isString(p[pName])){var m=p[pName].match(/-=/)?-1:1,v=p[pName].substring(2);return o[pName]+m*v;}else{return p[pName];}}else{return o[pName];}};return[_one("left"),_one("top")];};_jp.extend(root.jsPlumbInstance.prototype,{animationSupported:true,getElement:function getElement(el){if(el==null){return null;}// here we pluck the first entry if el was a list of entries.\n// this is not my favourite thing to do, but previous versions of\n// jsplumb supported jquery selectors, and it is possible a selector\n// will be passed in here.\nel=typeof el==="string"?el:el.length!=null&&el.enctype==null?el[0]:el;return typeof el==="string"?document.getElementById(el):el;},removeElement:function removeElement(element){_getDragManager(this).elementRemoved(element);this.getEventManager().remove(element);},//\n// this adapter supports a rudimentary animation function. no easing is supported.  only\n// left/top properties are supported. property delta args are expected to be in the form\n//\n// +=x.xxxx\n//\n// or\n//\n// -=x.xxxx\n//\ndoAnimate:function doAnimate(el,properties,options){options=options||{};var o=this.getOffset(el),ap=_animProps(o,properties),ldist=ap[0]-o.left,tdist=ap[1]-o.top,d=options.duration||250,step=15,steps=d/step,linc=step/d*ldist,tinc=step/d*tdist,idx=0,_int=setInterval(function(){_jp.setPosition(el,{left:o.left+linc*(idx+1),top:o.top+tinc*(idx+1)});if(options.step!=null){options.step(idx,Math.ceil(steps));}idx++;if(idx>=steps){window.clearInterval(_int);if(options.complete!=null){options.complete();}}},step);},// DRAG/DROP\ndestroyDraggable:function destroyDraggable(el,category){_getDragManager(this,category).destroyDraggable(el);},unbindDraggable:function unbindDraggable(el,evt,fn,category){_getDragManager(this,category).destroyDraggable(el,evt,fn);},destroyDroppable:function destroyDroppable(el,category){_getDragManager(this,category).destroyDroppable(el);},unbindDroppable:function unbindDroppable(el,evt,fn,category){_getDragManager(this,category).destroyDroppable(el,evt,fn);},initDraggable:function initDraggable(el,options,category){_getDragManager(this,category).draggable(el,options);},initDroppable:function initDroppable(el,options,category){_getDragManager(this,category).droppable(el,options);},isAlreadyDraggable:function isAlreadyDraggable(el){return el._katavorioDrag!=null;},isDragSupported:function isDragSupported(el,options){return true;},isDropSupported:function isDropSupported(el,options){return true;},isElementDraggable:function isElementDraggable(el){el=_jp.getElement(el);return el._katavorioDrag&&el._katavorioDrag.isEnabled();},getDragObject:function getDragObject(eventArgs){return eventArgs[0].drag.getDragElement();},getDragScope:function getDragScope(el){return el._katavorioDrag&&el._katavorioDrag.scopes.join(" ")||"";},getDropEvent:function getDropEvent(args){return args[0].e;},getUIPosition:function getUIPosition(eventArgs,zoom){// here the position reported to us by Katavorio is relative to the element\'s offsetParent. For top\n// level nodes that is fine, but if we have a nested draggable then its offsetParent is actually\n// not going to be the jsplumb container; it\'s going to be some child of that element. In that case\n// we want to adjust the UI position to account for the offsetParent\'s position relative to the Container\n// origin.\nvar el=eventArgs[0].el;if(el.offsetParent==null){return null;}var finalPos=eventArgs[0].finalPos||eventArgs[0].pos;var p={left:finalPos[0],top:finalPos[1]};if(el._katavorioDrag&&el.offsetParent!==this.getContainer()){var oc=this.getOffset(el.offsetParent);p.left+=oc.left;p.top+=oc.top;}return p;},setDragFilter:function setDragFilter(el,filter,_exclude){if(el._katavorioDrag){el._katavorioDrag.setFilter(filter,_exclude);}},setElementDraggable:function setElementDraggable(el,draggable){el=_jp.getElement(el);if(el._katavorioDrag){el._katavorioDrag.setEnabled(draggable);}},setDragScope:function setDragScope(el,scope){if(el._katavorioDrag){el._katavorioDrag.k.setDragScope(el,scope);}},setDropScope:function setDropScope(el,scope){if(el._katavorioDrop&&el._katavorioDrop.length>0){el._katavorioDrop[0].k.setDropScope(el,scope);}},addToPosse:function addToPosse(el,spec){var specs=Array.prototype.slice.call(arguments,1);var dm=_getDragManager(this);_jp.each(el,function(_el){_el=[_jp.getElement(_el)];_el.push.apply(_el,specs);dm.addToPosse.apply(dm,_el);});},setPosse:function setPosse(el,spec){var specs=Array.prototype.slice.call(arguments,1);var dm=_getDragManager(this);_jp.each(el,function(_el){_el=[_jp.getElement(_el)];_el.push.apply(_el,specs);dm.setPosse.apply(dm,_el);});},removeFromPosse:function removeFromPosse(el,posseId){var specs=Array.prototype.slice.call(arguments,1);var dm=_getDragManager(this);_jp.each(el,function(_el){_el=[_jp.getElement(_el)];_el.push.apply(_el,specs);dm.removeFromPosse.apply(dm,_el);});},removeFromAllPosses:function removeFromAllPosses(el){var dm=_getDragManager(this);_jp.each(el,function(_el){dm.removeFromAllPosses(_jp.getElement(_el));});},setPosseState:function setPosseState(el,posseId,state){var dm=_getDragManager(this);_jp.each(el,function(_el){dm.setPosseState(_jp.getElement(_el),posseId,state);});},dragEvents:{\'start\':\'start\',\'stop\':\'stop\',\'drag\':\'drag\',\'step\':\'step\',\'over\':\'over\',\'out\':\'out\',\'drop\':\'drop\',\'complete\':\'complete\',\'beforeStart\':\'beforeStart\'},animEvents:{\'step\':"step",\'complete\':\'complete\'},stopDrag:function stopDrag(el){if(el._katavorioDrag){el._katavorioDrag.abort();}},addToDragSelection:function addToDragSelection(spec){_getDragManager(this).select(spec);},removeFromDragSelection:function removeFromDragSelection(spec){_getDragManager(this).deselect(spec);},clearDragSelection:function clearDragSelection(){_getDragManager(this).deselectAll();},trigger:function trigger(el,event,originalEvent,payload){this.getEventManager().trigger(el,event,originalEvent,payload);},doReset:function doReset(){// look for katavorio instances and reset each one if found.\nfor(var key in this){if(key.indexOf("_katavorio_")===0){this[key].reset();}}}});var ready=function ready(f){var _do=function _do(){if(/complete|loaded|interactive/.test(document.readyState)&&typeof document.body!=="undefined"&&document.body!=null){f();}else{setTimeout(_do,9);}};_do();};ready(_jp.init);}).call(typeof window!==\'undefined\'?window:this);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vY29yZS9jaGFydC9qc1BsdW1iLmpzPzlkMGMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF90eXBlb2Y9dHlwZW9mIFN5bWJvbD09PVwiZnVuY3Rpb25cIiYmdHlwZW9mIFN5bWJvbC5pdGVyYXRvcj09PVwic3ltYm9sXCI/ZnVuY3Rpb24ob2JqKXtyZXR1cm4gdHlwZW9mIG9iajt9OmZ1bmN0aW9uKG9iail7cmV0dXJuIG9iaiYmdHlwZW9mIFN5bWJvbD09PVwiZnVuY3Rpb25cIiYmb2JqLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZvYmohPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIG9iajt9Oy8qKlxyXG4gKiBqc0JlemllclxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgLSAyMDE3IGpzUGx1bWIgKGhlbGxvQGpzcGx1bWJ0b29sa2l0LmNvbSlcclxuICpcclxuICogbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxyXG4gKlxyXG4gKiBhIHNldCBvZiBCZXppZXIgY3VydmUgZnVuY3Rpb25zIHRoYXQgZGVhbCB3aXRoIEJlemllcnMsIHVzZWQgYnkganNQbHVtYiwgYW5kIHBlcmhhcHMgdXNlZnVsIGZvciBvdGhlciBwZW9wbGUuICBUaGVzZSBmdW5jdGlvbnMgd29yayB3aXRoIEJlemllclxyXG4gKiBjdXJ2ZXMgb2YgYXJiaXRyYXJ5IGRlZ3JlZS5cclxuICpcclxuICogLSBmdW5jdGlvbnMgYXJlIGFsbCBpbiB0aGUgJ2pzQmV6aWVyJyBuYW1lc3BhY2UuXHJcbiAqXHJcbiAqIC0gYWxsIGlucHV0IHBvaW50cyBzaG91bGQgYmUgaW4gdGhlIGZvcm1hdCB7eDouLiwgeTouLn0uIGFsbCBvdXRwdXQgcG9pbnRzIGFyZSBpbiB0aGlzIGZvcm1hdCB0b28uXHJcbiAqXHJcbiAqIC0gYWxsIGlucHV0IGN1cnZlcyBzaG91bGQgYmUgaW4gdGhlIGZvcm1hdCBbIHt4Oi4uLCB5Oi4ufSwge3g6Li4sIHk6Li59LCB7eDouLiwgeTouLn0sIHt4Oi4uLCB5Oi4ufSBdXHJcbiAqXHJcbiAqIC0gJ2xvY2F0aW9uJyBhcyB1c2VkIGFzIGFuIGlucHV0IGhlcmUgcmVmZXJzIHRvIGEgZGVjaW1hbCBpbiB0aGUgcmFuZ2UgMC0xIGluY2x1c2l2ZSwgd2hpY2ggaW5kaWNhdGVzIGEgcG9pbnQgc29tZSBwcm9wb3J0aW9uIGFsb25nIHRoZSBsZW5ndGhcclxuICogb2YgdGhlIGN1cnZlLiAgbG9jYXRpb24gYXMgb3V0cHV0IGhhcyB0aGUgc2FtZSBmb3JtYXQgYW5kIG1lYW5pbmcuXHJcbiAqXHJcbiAqXHJcbiAqIEZ1bmN0aW9uIExpc3Q6XHJcbiAqIC0tLS0tLS0tLS0tLS0tXHJcbiAqXHJcbiAqIGRpc3RhbmNlRnJvbUN1cnZlKHBvaW50LCBjdXJ2ZSlcclxuICpcclxuICogXHRDYWxjdWxhdGVzIHRoZSBkaXN0YW5jZSB0aGF0IHRoZSBnaXZlbiBwb2ludCBsaWVzIGZyb20gdGhlIGdpdmVuIEJlemllci4gIE5vdGUgdGhhdCBpdCBpcyBjb21wdXRlZCByZWxhdGl2ZSB0byB0aGUgY2VudGVyIG9mIHRoZSBCZXppZXIsXHJcbiAqIHNvIGlmIHlvdSBoYXZlIHN0cm9rZWQgdGhlIGN1cnZlIHdpdGggYSB3aWRlIHBlbiB5b3UgbWF5IHdpc2ggdG8gdGFrZSB0aGF0IGludG8gYWNjb3VudCEgIFRoZSBkaXN0YW5jZSByZXR1cm5lZCBpcyByZWxhdGl2ZSB0byB0aGUgdmFsdWVzXHJcbiAqIG9mIHRoZSBjdXJ2ZSBhbmQgdGhlIHBvaW50IC0gaXQgd2lsbCBtb3N0IGxpa2VseSBiZSBwaXhlbHMuXHJcbiAqXHJcbiAqIGdyYWRpZW50QXRQb2ludChjdXJ2ZSwgbG9jYXRpb24pXHJcbiAqXHJcbiAqIFx0Q2FsY3VsYXRlcyB0aGUgZ3JhZGllbnQgdG8gdGhlIGN1cnZlIGF0IHRoZSBnaXZlbiBsb2NhdGlvbiwgYXMgYSBkZWNpbWFsIGJldHdlZW4gMCBhbmQgMSBpbmNsdXNpdmUuXHJcbiAqXHJcbiAqIGdyYWRpZW50QXRQb2ludEFsb25nQ3VydmVGcm9tIChjdXJ2ZSwgbG9jYXRpb24pXHJcbiAqXHJcbiAqXHRDYWxjdWxhdGVzIHRoZSBncmFkaWVudCBhdCB0aGUgcG9pbnQgb24gdGhlIGdpdmVuIGN1cnZlIHRoYXQgaXMgJ2Rpc3RhbmNlJyB1bml0cyBmcm9tIGxvY2F0aW9uLlxyXG4gKlxyXG4gKiBuZWFyZXN0UG9pbnRPbkN1cnZlKHBvaW50LCBjdXJ2ZSlcclxuICpcclxuICpcdENhbGN1bGF0ZXMgdGhlIG5lYXJlc3QgcG9pbnQgdG8gdGhlIGdpdmVuIHBvaW50IG9uIHRoZSBnaXZlbiBjdXJ2ZS4gIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBpcyBhIEpTIG9iamVjdCBsaXRlcmFsLCBjb250YWluaW5nIGJvdGggdGhlXHJcbiAqcG9pbnQncyBjb29yZGluYXRlcyBhbmQgYWxzbyB0aGUgJ2xvY2F0aW9uJyBvZiB0aGUgcG9pbnQgKHNlZSBhYm92ZSksIGZvciBleGFtcGxlOiAgeyBwb2ludDp7eDo1NTEseToxNTB9LCBsb2NhdGlvbjowLjI2MzM2NSB9LlxyXG4gKlxyXG4gKiBwb2ludE9uQ3VydmUoY3VydmUsIGxvY2F0aW9uKVxyXG4gKlxyXG4gKiBcdENhbGN1bGF0ZXMgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBvbiB0aGUgZ2l2ZW4gQmV6aWVyIGN1cnZlIGF0IHRoZSBnaXZlbiBsb2NhdGlvbi5cclxuICpcclxuICogcG9pbnRBbG9uZ0N1cnZlRnJvbShjdXJ2ZSwgbG9jYXRpb24sIGRpc3RhbmNlKVxyXG4gKlxyXG4gKiBcdENhbGN1bGF0ZXMgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBvbiB0aGUgZ2l2ZW4gY3VydmUgdGhhdCBpcyAnZGlzdGFuY2UnIHVuaXRzIGZyb20gbG9jYXRpb24uICAnZGlzdGFuY2UnIHNob3VsZCBiZSBpbiB0aGUgc2FtZSBjb29yZGluYXRlXHJcbiAqIHNwYWNlIGFzIHRoYXQgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIEJlemllciBjdXJ2ZS4gIEZvciBhbiBIVE1MIENhbnZhcyB1c2FnZSwgZm9yIGV4YW1wbGUsIGRpc3RhbmNlIHdvdWxkIGJlIGEgbWVhc3VyZSBvZiBwaXhlbHMuXHJcbiAqXHJcbiAqIGxvY2F0aW9uQWxvbmdDdXJ2ZUZyb20oY3VydmUsIGxvY2F0aW9uLCBkaXN0YW5jZSlcclxuICpcclxuICogXHRDYWxjdWxhdGVzIHRoZSBsb2NhdGlvbiBvbiB0aGUgZ2l2ZW4gY3VydmUgdGhhdCBpcyAnZGlzdGFuY2UnIHVuaXRzIGZyb20gbG9jYXRpb24uICAnZGlzdGFuY2UnIHNob3VsZCBiZSBpbiB0aGUgc2FtZSBjb29yZGluYXRlXHJcbiAqIHNwYWNlIGFzIHRoYXQgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIEJlemllciBjdXJ2ZS4gIEZvciBhbiBIVE1MIENhbnZhcyB1c2FnZSwgZm9yIGV4YW1wbGUsIGRpc3RhbmNlIHdvdWxkIGJlIGEgbWVhc3VyZSBvZiBwaXhlbHMuXHJcbiAqXHJcbiAqIHBlcnBlbmRpY3VsYXJUb0N1cnZlQXQoY3VydmUsIGxvY2F0aW9uLCBsZW5ndGgsIGRpc3RhbmNlKVxyXG4gKlxyXG4gKiBcdENhbGN1bGF0ZXMgdGhlIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGdpdmVuIGN1cnZlIGF0IHRoZSBnaXZlbiBsb2NhdGlvbi4gIGxlbmd0aCBpcyB0aGUgbGVuZ3RoIG9mIHRoZSBsaW5lIHlvdSB3aXNoIGZvciAoaXQgd2lsbCBiZSBjZW50ZXJlZFxyXG4gKiBvbiB0aGUgcG9pbnQgYXQgJ2xvY2F0aW9uJykuIGRpc3RhbmNlIGlzIG9wdGlvbmFsLCBhbmQgYWxsb3dzIHlvdSB0byBzcGVjaWZ5IGEgcG9pbnQgYWxvbmcgdGhlIHBhdGggZnJvbSB0aGUgZ2l2ZW4gbG9jYXRpb24gYXMgdGhlIGNlbnRlciBvZlxyXG4gKiB0aGUgcGVycGVuZGljdWxhciByZXR1cm5lZC4gIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBpcyBhbiBhcnJheSBvZiB0d28gcG9pbnRzOiBbIHt4Oi4uLix5Oi4uLn0sIHt4Oi4uLix5Oi4uLn0gXS5cclxuICpcclxuICpcclxuICovKGZ1bmN0aW9uKCl7dmFyIHJvb3Q9dGhpcztpZih0eXBlb2YgTWF0aC5zZ249PVwidW5kZWZpbmVkXCIpe01hdGguc2duPWZ1bmN0aW9uKHgpe3JldHVybiB4PT0wPzA6eD4wPzE6LTE7fTt9dmFyIFZlY3RvcnM9e3N1YnRyYWN0OmZ1bmN0aW9uIHN1YnRyYWN0KHYxLHYyKXtyZXR1cm57eDp2MS54LXYyLngseTp2MS55LXYyLnl9O30sZG90UHJvZHVjdDpmdW5jdGlvbiBkb3RQcm9kdWN0KHYxLHYyKXtyZXR1cm4gdjEueCp2Mi54K3YxLnkqdjIueTt9LHNxdWFyZTpmdW5jdGlvbiBzcXVhcmUodil7cmV0dXJuIE1hdGguc3FydCh2Lngqdi54K3YueSp2LnkpO30sc2NhbGU6ZnVuY3Rpb24gc2NhbGUodixzKXtyZXR1cm57eDp2Lngqcyx5OnYueSpzfTt9fSxtYXhSZWN1cnNpb249NjQsZmxhdG5lc3NUb2xlcmFuY2U9TWF0aC5wb3coMi4wLC1tYXhSZWN1cnNpb24tMSk7LyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBkaXN0YW5jZSB0aGF0IHRoZSBwb2ludCBsaWVzIGZyb20gdGhlIGN1cnZlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwb2ludCBhIHBvaW50IGluIHRoZSBmb3JtIHt4OjU2NywgeTozMzQyfVxyXG4gICAgICogQHBhcmFtIGN1cnZlIGEgQmV6aWVyIGN1cnZlIGluIHRoZSBmb3JtIFt7eDouLi4sIHk6Li4ufSwge3g6Li4uLCB5Oi4uLn0sIHt4Oi4uLiwgeTouLi59LCB7eDouLi4sIHk6Li4ufV0uICBub3RlIHRoYXQgdGhpcyBpcyBjdXJyZW50bHlcclxuICAgICAqIGhhcmRjb2RlZCB0byBhc3N1bWUgY3ViaXogYmV6aWVycywgYnV0IHdvdWxkIGJlIGJldHRlciBvZmYgc3VwcG9ydGluZyBhbnkgZGVncmVlLlxyXG4gICAgICogQHJldHVybiBhIEpTIG9iamVjdCBsaXRlcmFsIGNvbnRhaW5pbmcgbG9jYXRpb24gYW5kIGRpc3RhbmNlLCBmb3IgZXhhbXBsZToge2xvY2F0aW9uOjAuMzUsIGRpc3RhbmNlOjEwfS4gIExvY2F0aW9uIGlzIGFuYWxvZ291cyB0byB0aGUgbG9jYXRpb25cclxuICAgICAqIGFyZ3VtZW50IHlvdSBwYXNzIHRvIHRoZSBwb2ludE9uUGF0aCBmdW5jdGlvbjogaXQgaXMgYSByYXRpbyBvZiBkaXN0YW5jZSB0cmF2ZWxsZWQgYWxvbmcgdGhlIGN1cnZlLiAgRGlzdGFuY2UgaXMgdGhlIGRpc3RhbmNlIGluIHBpeGVscyBmcm9tXHJcbiAgICAgKiB0aGUgcG9pbnQgdG8gdGhlIGN1cnZlLlxyXG4gICAgICovdmFyIF9kaXN0YW5jZUZyb21DdXJ2ZT1mdW5jdGlvbiBfZGlzdGFuY2VGcm9tQ3VydmUocG9pbnQsY3VydmUpe3ZhciBjYW5kaWRhdGVzPVtdLHc9X2NvbnZlcnRUb0Jlemllcihwb2ludCxjdXJ2ZSksZGVncmVlPWN1cnZlLmxlbmd0aC0xLGhpZ2hlckRlZ3JlZT0yKmRlZ3JlZS0xLG51bVNvbHV0aW9ucz1fZmluZFJvb3RzKHcsaGlnaGVyRGVncmVlLGNhbmRpZGF0ZXMsMCksdj1WZWN0b3JzLnN1YnRyYWN0KHBvaW50LGN1cnZlWzBdKSxkaXN0PVZlY3RvcnMuc3F1YXJlKHYpLHQ9MC4wO2Zvcih2YXIgaT0wO2k8bnVtU29sdXRpb25zO2krKyl7dj1WZWN0b3JzLnN1YnRyYWN0KHBvaW50LF9iZXppZXIoY3VydmUsZGVncmVlLGNhbmRpZGF0ZXNbaV0sbnVsbCxudWxsKSk7dmFyIG5ld0Rpc3Q9VmVjdG9ycy5zcXVhcmUodik7aWYobmV3RGlzdDxkaXN0KXtkaXN0PW5ld0Rpc3Q7dD1jYW5kaWRhdGVzW2ldO319dj1WZWN0b3JzLnN1YnRyYWN0KHBvaW50LGN1cnZlW2RlZ3JlZV0pO25ld0Rpc3Q9VmVjdG9ycy5zcXVhcmUodik7aWYobmV3RGlzdDxkaXN0KXtkaXN0PW5ld0Rpc3Q7dD0xLjA7fXJldHVybntsb2NhdGlvbjp0LGRpc3RhbmNlOmRpc3R9O307LyoqXHJcbiAgICAgKiBmaW5kcyB0aGUgbmVhcmVzdCBwb2ludCBvbiB0aGUgY3VydmUgdG8gdGhlIGdpdmVuIHBvaW50LlxyXG4gICAgICovdmFyIF9uZWFyZXN0UG9pbnRPbkN1cnZlPWZ1bmN0aW9uIF9uZWFyZXN0UG9pbnRPbkN1cnZlKHBvaW50LGN1cnZlKXt2YXIgdGQ9X2Rpc3RhbmNlRnJvbUN1cnZlKHBvaW50LGN1cnZlKTtyZXR1cm57cG9pbnQ6X2JlemllcihjdXJ2ZSxjdXJ2ZS5sZW5ndGgtMSx0ZC5sb2NhdGlvbixudWxsLG51bGwpLGxvY2F0aW9uOnRkLmxvY2F0aW9ufTt9O3ZhciBfY29udmVydFRvQmV6aWVyPWZ1bmN0aW9uIF9jb252ZXJ0VG9CZXppZXIocG9pbnQsY3VydmUpe3ZhciBkZWdyZWU9Y3VydmUubGVuZ3RoLTEsaGlnaGVyRGVncmVlPTIqZGVncmVlLTEsYz1bXSxkPVtdLGNkVGFibGU9W10sdz1bXSx6PVtbMS4wLDAuNiwwLjMsMC4xXSxbMC40LDAuNiwwLjYsMC40XSxbMC4xLDAuMywwLjYsMS4wXV07Zm9yKHZhciBpPTA7aTw9ZGVncmVlO2krKyl7Y1tpXT1WZWN0b3JzLnN1YnRyYWN0KGN1cnZlW2ldLHBvaW50KTt9Zm9yKHZhciBpPTA7aTw9ZGVncmVlLTE7aSsrKXtkW2ldPVZlY3RvcnMuc3VidHJhY3QoY3VydmVbaSsxXSxjdXJ2ZVtpXSk7ZFtpXT1WZWN0b3JzLnNjYWxlKGRbaV0sMy4wKTt9Zm9yKHZhciByb3c9MDtyb3c8PWRlZ3JlZS0xO3JvdysrKXtmb3IodmFyIGNvbHVtbj0wO2NvbHVtbjw9ZGVncmVlO2NvbHVtbisrKXtpZighY2RUYWJsZVtyb3ddKWNkVGFibGVbcm93XT1bXTtjZFRhYmxlW3Jvd11bY29sdW1uXT1WZWN0b3JzLmRvdFByb2R1Y3QoZFtyb3ddLGNbY29sdW1uXSk7fX1mb3IoaT0wO2k8PWhpZ2hlckRlZ3JlZTtpKyspe2lmKCF3W2ldKXdbaV09W107d1tpXS55PTAuMDt3W2ldLng9cGFyc2VGbG9hdChpKS9oaWdoZXJEZWdyZWU7fXZhciBuPWRlZ3JlZSxtPWRlZ3JlZS0xO2Zvcih2YXIgaz0wO2s8PW4rbTtrKyspe3ZhciBsYj1NYXRoLm1heCgwLGstbSksdWI9TWF0aC5taW4oayxuKTtmb3IoaT1sYjtpPD11YjtpKyspe2o9ay1pO3dbaStqXS55Kz1jZFRhYmxlW2pdW2ldKnpbal1baV07fX1yZXR1cm4gdzt9Oy8qKlxyXG4gICAgICogY291bnRzIGhvdyBtYW55IHJvb3RzIHRoZXJlIGFyZS5cclxuICAgICAqL3ZhciBfZmluZFJvb3RzPWZ1bmN0aW9uIF9maW5kUm9vdHModyxkZWdyZWUsdCxkZXB0aCl7dmFyIGxlZnQ9W10scmlnaHQ9W10sbGVmdF9jb3VudCxyaWdodF9jb3VudCxsZWZ0X3Q9W10scmlnaHRfdD1bXTtzd2l0Y2goX2dldENyb3NzaW5nQ291bnQodyxkZWdyZWUpKXtjYXNlIDA6e3JldHVybiAwO31jYXNlIDE6e2lmKGRlcHRoPj1tYXhSZWN1cnNpb24pe3RbMF09KHdbMF0ueCt3W2RlZ3JlZV0ueCkvMi4wO3JldHVybiAxO31pZihfaXNGbGF0RW5vdWdoKHcsZGVncmVlKSl7dFswXT1fY29tcHV0ZVhJbnRlcmNlcHQodyxkZWdyZWUpO3JldHVybiAxO31icmVhazt9fV9iZXppZXIodyxkZWdyZWUsMC41LGxlZnQscmlnaHQpO2xlZnRfY291bnQ9X2ZpbmRSb290cyhsZWZ0LGRlZ3JlZSxsZWZ0X3QsZGVwdGgrMSk7cmlnaHRfY291bnQ9X2ZpbmRSb290cyhyaWdodCxkZWdyZWUscmlnaHRfdCxkZXB0aCsxKTtmb3IodmFyIGk9MDtpPGxlZnRfY291bnQ7aSsrKXt0W2ldPWxlZnRfdFtpXTt9Zm9yKHZhciBpPTA7aTxyaWdodF9jb3VudDtpKyspe3RbaStsZWZ0X2NvdW50XT1yaWdodF90W2ldO31yZXR1cm4gbGVmdF9jb3VudCtyaWdodF9jb3VudDt9O3ZhciBfZ2V0Q3Jvc3NpbmdDb3VudD1mdW5jdGlvbiBfZ2V0Q3Jvc3NpbmdDb3VudChjdXJ2ZSxkZWdyZWUpe3ZhciBuX2Nyb3NzaW5ncz0wLHNpZ24sb2xkX3NpZ247c2lnbj1vbGRfc2lnbj1NYXRoLnNnbihjdXJ2ZVswXS55KTtmb3IodmFyIGk9MTtpPD1kZWdyZWU7aSsrKXtzaWduPU1hdGguc2duKGN1cnZlW2ldLnkpO2lmKHNpZ24hPW9sZF9zaWduKW5fY3Jvc3NpbmdzKys7b2xkX3NpZ249c2lnbjt9cmV0dXJuIG5fY3Jvc3NpbmdzO307dmFyIF9pc0ZsYXRFbm91Z2g9ZnVuY3Rpb24gX2lzRmxhdEVub3VnaChjdXJ2ZSxkZWdyZWUpe3ZhciBlcnJvcixpbnRlcmNlcHRfMSxpbnRlcmNlcHRfMixsZWZ0X2ludGVyY2VwdCxyaWdodF9pbnRlcmNlcHQsYSxiLGMsZGV0LGRJbnYsYTEsYjEsYzEsYTIsYjIsYzI7YT1jdXJ2ZVswXS55LWN1cnZlW2RlZ3JlZV0ueTtiPWN1cnZlW2RlZ3JlZV0ueC1jdXJ2ZVswXS54O2M9Y3VydmVbMF0ueCpjdXJ2ZVtkZWdyZWVdLnktY3VydmVbZGVncmVlXS54KmN1cnZlWzBdLnk7dmFyIG1heF9kaXN0YW5jZV9hYm92ZT1tYXhfZGlzdGFuY2VfYmVsb3c9MC4wO2Zvcih2YXIgaT0xO2k8ZGVncmVlO2krKyl7dmFyIHZhbHVlPWEqY3VydmVbaV0ueCtiKmN1cnZlW2ldLnkrYztpZih2YWx1ZT5tYXhfZGlzdGFuY2VfYWJvdmUpbWF4X2Rpc3RhbmNlX2Fib3ZlPXZhbHVlO2Vsc2UgaWYodmFsdWU8bWF4X2Rpc3RhbmNlX2JlbG93KW1heF9kaXN0YW5jZV9iZWxvdz12YWx1ZTt9YTE9MC4wO2IxPTEuMDtjMT0wLjA7YTI9YTtiMj1iO2MyPWMtbWF4X2Rpc3RhbmNlX2Fib3ZlO2RldD1hMSpiMi1hMipiMTtkSW52PTEuMC9kZXQ7aW50ZXJjZXB0XzE9KGIxKmMyLWIyKmMxKSpkSW52O2EyPWE7YjI9YjtjMj1jLW1heF9kaXN0YW5jZV9iZWxvdztkZXQ9YTEqYjItYTIqYjE7ZEludj0xLjAvZGV0O2ludGVyY2VwdF8yPShiMSpjMi1iMipjMSkqZEludjtsZWZ0X2ludGVyY2VwdD1NYXRoLm1pbihpbnRlcmNlcHRfMSxpbnRlcmNlcHRfMik7cmlnaHRfaW50ZXJjZXB0PU1hdGgubWF4KGludGVyY2VwdF8xLGludGVyY2VwdF8yKTtlcnJvcj1yaWdodF9pbnRlcmNlcHQtbGVmdF9pbnRlcmNlcHQ7cmV0dXJuIGVycm9yPGZsYXRuZXNzVG9sZXJhbmNlPzE6MDt9O3ZhciBfY29tcHV0ZVhJbnRlcmNlcHQ9ZnVuY3Rpb24gX2NvbXB1dGVYSW50ZXJjZXB0KGN1cnZlLGRlZ3JlZSl7dmFyIFhMSz0xLjAsWUxLPTAuMCxYTk09Y3VydmVbZGVncmVlXS54LWN1cnZlWzBdLngsWU5NPWN1cnZlW2RlZ3JlZV0ueS1jdXJ2ZVswXS55LFhNSz1jdXJ2ZVswXS54LTAuMCxZTUs9Y3VydmVbMF0ueS0wLjAsZGV0PVhOTSpZTEstWU5NKlhMSyxkZXRJbnY9MS4wL2RldCxTPShYTk0qWU1LLVlOTSpYTUspKmRldEludjtyZXR1cm4gMC4wK1hMSypTO307dmFyIF9iZXppZXI9ZnVuY3Rpb24gX2JlemllcihjdXJ2ZSxkZWdyZWUsdCxsZWZ0LHJpZ2h0KXt2YXIgdGVtcD1bW11dO2Zvcih2YXIgaj0wO2o8PWRlZ3JlZTtqKyspe3RlbXBbMF1bal09Y3VydmVbal07fWZvcih2YXIgaT0xO2k8PWRlZ3JlZTtpKyspe2Zvcih2YXIgaj0wO2o8PWRlZ3JlZS1pO2orKyl7aWYoIXRlbXBbaV0pdGVtcFtpXT1bXTtpZighdGVtcFtpXVtqXSl0ZW1wW2ldW2pdPXt9O3RlbXBbaV1bal0ueD0oMS4wLXQpKnRlbXBbaS0xXVtqXS54K3QqdGVtcFtpLTFdW2orMV0ueDt0ZW1wW2ldW2pdLnk9KDEuMC10KSp0ZW1wW2ktMV1bal0ueSt0KnRlbXBbaS0xXVtqKzFdLnk7fX1pZihsZWZ0IT1udWxsKWZvcihqPTA7ajw9ZGVncmVlO2orKyl7bGVmdFtqXT10ZW1wW2pdWzBdO31pZihyaWdodCE9bnVsbClmb3Ioaj0wO2o8PWRlZ3JlZTtqKyspe3JpZ2h0W2pdPXRlbXBbZGVncmVlLWpdW2pdO31yZXR1cm4gdGVtcFtkZWdyZWVdWzBdO307dmFyIF9jdXJ2ZUZ1bmN0aW9uQ2FjaGU9e307dmFyIF9nZXRDdXJ2ZUZ1bmN0aW9ucz1mdW5jdGlvbiBfZ2V0Q3VydmVGdW5jdGlvbnMob3JkZXIpe3ZhciBmbnM9X2N1cnZlRnVuY3Rpb25DYWNoZVtvcmRlcl07aWYoIWZucyl7Zm5zPVtdO3ZhciBmX3Rlcm09ZnVuY3Rpb24gZl90ZXJtKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLnBvdyh0LG9yZGVyKTt9O30sbF90ZXJtPWZ1bmN0aW9uIGxfdGVybSgpe3JldHVybiBmdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5wb3coMS10LG9yZGVyKTt9O30sY190ZXJtPWZ1bmN0aW9uIGNfdGVybShjKXtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIGM7fTt9LHRfdGVybT1mdW5jdGlvbiB0X3Rlcm0oKXtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIHQ7fTt9LG9uZV9taW51c190X3Rlcm09ZnVuY3Rpb24gb25lX21pbnVzX3RfdGVybSgpe3JldHVybiBmdW5jdGlvbih0KXtyZXR1cm4gMS10O307fSxfdGVybUZ1bmM9ZnVuY3Rpb24gX3Rlcm1GdW5jKHRlcm1zKXtyZXR1cm4gZnVuY3Rpb24odCl7dmFyIHA9MTtmb3IodmFyIGk9MDtpPHRlcm1zLmxlbmd0aDtpKyspe3A9cCp0ZXJtc1tpXSh0KTt9cmV0dXJuIHA7fTt9O2Zucy5wdXNoKG5ldyBmX3Rlcm0oKSk7Ly8gZmlyc3QgaXMgdCB0byB0aGUgcG93ZXIgb2YgdGhlIGN1cnZlIG9yZGVyXG5mb3IodmFyIGk9MTtpPG9yZGVyO2krKyl7dmFyIHRlcm1zPVtuZXcgY190ZXJtKG9yZGVyKV07Zm9yKHZhciBqPTA7ajxvcmRlci1pO2orKyl7dGVybXMucHVzaChuZXcgdF90ZXJtKCkpO31mb3IodmFyIGo9MDtqPGk7aisrKXt0ZXJtcy5wdXNoKG5ldyBvbmVfbWludXNfdF90ZXJtKCkpO31mbnMucHVzaChuZXcgX3Rlcm1GdW5jKHRlcm1zKSk7fWZucy5wdXNoKG5ldyBsX3Rlcm0oKSk7Ly8gbGFzdCBpcyAoMS10KSB0byB0aGUgcG93ZXIgb2YgdGhlIGN1cnZlIG9yZGVyXG5fY3VydmVGdW5jdGlvbkNhY2hlW29yZGVyXT1mbnM7fXJldHVybiBmbnM7fTsvKipcclxuICAgICAqIGNhbGN1bGF0ZXMgYSBwb2ludCBvbiB0aGUgY3VydmUsIGZvciBhIEJlemllciBvZiBhcmJpdHJhcnkgb3JkZXIuXHJcbiAgICAgKiBAcGFyYW0gY3VydmUgYW4gYXJyYXkgb2YgY29udHJvbCBwb2ludHMsIGVnIFt7eDoxMCx5OjIwfSwge3g6NTAseTo1MH0sIHt4OjEwMCx5OjEwMH0sIHt4OjEyMCx5OjEwMH1dLiAgRm9yIGEgY3ViaWMgYmV6aWVyIHRoaXMgc2hvdWxkIGhhdmUgZm91ciBwb2ludHMuXHJcbiAgICAgKiBAcGFyYW0gbG9jYXRpb24gYSBkZWNpbWFsIGluZGljYXRpbmcgdGhlIGRpc3RhbmNlIGFsb25nIHRoZSBjdXJ2ZSB0aGUgcG9pbnQgc2hvdWxkIGJlIGxvY2F0ZWQgYXQuICB0aGlzIGlzIHRoZSBkaXN0YW5jZSBhbG9uZyB0aGUgY3VydmUgYXMgaXQgdHJhdmVscywgdGFraW5nIHRoZSB3YXkgaXQgYmVuZHMgaW50byBhY2NvdW50LiAgc2hvdWxkIGJlIGEgbnVtYmVyIGZyb20gMCB0byAxLCBpbmNsdXNpdmUuXHJcbiAgICAgKi92YXIgX3BvaW50T25QYXRoPWZ1bmN0aW9uIF9wb2ludE9uUGF0aChjdXJ2ZSxsb2NhdGlvbil7dmFyIGNjPV9nZXRDdXJ2ZUZ1bmN0aW9ucyhjdXJ2ZS5sZW5ndGgtMSksX3g9MCxfeT0wO2Zvcih2YXIgaT0wO2k8Y3VydmUubGVuZ3RoO2krKyl7X3g9X3grY3VydmVbaV0ueCpjY1tpXShsb2NhdGlvbik7X3k9X3krY3VydmVbaV0ueSpjY1tpXShsb2NhdGlvbik7fXJldHVybnt4Ol94LHk6X3l9O307dmFyIF9kaXN0PWZ1bmN0aW9uIF9kaXN0KHAxLHAyKXtyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHAxLngtcDIueCwyKStNYXRoLnBvdyhwMS55LXAyLnksMikpO307dmFyIF9pc1BvaW50PWZ1bmN0aW9uIF9pc1BvaW50KGN1cnZlKXtyZXR1cm4gY3VydmVbMF0ueD09Y3VydmVbMV0ueCYmY3VydmVbMF0ueT09Y3VydmVbMV0ueTt9Oy8qKlxyXG4gICAgICogZmluZHMgdGhlIHBvaW50IHRoYXQgaXMgJ2Rpc3RhbmNlJyBhbG9uZyB0aGUgcGF0aCBmcm9tICdsb2NhdGlvbicuICB0aGlzIG1ldGhvZCByZXR1cm5zIGJvdGggdGhlIHgseSBsb2NhdGlvbiBvZiB0aGUgcG9pbnQgYW5kIGFsc29cclxuICAgICAqIGl0cyAnbG9jYXRpb24nIChwcm9wb3J0aW9uIG9mIHRyYXZlbCBhbG9uZyB0aGUgcGF0aCk7IHRoZSBtZXRob2QgYmVsb3cgLSBfcG9pbnRBbG9uZ1BhdGhGcm9tIC0gY2FsbHMgdGhpcyBtZXRob2QgYW5kIGp1c3QgcmV0dXJucyB0aGVcclxuICAgICAqIHBvaW50LlxyXG4gICAgICovdmFyIF9wb2ludEFsb25nUGF0aD1mdW5jdGlvbiBfcG9pbnRBbG9uZ1BhdGgoY3VydmUsbG9jYXRpb24sZGlzdGFuY2Upe2lmKF9pc1BvaW50KGN1cnZlKSl7cmV0dXJue3BvaW50OmN1cnZlWzBdLGxvY2F0aW9uOmxvY2F0aW9ufTt9dmFyIHByZXY9X3BvaW50T25QYXRoKGN1cnZlLGxvY2F0aW9uKSx0YWxseT0wLGN1ckxvYz1sb2NhdGlvbixkaXJlY3Rpb249ZGlzdGFuY2U+MD8xOi0xLGN1cj1udWxsO3doaWxlKHRhbGx5PE1hdGguYWJzKGRpc3RhbmNlKSl7Y3VyTG9jKz0wLjAwNSpkaXJlY3Rpb247Y3VyPV9wb2ludE9uUGF0aChjdXJ2ZSxjdXJMb2MpO3RhbGx5Kz1fZGlzdChjdXIscHJldik7cHJldj1jdXI7fXJldHVybntwb2ludDpjdXIsbG9jYXRpb246Y3VyTG9jfTt9O3ZhciBfbGVuZ3RoPWZ1bmN0aW9uIF9sZW5ndGgoY3VydmUpe2lmKF9pc1BvaW50KGN1cnZlKSlyZXR1cm4gMDt2YXIgcHJldj1fcG9pbnRPblBhdGgoY3VydmUsMCksdGFsbHk9MCxjdXJMb2M9MCxkaXJlY3Rpb249MSxjdXI9bnVsbDt3aGlsZShjdXJMb2M8MSl7Y3VyTG9jKz0wLjAwNSpkaXJlY3Rpb247Y3VyPV9wb2ludE9uUGF0aChjdXJ2ZSxjdXJMb2MpO3RhbGx5Kz1fZGlzdChjdXIscHJldik7cHJldj1jdXI7fXJldHVybiB0YWxseTt9Oy8qKlxyXG4gICAgICogZmluZHMgdGhlIHBvaW50IHRoYXQgaXMgJ2Rpc3RhbmNlJyBhbG9uZyB0aGUgcGF0aCBmcm9tICdsb2NhdGlvbicuXHJcbiAgICAgKi92YXIgX3BvaW50QWxvbmdQYXRoRnJvbT1mdW5jdGlvbiBfcG9pbnRBbG9uZ1BhdGhGcm9tKGN1cnZlLGxvY2F0aW9uLGRpc3RhbmNlKXtyZXR1cm4gX3BvaW50QWxvbmdQYXRoKGN1cnZlLGxvY2F0aW9uLGRpc3RhbmNlKS5wb2ludDt9Oy8qKlxyXG4gICAgICogZmluZHMgdGhlIGxvY2F0aW9uIHRoYXQgaXMgJ2Rpc3RhbmNlJyBhbG9uZyB0aGUgcGF0aCBmcm9tICdsb2NhdGlvbicuXHJcbiAgICAgKi92YXIgX2xvY2F0aW9uQWxvbmdQYXRoRnJvbT1mdW5jdGlvbiBfbG9jYXRpb25BbG9uZ1BhdGhGcm9tKGN1cnZlLGxvY2F0aW9uLGRpc3RhbmNlKXtyZXR1cm4gX3BvaW50QWxvbmdQYXRoKGN1cnZlLGxvY2F0aW9uLGRpc3RhbmNlKS5sb2NhdGlvbjt9Oy8qKlxyXG4gICAgICogcmV0dXJucyB0aGUgZ3JhZGllbnQgb2YgdGhlIGN1cnZlIGF0IHRoZSBnaXZlbiBsb2NhdGlvbiwgd2hpY2ggaXMgYSBkZWNpbWFsIGJldHdlZW4gMCBhbmQgMSBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogdGhhbmtzIC8vIGh0dHA6Ly9iaW1peHVhbC5vcmcvQW5pbWF0aW9uTGlicmFyeS9iZXppZXJ0YW5nZW50cy5odG1sXHJcbiAgICAgKi92YXIgX2dyYWRpZW50QXRQb2ludD1mdW5jdGlvbiBfZ3JhZGllbnRBdFBvaW50KGN1cnZlLGxvY2F0aW9uKXt2YXIgcDE9X3BvaW50T25QYXRoKGN1cnZlLGxvY2F0aW9uKSxwMj1fcG9pbnRPblBhdGgoY3VydmUuc2xpY2UoMCxjdXJ2ZS5sZW5ndGgtMSksbG9jYXRpb24pLGR5PXAyLnktcDEueSxkeD1wMi54LXAxLng7cmV0dXJuIGR5PT0wP0luZmluaXR5Ok1hdGguYXRhbihkeS9keCk7fTsvKipcclxuICAgICByZXR1cm5zIHRoZSBncmFkaWVudCBvZiB0aGUgY3VydmUgYXQgdGhlIHBvaW50IHdoaWNoIGlzICdkaXN0YW5jZScgZnJvbSB0aGUgZ2l2ZW4gbG9jYXRpb24uXHJcbiAgICAgaWYgdGhpcyBwb2ludCBpcyBncmVhdGVyIHRoYW4gbG9jYXRpb24gMSwgdGhlIGdyYWRpZW50IGF0IGxvY2F0aW9uIDEgaXMgcmV0dXJuZWQuXHJcbiAgICAgaWYgdGhpcyBwb2ludCBpcyBsZXNzIHRoYW4gbG9jYXRpb24gMCwgdGhlIGdyYWRpZW50IGF0IGxvY2F0aW9uIDAgaXMgcmV0dXJuZWQuXHJcbiAgICAgKi92YXIgX2dyYWRpZW50QXRQb2ludEFsb25nUGF0aEZyb209ZnVuY3Rpb24gX2dyYWRpZW50QXRQb2ludEFsb25nUGF0aEZyb20oY3VydmUsbG9jYXRpb24sZGlzdGFuY2Upe3ZhciBwPV9wb2ludEFsb25nUGF0aChjdXJ2ZSxsb2NhdGlvbixkaXN0YW5jZSk7aWYocC5sb2NhdGlvbj4xKXAubG9jYXRpb249MTtpZihwLmxvY2F0aW9uPDApcC5sb2NhdGlvbj0wO3JldHVybiBfZ3JhZGllbnRBdFBvaW50KGN1cnZlLHAubG9jYXRpb24pO307LyoqXHJcbiAgICAgKiBjYWxjdWxhdGVzIGEgbGluZSB0aGF0IGlzICdsZW5ndGgnIHBpeGVscyBsb25nLCBwZXJwZW5kaWN1bGFyIHRvLCBhbmQgY2VudGVyZWQgb24sIHRoZSBwYXRoIGF0ICdkaXN0YW5jZScgcGl4ZWxzIGZyb20gdGhlIGdpdmVuIGxvY2F0aW9uLlxyXG4gICAgICogaWYgZGlzdGFuY2UgaXMgbm90IHN1cHBsaWVkLCB0aGUgcGVycGVuZGljdWxhciBmb3IgdGhlIGdpdmVuIGxvY2F0aW9uIGlzIGNvbXB1dGVkIChpZS4gd2Ugc2V0IGRpc3RhbmNlIHRvIHplcm8pLlxyXG4gICAgICovdmFyIF9wZXJwZW5kaWN1bGFyVG9QYXRoQXQ9ZnVuY3Rpb24gX3BlcnBlbmRpY3VsYXJUb1BhdGhBdChjdXJ2ZSxsb2NhdGlvbixsZW5ndGgsZGlzdGFuY2Upe2Rpc3RhbmNlPWRpc3RhbmNlPT1udWxsPzA6ZGlzdGFuY2U7dmFyIHA9X3BvaW50QWxvbmdQYXRoKGN1cnZlLGxvY2F0aW9uLGRpc3RhbmNlKSxtPV9ncmFkaWVudEF0UG9pbnQoY3VydmUscC5sb2NhdGlvbiksX3RoZXRhMj1NYXRoLmF0YW4oLTEvbSkseT1sZW5ndGgvMipNYXRoLnNpbihfdGhldGEyKSx4PWxlbmd0aC8yKk1hdGguY29zKF90aGV0YTIpO3JldHVyblt7eDpwLnBvaW50LngreCx5OnAucG9pbnQueSt5fSx7eDpwLnBvaW50LngteCx5OnAucG9pbnQueS15fV07fTt2YXIganNCZXppZXI9dGhpcy5qc0Jlemllcj17ZGlzdGFuY2VGcm9tQ3VydmU6X2Rpc3RhbmNlRnJvbUN1cnZlLGdyYWRpZW50QXRQb2ludDpfZ3JhZGllbnRBdFBvaW50LGdyYWRpZW50QXRQb2ludEFsb25nQ3VydmVGcm9tOl9ncmFkaWVudEF0UG9pbnRBbG9uZ1BhdGhGcm9tLG5lYXJlc3RQb2ludE9uQ3VydmU6X25lYXJlc3RQb2ludE9uQ3VydmUscG9pbnRPbkN1cnZlOl9wb2ludE9uUGF0aCxwb2ludEFsb25nQ3VydmVGcm9tOl9wb2ludEFsb25nUGF0aEZyb20scGVycGVuZGljdWxhclRvQ3VydmVBdDpfcGVycGVuZGljdWxhclRvUGF0aEF0LGxvY2F0aW9uQWxvbmdDdXJ2ZUZyb206X2xvY2F0aW9uQWxvbmdQYXRoRnJvbSxnZXRMZW5ndGg6X2xlbmd0aCx2ZXJzaW9uOlwiMC45LjBcIn07aWYodHlwZW9mIGV4cG9ydHMhPT1cInVuZGVmaW5lZFwiKXtleHBvcnRzLmpzQmV6aWVyPWpzQmV6aWVyO319KS5jYWxsKHR5cGVvZiB3aW5kb3chPT0ndW5kZWZpbmVkJz93aW5kb3c6dGhpcyk7LyoqXHJcbiAqIEJpbHRvbmcgdjAuNC4wXHJcbiAqXHJcbiAqIFZhcmlvdXMgZ2VvbWV0cnkgZnVuY3Rpb25zIHdyaXR0ZW4gYXMgcGFydCBvZiBqc1BsdW1iIGFuZCBwZXJoYXBzIHVzZWZ1bCBmb3Igb3RoZXJzLlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcganNQbHVtYlxyXG4gKiBodHRwczovL2pzcGx1bWJ0b29sa2l0LmNvbVxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxyXG4gKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxyXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcclxuICogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXHJcbiAqIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxyXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xyXG4gKiBjb25kaXRpb25zOlxyXG4gKlxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICpcclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXHJcbiAqIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXHJcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXHJcbiAqIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxyXG4gKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcclxuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxyXG4gKiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbiAqLzsoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgcm9vdD10aGlzO3ZhciBCaWx0b25nPXJvb3QuQmlsdG9uZz17dmVyc2lvbjpcIjAuNC4wXCJ9O2lmKHR5cGVvZiBleHBvcnRzIT09XCJ1bmRlZmluZWRcIil7ZXhwb3J0cy5CaWx0b25nPUJpbHRvbmc7fXZhciBfaXNhPWZ1bmN0aW9uIF9pc2EoYSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKT09PVwiW29iamVjdCBBcnJheV1cIjt9LF9wb2ludEhlbHBlcj1mdW5jdGlvbiBfcG9pbnRIZWxwZXIocDEscDIsZm4pe3AxPV9pc2EocDEpP3AxOltwMS54LHAxLnldO3AyPV9pc2EocDIpP3AyOltwMi54LHAyLnldO3JldHVybiBmbihwMSxwMik7fSwvKipcclxuICAgICAgICAgKiBAbmFtZSBCaWx0b25nLmdyYWRpZW50XHJcbiAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICogQGRlc2MgQ2FsY3VsYXRlcyB0aGUgZ3JhZGllbnQgb2YgYSBsaW5lIGJldHdlZW4gdGhlIHR3byBwb2ludHMuXHJcbiAgICAgICAgICogQHBhcmFtIHtQb2ludH0gcDEgRmlyc3QgcG9pbnQsIGVpdGhlciBhcyBhIDIgZW50cnkgYXJyYXkgb3Igb2JqZWN0IHdpdGggYGxlZnRgIGFuZCBgdG9wYCBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7UG9pbnR9IHAyIFNlY29uZCBwb2ludCwgZWl0aGVyIGFzIGEgMiBlbnRyeSBhcnJheSBvciBvYmplY3Qgd2l0aCBgbGVmdGAgYW5kIGB0b3BgIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICogQHJldHVybiB7RmxvYXR9IFRoZSBncmFkaWVudCBvZiBhIGxpbmUgYmV0d2VlbiB0aGUgdHdvIHBvaW50cy5cclxuICAgICAgICAgKi9fZ3JhZGllbnQ9QmlsdG9uZy5ncmFkaWVudD1mdW5jdGlvbihwMSxwMil7cmV0dXJuIF9wb2ludEhlbHBlcihwMSxwMixmdW5jdGlvbihfcDEsX3AyKXtpZihfcDJbMF09PV9wMVswXSlyZXR1cm4gX3AyWzFdPl9wMVsxXT9JbmZpbml0eTotSW5maW5pdHk7ZWxzZSBpZihfcDJbMV09PV9wMVsxXSlyZXR1cm4gX3AyWzBdPl9wMVswXT8wOi0wO2Vsc2UgcmV0dXJuKF9wMlsxXS1fcDFbMV0pLyhfcDJbMF0tX3AxWzBdKTt9KTt9LC8qKlxyXG4gICAgICAgICAqIEBuYW1lIEJpbHRvbmcubm9ybWFsXHJcbiAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICogQGRlc2MgQ2FsY3VsYXRlcyB0aGUgZ3JhZGllbnQgb2YgYSBub3JtYWwgdG8gYSBsaW5lIGJldHdlZW4gdGhlIHR3byBwb2ludHMuXHJcbiAgICAgICAgICogQHBhcmFtIHtQb2ludH0gcDEgRmlyc3QgcG9pbnQsIGVpdGhlciBhcyBhIDIgZW50cnkgYXJyYXkgb3Igb2JqZWN0IHdpdGggYGxlZnRgIGFuZCBgdG9wYCBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7UG9pbnR9IHAyIFNlY29uZCBwb2ludCwgZWl0aGVyIGFzIGEgMiBlbnRyeSBhcnJheSBvciBvYmplY3Qgd2l0aCBgbGVmdGAgYW5kIGB0b3BgIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICogQHJldHVybiB7RmxvYXR9IFRoZSBncmFkaWVudCBvZiBhIG5vcm1hbCB0byBhIGxpbmUgYmV0d2VlbiB0aGUgdHdvIHBvaW50cy5cclxuICAgICAgICAgKi9fbm9ybWFsPUJpbHRvbmcubm9ybWFsPWZ1bmN0aW9uKHAxLHAyKXtyZXR1cm4tMS9fZ3JhZGllbnQocDEscDIpO30sLyoqXHJcbiAgICAgICAgICogQG5hbWUgQmlsdG9uZy5saW5lTGVuZ3RoXHJcbiAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICogQGRlc2MgQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgbGluZSBiZXR3ZWVuIHRoZSB0d28gcG9pbnRzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7UG9pbnR9IHAxIEZpcnN0IHBvaW50LCBlaXRoZXIgYXMgYSAyIGVudHJ5IGFycmF5IG9yIG9iamVjdCB3aXRoIGBsZWZ0YCBhbmQgYHRvcGAgcHJvcGVydGllcy5cclxuICAgICAgICAgKiBAcGFyYW0ge1BvaW50fSBwMiBTZWNvbmQgcG9pbnQsIGVpdGhlciBhcyBhIDIgZW50cnkgYXJyYXkgb3Igb2JqZWN0IHdpdGggYGxlZnRgIGFuZCBgdG9wYCBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAqIEByZXR1cm4ge0Zsb2F0fSBUaGUgbGVuZ3RoIG9mIGEgbGluZSBiZXR3ZWVuIHRoZSB0d28gcG9pbnRzLlxyXG4gICAgICAgICAqL19saW5lTGVuZ3RoPUJpbHRvbmcubGluZUxlbmd0aD1mdW5jdGlvbihwMSxwMil7cmV0dXJuIF9wb2ludEhlbHBlcihwMSxwMixmdW5jdGlvbihfcDEsX3AyKXtyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KF9wMlsxXS1fcDFbMV0sMikrTWF0aC5wb3coX3AyWzBdLV9wMVswXSwyKSk7fSk7fSwvKipcclxuICAgICAgICAgKiBAbmFtZSBCaWx0b25nLnF1YWRyYW50XHJcbiAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICogQGRlc2MgQ2FsY3VsYXRlcyB0aGUgcXVhZHJhbnQgaW4gd2hpY2ggdGhlIGFuZ2xlIGJldHdlZW4gdGhlIHR3byBwb2ludHMgbGllcy5cclxuICAgICAgICAgKiBAcGFyYW0ge1BvaW50fSBwMSBGaXJzdCBwb2ludCwgZWl0aGVyIGFzIGEgMiBlbnRyeSBhcnJheSBvciBvYmplY3Qgd2l0aCBgbGVmdGAgYW5kIGB0b3BgIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHtQb2ludH0gcDIgU2Vjb25kIHBvaW50LCBlaXRoZXIgYXMgYSAyIGVudHJ5IGFycmF5IG9yIG9iamVjdCB3aXRoIGBsZWZ0YCBhbmQgYHRvcGAgcHJvcGVydGllcy5cclxuICAgICAgICAgKiBAcmV0dXJuIHtJbnRlZ2VyfSBUaGUgcXVhZHJhbnQgLSAxIGZvciB1cHBlciByaWdodCwgMiBmb3IgbG93ZXIgcmlnaHQsIDMgZm9yIGxvd2VyIGxlZnQsIDQgZm9yIHVwcGVyIGxlZnQuXHJcbiAgICAgICAgICovX3F1YWRyYW50PUJpbHRvbmcucXVhZHJhbnQ9ZnVuY3Rpb24ocDEscDIpe3JldHVybiBfcG9pbnRIZWxwZXIocDEscDIsZnVuY3Rpb24oX3AxLF9wMil7aWYoX3AyWzBdPl9wMVswXSl7cmV0dXJuIF9wMlsxXT5fcDFbMV0/MjoxO31lbHNlIGlmKF9wMlswXT09X3AxWzBdKXtyZXR1cm4gX3AyWzFdPl9wMVsxXT8yOjE7fWVsc2V7cmV0dXJuIF9wMlsxXT5fcDFbMV0/Mzo0O319KTt9LC8qKlxyXG4gICAgICAgICAqIEBuYW1lIEJpbHRvbmcudGhldGFcclxuICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgKiBAZGVzYyBDYWxjdWxhdGVzIHRoZSBhbmdsZSBiZXR3ZWVuIHRoZSB0d28gcG9pbnRzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7UG9pbnR9IHAxIEZpcnN0IHBvaW50LCBlaXRoZXIgYXMgYSAyIGVudHJ5IGFycmF5IG9yIG9iamVjdCB3aXRoIGBsZWZ0YCBhbmQgYHRvcGAgcHJvcGVydGllcy5cclxuICAgICAgICAgKiBAcGFyYW0ge1BvaW50fSBwMiBTZWNvbmQgcG9pbnQsIGVpdGhlciBhcyBhIDIgZW50cnkgYXJyYXkgb3Igb2JqZWN0IHdpdGggYGxlZnRgIGFuZCBgdG9wYCBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAqIEByZXR1cm4ge0Zsb2F0fSBUaGUgYW5nbGUgYmV0d2VlbiB0aGUgdHdvIHBvaW50cy5cclxuICAgICAgICAgKi9fdGhldGE9QmlsdG9uZy50aGV0YT1mdW5jdGlvbihwMSxwMil7cmV0dXJuIF9wb2ludEhlbHBlcihwMSxwMixmdW5jdGlvbihfcDEsX3AyKXt2YXIgbT1fZ3JhZGllbnQoX3AxLF9wMiksdD1NYXRoLmF0YW4obSkscz1fcXVhZHJhbnQoX3AxLF9wMik7aWYocz09NHx8cz09Myl0Kz1NYXRoLlBJO2lmKHQ8MCl0Kz0yKk1hdGguUEk7cmV0dXJuIHQ7fSk7fSwvKipcclxuICAgICAgICAgKiBAbmFtZSBCaWx0b25nLmludGVyc2VjdHNcclxuICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgKiBAZGVzYyBDYWxjdWxhdGVzIHdoZXRoZXIgb3Igbm90IHRoZSB0d28gcmVjdGFuZ2xlcyBpbnRlcnNlY3QuXHJcbiAgICAgICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IHIxIEZpcnN0IHJlY3RhbmdsZSwgYXMgYSBqcyBvYmplY3QgaW4gdGhlIGZvcm0gYHt4Oi4uLCB5Oi4uLCB3Oi4uLCBoOi4ufWBcclxuICAgICAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gcjIgU2Vjb25kIHJlY3RhbmdsZSwgYXMgYSBqcyBvYmplY3QgaW4gdGhlIGZvcm0gYHt4Oi4uLCB5Oi4uLCB3Oi4uLCBoOi4ufWBcclxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSByZWN0YW5nbGVzIGludGVyc2VjdCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICAgICAqL19pbnRlcnNlY3RzPUJpbHRvbmcuaW50ZXJzZWN0cz1mdW5jdGlvbihyMSxyMil7dmFyIHgxPXIxLngseDI9cjEueCtyMS53LHkxPXIxLnkseTI9cjEueStyMS5oLGExPXIyLngsYTI9cjIueCtyMi53LGIxPXIyLnksYjI9cjIueStyMi5oO3JldHVybiB4MTw9YTEmJmExPD14MiYmeTE8PWIxJiZiMTw9eTJ8fHgxPD1hMiYmYTI8PXgyJiZ5MTw9YjEmJmIxPD15Mnx8eDE8PWExJiZhMTw9eDImJnkxPD1iMiYmYjI8PXkyfHx4MTw9YTImJmExPD14MiYmeTE8PWIyJiZiMjw9eTJ8fGExPD14MSYmeDE8PWEyJiZiMTw9eTEmJnkxPD1iMnx8YTE8PXgyJiZ4Mjw9YTImJmIxPD15MSYmeTE8PWIyfHxhMTw9eDEmJngxPD1hMiYmYjE8PXkyJiZ5Mjw9YjJ8fGExPD14MiYmeDE8PWEyJiZiMTw9eTImJnkyPD1iMjt9LC8qKlxyXG4gICAgICAgICAqIEBuYW1lIEJpbHRvbmcuZW5jbG9zZXNcclxuICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgKiBAZGVzYyBDYWxjdWxhdGVzIHdoZXRoZXIgb3Igbm90IHIyIGlzIGNvbXBsZXRlbHkgZW5jbG9zZWQgYnkgcjEuXHJcbiAgICAgICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IHIxIEZpcnN0IHJlY3RhbmdsZSwgYXMgYSBqcyBvYmplY3QgaW4gdGhlIGZvcm0gYHt4Oi4uLCB5Oi4uLCB3Oi4uLCBoOi4ufWBcclxuICAgICAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gcjIgU2Vjb25kIHJlY3RhbmdsZSwgYXMgYSBqcyBvYmplY3QgaW4gdGhlIGZvcm0gYHt4Oi4uLCB5Oi4uLCB3Oi4uLCBoOi4ufWBcclxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthbGxvd1NoYXJlZEVkZ2VzPWZhbHNlXSBJZiB0cnVlLCB0aGUgY29uY2VwdCBvZiBlbmNsb3N1cmUgYWxsb3dzIGZvciBvbmUgb3IgbW9yZSBlZGdlcyB0byBiZSBzaGFyZWQgYnkgdGhlIHR3byByZWN0YW5nbGVzLlxyXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgcjEgZW5jbG9zZXMgcjIsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAgICAgKi9fZW5jbG9zZXM9QmlsdG9uZy5lbmNsb3Nlcz1mdW5jdGlvbihyMSxyMixhbGxvd1NoYXJlZEVkZ2VzKXt2YXIgeDE9cjEueCx4Mj1yMS54K3IxLncseTE9cjEueSx5Mj1yMS55K3IxLmgsYTE9cjIueCxhMj1yMi54K3IyLncsYjE9cjIueSxiMj1yMi55K3IyLmgsYz1mdW5jdGlvbiBjKHYxLHYyLHYzLHY0KXtyZXR1cm4gYWxsb3dTaGFyZWRFZGdlcz92MTw9djImJnYzPj12NDp2MTx2MiYmdjM+djQ7fTtyZXR1cm4gYyh4MSxhMSx4MixhMikmJmMoeTEsYjEseTIsYjIpO30sX3NlZ21lbnRNdWx0aXBsaWVycz1bbnVsbCxbMSwtMV0sWzEsMV0sWy0xLDFdLFstMSwtMV1dLF9pbnZlcnNlU2VnbWVudE11bHRpcGxpZXJzPVtudWxsLFstMSwtMV0sWy0xLDFdLFsxLDFdLFsxLC0xXV0sLyoqXHJcbiAgICAgICAgICogQG5hbWUgQmlsdG9uZy5wb2ludE9uTGluZVxyXG4gICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAqIEBkZXNjIENhbGN1bGF0ZXMgYSBwb2ludCBvbiB0aGUgbGluZSBmcm9tIGBmcm9tUG9pbnRgIHRvIGB0b1BvaW50YCB0aGF0IGlzIGBkaXN0YW5jZWAgdW5pdHMgYWxvbmcgdGhlIGxlbmd0aCBvZiB0aGUgbGluZS5cclxuICAgICAgICAgKiBAcGFyYW0ge1BvaW50fSBwMSBGaXJzdCBwb2ludCwgZWl0aGVyIGFzIGEgMiBlbnRyeSBhcnJheSBvciBvYmplY3Qgd2l0aCBgbGVmdGAgYW5kIGB0b3BgIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHtQb2ludH0gcDIgU2Vjb25kIHBvaW50LCBlaXRoZXIgYXMgYSAyIGVudHJ5IGFycmF5IG9yIG9iamVjdCB3aXRoIGBsZWZ0YCBhbmQgYHRvcGAgcHJvcGVydGllcy5cclxuICAgICAgICAgKiBAcmV0dXJuIHtQb2ludH0gUG9pbnQgb24gdGhlIGxpbmUsIGluIHRoZSBmb3JtIGB7IHg6Li4uLCB5Oi4uLiB9YC5cclxuICAgICAgICAgKi9fcG9pbnRPbkxpbmU9QmlsdG9uZy5wb2ludE9uTGluZT1mdW5jdGlvbihmcm9tUG9pbnQsdG9Qb2ludCxkaXN0YW5jZSl7dmFyIG09X2dyYWRpZW50KGZyb21Qb2ludCx0b1BvaW50KSxzPV9xdWFkcmFudChmcm9tUG9pbnQsdG9Qb2ludCksc2VnbWVudE11bHRpcGxpZXI9ZGlzdGFuY2U+MD9fc2VnbWVudE11bHRpcGxpZXJzW3NdOl9pbnZlcnNlU2VnbWVudE11bHRpcGxpZXJzW3NdLHRoZXRhPU1hdGguYXRhbihtKSx5PU1hdGguYWJzKGRpc3RhbmNlKk1hdGguc2luKHRoZXRhKSkqc2VnbWVudE11bHRpcGxpZXJbMV0seD1NYXRoLmFicyhkaXN0YW5jZSpNYXRoLmNvcyh0aGV0YSkpKnNlZ21lbnRNdWx0aXBsaWVyWzBdO3JldHVybnt4OmZyb21Qb2ludC54K3gseTpmcm9tUG9pbnQueSt5fTt9LC8qKlxyXG4gICAgICAgICAqIEBuYW1lIEJpbHRvbmcucGVycGVuZGljdWxhckxpbmVUb1xyXG4gICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAqIEBkZXNjIENhbGN1bGF0ZXMgYSBsaW5lIG9mIGxlbmd0aCBgbGVuZ3RoYCB0aGF0IGlzIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGxpbmUgZnJvbSBgZnJvbVBvaW50YCB0byBgdG9Qb2ludGAgYW5kIHBhc3NlcyB0aHJvdWdoIGB0b1BvaW50YC5cclxuICAgICAgICAgKiBAcGFyYW0ge1BvaW50fSBwMSBGaXJzdCBwb2ludCwgZWl0aGVyIGFzIGEgMiBlbnRyeSBhcnJheSBvciBvYmplY3Qgd2l0aCBgbGVmdGAgYW5kIGB0b3BgIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHtQb2ludH0gcDIgU2Vjb25kIHBvaW50LCBlaXRoZXIgYXMgYSAyIGVudHJ5IGFycmF5IG9yIG9iamVjdCB3aXRoIGBsZWZ0YCBhbmQgYHRvcGAgcHJvcGVydGllcy5cclxuICAgICAgICAgKiBAcmV0dXJuIHtMaW5lfSBQZXJwZW5kaWN1bGFyIGxpbmUsIGluIHRoZSBmb3JtIGBbIHsgeDouLi4sIHk6Li4uIH0sIHsgeDouLi4sIHk6Li4uIH0gXWAuXHJcbiAgICAgICAgICovX3BlcnBlbmRpY3VsYXJMaW5lVG89QmlsdG9uZy5wZXJwZW5kaWN1bGFyTGluZVRvPWZ1bmN0aW9uKGZyb21Qb2ludCx0b1BvaW50LGxlbmd0aCl7dmFyIG09X2dyYWRpZW50KGZyb21Qb2ludCx0b1BvaW50KSx0aGV0YTI9TWF0aC5hdGFuKC0xL20pLHk9bGVuZ3RoLzIqTWF0aC5zaW4odGhldGEyKSx4PWxlbmd0aC8yKk1hdGguY29zKHRoZXRhMik7cmV0dXJuW3t4OnRvUG9pbnQueCt4LHk6dG9Qb2ludC55K3l9LHt4OnRvUG9pbnQueC14LHk6dG9Qb2ludC55LXl9XTt9O30pLmNhbGwodHlwZW9mIHdpbmRvdyE9PSd1bmRlZmluZWQnP3dpbmRvdzp0aGlzKTs7KGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHJvb3Q9dGhpcyxTbmlmZj17YW5kcm9pZDpuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImFuZHJvaWRcIik+LTF9LG1hdGNoZXNTZWxlY3Rvcj1mdW5jdGlvbiBtYXRjaGVzU2VsZWN0b3IoZWwsc2VsZWN0b3IsY3R4KXtjdHg9Y3R4fHxlbC5wYXJlbnROb2RlO3ZhciBwb3NzaWJsZXM9Y3R4LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO2Zvcih2YXIgaT0wO2k8cG9zc2libGVzLmxlbmd0aDtpKyspe2lmKHBvc3NpYmxlc1tpXT09PWVsKXtyZXR1cm4gdHJ1ZTt9fXJldHVybiBmYWxzZTt9LF9nZWw9ZnVuY3Rpb24gX2dlbChlbCl7cmV0dXJuIHR5cGVvZiBlbD09XCJzdHJpbmdcInx8ZWwuY29uc3RydWN0b3I9PT1TdHJpbmc/ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWwpOmVsO30sX3Q9ZnVuY3Rpb24gX3QoZSl7cmV0dXJuIGUuc3JjRWxlbWVudHx8ZS50YXJnZXQ7fSwvL1xuLy8gZ2V0cyBwYXRoIGluZm8gZm9yIHRoZSBnaXZlbiBldmVudCAtIHRoZSBwYXRoIGZyb20gdGFyZ2V0IHRvIG9iaiwgaW4gdGhlIGV2ZW50J3MgYnViYmxlIGNoYWluLiBpZiBkb0NvbXB1dGVcbi8vIGlzIGZhbHNlIHdlIGp1c3QgcmV0dXJuIHRhcmdldCBmb3IgdGhlIHBhdGguXG4vL1xuX3BpPWZ1bmN0aW9uIF9waShlLHRhcmdldCxvYmosZG9Db21wdXRlKXtpZighZG9Db21wdXRlKXJldHVybntwYXRoOlt0YXJnZXRdLGVuZDoxfTtlbHNlIGlmKHR5cGVvZiBlLnBhdGghPT1cInVuZGVmaW5lZFwiJiZlLnBhdGguaW5kZXhPZil7cmV0dXJue3BhdGg6ZS5wYXRoLGVuZDplLnBhdGguaW5kZXhPZihvYmopfTt9ZWxzZXt2YXIgb3V0PXtwYXRoOltdLGVuZDotMX0sX29uZT1mdW5jdGlvbiBfb25lKGVsKXtvdXQucGF0aC5wdXNoKGVsKTtpZihlbD09PW9iail7b3V0LmVuZD1vdXQucGF0aC5sZW5ndGgtMTt9ZWxzZSBpZihlbC5wYXJlbnROb2RlIT1udWxsKXtfb25lKGVsLnBhcmVudE5vZGUpO319O19vbmUodGFyZ2V0KTtyZXR1cm4gb3V0O319LF9kPWZ1bmN0aW9uIF9kKGwsZm4pe2Zvcih2YXIgaT0wLGo9bC5sZW5ndGg7aTxqO2krKyl7aWYobFtpXT09Zm4pYnJlYWs7fWlmKGk8bC5sZW5ndGgpbC5zcGxpY2UoaSwxKTt9LGd1aWQ9MSwvL1xuLy8gdGhpcyBmdW5jdGlvbiBnZW5lcmF0ZXMgYSBndWlkIGZvciBldmVyeSBoYW5kbGVyLCBzZXRzIGl0IG9uIHRoZSBoYW5kbGVyLCB0aGVuIGFkZHNcbi8vIGl0IHRvIHRoZSBhc3NvY2lhdGVkIG9iamVjdCdzIG1hcCBvZiBoYW5kbGVycyBmb3IgdGhlIGdpdmVuIGV2ZW50LiB0aGlzIGlzIHdoYXQgZW5hYmxlcyB1c1xuLy8gdG8gdW5iaW5kIGFsbCBldmVudHMgb2Ygc29tZSB0eXBlLCBvciBhbGwgZXZlbnRzICh0aGUgc2Vjb25kIG9mIHdoaWNoIGNhbiBiZSByZXF1ZXN0ZWQgYnkgdGhlIHVzZXIsXG4vLyBidXQgaXQgYWxzbyB1c2VkIGJ5IE1vdHRsZSB3aGVuIGFuIGVsZW1lbnQgaXMgcmVtb3ZlZC4pXG5fc3RvcmU9ZnVuY3Rpb24gX3N0b3JlKG9iaixldmVudCxmbil7dmFyIGc9Z3VpZCsrO29iai5fX3RhPW9iai5fX3RhfHx7fTtvYmouX190YVtldmVudF09b2JqLl9fdGFbZXZlbnRdfHx7fTsvLyBzdG9yZSBlYWNoIGhhbmRsZXIgd2l0aCBhIHVuaXF1ZSBndWlkLlxub2JqLl9fdGFbZXZlbnRdW2ddPWZuOy8vIHNldCB0aGUgZ3VpZCBvbiB0aGUgaGFuZGxlci5cbmZuLl9fdGF1aWQ9ZztyZXR1cm4gZzt9LF91bnN0b3JlPWZ1bmN0aW9uIF91bnN0b3JlKG9iaixldmVudCxmbil7b2JqLl9fdGEmJm9iai5fX3RhW2V2ZW50XSYmZGVsZXRlIG9iai5fX3RhW2V2ZW50XVtmbi5fX3RhdWlkXTsvLyBhIGhhbmRsZXIgbWlnaHQgaGF2ZSBhdHRhY2hlZCBleHRyYSBmdW5jdGlvbnMsIHNvIHdlIHVuYmluZCB0aG9zZSB0b28uXG5pZihmbi5fX3RhRXh0cmEpe2Zvcih2YXIgaT0wO2k8Zm4uX190YUV4dHJhLmxlbmd0aDtpKyspe191bmJpbmQob2JqLGZuLl9fdGFFeHRyYVtpXVswXSxmbi5fX3RhRXh0cmFbaV1bMV0pO31mbi5fX3RhRXh0cmEubGVuZ3RoPTA7fS8vIGEgaGFuZGxlciBtaWdodCBoYXZlIGF0dGFjaGVkIGFuIHVuc3RvcmUgY2FsbGJhY2tcbmZuLl9fdGFVbnN0b3JlJiZmbi5fX3RhVW5zdG9yZSgpO30sX2N1cnJ5Q2hpbGRGaWx0ZXI9ZnVuY3Rpb24gX2N1cnJ5Q2hpbGRGaWx0ZXIoY2hpbGRyZW4sb2JqLGZuLGV2dCl7aWYoY2hpbGRyZW49PW51bGwpcmV0dXJuIGZuO2Vsc2V7dmFyIGM9Y2hpbGRyZW4uc3BsaXQoXCIsXCIpLF9mbj1mdW5jdGlvbiBfZm4oZSl7X2ZuLl9fdGF1aWQ9Zm4uX190YXVpZDt2YXIgdD1fdChlKSx0YXJnZXQ9dDsvLyB0IGlzIHRoZSB0YXJnZXQgZWxlbWVudCBvbiB3aGljaCB0aGUgZXZlbnQgb2NjdXJyZWQuIGl0IGlzIHRoZVxuLy8gZWxlbWVudCB3ZSB3aWxsIHdpc2ggdG8gcGFzcyB0byBhbnkgY2FsbGJhY2tzLlxudmFyIHBhdGhJbmZvPV9waShlLHQsb2JqLGNoaWxkcmVuIT1udWxsKTtpZihwYXRoSW5mby5lbmQhPS0xKXtmb3IodmFyIHA9MDtwPHBhdGhJbmZvLmVuZDtwKyspe3RhcmdldD1wYXRoSW5mby5wYXRoW3BdO2Zvcih2YXIgaT0wO2k8Yy5sZW5ndGg7aSsrKXtpZihtYXRjaGVzU2VsZWN0b3IodGFyZ2V0LGNbaV0sb2JqKSl7Zm4uYXBwbHkodGFyZ2V0LGFyZ3VtZW50cyk7fX19fX07cmVnaXN0ZXJFeHRyYUZ1bmN0aW9uKGZuLGV2dCxfZm4pO3JldHVybiBfZm47fX0sLy9cbi8vIHJlZ2lzdGVycyBhbiAnZXh0cmEnIGZ1bmN0aW9uIG9uIHNvbWUgZXZlbnQgbGlzdGVuZXIgZnVuY3Rpb24gd2Ugd2VyZSBnaXZlbiAtIGEgZnVuY3Rpb24gdGhhdCB3ZVxuLy8gY3JlYXRlZCBhbmQgYm91bmQgdG8gdGhlIGVsZW1lbnQgYXMgcGFydCBvZiBvdXIgaG91c2VrZWVwaW5nLCBhbmQgd2hpY2ggd2Ugd2FudCB0byB1bmJpbmQgYW5kIHJlbW92ZVxuLy8gd2hlbmV2ZXIgdGhlIGdpdmVuIGZ1bmN0aW9uIGlzIHVuYm91bmQuXG5yZWdpc3RlckV4dHJhRnVuY3Rpb249ZnVuY3Rpb24gcmVnaXN0ZXJFeHRyYUZ1bmN0aW9uKGZuLGV2dCxuZXdGbil7Zm4uX190YUV4dHJhPWZuLl9fdGFFeHRyYXx8W107Zm4uX190YUV4dHJhLnB1c2goW2V2dCxuZXdGbl0pO30sRGVmYXVsdEhhbmRsZXI9ZnVuY3Rpb24gRGVmYXVsdEhhbmRsZXIob2JqLGV2dCxmbixjaGlsZHJlbil7aWYoaXNUb3VjaERldmljZSYmdG91Y2hNYXBbZXZ0XSl7dmFyIHRmbj1fY3VycnlDaGlsZEZpbHRlcihjaGlsZHJlbixvYmosZm4sdG91Y2hNYXBbZXZ0XSk7X2JpbmQob2JqLHRvdWNoTWFwW2V2dF0sdGZuLGZuKTt9aWYoZXZ0PT09XCJmb2N1c1wiJiZvYmouZ2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIik9PW51bGwpe29iai5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLFwiMVwiKTt9X2JpbmQob2JqLGV2dCxfY3VycnlDaGlsZEZpbHRlcihjaGlsZHJlbixvYmosZm4sZXZ0KSxmbik7fSxTbWFydENsaWNrSGFuZGxlcj1mdW5jdGlvbiBTbWFydENsaWNrSGFuZGxlcihvYmosZXZ0LGZuLGNoaWxkcmVuKXtpZihvYmouX190YVNtYXJ0Q2xpY2tzPT1udWxsKXt2YXIgZG93bj1mdW5jdGlvbiBkb3duKGUpe29iai5fX3RhZD1fcGFnZUxvY2F0aW9uKGUpO30sdXA9ZnVuY3Rpb24gdXAoZSl7b2JqLl9fdGF1PV9wYWdlTG9jYXRpb24oZSk7fSxjbGljaz1mdW5jdGlvbiBjbGljayhlKXtpZihvYmouX190YWQmJm9iai5fX3RhdSYmb2JqLl9fdGFkWzBdPT09b2JqLl9fdGF1WzBdJiZvYmouX190YWRbMV09PT1vYmouX190YXVbMV0pe2Zvcih2YXIgaT0wO2k8b2JqLl9fdGFTbWFydENsaWNrcy5sZW5ndGg7aSsrKXtvYmouX190YVNtYXJ0Q2xpY2tzW2ldLmFwcGx5KF90KGUpLFtlXSk7fX19O0RlZmF1bHRIYW5kbGVyKG9iaixcIm1vdXNlZG93blwiLGRvd24sY2hpbGRyZW4pO0RlZmF1bHRIYW5kbGVyKG9iaixcIm1vdXNldXBcIix1cCxjaGlsZHJlbik7RGVmYXVsdEhhbmRsZXIob2JqLFwiY2xpY2tcIixjbGljayxjaGlsZHJlbik7b2JqLl9fdGFTbWFydENsaWNrcz1bXTt9Ly8gc3RvcmUgaW4gdGhlIGxpc3Qgb2YgY2FsbGJhY2tzXG5vYmouX190YVNtYXJ0Q2xpY2tzLnB1c2goZm4pOy8vIHRoZSB1bnN0b3JlIGZ1bmN0aW9uIHJlbW92ZXMgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBvYmplY3QncyBsaXN0ZW5lciBsaXN0IGZvciB0aGlzIHR5cGUuXG5mbi5fX3RhVW5zdG9yZT1mdW5jdGlvbigpe19kKG9iai5fX3RhU21hcnRDbGlja3MsZm4pO307fSxfdGFwUHJvZmlsZXM9e1widGFwXCI6e3RvdWNoZXM6MSx0YXBzOjF9LFwiZGJsdGFwXCI6e3RvdWNoZXM6MSx0YXBzOjJ9LFwiY29udGV4dG1lbnVcIjp7dG91Y2hlczoyLHRhcHM6MX19LFRhcEhhbmRsZXI9ZnVuY3Rpb24gVGFwSGFuZGxlcihjbGlja1RocmVzaG9sZCxkYmxDbGlja1RocmVzaG9sZCl7cmV0dXJuIGZ1bmN0aW9uKG9iaixldnQsZm4sY2hpbGRyZW4pey8vIGlmIGV2ZW50IGlzIGNvbnRleHRtZW51LCBmb3IgZGV2aWNlcyB3aGljaCBhcmUgbW91c2Ugb25seSwgd2Ugd2FudCB0b1xuLy8gdXNlIHRoZSBkZWZhdWx0IGJpbmQuXG5pZihldnQ9PVwiY29udGV4dG1lbnVcIiYmaXNNb3VzZURldmljZSlEZWZhdWx0SGFuZGxlcihvYmosZXZ0LGZuLGNoaWxkcmVuKTtlbHNley8vIHRoZSBpc3N1ZSBoZXJlIGlzIHRoYXQgdGhpcyBkb3duIGhhbmRsZXIgZ2V0cyByZWdpc3RlcmVkIG9ubHkgZm9yIHRoZVxuLy8gY2hpbGQgbm9kZXMgaW4gdGhlIGZpcnN0IHJlZ2lzdHJhdGlvbi4gaW4gZmFjdCBpdCBzaG91bGQgYmUgcmVnaXN0ZXJlZCB3aXRoXG4vLyBubyBjaGlsZCBzZWxlY3RvciBhbmQgdGhlbiBvbiBkb3duIHdlIHNob3VsZCBjeWNsZSB0aHJvdWdoIHRoZSByZWdpc3RlcmVkXG4vLyBmdW5jdGlvbnMgdG8gc2VlIGlmIG9uZSBvZiB0aGVtIG1hdGNoZXMuIG9uIG1vdXNldXAgd2Ugc2hvdWxkIGV4ZWN1dGUgQUxMIG9mXG4vLyB0aGUgZnVuY3Rpb25zIHdob3NlIGNoaWxkcmVuIGFyZSBlaXRoZXIgbnVsbCBvciBtYXRjaCB0aGUgZWxlbWVudC5cbmlmKG9iai5fX3RhVGFwSGFuZGxlcj09bnVsbCl7dmFyIHR0PW9iai5fX3RhVGFwSGFuZGxlcj17dGFwOltdLGRibHRhcDpbXSxjb250ZXh0bWVudTpbXSxkb3duOmZhbHNlLHRhcHM6MCxkb3duU2VsZWN0b3JzOltdfTt2YXIgZG93bj1mdW5jdGlvbiBkb3duKGUpe3ZhciB0YXJnZXQ9X3QoZSkscGF0aEluZm89X3BpKGUsdGFyZ2V0LG9iaixjaGlsZHJlbiE9bnVsbCksZmluaXNoZWQ9ZmFsc2U7Zm9yKHZhciBwPTA7cDxwYXRoSW5mby5lbmQ7cCsrKXtpZihmaW5pc2hlZClyZXR1cm47dGFyZ2V0PXBhdGhJbmZvLnBhdGhbcF07Zm9yKHZhciBpPTA7aTx0dC5kb3duU2VsZWN0b3JzLmxlbmd0aDtpKyspe2lmKHR0LmRvd25TZWxlY3RvcnNbaV09PW51bGx8fG1hdGNoZXNTZWxlY3Rvcih0YXJnZXQsdHQuZG93blNlbGVjdG9yc1tpXSxvYmopKXt0dC5kb3duPXRydWU7c2V0VGltZW91dChjbGVhclNpbmdsZSxjbGlja1RocmVzaG9sZCk7c2V0VGltZW91dChjbGVhckRvdWJsZSxkYmxDbGlja1RocmVzaG9sZCk7ZmluaXNoZWQ9dHJ1ZTticmVhazsvLyB3ZSBvbmx5IG5lZWQgb25lIG1hdGNoIG9uIG1vdXNlZG93blxufX19fSx1cD1mdW5jdGlvbiB1cChlKXtpZih0dC5kb3duKXt2YXIgdGFyZ2V0PV90KGUpLGN1cnJlbnRUYXJnZXQscGF0aEluZm87dHQudGFwcysrO3ZhciB0Yz1fdG91Y2hDb3VudChlKTtmb3IodmFyIGV2ZW50SWQgaW4gX3RhcFByb2ZpbGVzKXtpZihfdGFwUHJvZmlsZXMuaGFzT3duUHJvcGVydHkoZXZlbnRJZCkpe3ZhciBwPV90YXBQcm9maWxlc1tldmVudElkXTtpZihwLnRvdWNoZXM9PT10YyYmKHAudGFwcz09PTF8fHAudGFwcz09PXR0LnRhcHMpKXtmb3IodmFyIGk9MDtpPHR0W2V2ZW50SWRdLmxlbmd0aDtpKyspe3BhdGhJbmZvPV9waShlLHRhcmdldCxvYmosdHRbZXZlbnRJZF1baV1bMV0hPW51bGwpO2Zvcih2YXIgcExvb3A9MDtwTG9vcDxwYXRoSW5mby5lbmQ7cExvb3ArKyl7Y3VycmVudFRhcmdldD1wYXRoSW5mby5wYXRoW3BMb29wXTsvLyB0aGlzIGlzIGEgc2luZ2xlIGV2ZW50IHJlZ2lzdHJhdGlvbiBoYW5kbGVyLlxuaWYodHRbZXZlbnRJZF1baV1bMV09PW51bGx8fG1hdGNoZXNTZWxlY3RvcihjdXJyZW50VGFyZ2V0LHR0W2V2ZW50SWRdW2ldWzFdLG9iaikpe3R0W2V2ZW50SWRdW2ldWzBdLmFwcGx5KGN1cnJlbnRUYXJnZXQsW2VdKTticmVhazt9fX19fX19fSxjbGVhclNpbmdsZT1mdW5jdGlvbiBjbGVhclNpbmdsZSgpe3R0LmRvd249ZmFsc2U7fSxjbGVhckRvdWJsZT1mdW5jdGlvbiBjbGVhckRvdWJsZSgpe3R0LnRhcHM9MDt9O0RlZmF1bHRIYW5kbGVyKG9iaixcIm1vdXNlZG93blwiLGRvd24pO0RlZmF1bHRIYW5kbGVyKG9iaixcIm1vdXNldXBcIix1cCk7fS8vIGFkZCB0aGlzIGNoaWxkIHNlbGVjdG9yIChpdCBjYW4gYmUgbnVsbCwgdGhhdCdzIGZpbmUpLlxub2JqLl9fdGFUYXBIYW5kbGVyLmRvd25TZWxlY3RvcnMucHVzaChjaGlsZHJlbik7b2JqLl9fdGFUYXBIYW5kbGVyW2V2dF0ucHVzaChbZm4sY2hpbGRyZW5dKTsvLyB0aGUgdW5zdG9yZSBmdW5jdGlvbiByZW1vdmVzIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgb2JqZWN0J3MgbGlzdGVuZXIgbGlzdCBmb3IgdGhpcyB0eXBlLlxuZm4uX190YVVuc3RvcmU9ZnVuY3Rpb24oKXtfZChvYmouX190YVRhcEhhbmRsZXJbZXZ0XSxmbik7fTt9fTt9LG1lZUhlbHBlcj1mdW5jdGlvbiBtZWVIZWxwZXIodHlwZSxldnQsb2JqLHRhcmdldCl7Zm9yKHZhciBpIGluIG9iai5fX3RhbWVlW3R5cGVdKXtpZihvYmouX190YW1lZVt0eXBlXS5oYXNPd25Qcm9wZXJ0eShpKSl7b2JqLl9fdGFtZWVbdHlwZV1baV0uYXBwbHkodGFyZ2V0LFtldnRdKTt9fX0sTW91c2VFbnRlckV4aXRIYW5kbGVyPWZ1bmN0aW9uIE1vdXNlRW50ZXJFeGl0SGFuZGxlcigpe3ZhciBhY3RpdmVFbGVtZW50cz1bXTtyZXR1cm4gZnVuY3Rpb24ob2JqLGV2dCxmbixjaGlsZHJlbil7aWYoIW9iai5fX3RhbWVlKXsvLyBfX3RhbWVlIGhvbGRzIGEgZmxhZyBzYXlpbmcgd2hldGhlciB0aGUgbW91c2UgaXMgY3VycmVudGx5IFwiaW5cIiB0aGUgZWxlbWVudCwgYW5kIGEgbGlzdCBvZlxuLy8gYm90aCBtb3VzZWVudGVyIGFuZCBtb3VzZWV4aXQgZnVuY3Rpb25zLlxub2JqLl9fdGFtZWU9e292ZXI6ZmFsc2UsbW91c2VlbnRlcjpbXSxtb3VzZWV4aXQ6W119Oy8vIHJlZ2lzdGVyIG92ZXIgYW5kIG91dCBmdW5jdGlvbnNcbnZhciBvdmVyPWZ1bmN0aW9uIG92ZXIoZSl7dmFyIHQ9X3QoZSk7aWYoY2hpbGRyZW49PW51bGwmJnQ9PW9iaiYmIW9iai5fX3RhbWVlLm92ZXJ8fG1hdGNoZXNTZWxlY3Rvcih0LGNoaWxkcmVuLG9iaikmJih0Ll9fdGFtZWU9PW51bGx8fCF0Ll9fdGFtZWUub3Zlcikpe21lZUhlbHBlcihcIm1vdXNlZW50ZXJcIixlLG9iaix0KTt0Ll9fdGFtZWU9dC5fX3RhbWVlfHx7fTt0Ll9fdGFtZWUub3Zlcj10cnVlO2FjdGl2ZUVsZW1lbnRzLnB1c2godCk7fX0sb3V0PWZ1bmN0aW9uIG91dChlKXt2YXIgdD1fdChlKTsvLyBpcyB0aGUgY3VycmVudCB0YXJnZXQgb25lIG9mIHRoZSBhY3RpdmVFbGVtZW50cz8gYW5kIGlzIHRoZVxuLy8gcmVsYXRlZCB0YXJnZXQgTk9UIGEgZGVzY2VuZGFudCBvZiBpdD9cbmZvcih2YXIgaT0wO2k8YWN0aXZlRWxlbWVudHMubGVuZ3RoO2krKyl7aWYodD09YWN0aXZlRWxlbWVudHNbaV0mJiFtYXRjaGVzU2VsZWN0b3IoZS5yZWxhdGVkVGFyZ2V0fHxlLnRvRWxlbWVudCxcIipcIix0KSl7dC5fX3RhbWVlLm92ZXI9ZmFsc2U7YWN0aXZlRWxlbWVudHMuc3BsaWNlKGksMSk7bWVlSGVscGVyKFwibW91c2VleGl0XCIsZSxvYmosdCk7fX19O19iaW5kKG9iaixcIm1vdXNlb3ZlclwiLF9jdXJyeUNoaWxkRmlsdGVyKGNoaWxkcmVuLG9iaixvdmVyLFwibW91c2VvdmVyXCIpLG92ZXIpO19iaW5kKG9iaixcIm1vdXNlb3V0XCIsX2N1cnJ5Q2hpbGRGaWx0ZXIoY2hpbGRyZW4sb2JqLG91dCxcIm1vdXNlb3V0XCIpLG91dCk7fWZuLl9fdGFVbnN0b3JlPWZ1bmN0aW9uKCl7ZGVsZXRlIG9iai5fX3RhbWVlW2V2dF1bZm4uX190YXVpZF07fTtfc3RvcmUob2JqLGV2dCxmbik7b2JqLl9fdGFtZWVbZXZ0XVtmbi5fX3RhdWlkXT1mbjt9O30saXNUb3VjaERldmljZT1cIm9udG91Y2hzdGFydFwiaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LGlzTW91c2VEZXZpY2U9XCJvbm1vdXNlZG93blwiaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LHRvdWNoTWFwPXtcIm1vdXNlZG93blwiOlwidG91Y2hzdGFydFwiLFwibW91c2V1cFwiOlwidG91Y2hlbmRcIixcIm1vdXNlbW92ZVwiOlwidG91Y2htb3ZlXCJ9LHRvdWNoc3RhcnQ9XCJ0b3VjaHN0YXJ0XCIsdG91Y2hlbmQ9XCJ0b3VjaGVuZFwiLHRvdWNobW92ZT1cInRvdWNobW92ZVwiLGlldj1mdW5jdGlvbigpe3ZhciBydj0tMTtpZihuYXZpZ2F0b3IuYXBwTmFtZT09J01pY3Jvc29mdCBJbnRlcm5ldCBFeHBsb3Jlcicpe3ZhciB1YT1uYXZpZ2F0b3IudXNlckFnZW50LHJlPW5ldyBSZWdFeHAoXCJNU0lFIChbMC05XXsxLH1bXFwuMC05XXswLH0pXCIpO2lmKHJlLmV4ZWModWEpIT1udWxsKXJ2PXBhcnNlRmxvYXQoUmVnRXhwLiQxKTt9cmV0dXJuIHJ2O30oKSxpc0lFTFQ5PWlldj4tMSYmaWV2PDksX2dlbkxvYz1mdW5jdGlvbiBfZ2VuTG9jKGUscHJlZml4KXtpZihlPT1udWxsKXJldHVyblswLDBdO3ZhciB0cz1fdG91Y2hlcyhlKSx0PV9nZXRUb3VjaCh0cywwKTtyZXR1cm5bdFtwcmVmaXgrXCJYXCJdLHRbcHJlZml4K1wiWVwiXV07fSxfcGFnZUxvY2F0aW9uPWZ1bmN0aW9uIF9wYWdlTG9jYXRpb24oZSl7aWYoZT09bnVsbClyZXR1cm5bMCwwXTtpZihpc0lFTFQ5KXtyZXR1cm5bZS5jbGllbnRYK2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LGUuY2xpZW50WStkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXTt9ZWxzZXtyZXR1cm4gX2dlbkxvYyhlLFwicGFnZVwiKTt9fSxfc2NyZWVuTG9jYXRpb249ZnVuY3Rpb24gX3NjcmVlbkxvY2F0aW9uKGUpe3JldHVybiBfZ2VuTG9jKGUsXCJzY3JlZW5cIik7fSxfY2xpZW50TG9jYXRpb249ZnVuY3Rpb24gX2NsaWVudExvY2F0aW9uKGUpe3JldHVybiBfZ2VuTG9jKGUsXCJjbGllbnRcIik7fSxfZ2V0VG91Y2g9ZnVuY3Rpb24gX2dldFRvdWNoKHRvdWNoZXMsaWR4KXtyZXR1cm4gdG91Y2hlcy5pdGVtP3RvdWNoZXMuaXRlbShpZHgpOnRvdWNoZXNbaWR4XTt9LF90b3VjaGVzPWZ1bmN0aW9uIF90b3VjaGVzKGUpe3JldHVybiBlLnRvdWNoZXMmJmUudG91Y2hlcy5sZW5ndGg+MD9lLnRvdWNoZXM6ZS5jaGFuZ2VkVG91Y2hlcyYmZS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg+MD9lLmNoYW5nZWRUb3VjaGVzOmUudGFyZ2V0VG91Y2hlcyYmZS50YXJnZXRUb3VjaGVzLmxlbmd0aD4wP2UudGFyZ2V0VG91Y2hlczpbZV07fSxfdG91Y2hDb3VudD1mdW5jdGlvbiBfdG91Y2hDb3VudChlKXtyZXR1cm4gX3RvdWNoZXMoZSkubGVuZ3RoO30sLy9odHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAwNS8xMC9fYW5kX3RoZV93aW5uZXJfMS5odG1sXG5fYmluZD1mdW5jdGlvbiBfYmluZChvYmosdHlwZSxmbixvcmlnaW5hbEZuKXtfc3RvcmUob2JqLHR5cGUsZm4pO29yaWdpbmFsRm4uX190YXVpZD1mbi5fX3RhdWlkO2lmKG9iai5hZGRFdmVudExpc3RlbmVyKW9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUsZm4sZmFsc2UpO2Vsc2UgaWYob2JqLmF0dGFjaEV2ZW50KXt2YXIga2V5PXR5cGUrZm4uX190YXVpZDtvYmpbXCJlXCIra2V5XT1mbjsvLyBUT0RPIGxvb2sgYXQgcmVwbGFjaW5nIHdpdGggLmNhbGwoLi4pXG5vYmpba2V5XT1mdW5jdGlvbigpe29ialtcImVcIitrZXldJiZvYmpbXCJlXCIra2V5XSh3aW5kb3cuZXZlbnQpO307b2JqLmF0dGFjaEV2ZW50KFwib25cIit0eXBlLG9ialtrZXldKTt9fSxfdW5iaW5kPWZ1bmN0aW9uIF91bmJpbmQob2JqLHR5cGUsZm4pe2lmKGZuPT1udWxsKXJldHVybjtfZWFjaChvYmosZnVuY3Rpb24oKXt2YXIgX2VsPV9nZWwodGhpcyk7X3Vuc3RvcmUoX2VsLHR5cGUsZm4pOy8vIGl0IGhhcyBiZWVuIGJvdW5kIGlmIHRoZXJlIGlzIGEgdGF1aWQuIG90aGVyd2lzZSBpdCB3YXMgbm90IGJvdW5kIGFuZCB3ZSBjYW4gaWdub3JlIGl0LlxuaWYoZm4uX190YXVpZCE9bnVsbCl7aWYoX2VsLnJlbW92ZUV2ZW50TGlzdGVuZXIpe19lbC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsZm4sZmFsc2UpO2lmKGlzVG91Y2hEZXZpY2UmJnRvdWNoTWFwW3R5cGVdKV9lbC5yZW1vdmVFdmVudExpc3RlbmVyKHRvdWNoTWFwW3R5cGVdLGZuLGZhbHNlKTt9ZWxzZSBpZih0aGlzLmRldGFjaEV2ZW50KXt2YXIga2V5PXR5cGUrZm4uX190YXVpZDtfZWxba2V5XSYmX2VsLmRldGFjaEV2ZW50KFwib25cIit0eXBlLF9lbFtrZXldKTtfZWxba2V5XT1udWxsO19lbFtcImVcIitrZXldPW51bGw7fX0vLyBpZiBhIHRvdWNoIGV2ZW50IHdhcyBhbHNvIHJlZ2lzdGVyZWQsIGRlcmVnaXN0ZXIgbm93LlxuaWYoZm4uX190YVRvdWNoUHJveHkpe191bmJpbmQob2JqLGZuLl9fdGFUb3VjaFByb3h5WzFdLGZuLl9fdGFUb3VjaFByb3h5WzBdKTt9fSk7fSxfZWFjaD1mdW5jdGlvbiBfZWFjaChvYmosZm4pe2lmKG9iaj09bnVsbClyZXR1cm47Ly8gaWYgYSBsaXN0IChvciBsaXN0LWxpa2UpLCB1c2UgaXQuIGlmIGEgc3RyaW5nLCBnZXQgYSBsaXN0XG4vLyBieSBydW5uaW5nIHRoZSBzdHJpbmcgdGhyb3VnaCBxdWVyeVNlbGVjdG9yQWxsLiBlbHNlLCBhc3N1bWVcbi8vIGl0J3MgYW4gRWxlbWVudC5cbi8vIG9iai50b3AgaXMgXCJ1bmtub3duXCIgaW4gSUU4Llxub2JqPXR5cGVvZiBXaW5kb3chPT1cInVuZGVmaW5lZFwiJiZ0eXBlb2Ygb2JqLnRvcCE9PVwidW5rbm93blwiJiZvYmo9PW9iai50b3A/W29ial06dHlwZW9mIG9iaiE9PVwic3RyaW5nXCImJm9iai50YWdOYW1lPT1udWxsJiZvYmoubGVuZ3RoIT1udWxsP29iajp0eXBlb2Ygb2JqPT09XCJzdHJpbmdcIj9kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKG9iaik6W29ial07Zm9yKHZhciBpPTA7aTxvYmoubGVuZ3RoO2krKyl7Zm4uYXBwbHkob2JqW2ldKTt9fTsvKipcclxuICAgICAqIE1vdHRsZSBvZmZlcnMgc3VwcG9ydCBmb3IgYWJzdHJhY3Rpbmcgb3V0IHRoZSBkaWZmZXJlbmNlc1xyXG4gICAgICogYmV0d2VlbiB0b3VjaCBhbmQgbW91c2UgZGV2aWNlcywgcGx1cyBcInNtYXJ0IGNsaWNrXCIgZnVuY3Rpb25hbGl0eVxyXG4gICAgICogKGRvbid0IGZpcmUgY2xpY2sgaWYgdGhlIG1vdXNlIGhhcyBtb3ZlZCBiZXR3ZWVuIG1vdXNlZG93biBhbmQgbW91c2V1cCksXHJcbiAgICAgKiBhbmQgc3ludGhlc2l6ZWQgY2xpY2svdGFwIGV2ZW50cy5cclxuICAgICAqIEBjbGFzcyBNb3R0bGVcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBDb25zdHJ1Y3RvciBwYXJhbXNcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1zLmNsaWNrVGhyZXNob2xkPTI1MF0gVGhyZXNob2xkLCBpbiBtaWxsaXNlY29uZHMgYmV5b25kIHdoaWNoIGEgdG91Y2hzdGFydCBmb2xsb3dlZCBieSBhIHRvdWNoZW5kIGlzIG5vdCBjb25zaWRlcmVkIHRvIGJlIGEgY2xpY2suXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5kYmxDbGlja1RocmVzaG9sZD00NTBdIFRocmVzaG9sZCwgaW4gbWlsbGlzZWNvbmRzIGJleW9uZCB3aGljaCB0d28gc3VjY2Vzc2l2ZSB0YXAgZXZlbnRzIGFyZSBub3QgY29uc2lkZXJlZCB0byBiZSBhIGNsaWNrLlxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLnNtYXJ0Q2xpY2tzPWZhbHNlXSBJZiB0cnVlLCB3b24ndCBmaXJlIGNsaWNrIGV2ZW50cyBpZiB0aGUgbW91c2UgaGFzIG1vdmVkIGJldHdlZW4gbW91c2Vkb3duIGFuZCBtb3VzZXVwLiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbmFsaXR5XHJcbiAgICAgKiByZXF1aXJlcyB0aGF0IE1vdHRsZSBjb25zdW1lIHRoZSBtb3VzZWRvd24gZXZlbnQsIGFuZCBzbyBtYXkgbm90IGJlIHZpYWJsZSBpbiBhbGwgdXNlIGNhc2VzLlxyXG4gICAgICovcm9vdC5Nb3R0bGU9ZnVuY3Rpb24ocGFyYW1zKXtwYXJhbXM9cGFyYW1zfHx7fTt2YXIgY2xpY2tUaHJlc2hvbGQ9cGFyYW1zLmNsaWNrVGhyZXNob2xkfHwyNTAsZGJsQ2xpY2tUaHJlc2hvbGQ9cGFyYW1zLmRibENsaWNrVGhyZXNob2xkfHw0NTAsbW91c2VFbnRlckV4aXRIYW5kbGVyPW5ldyBNb3VzZUVudGVyRXhpdEhhbmRsZXIoKSx0YXBIYW5kbGVyPW5ldyBUYXBIYW5kbGVyKGNsaWNrVGhyZXNob2xkLGRibENsaWNrVGhyZXNob2xkKSxfc21hcnRDbGlja3M9cGFyYW1zLnNtYXJ0Q2xpY2tzLF9kb0JpbmQ9ZnVuY3Rpb24gX2RvQmluZChvYmosZXZ0LGZuLGNoaWxkcmVuKXtpZihmbj09bnVsbClyZXR1cm47X2VhY2gob2JqLGZ1bmN0aW9uKCl7dmFyIF9lbD1fZ2VsKHRoaXMpO2lmKF9zbWFydENsaWNrcyYmZXZ0PT09XCJjbGlja1wiKVNtYXJ0Q2xpY2tIYW5kbGVyKF9lbCxldnQsZm4sY2hpbGRyZW4pO2Vsc2UgaWYoZXZ0PT09XCJ0YXBcInx8ZXZ0PT09XCJkYmx0YXBcInx8ZXZ0PT09XCJjb250ZXh0bWVudVwiKXt0YXBIYW5kbGVyKF9lbCxldnQsZm4sY2hpbGRyZW4pO31lbHNlIGlmKGV2dD09PVwibW91c2VlbnRlclwifHxldnQ9PVwibW91c2VleGl0XCIpbW91c2VFbnRlckV4aXRIYW5kbGVyKF9lbCxldnQsZm4sY2hpbGRyZW4pO2Vsc2UgRGVmYXVsdEhhbmRsZXIoX2VsLGV2dCxmbixjaGlsZHJlbik7fSk7fTsvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGFuIGVsZW1lbnQgZnJvbSB0aGUgRE9NLCBhbmQgZGVyZWdpc3RlcnMgYWxsIGV2ZW50IGhhbmRsZXJzIGZvciBpdC4gWW91IHNob3VsZCB1c2UgdGhpc1xyXG4gICAgICAgICAqIHRvIGVuc3VyZSB5b3UgZG9uJ3QgbGVhayBtZW1vcnkuXHJcbiAgICAgICAgICogQG1ldGhvZCByZW1vdmVcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fSBlbCBFbGVtZW50LCBvciBpZCBvZiB0aGUgZWxlbWVudCwgdG8gcmVtb3ZlLlxyXG4gICAgICAgICAqIEByZXR1cm4ge01vdHRsZX0gVGhlIGN1cnJlbnQgTW90dGxlIGluc3RhbmNlOyB5b3UgY2FuIGNoYWluIHRoaXMgbWV0aG9kLlxyXG4gICAgICAgICAqL3RoaXMucmVtb3ZlPWZ1bmN0aW9uKGVsKXtfZWFjaChlbCxmdW5jdGlvbigpe3ZhciBfZWw9X2dlbCh0aGlzKTtpZihfZWwuX190YSl7Zm9yKHZhciBldnQgaW4gX2VsLl9fdGEpe2lmKF9lbC5fX3RhLmhhc093blByb3BlcnR5KGV2dCkpe2Zvcih2YXIgaCBpbiBfZWwuX190YVtldnRdKXtpZihfZWwuX190YVtldnRdLmhhc093blByb3BlcnR5KGgpKV91bmJpbmQoX2VsLGV2dCxfZWwuX190YVtldnRdW2hdKTt9fX19X2VsLnBhcmVudE5vZGUmJl9lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKF9lbCk7fSk7cmV0dXJuIHRoaXM7fTsvKipcclxuICAgICAgICAgKiBSZWdpc3RlciBhbiBldmVudCBoYW5kbGVyLCBvcHRpb25hbGx5IGFzIGEgZGVsZWdhdGUgZm9yIHNvbWUgc2V0IG9mIGRlc2NlbmRhbnQgZWxlbWVudHMuIE5vdGVcclxuICAgICAgICAgKiB0aGF0IHRoaXMgbWV0aG9kIHRha2VzIGVpdGhlciAzIG9yIDQgYXJndW1lbnRzIC0gaWYgeW91IHN1cHBseSAzIGFyZ3VtZW50cyBpdCBpcyBhc3N1bWVkIHlvdSBoYXZlXHJcbiAgICAgICAgICogb21pdHRlZCB0aGUgYGNoaWxkcmVuYCBwYXJhbWV0ZXIsIGFuZCB0aGF0IHRoZSBldmVudCBoYW5kbGVyIHNob3VsZCBiZSBib3VuZCBkaXJlY3RseSB0byB0aGUgZ2l2ZW4gZWxlbWVudC5cclxuICAgICAgICAgKiBAbWV0aG9kIG9uXHJcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50W118RWxlbWVudHxTdHJpbmd9IGVsIEVpdGhlciBhbiBFbGVtZW50LCBvciBhIENTUyBzcGVjIGZvciBhIGxpc3Qgb2YgZWxlbWVudHMsIG9yIGFuIGFycmF5IG9mIEVsZW1lbnRzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY2hpbGRyZW5dIENvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHNlbGVjdG9ycyBpZGVudGlmeWluZyBhbGxvd2VkIGNoaWxkcmVuLlxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBFdmVudCBJRC5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBFdmVudCBoYW5kbGVyIGZ1bmN0aW9uLlxyXG4gICAgICAgICAqIEByZXR1cm4ge01vdHRsZX0gVGhlIGN1cnJlbnQgTW90dGxlIGluc3RhbmNlOyB5b3UgY2FuIGNoYWluIHRoaXMgbWV0aG9kLlxyXG4gICAgICAgICAqL3RoaXMub249ZnVuY3Rpb24oZWwsZXZlbnQsY2hpbGRyZW4sZm4pe3ZhciBfZWw9YXJndW1lbnRzWzBdLF9jPWFyZ3VtZW50cy5sZW5ndGg9PTQ/YXJndW1lbnRzWzJdOm51bGwsX2U9YXJndW1lbnRzWzFdLF9mPWFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoLTFdO19kb0JpbmQoX2VsLF9lLF9mLF9jKTtyZXR1cm4gdGhpczt9Oy8qKlxyXG4gICAgICAgICAqIENhbmNlbCBkZWxlZ2F0ZSBldmVudCBoYW5kbGluZyBmb3IgdGhlIGdpdmVuIGZ1bmN0aW9uLiBOb3RlIHRoYXQgdW5saWtlIHdpdGggJ29uJyB5b3UgZG8gbm90IHN1cHBseVxyXG4gICAgICAgICAqIGEgbGlzdCBvZiBjaGlsZCBzZWxlY3RvcnMgaGVyZTogaXQgcmVtb3ZlcyBldmVudCBkZWxlZ2F0aW9uIGZyb20gYWxsIG9mIHRoZSBjaGlsZCBzZWxlY3RvcnMgZm9yIHdoaWNoIHRoZVxyXG4gICAgICAgICAqIGdpdmVuIGZ1bmN0aW9uIHdhcyByZWdpc3RlcmVkIChpZiBhbnkpLlxyXG4gICAgICAgICAqIEBtZXRob2Qgb2ZmXHJcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50W118RWxlbWVudHxTdHJpbmd9IGVsIEVsZW1lbnQgLSBvciBJRCBvZiBlbGVtZW50IC0gZnJvbSB3aGljaCB0byByZW1vdmUgZXZlbnQgbGlzdGVuZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IEV2ZW50IElELlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEV2ZW50IGhhbmRsZXIgZnVuY3Rpb24uXHJcbiAgICAgICAgICogQHJldHVybiB7TW90dGxlfSBUaGUgY3VycmVudCBNb3R0bGUgaW5zdGFuY2U7IHlvdSBjYW4gY2hhaW4gdGhpcyBtZXRob2QuXHJcbiAgICAgICAgICovdGhpcy5vZmY9ZnVuY3Rpb24oZWwsZXZlbnQsZm4pe191bmJpbmQoZWwsZXZlbnQsZm4pO3JldHVybiB0aGlzO307LyoqXHJcbiAgICAgICAgICogVHJpZ2dlcnMgc29tZSBldmVudCBmb3IgYSBnaXZlbiBlbGVtZW50LlxyXG4gICAgICAgICAqIEBtZXRob2QgdHJpZ2dlclxyXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWwgRWxlbWVudCBmb3Igd2hpY2ggdG8gdHJpZ2dlciB0aGUgZXZlbnQuXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IEV2ZW50IElELlxyXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IG9yaWdpbmFsRXZlbnQgVGhlIG9yaWdpbmFsIGV2ZW50LiBTaG91bGQgYmUgb3B0aW9uYWwgb2YgY291cnNlLCBidXQgY3VycmVudGx5IGlzIG5vdCwgZHVlXHJcbiAgICAgICAgICogdG8gdGhlIGpzUGx1bWIgdXNlIGNhc2UgdGhhdCBjYXVzZWQgdGhpcyBtZXRob2QgdG8gYmUgYWRkZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXlsb2FkXSBPcHRpb25hbCBvYmplY3QgdG8gc2V0IGFzIGBwYXlsb2FkYCBvbiB0aGUgZ2VuZXJhdGVkIGV2ZW50OyB1c2VmdWwgZm9yIG1lc3NhZ2UgcGFzc2luZy5cclxuICAgICAgICAgKiBAcmV0dXJuIHtNb3R0bGV9IFRoZSBjdXJyZW50IE1vdHRsZSBpbnN0YW5jZTsgeW91IGNhbiBjaGFpbiB0aGlzIG1ldGhvZC5cclxuICAgICAgICAgKi90aGlzLnRyaWdnZXI9ZnVuY3Rpb24oZWwsZXZlbnQsb3JpZ2luYWxFdmVudCxwYXlsb2FkKXsvLyBNb3VzZUV2ZW50IHVuZGVmaW5lZCBpbiBvbGQgSUU7IHRoYXQncyBob3cgd2Uga25vdyBpdCdzIGEgbW91c2UgZXZlbnQuICBBIGZpbmUgTWljcm9zb2Z0IHBhcmFkb3guXG52YXIgb3JpZ2luYWxJc01vdXNlPWlzTW91c2VEZXZpY2UmJih0eXBlb2YgTW91c2VFdmVudD09PVwidW5kZWZpbmVkXCJ8fG9yaWdpbmFsRXZlbnQ9PW51bGx8fG9yaWdpbmFsRXZlbnQuY29uc3RydWN0b3I9PT1Nb3VzZUV2ZW50KTt2YXIgZXZlbnRUb0JpbmQ9aXNUb3VjaERldmljZSYmIWlzTW91c2VEZXZpY2UmJnRvdWNoTWFwW2V2ZW50XT90b3VjaE1hcFtldmVudF06ZXZlbnQsYmluZGluZ0FNb3VzZUV2ZW50PSEoaXNUb3VjaERldmljZSYmIWlzTW91c2VEZXZpY2UmJnRvdWNoTWFwW2V2ZW50XSk7dmFyIHBsPV9wYWdlTG9jYXRpb24ob3JpZ2luYWxFdmVudCksc2w9X3NjcmVlbkxvY2F0aW9uKG9yaWdpbmFsRXZlbnQpLGNsPV9jbGllbnRMb2NhdGlvbihvcmlnaW5hbEV2ZW50KTtfZWFjaChlbCxmdW5jdGlvbigpe3ZhciBfZWw9X2dlbCh0aGlzKSxldnQ7b3JpZ2luYWxFdmVudD1vcmlnaW5hbEV2ZW50fHx7c2NyZWVuWDpzbFswXSxzY3JlZW5ZOnNsWzFdLGNsaWVudFg6Y2xbMF0sY2xpZW50WTpjbFsxXX07dmFyIF9kZWNvcmF0ZT1mdW5jdGlvbiBfZGVjb3JhdGUoX2V2dCl7aWYocGF5bG9hZClfZXZ0LnBheWxvYWQ9cGF5bG9hZDt9O3ZhciBldmVudEdlbmVyYXRvcnM9e1wiVG91Y2hFdmVudFwiOmZ1bmN0aW9uIFRvdWNoRXZlbnQoZXZ0KXt2YXIgdG91Y2g9ZG9jdW1lbnQuY3JlYXRlVG91Y2god2luZG93LF9lbCwwLHBsWzBdLHBsWzFdLHNsWzBdLHNsWzFdLGNsWzBdLGNsWzFdLDAsMCwwLDApOy8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3NzdGVwaGVuc29uLzQ0ODgwOFxudmFyIHRvdWNoZXM9ZG9jdW1lbnQuY3JlYXRlVG91Y2hMaXN0KHRvdWNoKTt2YXIgdGFyZ2V0VG91Y2hlcz1kb2N1bWVudC5jcmVhdGVUb3VjaExpc3QodG91Y2gpO3ZhciBjaGFuZ2VkVG91Y2hlcz1kb2N1bWVudC5jcmVhdGVUb3VjaExpc3QodG91Y2gpO2V2dC5pbml0VG91Y2hFdmVudChldmVudFRvQmluZCx0cnVlLHRydWUsd2luZG93LG51bGwsc2xbMF0sc2xbMV0sY2xbMF0sY2xbMV0sZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsdG91Y2hlcyx0YXJnZXRUb3VjaGVzLGNoYW5nZWRUb3VjaGVzLDEsMCk7fSxcIk1vdXNlRXZlbnRzXCI6ZnVuY3Rpb24gTW91c2VFdmVudHMoZXZ0KXtldnQuaW5pdE1vdXNlRXZlbnQoZXZlbnRUb0JpbmQsdHJ1ZSx0cnVlLHdpbmRvdywwLHNsWzBdLHNsWzFdLGNsWzBdLGNsWzFdLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLDEsX2VsKTtpZihTbmlmZi5hbmRyb2lkKXsvLyBBbmRyb2lkJ3MgdG91Y2ggZXZlbnRzIGFyZSBub3Qgc3RhbmRhcmQuXG52YXIgdD1kb2N1bWVudC5jcmVhdGVUb3VjaCh3aW5kb3csX2VsLDAscGxbMF0scGxbMV0sc2xbMF0sc2xbMV0sY2xbMF0sY2xbMV0sMCwwLDAsMCk7ZXZ0LnRvdWNoZXM9ZXZ0LnRhcmdldFRvdWNoZXM9ZXZ0LmNoYW5nZWRUb3VjaGVzPWRvY3VtZW50LmNyZWF0ZVRvdWNoTGlzdCh0KTt9fX07aWYoZG9jdW1lbnQuY3JlYXRlRXZlbnQpe3ZhciBpdGU9IWJpbmRpbmdBTW91c2VFdmVudCYmIW9yaWdpbmFsSXNNb3VzZSYmaXNUb3VjaERldmljZSYmdG91Y2hNYXBbZXZlbnRdJiYhU25pZmYuYW5kcm9pZCxldnROYW1lPWl0ZT9cIlRvdWNoRXZlbnRcIjpcIk1vdXNlRXZlbnRzXCI7ZXZ0PWRvY3VtZW50LmNyZWF0ZUV2ZW50KGV2dE5hbWUpO2V2ZW50R2VuZXJhdG9yc1tldnROYW1lXShldnQpO19kZWNvcmF0ZShldnQpO19lbC5kaXNwYXRjaEV2ZW50KGV2dCk7fWVsc2UgaWYoZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3Qpe2V2dD1kb2N1bWVudC5jcmVhdGVFdmVudE9iamVjdCgpO2V2dC5ldmVudFR5cGU9ZXZ0LmV2ZW50TmFtZT1ldmVudFRvQmluZDtldnQuc2NyZWVuWD1zbFswXTtldnQuc2NyZWVuWT1zbFsxXTtldnQuY2xpZW50WD1jbFswXTtldnQuY2xpZW50WT1jbFsxXTtfZGVjb3JhdGUoZXZ0KTtfZWwuZmlyZUV2ZW50KCdvbicrZXZlbnRUb0JpbmQsZXZ0KTt9fSk7cmV0dXJuIHRoaXM7fTt9Oy8qKlxyXG4gICAgICogU3RhdGljIG1ldGhvZCB0byBhc3Npc3QgaW4gJ2NvbnN1bWluZycgYW4gZWxlbWVudDogdXNlcyBgc3RvcFByb3BhZ2F0aW9uYCB3aGVyZSBhdmFpbGFibGUsIG9yIHNldHNcclxuICAgICAqIGBlLnJldHVyblZhbHVlPWZhbHNlYCB3aGVyZSBpdCBpcyBub3QuXHJcbiAgICAgKiBAbWV0aG9kIE1vdHRsZS5jb25zdW1lXHJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IHRvIGNvbnN1bWVcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RvTm90UHJldmVudERlZmF1bHQ9ZmFsc2VdIElmIHRydWUsIGRvZXMgbm90IGNhbGwgYHByZXZlbnREZWZhdWx0KClgIG9uIHRoZSBldmVudC5cclxuICAgICAqL3Jvb3QuTW90dGxlLmNvbnN1bWU9ZnVuY3Rpb24oZSxkb05vdFByZXZlbnREZWZhdWx0KXtpZihlLnN0b3BQcm9wYWdhdGlvbillLnN0b3BQcm9wYWdhdGlvbigpO2Vsc2UgZS5yZXR1cm5WYWx1ZT1mYWxzZTtpZighZG9Ob3RQcmV2ZW50RGVmYXVsdCYmZS5wcmV2ZW50RGVmYXVsdCllLnByZXZlbnREZWZhdWx0KCk7fTsvKipcclxuICAgICAqIEdldHMgdGhlIHBhZ2UgbG9jYXRpb24gY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gZXZlbnQuIEZvciB0b3VjaCBldmVudHMgdGhpcyBtZWFucyBnZXQgdGhlIHBhZ2UgbG9jYXRpb24gb2YgdGhlIGZpcnN0IHRvdWNoLlxyXG4gICAgICogQG1ldGhvZCBNb3R0bGUucGFnZUxvY2F0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IHRvIGdldCBwYWdlIGxvY2F0aW9uIGZvci5cclxuICAgICAqIEByZXR1cm4ge051bWJlcltdfSBbbGVmdCwgdG9wXSBmb3IgdGhlIGdpdmVuIGV2ZW50LlxyXG4gICAgICovcm9vdC5Nb3R0bGUucGFnZUxvY2F0aW9uPV9wYWdlTG9jYXRpb247LyoqXHJcbiAgICAgKiBGb3JjZXMgdG91Y2ggZXZlbnRzIHRvIGJlIHR1cm5lZCBcIm9uXCIuIFVzZWZ1bCBmb3IgdGVzdGluZzogZXZlbiBpZiB5b3UgZG9uJ3QgaGF2ZSBhIHRvdWNoIGRldmljZSwgeW91IGNhbiBzdGlsbFxyXG4gICAgICogdHJpZ2dlciBhIHRvdWNoIGV2ZW50IHdoZW4gdGhpcyBpcyBzd2l0Y2hlZCBvbiBhbmQgaXQgd2lsbCBiZSBjYXB0dXJlZCBhbmQgYWN0ZWQgb24uXHJcbiAgICAgKiBAbWV0aG9kIHNldEZvcmNlVG91Y2hFdmVudHNcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgSWYgdHJ1ZSwgZm9yY2UgdG91Y2ggZXZlbnRzIHRvIGJlIG9uLlxyXG4gICAgICovcm9vdC5Nb3R0bGUuc2V0Rm9yY2VUb3VjaEV2ZW50cz1mdW5jdGlvbih2YWx1ZSl7aXNUb3VjaERldmljZT12YWx1ZTt9Oy8qKlxyXG4gICAgICogRm9yY2VzIG1vdXNlIGV2ZW50cyB0byBiZSB0dXJuZWQgXCJvblwiLiBVc2VmdWwgZm9yIHRlc3Rpbmc6IGV2ZW4gaWYgeW91IGRvbid0IGhhdmUgYSBtb3VzZSwgeW91IGNhbiBzdGlsbFxyXG4gICAgICogdHJpZ2dlciBhIG1vdXNlIGV2ZW50IHdoZW4gdGhpcyBpcyBzd2l0Y2hlZCBvbiBhbmQgaXQgd2lsbCBiZSBjYXB0dXJlZCBhbmQgYWN0ZWQgb24uXHJcbiAgICAgKiBAbWV0aG9kIHNldEZvcmNlTW91c2VFdmVudHNcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgSWYgdHJ1ZSwgZm9yY2UgbW91c2UgZXZlbnRzIHRvIGJlIG9uLlxyXG4gICAgICovcm9vdC5Nb3R0bGUuc2V0Rm9yY2VNb3VzZUV2ZW50cz1mdW5jdGlvbih2YWx1ZSl7aXNNb3VzZURldmljZT12YWx1ZTt9O3Jvb3QuTW90dGxlLnZlcnNpb249XCIwLjguMFwiO2lmKHR5cGVvZiBleHBvcnRzIT09XCJ1bmRlZmluZWRcIil7ZXhwb3J0cy5Nb3R0bGU9cm9vdC5Nb3R0bGU7fX0pLmNhbGwodHlwZW9mIHdpbmRvdz09PVwidW5kZWZpbmVkXCI/dGhpczp3aW5kb3cpOy8qKlxyXG4gZHJhZy9kcm9wIGZ1bmN0aW9uYWxpdHkgZm9yIHVzZSB3aXRoIGpzUGx1bWIgYnV0IHdpdGhcclxuIG5vIGtub3dsZWRnZSBvZiBqc1BsdW1iLiBzdXBwb3J0cyBtdWx0aXBsZSBzY29wZXMgKHNlcGFyYXRlZCBieSB3aGl0ZXNwYWNlKSwgZHJhZ2dpbmdcclxuIG11bHRpcGxlIGVsZW1lbnRzLCBjb25zdHJhaW4gdG8gcGFyZW50LCBkcm9wIGZpbHRlcnMsIGRyYWcgc3RhcnQgZmlsdGVycywgY3VzdG9tXHJcbiBjc3MgY2xhc3Nlcy5cclxuXHJcbiBhIGxvdCBvZiB0aGUgZnVuY3Rpb25hbGl0eSBvZiB0aGlzIHNjcmlwdCBpcyBleHBlY3RlZCB0byBiZSBwbHVnZ2VkIGluOlxyXG5cclxuIGFkZENsYXNzXHJcbiByZW1vdmVDbGFzc1xyXG5cclxuIGFkZEV2ZW50XHJcbiByZW1vdmVFdmVudFxyXG5cclxuIGdldFBvc2l0aW9uXHJcbiBzZXRQb3NpdGlvblxyXG4gZ2V0U2l6ZVxyXG5cclxuIGluZGV4T2ZcclxuIGludGVyc2VjdHNcclxuXHJcbiB0aGUgbmFtZSBjYW1lIGZyb20gaGVyZTpcclxuXHJcbiBodHRwOi8vbXJzaGFycG9ibHVudG8uZ2l0aHViLmlvL2Zvc3dpZy5qcy9cclxuXHJcbiBjb3B5cmlnaHQgMjAxNiBqc1BsdW1iXHJcbiAqLzsoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgcm9vdD10aGlzO3ZhciBfc3VnZ2VzdD1mdW5jdGlvbiBfc3VnZ2VzdChsaXN0LGl0ZW0saGVhZCl7aWYobGlzdC5pbmRleE9mKGl0ZW0pPT09LTEpe2hlYWQ/bGlzdC51bnNoaWZ0KGl0ZW0pOmxpc3QucHVzaChpdGVtKTtyZXR1cm4gdHJ1ZTt9cmV0dXJuIGZhbHNlO307dmFyIF92YW5xdWlzaD1mdW5jdGlvbiBfdmFucXVpc2gobGlzdCxpdGVtKXt2YXIgaWR4PWxpc3QuaW5kZXhPZihpdGVtKTtpZihpZHghPT0tMSlsaXN0LnNwbGljZShpZHgsMSk7fTt2YXIgX2RpZmZlcmVuY2U9ZnVuY3Rpb24gX2RpZmZlcmVuY2UobDEsbDIpe3ZhciBkPVtdO2Zvcih2YXIgaT0wO2k8bDEubGVuZ3RoO2krKyl7aWYobDIuaW5kZXhPZihsMVtpXSk9PT0tMSlkLnB1c2gobDFbaV0pO31yZXR1cm4gZDt9O3ZhciBfaXNTdHJpbmc9ZnVuY3Rpb24gX2lzU3RyaW5nKGYpe3JldHVybiBmPT1udWxsP2ZhbHNlOnR5cGVvZiBmPT09XCJzdHJpbmdcInx8Zi5jb25zdHJ1Y3Rvcj09PVN0cmluZzt9O3ZhciBnZXRPZmZzZXRSZWN0PWZ1bmN0aW9uIGdldE9mZnNldFJlY3QoZWxlbSl7Ly8gKDEpXG52YXIgYm94PWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksYm9keT1kb2N1bWVudC5ib2R5LGRvY0VsZW09ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LC8vICgyKVxuc2Nyb2xsVG9wPXdpbmRvdy5wYWdlWU9mZnNldHx8ZG9jRWxlbS5zY3JvbGxUb3B8fGJvZHkuc2Nyb2xsVG9wLHNjcm9sbExlZnQ9d2luZG93LnBhZ2VYT2Zmc2V0fHxkb2NFbGVtLnNjcm9sbExlZnR8fGJvZHkuc2Nyb2xsTGVmdCwvLyAoMylcbmNsaWVudFRvcD1kb2NFbGVtLmNsaWVudFRvcHx8Ym9keS5jbGllbnRUb3B8fDAsY2xpZW50TGVmdD1kb2NFbGVtLmNsaWVudExlZnR8fGJvZHkuY2xpZW50TGVmdHx8MCwvLyAoNClcbnRvcD1ib3gudG9wK3Njcm9sbFRvcC1jbGllbnRUb3AsbGVmdD1ib3gubGVmdCtzY3JvbGxMZWZ0LWNsaWVudExlZnQ7cmV0dXJue3RvcDpNYXRoLnJvdW5kKHRvcCksbGVmdDpNYXRoLnJvdW5kKGxlZnQpfTt9O3ZhciBtYXRjaGVzU2VsZWN0b3I9ZnVuY3Rpb24gbWF0Y2hlc1NlbGVjdG9yKGVsLHNlbGVjdG9yLGN0eCl7Y3R4PWN0eHx8ZWwucGFyZW50Tm9kZTt2YXIgcG9zc2libGVzPWN0eC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtmb3IodmFyIGk9MDtpPHBvc3NpYmxlcy5sZW5ndGg7aSsrKXtpZihwb3NzaWJsZXNbaV09PT1lbClyZXR1cm4gdHJ1ZTt9cmV0dXJuIGZhbHNlO307dmFyIGlldj1mdW5jdGlvbigpe3ZhciBydj0tMTtpZihuYXZpZ2F0b3IuYXBwTmFtZT09PSdNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXInKXt2YXIgdWE9bmF2aWdhdG9yLnVzZXJBZ2VudCxyZT1uZXcgUmVnRXhwKFwiTVNJRSAoWzAtOV17MSx9W1xcLjAtOV17MCx9KVwiKTtpZihyZS5leGVjKHVhKSE9bnVsbClydj1wYXJzZUZsb2F0KFJlZ0V4cC4kMSk7fXJldHVybiBydjt9KCksREVGQVVMVF9HUklEX1g9MTAsREVGQVVMVF9HUklEX1k9MTAsaXNJRUxUOT1pZXY+LTEmJmlldjw5LGlzSUU5PWlldj09PTksX3BsPWZ1bmN0aW9uIF9wbChlKXtpZihpc0lFTFQ5KXtyZXR1cm5bZS5jbGllbnRYK2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LGUuY2xpZW50WStkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXTt9ZWxzZXt2YXIgdHM9X3RvdWNoZXMoZSksdD1fZ2V0VG91Y2godHMsMCk7Ly8gZm9yIElFOSBwYWdlWCBtaWdodCBiZSBudWxsIGlmIHRoZSBldmVudCB3YXMgc3ludGhlc2l6ZWQuIFdlIHRyeSBmb3IgcGFnZVgvcGFnZVkgZmlyc3QsXG4vLyBmYWxsaW5nIGJhY2sgdG8gY2xpZW50WC9jbGllbnRZIGlmIG5lY2Vzc2FyeS4gSW4gZXZlcnkgb3RoZXIgYnJvd3NlciB3ZSB3YW50IHRvIHVzZSBwYWdlWC9wYWdlWS5cbnJldHVybiBpc0lFOT9bdC5wYWdlWHx8dC5jbGllbnRYLHQucGFnZVl8fHQuY2xpZW50WV06W3QucGFnZVgsdC5wYWdlWV07fX0sX2dldFRvdWNoPWZ1bmN0aW9uIF9nZXRUb3VjaCh0b3VjaGVzLGlkeCl7cmV0dXJuIHRvdWNoZXMuaXRlbT90b3VjaGVzLml0ZW0oaWR4KTp0b3VjaGVzW2lkeF07fSxfdG91Y2hlcz1mdW5jdGlvbiBfdG91Y2hlcyhlKXtyZXR1cm4gZS50b3VjaGVzJiZlLnRvdWNoZXMubGVuZ3RoPjA/ZS50b3VjaGVzOmUuY2hhbmdlZFRvdWNoZXMmJmUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoPjA/ZS5jaGFuZ2VkVG91Y2hlczplLnRhcmdldFRvdWNoZXMmJmUudGFyZ2V0VG91Y2hlcy5sZW5ndGg+MD9lLnRhcmdldFRvdWNoZXM6W2VdO30sX2NsYXNzZXM9e2RyYWdnYWJsZTpcImthdGF2b3Jpby1kcmFnZ2FibGVcIiwvLyBkcmFnZ2FibGUgZWxlbWVudHNcbmRyb3BwYWJsZTpcImthdGF2b3Jpby1kcm9wcGFibGVcIiwvLyBkcm9wcGFibGUgZWxlbWVudHNcbmRyYWc6XCJrYXRhdm9yaW8tZHJhZ1wiLC8vIGVsZW1lbnRzIGN1cnJlbnRseSBiZWluZyBkcmFnZ2VkXG5zZWxlY3RlZDpcImthdGF2b3Jpby1kcmFnLXNlbGVjdGVkXCIsLy8gZWxlbWVudHMgaW4gY3VycmVudCBkcmFnIHNlbGVjdGlvblxuYWN0aXZlOlwia2F0YXZvcmlvLWRyYWctYWN0aXZlXCIsLy8gZHJvcHBhYmxlcyB0aGF0IGFyZSB0YXJnZXRzIG9mIGEgY3VycmVudGx5IGRyYWdnZWQgZWxlbWVudFxuaG92ZXI6XCJrYXRhdm9yaW8tZHJhZy1ob3ZlclwiLC8vIGRyb3BwYWJsZXMgb3ZlciB3aGljaCBhIG1hdGNoaW5nIGRyYWcgZWxlbWVudCBpcyBob3ZlcmluZ1xubm9TZWxlY3Q6XCJrYXRhdm9yaW8tZHJhZy1uby1zZWxlY3RcIiwvLyBhZGRlZCB0byB0aGUgYm9keSB0byBwcm92aWRlIGEgaG9vayB0byBzdXBwcmVzcyB0ZXh0IHNlbGVjdGlvblxuZ2hvc3RQcm94eTpcImthdGF2b3Jpby1naG9zdC1wcm94eVwiLC8vIGFkZGVkIHRvIGEgZ2hvc3QgcHJveHkgZWxlbWVudCBpbiB1c2Ugd2hlbiBhIGRyYWcgaGFzIGV4aXRlZCB0aGUgYm91bmRzIG9mIGl0cyBwYXJlbnQuXG5jbG9uZWREcmFnOlwia2F0YXZvcmlvLWNsb25lLWRyYWdcIi8vIGFkZGVkIHRvIGEgbm9kZSB0aGF0IGlzIGEgY2xvbmUgb2YgYW4gZWxlbWVudCBjcmVhdGVkIGF0IHRoZSBzdGFydCBvZiBhIGRyYWdcbn0sX2RlZmF1bHRTY29wZT1cImthdGF2b3Jpby1kcmFnLXNjb3BlXCIsX2V2ZW50cz1bXCJzdG9wXCIsXCJzdGFydFwiLFwiZHJhZ1wiLFwiZHJvcFwiLFwib3ZlclwiLFwib3V0XCIsXCJiZWZvcmVTdGFydFwiXSxfZGV2TnVsbD1mdW5jdGlvbiBfZGV2TnVsbCgpe30sX3RydWU9ZnVuY3Rpb24gX3RydWUoKXtyZXR1cm4gdHJ1ZTt9LF9mb3JlYWNoPWZ1bmN0aW9uIF9mb3JlYWNoKGwsZm4sZnJvbSl7Zm9yKHZhciBpPTA7aTxsLmxlbmd0aDtpKyspe2lmKGxbaV0hPWZyb20pZm4obFtpXSk7fX0sX3NldERyb3BwYWJsZXNBY3RpdmU9ZnVuY3Rpb24gX3NldERyb3BwYWJsZXNBY3RpdmUoZGQsdmFsLGFuZEhvdmVyLGRyYWcpe19mb3JlYWNoKGRkLGZ1bmN0aW9uKGUpe2Uuc2V0QWN0aXZlKHZhbCk7aWYodmFsKWUudXBkYXRlUG9zaXRpb24oKTtpZihhbmRIb3ZlcillLnNldEhvdmVyKGRyYWcsdmFsKTt9KTt9LF9lYWNoPWZ1bmN0aW9uIF9lYWNoKG9iaixmbil7aWYob2JqPT1udWxsKXJldHVybjtvYmo9IV9pc1N0cmluZyhvYmopJiZvYmoudGFnTmFtZT09bnVsbCYmb2JqLmxlbmd0aCE9bnVsbD9vYmo6W29ial07Zm9yKHZhciBpPTA7aTxvYmoubGVuZ3RoO2krKyl7Zm4uYXBwbHkob2JqW2ldLFtvYmpbaV1dKTt9fSxfY29uc3VtZT1mdW5jdGlvbiBfY29uc3VtZShlKXtpZihlLnN0b3BQcm9wYWdhdGlvbil7ZS5zdG9wUHJvcGFnYXRpb24oKTtlLnByZXZlbnREZWZhdWx0KCk7fWVsc2V7ZS5yZXR1cm5WYWx1ZT1mYWxzZTt9fSxfZGVmYXVsdElucHV0RmlsdGVyU2VsZWN0b3I9XCJpbnB1dCx0ZXh0YXJlYSxzZWxlY3QsYnV0dG9uLG9wdGlvblwiLC8vXG4vLyBmaWx0ZXJzIG91dCBldmVudHMgb24gYWxsIGlucHV0IGVsZW1lbnRzLCBsaWtlIHRleHRhcmVhLCBjaGVja2JveCwgaW5wdXQsIHNlbGVjdC5cbl9pbnB1dEZpbHRlcj1mdW5jdGlvbiBfaW5wdXRGaWx0ZXIoZSxlbCxfa2F0YXZvcmlvKXt2YXIgdD1lLnNyY0VsZW1lbnR8fGUudGFyZ2V0O3JldHVybiFtYXRjaGVzU2VsZWN0b3IodCxfa2F0YXZvcmlvLmdldElucHV0RmlsdGVyU2VsZWN0b3IoKSxlbCk7fTt2YXIgU3VwZXI9ZnVuY3Rpb24gU3VwZXIoZWwscGFyYW1zLGNzcyxzY29wZSl7dGhpcy5wYXJhbXM9cGFyYW1zfHx7fTt0aGlzLmVsPWVsO3RoaXMucGFyYW1zLmFkZENsYXNzKHRoaXMuZWwsdGhpcy5fY2xhc3MpO3RoaXMudXVpZD1fdXVpZCgpO3ZhciBlbmFibGVkPXRydWU7dGhpcy5zZXRFbmFibGVkPWZ1bmN0aW9uKGUpe2VuYWJsZWQ9ZTt9O3RoaXMuaXNFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIGVuYWJsZWQ7fTt0aGlzLnRvZ2dsZUVuYWJsZWQ9ZnVuY3Rpb24oKXtlbmFibGVkPSFlbmFibGVkO307dGhpcy5zZXRTY29wZT1mdW5jdGlvbihzY29wZXMpe3RoaXMuc2NvcGVzPXNjb3Blcz9zY29wZXMuc3BsaXQoL1xccysvKTpbc2NvcGVdO307dGhpcy5hZGRTY29wZT1mdW5jdGlvbihzY29wZXMpe3ZhciBtPXt9O19lYWNoKHRoaXMuc2NvcGVzLGZ1bmN0aW9uKHMpe21bc109dHJ1ZTt9KTtfZWFjaChzY29wZXM/c2NvcGVzLnNwbGl0KC9cXHMrLyk6W10sZnVuY3Rpb24ocyl7bVtzXT10cnVlO30pO3RoaXMuc2NvcGVzPVtdO2Zvcih2YXIgaSBpbiBtKXt0aGlzLnNjb3Blcy5wdXNoKGkpO319O3RoaXMucmVtb3ZlU2NvcGU9ZnVuY3Rpb24oc2NvcGVzKXt2YXIgbT17fTtfZWFjaCh0aGlzLnNjb3BlcyxmdW5jdGlvbihzKXttW3NdPXRydWU7fSk7X2VhY2goc2NvcGVzP3Njb3Blcy5zcGxpdCgvXFxzKy8pOltdLGZ1bmN0aW9uKHMpe2RlbGV0ZSBtW3NdO30pO3RoaXMuc2NvcGVzPVtdO2Zvcih2YXIgaSBpbiBtKXt0aGlzLnNjb3Blcy5wdXNoKGkpO319O3RoaXMudG9nZ2xlU2NvcGU9ZnVuY3Rpb24oc2NvcGVzKXt2YXIgbT17fTtfZWFjaCh0aGlzLnNjb3BlcyxmdW5jdGlvbihzKXttW3NdPXRydWU7fSk7X2VhY2goc2NvcGVzP3Njb3Blcy5zcGxpdCgvXFxzKy8pOltdLGZ1bmN0aW9uKHMpe2lmKG1bc10pZGVsZXRlIG1bc107ZWxzZSBtW3NdPXRydWU7fSk7dGhpcy5zY29wZXM9W107Zm9yKHZhciBpIGluIG0pe3RoaXMuc2NvcGVzLnB1c2goaSk7fX07dGhpcy5zZXRTY29wZShwYXJhbXMuc2NvcGUpO3RoaXMuaz1wYXJhbXMua2F0YXZvcmlvO3JldHVybiBwYXJhbXMua2F0YXZvcmlvO307dmFyIFRSVUU9ZnVuY3Rpb24gVFJVRSgpe3JldHVybiB0cnVlO307dmFyIEZBTFNFPWZ1bmN0aW9uIEZBTFNFKCl7cmV0dXJuIGZhbHNlO307dmFyIERyYWc9ZnVuY3Rpb24gRHJhZyhlbCxwYXJhbXMsY3NzLHNjb3BlKXt0aGlzLl9jbGFzcz1jc3MuZHJhZ2dhYmxlO3ZhciBrPVN1cGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aGlzLnJpZ2h0QnV0dG9uQ2FuRHJhZz10aGlzLnBhcmFtcy5yaWdodEJ1dHRvbkNhbkRyYWc7dmFyIGRvd25BdD1bMCwwXSxwb3NBdERvd249bnVsbCxwYWdlUG9zQXREb3duPW51bGwscGFnZURlbHRhPVswLDBdLG1vdmluZz1mYWxzZSxjb25zdW1lU3RhcnRFdmVudD10aGlzLnBhcmFtcy5jb25zdW1lU3RhcnRFdmVudCE9PWZhbHNlLGRyYWdFbD10aGlzLmVsLGNsb25lPXRoaXMucGFyYW1zLmNsb25lLHNjcm9sbD10aGlzLnBhcmFtcy5zY3JvbGwsX211bHRpcGxlRHJvcD1wYXJhbXMubXVsdGlwbGVEcm9wIT09ZmFsc2UsaXNDb25zdHJhaW5lZD1mYWxzZSx1c2VHaG9zdFByb3h5PXBhcmFtcy5naG9zdFByb3h5PT09dHJ1ZT9UUlVFOnBhcmFtcy5naG9zdFByb3h5JiZ0eXBlb2YgcGFyYW1zLmdob3N0UHJveHk9PT1cImZ1bmN0aW9uXCI/cGFyYW1zLmdob3N0UHJveHk6RkFMU0UsZ2hvc3RQcm94eT1mdW5jdGlvbiBnaG9zdFByb3h5KGVsKXtyZXR1cm4gZWwuY2xvbmVOb2RlKHRydWUpO307dmFyIHNuYXBUaHJlc2hvbGQ9cGFyYW1zLnNuYXBUaHJlc2hvbGQsX3NuYXA9ZnVuY3Rpb24gX3NuYXAocG9zLGdyaWRYLGdyaWRZLHRocmVzaG9sZFgsdGhyZXNob2xkWSl7dmFyIF9keD1NYXRoLmZsb29yKHBvc1swXS9ncmlkWCksX2R4bD1ncmlkWCpfZHgsX2R4dD1fZHhsK2dyaWRYLF94PU1hdGguYWJzKHBvc1swXS1fZHhsKTw9dGhyZXNob2xkWD9fZHhsOk1hdGguYWJzKF9keHQtcG9zWzBdKTw9dGhyZXNob2xkWD9fZHh0OnBvc1swXTt2YXIgX2R5PU1hdGguZmxvb3IocG9zWzFdL2dyaWRZKSxfZHlsPWdyaWRZKl9keSxfZHl0PV9keWwrZ3JpZFksX3k9TWF0aC5hYnMocG9zWzFdLV9keWwpPD10aHJlc2hvbGRZP19keWw6TWF0aC5hYnMoX2R5dC1wb3NbMV0pPD10aHJlc2hvbGRZP19keXQ6cG9zWzFdO3JldHVybltfeCxfeV07fTt0aGlzLnBvc3Nlcz1bXTt0aGlzLnBvc3NlUm9sZXM9e307dGhpcy50b0dyaWQ9ZnVuY3Rpb24ocG9zKXtpZih0aGlzLnBhcmFtcy5ncmlkPT1udWxsKXtyZXR1cm4gcG9zO31lbHNle3ZhciB0eD10aGlzLnBhcmFtcy5ncmlkP3RoaXMucGFyYW1zLmdyaWRbMF0vMjpzbmFwVGhyZXNob2xkP3NuYXBUaHJlc2hvbGQ6REVGQVVMVF9HUklEX1gvMix0eT10aGlzLnBhcmFtcy5ncmlkP3RoaXMucGFyYW1zLmdyaWRbMV0vMjpzbmFwVGhyZXNob2xkP3NuYXBUaHJlc2hvbGQ6REVGQVVMVF9HUklEX1kvMjtyZXR1cm4gX3NuYXAocG9zLHRoaXMucGFyYW1zLmdyaWRbMF0sdGhpcy5wYXJhbXMuZ3JpZFsxXSx0eCx0eSk7fX07dGhpcy5zbmFwPWZ1bmN0aW9uKHgseSl7aWYoZHJhZ0VsPT1udWxsKXJldHVybjt4PXh8fCh0aGlzLnBhcmFtcy5ncmlkP3RoaXMucGFyYW1zLmdyaWRbMF06REVGQVVMVF9HUklEX1gpO3k9eXx8KHRoaXMucGFyYW1zLmdyaWQ/dGhpcy5wYXJhbXMuZ3JpZFsxXTpERUZBVUxUX0dSSURfWSk7dmFyIHA9dGhpcy5wYXJhbXMuZ2V0UG9zaXRpb24oZHJhZ0VsKSx0eD10aGlzLnBhcmFtcy5ncmlkP3RoaXMucGFyYW1zLmdyaWRbMF0vMjpzbmFwVGhyZXNob2xkLHR5PXRoaXMucGFyYW1zLmdyaWQ/dGhpcy5wYXJhbXMuZ3JpZFsxXS8yOnNuYXBUaHJlc2hvbGQ7dGhpcy5wYXJhbXMuc2V0UG9zaXRpb24oZHJhZ0VsLF9zbmFwKHAseCx5LHR4LHR5KSk7fTt0aGlzLnNldFVzZUdob3N0UHJveHk9ZnVuY3Rpb24odmFsKXt1c2VHaG9zdFByb3h5PXZhbD9UUlVFOkZBTFNFO307dmFyIGNvbnN0cmFpbjt2YXIgbmVnYXRpdmVGaWx0ZXI9ZnVuY3Rpb24gbmVnYXRpdmVGaWx0ZXIocG9zKXtyZXR1cm4gcGFyYW1zLmFsbG93TmVnYXRpdmU9PT1mYWxzZT9bTWF0aC5tYXgoMCxwb3NbMF0pLE1hdGgubWF4KDAscG9zWzFdKV06cG9zO307dmFyIF9zZXRDb25zdHJhaW49ZnVuY3Rpb24odmFsdWUpe2NvbnN0cmFpbj10eXBlb2YgdmFsdWU9PT1cImZ1bmN0aW9uXCI/dmFsdWU6dmFsdWU/ZnVuY3Rpb24ocG9zKXtyZXR1cm4gbmVnYXRpdmVGaWx0ZXIoW01hdGgubWF4KDAsTWF0aC5taW4oY29uc3RyYWluUmVjdC53LXRoaXMuc2l6ZVswXSxwb3NbMF0pKSxNYXRoLm1heCgwLE1hdGgubWluKGNvbnN0cmFpblJlY3QuaC10aGlzLnNpemVbMV0scG9zWzFdKSldKTt9LmJpbmQodGhpcyk6ZnVuY3Rpb24ocG9zKXtyZXR1cm4gbmVnYXRpdmVGaWx0ZXIocG9zKTt9O30uYmluZCh0aGlzKTtfc2V0Q29uc3RyYWluKHR5cGVvZiB0aGlzLnBhcmFtcy5jb25zdHJhaW49PT1cImZ1bmN0aW9uXCI/dGhpcy5wYXJhbXMuY29uc3RyYWluOnRoaXMucGFyYW1zLmNvbnN0cmFpbnx8dGhpcy5wYXJhbXMuY29udGFpbm1lbnQpOy8qKlxyXG4gICAgICAgICAqIFNldHMgd2hldGhlciBvciBub3QgdGhlIERyYWcgaXMgY29uc3RyYWluZWQuIEEgdmFsdWUgb2YgJ3RydWUnIG1lYW5zIGNvbnN0cmFpbiB0byBwYXJlbnQgYm91bmRzOyBhIGZ1bmN0aW9uXHJcbiAgICAgICAgICogd2lsbCBiZSBleGVjdXRlZCBhbmQgcmV0dXJucyB0cnVlIGlmIHRoZSBwb3NpdGlvbiBpcyBhbGxvd2VkLlxyXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZVxyXG4gICAgICAgICAqL3RoaXMuc2V0Q29uc3RyYWluPWZ1bmN0aW9uKHZhbHVlKXtfc2V0Q29uc3RyYWluKHZhbHVlKTt9O3ZhciByZXZlcnRGdW5jdGlvbjsvKipcclxuICAgICAgICAgKiBTZXRzIGEgZnVuY3Rpb24gdG8gY2FsbCBvbiBkcmFnIHN0b3AsIHdoaWNoLCBpZiBpdCByZXR1cm5zIHRydWUsIGluZGljYXRlcyB0aGF0IHRoZSBnaXZlbiBlbGVtZW50IHNob3VsZFxyXG4gICAgICAgICAqIHJldmVydCB0byBpdHMgcG9zaXRpb24gYmVmb3JlIHRoZSBwcmV2aW91cyBkcmFnLlxyXG4gICAgICAgICAqIEBwYXJhbSBmblxyXG4gICAgICAgICAqL3RoaXMuc2V0UmV2ZXJ0PWZ1bmN0aW9uKGZuKXtyZXZlcnRGdW5jdGlvbj1mbjt9O3ZhciBfYXNzaWduSWQ9ZnVuY3Rpb24gX2Fzc2lnbklkKG9iail7aWYodHlwZW9mIG9iaj09PVwiZnVuY3Rpb25cIil7b2JqLl9rYXRhdm9yaW9JZD1fdXVpZCgpO3JldHVybiBvYmouX2thdGF2b3Jpb0lkO31lbHNle3JldHVybiBvYmo7fX0sLy8gYSBtYXAgb2YgeyBzcGVjIC0+IFsgZm4sIGV4Y2x1c2lvbiBdIH0gZW50cmllcy5cbl9maWx0ZXJzPXt9LF90ZXN0RmlsdGVyPWZ1bmN0aW9uIF90ZXN0RmlsdGVyKGUpe2Zvcih2YXIga2V5IGluIF9maWx0ZXJzKXt2YXIgZj1fZmlsdGVyc1trZXldO3ZhciBydj1mWzBdKGUpO2lmKGZbMV0pcnY9IXJ2O2lmKCFydilyZXR1cm4gZmFsc2U7fXJldHVybiB0cnVlO30sX3NldEZpbHRlcj10aGlzLnNldEZpbHRlcj1mdW5jdGlvbihmLF9leGNsdWRlKXtpZihmKXt2YXIga2V5PV9hc3NpZ25JZChmKTtfZmlsdGVyc1trZXldPVtmdW5jdGlvbihlKXt2YXIgdD1lLnNyY0VsZW1lbnR8fGUudGFyZ2V0LG07aWYoX2lzU3RyaW5nKGYpKXttPW1hdGNoZXNTZWxlY3Rvcih0LGYsZWwpO31lbHNlIGlmKHR5cGVvZiBmPT09XCJmdW5jdGlvblwiKXttPWYoZSxlbCk7fXJldHVybiBtO30sX2V4Y2x1ZGUhPT1mYWxzZV07fX0sX2FkZEZpbHRlcj10aGlzLmFkZEZpbHRlcj1fc2V0RmlsdGVyLF9yZW1vdmVGaWx0ZXI9dGhpcy5yZW1vdmVGaWx0ZXI9ZnVuY3Rpb24oZil7dmFyIGtleT10eXBlb2YgZj09PVwiZnVuY3Rpb25cIj9mLl9rYXRhdm9yaW9JZDpmO2RlbGV0ZSBfZmlsdGVyc1trZXldO307dGhpcy5jbGVhckFsbEZpbHRlcnM9ZnVuY3Rpb24oKXtfZmlsdGVycz17fTt9O3RoaXMuY2FuRHJhZz10aGlzLnBhcmFtcy5jYW5EcmFnfHxfdHJ1ZTt2YXIgY29uc3RyYWluUmVjdCxtYXRjaGluZ0Ryb3BwYWJsZXM9W10saW50ZXJzZWN0aW5nRHJvcHBhYmxlcz1bXTt0aGlzLmRvd25MaXN0ZW5lcj1mdW5jdGlvbihlKXt2YXIgaXNOb3RSaWdodENsaWNrPXRoaXMucmlnaHRCdXR0b25DYW5EcmFnfHxlLndoaWNoIT09MyYmZS5idXR0b24hPT0yO2lmKGlzTm90UmlnaHRDbGljayYmdGhpcy5pc0VuYWJsZWQoKSYmdGhpcy5jYW5EcmFnKCkpe3ZhciBfZj1fdGVzdEZpbHRlcihlKSYmX2lucHV0RmlsdGVyKGUsdGhpcy5lbCx0aGlzLmspO2lmKF9mKXtpZighY2xvbmUpZHJhZ0VsPXRoaXMuZWw7ZWxzZXtkcmFnRWw9dGhpcy5lbC5jbG9uZU5vZGUodHJ1ZSk7ZHJhZ0VsLnNldEF0dHJpYnV0ZShcImlkXCIsbnVsbCk7ZHJhZ0VsLnN0eWxlLnBvc2l0aW9uPVwiYWJzb2x1dGVcIjsvLyB0aGUgY2xvbmUgbm9kZSBpcyBhZGRlZCB0byB0aGUgYm9keTsgZ2V0T2Zmc2V0UmVjdCBnaXZlcyB1cyBhIHZhbHVlXG4vLyByZWxhdGl2ZSB0byB0aGUgYm9keS5cbnZhciBiPWdldE9mZnNldFJlY3QodGhpcy5lbCk7ZHJhZ0VsLnN0eWxlLmxlZnQ9Yi5sZWZ0K1wicHhcIjtkcmFnRWwuc3R5bGUudG9wPWIudG9wK1wicHhcIjt0aGlzLnBhcmFtcy5hZGRDbGFzcyhkcmFnRWwsX2NsYXNzZXMuY2xvbmVkRHJhZyk7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkcmFnRWwpO31jb25zdW1lU3RhcnRFdmVudCYmX2NvbnN1bWUoZSk7ZG93bkF0PV9wbChlKTsvL1xudGhpcy5wYXJhbXMuYmluZChkb2N1bWVudCxcIm1vdXNlbW92ZVwiLHRoaXMubW92ZUxpc3RlbmVyKTt0aGlzLnBhcmFtcy5iaW5kKGRvY3VtZW50LFwibW91c2V1cFwiLHRoaXMudXBMaXN0ZW5lcik7ay5tYXJrU2VsZWN0aW9uKHRoaXMpO2subWFya1Bvc3Nlcyh0aGlzKTt0aGlzLnBhcmFtcy5hZGRDbGFzcyhkb2N1bWVudC5ib2R5LGNzcy5ub1NlbGVjdCk7X2Rpc3BhdGNoKFwiYmVmb3JlU3RhcnRcIix7ZWw6dGhpcy5lbCxwb3M6cG9zQXREb3duLGU6ZSxkcmFnOnRoaXN9KTt9ZWxzZSBpZih0aGlzLnBhcmFtcy5jb25zdW1lRmlsdGVyZWRFdmVudHMpe19jb25zdW1lKGUpO319fS5iaW5kKHRoaXMpO3RoaXMubW92ZUxpc3RlbmVyPWZ1bmN0aW9uKGUpe2lmKGRvd25BdCl7aWYoIW1vdmluZyl7dmFyIF9jb250aW51ZT1fZGlzcGF0Y2goXCJzdGFydFwiLHtlbDp0aGlzLmVsLHBvczpwb3NBdERvd24sZTplLGRyYWc6dGhpc30pO2lmKF9jb250aW51ZSE9PWZhbHNlKXtpZighZG93bkF0KXtyZXR1cm47fXRoaXMubWFyayh0cnVlKTttb3Zpbmc9dHJ1ZTt9ZWxzZXt0aGlzLmFib3J0KCk7fX0vLyBpdCBpcyBwb3NzaWJsZSB0aGF0IHRoZSBzdGFydCBldmVudCBjYXVzZWQgdGhlIGRyYWcgdG8gYmUgYWJvcnRlZC4gU28gd2UgY2hlY2tcbi8vIGFnYWluIHRoYXQgd2UgYXJlIGN1cnJlbnRseSBkcmFnZ2luZy5cbmlmKGRvd25BdCl7aW50ZXJzZWN0aW5nRHJvcHBhYmxlcy5sZW5ndGg9MDt2YXIgcG9zPV9wbChlKSxkeD1wb3NbMF0tZG93bkF0WzBdLGR5PXBvc1sxXS1kb3duQXRbMV0sej10aGlzLnBhcmFtcy5pZ25vcmVab29tPzE6ay5nZXRab29tKCk7ZHgvPXo7ZHkvPXo7dGhpcy5tb3ZlQnkoZHgsZHksZSk7ay51cGRhdGVTZWxlY3Rpb24oZHgsZHksdGhpcyk7ay51cGRhdGVQb3NzZXMoZHgsZHksdGhpcyk7fX19LmJpbmQodGhpcyk7dGhpcy51cExpc3RlbmVyPWZ1bmN0aW9uKGUpe2lmKGRvd25BdCl7ZG93bkF0PW51bGw7dGhpcy5wYXJhbXMudW5iaW5kKGRvY3VtZW50LFwibW91c2Vtb3ZlXCIsdGhpcy5tb3ZlTGlzdGVuZXIpO3RoaXMucGFyYW1zLnVuYmluZChkb2N1bWVudCxcIm1vdXNldXBcIix0aGlzLnVwTGlzdGVuZXIpO3RoaXMucGFyYW1zLnJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksY3NzLm5vU2VsZWN0KTt0aGlzLnVubWFyayhlKTtrLnVubWFya1NlbGVjdGlvbih0aGlzLGUpO2sudW5tYXJrUG9zc2VzKHRoaXMsZSk7dGhpcy5zdG9wKGUpO2subm90aWZ5U2VsZWN0aW9uRHJhZ1N0b3AodGhpcyxlKTtrLm5vdGlmeVBvc3NlRHJhZ1N0b3AodGhpcyxlKTttb3Zpbmc9ZmFsc2U7aWYoY2xvbmUpe2RyYWdFbCYmZHJhZ0VsLnBhcmVudE5vZGUmJmRyYWdFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRyYWdFbCk7ZHJhZ0VsPW51bGw7fWludGVyc2VjdGluZ0Ryb3BwYWJsZXMubGVuZ3RoPTA7aWYocmV2ZXJ0RnVuY3Rpb24mJnJldmVydEZ1bmN0aW9uKHRoaXMuZWwsdGhpcy5wYXJhbXMuZ2V0UG9zaXRpb24odGhpcy5lbCkpPT09dHJ1ZSl7dGhpcy5wYXJhbXMuc2V0UG9zaXRpb24odGhpcy5lbCxwb3NBdERvd24pO19kaXNwYXRjaChcInJldmVydFwiLHRoaXMuZWwpO319fS5iaW5kKHRoaXMpO3RoaXMuZ2V0RmlsdGVycz1mdW5jdGlvbigpe3JldHVybiBfZmlsdGVyczt9O3RoaXMuYWJvcnQ9ZnVuY3Rpb24oKXtpZihkb3duQXQhPW51bGwpdGhpcy51cExpc3RlbmVyKCk7fTt0aGlzLmdldERyYWdFbGVtZW50PWZ1bmN0aW9uKCl7cmV0dXJuIGRyYWdFbHx8dGhpcy5lbDt9O3ZhciBsaXN0ZW5lcnM9e1wic3RhcnRcIjpbXSxcImRyYWdcIjpbXSxcInN0b3BcIjpbXSxcIm92ZXJcIjpbXSxcIm91dFwiOltdLFwiYmVmb3JlU3RhcnRcIjpbXSxcInJldmVydFwiOltdfTtpZihwYXJhbXMuZXZlbnRzLnN0YXJ0KWxpc3RlbmVycy5zdGFydC5wdXNoKHBhcmFtcy5ldmVudHMuc3RhcnQpO2lmKHBhcmFtcy5ldmVudHMuYmVmb3JlU3RhcnQpbGlzdGVuZXJzLmJlZm9yZVN0YXJ0LnB1c2gocGFyYW1zLmV2ZW50cy5iZWZvcmVTdGFydCk7aWYocGFyYW1zLmV2ZW50cy5zdG9wKWxpc3RlbmVycy5zdG9wLnB1c2gocGFyYW1zLmV2ZW50cy5zdG9wKTtpZihwYXJhbXMuZXZlbnRzLmRyYWcpbGlzdGVuZXJzLmRyYWcucHVzaChwYXJhbXMuZXZlbnRzLmRyYWcpO2lmKHBhcmFtcy5ldmVudHMucmV2ZXJ0KWxpc3RlbmVycy5yZXZlcnQucHVzaChwYXJhbXMuZXZlbnRzLnJldmVydCk7dGhpcy5vbj1mdW5jdGlvbihldnQsZm4pe2lmKGxpc3RlbmVyc1tldnRdKWxpc3RlbmVyc1tldnRdLnB1c2goZm4pO307dGhpcy5vZmY9ZnVuY3Rpb24oZXZ0LGZuKXtpZihsaXN0ZW5lcnNbZXZ0XSl7dmFyIGw9W107Zm9yKHZhciBpPTA7aTxsaXN0ZW5lcnNbZXZ0XS5sZW5ndGg7aSsrKXtpZihsaXN0ZW5lcnNbZXZ0XVtpXSE9PWZuKWwucHVzaChsaXN0ZW5lcnNbZXZ0XVtpXSk7fWxpc3RlbmVyc1tldnRdPWw7fX07dmFyIF9kaXNwYXRjaD1mdW5jdGlvbiBfZGlzcGF0Y2goZXZ0LHZhbHVlKXt2YXIgcmVzdWx0PW51bGw7aWYobGlzdGVuZXJzW2V2dF0pe2Zvcih2YXIgaT0wO2k8bGlzdGVuZXJzW2V2dF0ubGVuZ3RoO2krKyl7dHJ5e3ZhciB2PWxpc3RlbmVyc1tldnRdW2ldKHZhbHVlKTtpZih2IT1udWxsKXtyZXN1bHQ9djt9fWNhdGNoKGUpe319fXJldHVybiByZXN1bHQ7fTt0aGlzLm5vdGlmeVN0YXJ0PWZ1bmN0aW9uKGUpe19kaXNwYXRjaChcInN0YXJ0XCIse2VsOnRoaXMuZWwscG9zOnRoaXMucGFyYW1zLmdldFBvc2l0aW9uKGRyYWdFbCksZTplLGRyYWc6dGhpc30pO307dGhpcy5zdG9wPWZ1bmN0aW9uKGUsZm9yY2Upe2lmKGZvcmNlfHxtb3Zpbmcpe3ZhciBwb3NpdGlvbnM9W10sc2VsPWsuZ2V0U2VsZWN0aW9uKCksZFBvcz10aGlzLnBhcmFtcy5nZXRQb3NpdGlvbihkcmFnRWwpO2lmKHNlbC5sZW5ndGg+MSl7Zm9yKHZhciBpPTA7aTxzZWwubGVuZ3RoO2krKyl7dmFyIHA9dGhpcy5wYXJhbXMuZ2V0UG9zaXRpb24oc2VsW2ldLmVsKTtwb3NpdGlvbnMucHVzaChbc2VsW2ldLmVsLHtsZWZ0OnBbMF0sdG9wOnBbMV19LHNlbFtpXV0pO319ZWxzZXtwb3NpdGlvbnMucHVzaChbZHJhZ0VsLHtsZWZ0OmRQb3NbMF0sdG9wOmRQb3NbMV19LHRoaXNdKTt9X2Rpc3BhdGNoKFwic3RvcFwiLHtlbDpkcmFnRWwscG9zOmdob3N0UHJveHlPZmZzZXRzfHxkUG9zLGZpbmFsUG9zOmRQb3MsZTplLGRyYWc6dGhpcyxzZWxlY3Rpb246cG9zaXRpb25zfSk7fX07dGhpcy5tYXJrPWZ1bmN0aW9uKGFuZE5vdGlmeSl7cG9zQXREb3duPXRoaXMucGFyYW1zLmdldFBvc2l0aW9uKGRyYWdFbCk7cGFnZVBvc0F0RG93bj10aGlzLnBhcmFtcy5nZXRQb3NpdGlvbihkcmFnRWwsdHJ1ZSk7cGFnZURlbHRhPVtwYWdlUG9zQXREb3duWzBdLXBvc0F0RG93blswXSxwYWdlUG9zQXREb3duWzFdLXBvc0F0RG93blsxXV07dGhpcy5zaXplPXRoaXMucGFyYW1zLmdldFNpemUoZHJhZ0VsKTttYXRjaGluZ0Ryb3BwYWJsZXM9ay5nZXRNYXRjaGluZ0Ryb3BwYWJsZXModGhpcyk7X3NldERyb3BwYWJsZXNBY3RpdmUobWF0Y2hpbmdEcm9wcGFibGVzLHRydWUsZmFsc2UsdGhpcyk7dGhpcy5wYXJhbXMuYWRkQ2xhc3MoZHJhZ0VsLHRoaXMucGFyYW1zLmRyYWdDbGFzc3x8Y3NzLmRyYWcpO3ZhciBjcztpZih0aGlzLnBhcmFtcy5nZXRDb25zdHJhaW5pbmdSZWN0YW5nbGUpe2NzPXRoaXMucGFyYW1zLmdldENvbnN0cmFpbmluZ1JlY3RhbmdsZShkcmFnRWwpO31lbHNle2NzPXRoaXMucGFyYW1zLmdldFNpemUoZHJhZ0VsLnBhcmVudE5vZGUpO31jb25zdHJhaW5SZWN0PXt3OmNzWzBdLGg6Y3NbMV19O2lmKGFuZE5vdGlmeSl7ay5ub3RpZnlTZWxlY3Rpb25EcmFnU3RhcnQodGhpcyk7fX07dmFyIGdob3N0UHJveHlPZmZzZXRzO3RoaXMudW5tYXJrPWZ1bmN0aW9uKGUsZG9Ob3RDaGVja0Ryb3BwYWJsZXMpe19zZXREcm9wcGFibGVzQWN0aXZlKG1hdGNoaW5nRHJvcHBhYmxlcyxmYWxzZSx0cnVlLHRoaXMpO2lmKGlzQ29uc3RyYWluZWQmJnVzZUdob3N0UHJveHkodGhpcy5lbCkpe2dob3N0UHJveHlPZmZzZXRzPVtkcmFnRWwub2Zmc2V0TGVmdCxkcmFnRWwub2Zmc2V0VG9wXTt0aGlzLmVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZHJhZ0VsKTtkcmFnRWw9dGhpcy5lbDt9ZWxzZXtnaG9zdFByb3h5T2Zmc2V0cz1udWxsO310aGlzLnBhcmFtcy5yZW1vdmVDbGFzcyhkcmFnRWwsdGhpcy5wYXJhbXMuZHJhZ0NsYXNzfHxjc3MuZHJhZyk7bWF0Y2hpbmdEcm9wcGFibGVzLmxlbmd0aD0wO2lzQ29uc3RyYWluZWQ9ZmFsc2U7aWYoIWRvTm90Q2hlY2tEcm9wcGFibGVzKXtpZihpbnRlcnNlY3RpbmdEcm9wcGFibGVzLmxlbmd0aD4wJiZnaG9zdFByb3h5T2Zmc2V0cyl7cGFyYW1zLnNldFBvc2l0aW9uKHRoaXMuZWwsZ2hvc3RQcm94eU9mZnNldHMpO31pbnRlcnNlY3RpbmdEcm9wcGFibGVzLnNvcnQoX3JhbmtTb3J0KTtmb3IodmFyIGk9MDtpPGludGVyc2VjdGluZ0Ryb3BwYWJsZXMubGVuZ3RoO2krKyl7dmFyIHJldFZhbD1pbnRlcnNlY3RpbmdEcm9wcGFibGVzW2ldLmRyb3AodGhpcyxlKTtpZihyZXRWYWw9PT10cnVlKWJyZWFrO319fTt0aGlzLm1vdmVCeT1mdW5jdGlvbihkeCxkeSxlKXtpbnRlcnNlY3RpbmdEcm9wcGFibGVzLmxlbmd0aD0wO3ZhciBkZXNpcmVkTG9jPXRoaXMudG9HcmlkKFtwb3NBdERvd25bMF0rZHgscG9zQXREb3duWzFdK2R5XSksY1Bvcz1jb25zdHJhaW4oZGVzaXJlZExvYyxkcmFnRWwpO2lmKHVzZUdob3N0UHJveHkodGhpcy5lbCkpe2lmKGRlc2lyZWRMb2NbMF0hPT1jUG9zWzBdfHxkZXNpcmVkTG9jWzFdIT09Y1Bvc1sxXSl7aWYoIWlzQ29uc3RyYWluZWQpe3ZhciBncD1naG9zdFByb3h5KHRoaXMuZWwpO3BhcmFtcy5hZGRDbGFzcyhncCxfY2xhc3Nlcy5naG9zdFByb3h5KTt0aGlzLmVsLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZ3ApO2RyYWdFbD1ncDtpc0NvbnN0cmFpbmVkPXRydWU7fWNQb3M9ZGVzaXJlZExvYzt9ZWxzZXtpZihpc0NvbnN0cmFpbmVkKXt0aGlzLmVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZHJhZ0VsKTtkcmFnRWw9dGhpcy5lbDtpc0NvbnN0cmFpbmVkPWZhbHNlO319fXZhciByZWN0PXt4OmNQb3NbMF0seTpjUG9zWzFdLHc6dGhpcy5zaXplWzBdLGg6dGhpcy5zaXplWzFdfSxwYWdlUmVjdD17eDpyZWN0LngrcGFnZURlbHRhWzBdLHk6cmVjdC55K3BhZ2VEZWx0YVsxXSx3OnJlY3QudyxoOnJlY3QuaH0sZm9jdXNEcm9wRWxlbWVudD1udWxsO3RoaXMucGFyYW1zLnNldFBvc2l0aW9uKGRyYWdFbCxjUG9zKTtmb3IodmFyIGk9MDtpPG1hdGNoaW5nRHJvcHBhYmxlcy5sZW5ndGg7aSsrKXt2YXIgcjI9e3g6bWF0Y2hpbmdEcm9wcGFibGVzW2ldLnBhZ2VQb3NpdGlvblswXSx5Om1hdGNoaW5nRHJvcHBhYmxlc1tpXS5wYWdlUG9zaXRpb25bMV0sdzptYXRjaGluZ0Ryb3BwYWJsZXNbaV0uc2l6ZVswXSxoOm1hdGNoaW5nRHJvcHBhYmxlc1tpXS5zaXplWzFdfTtpZih0aGlzLnBhcmFtcy5pbnRlcnNlY3RzKHBhZ2VSZWN0LHIyKSYmKF9tdWx0aXBsZURyb3B8fGZvY3VzRHJvcEVsZW1lbnQ9PW51bGx8fGZvY3VzRHJvcEVsZW1lbnQ9PT1tYXRjaGluZ0Ryb3BwYWJsZXNbaV0uZWwpJiZtYXRjaGluZ0Ryb3BwYWJsZXNbaV0uY2FuRHJvcCh0aGlzKSl7aWYoIWZvY3VzRHJvcEVsZW1lbnQpZm9jdXNEcm9wRWxlbWVudD1tYXRjaGluZ0Ryb3BwYWJsZXNbaV0uZWw7aW50ZXJzZWN0aW5nRHJvcHBhYmxlcy5wdXNoKG1hdGNoaW5nRHJvcHBhYmxlc1tpXSk7bWF0Y2hpbmdEcm9wcGFibGVzW2ldLnNldEhvdmVyKHRoaXMsdHJ1ZSxlKTt9ZWxzZSBpZihtYXRjaGluZ0Ryb3BwYWJsZXNbaV0uaXNIb3ZlcigpKXttYXRjaGluZ0Ryb3BwYWJsZXNbaV0uc2V0SG92ZXIodGhpcyxmYWxzZSxlKTt9fV9kaXNwYXRjaChcImRyYWdcIix7ZWw6dGhpcy5lbCxwb3M6Y1BvcyxlOmUsZHJhZzp0aGlzfSk7LyogdGVzdCB0byBzZWUgaWYgdGhlIHBhcmVudCBuZWVkcyB0byBiZSBzY3JvbGxlZCAoZnV0dXJlKVxyXG4gICAgICAgICAgICAgaWYgKHNjcm9sbCkge1xyXG4gICAgICAgICAgICAgdmFyIHBuc2wgPSBkcmFnRWwucGFyZW50Tm9kZS5zY3JvbGxMZWZ0LCBwbnN0ID0gZHJhZ0VsLnBhcmVudE5vZGUuc2Nyb2xsVG9wO1xyXG4gICAgICAgICAgICAgY29uc29sZS5sb2coXCJzY3JvbGwhXCIsIHBuc2wsIHBuc3QpO1xyXG4gICAgICAgICAgICAgfSovfTt0aGlzLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLnBhcmFtcy51bmJpbmQodGhpcy5lbCxcIm1vdXNlZG93blwiLHRoaXMuZG93bkxpc3RlbmVyKTt0aGlzLnBhcmFtcy51bmJpbmQoZG9jdW1lbnQsXCJtb3VzZW1vdmVcIix0aGlzLm1vdmVMaXN0ZW5lcik7dGhpcy5wYXJhbXMudW5iaW5kKGRvY3VtZW50LFwibW91c2V1cFwiLHRoaXMudXBMaXN0ZW5lcik7dGhpcy5kb3duTGlzdGVuZXI9bnVsbDt0aGlzLnVwTGlzdGVuZXI9bnVsbDt0aGlzLm1vdmVMaXN0ZW5lcj1udWxsO307Ly8gaW5pdDpyZWdpc3RlciBtb3VzZWRvd24sIGFuZCBwZXJoYXBzIHNldCBhIGZpbHRlclxudGhpcy5wYXJhbXMuYmluZCh0aGlzLmVsLFwibW91c2Vkb3duXCIsdGhpcy5kb3duTGlzdGVuZXIpOy8vIGlmIGhhbmRsZSBwcm92ZGVkLCB1c2UgdGhhdC4gIG90aGVyd2lzZSwgdHJ5IHRvIHNldCBhIGZpbHRlci5cbi8vIG5vdGUgdGhhdCBhIGBoYW5kbGVgIHNlbGVjdG9yIGFsd2F5cyByZXN1bHRzIGluIGZpbHRlckV4Y2x1ZGUgYmVpbmcgc2V0IHRvIGZhbHNlLCBpZS5cbi8vIHRoZSBzZWxlY3RvciBkZWZpbmVzIHRoZSBoYW5kbGUgZWxlbWVudChzKS5cbmlmKHRoaXMucGFyYW1zLmhhbmRsZSlfc2V0RmlsdGVyKHRoaXMucGFyYW1zLmhhbmRsZSxmYWxzZSk7ZWxzZSBfc2V0RmlsdGVyKHRoaXMucGFyYW1zLmZpbHRlcix0aGlzLnBhcmFtcy5maWx0ZXJFeGNsdWRlKTt9O3ZhciBEcm9wPWZ1bmN0aW9uIERyb3AoZWwscGFyYW1zLGNzcyxzY29wZSl7dGhpcy5fY2xhc3M9Y3NzLmRyb3BwYWJsZTt0aGlzLnBhcmFtcz1wYXJhbXN8fHt9O3RoaXMucmFuaz1wYXJhbXMucmFua3x8MDt0aGlzLl9hY3RpdmVDbGFzcz10aGlzLnBhcmFtcy5hY3RpdmVDbGFzc3x8Y3NzLmFjdGl2ZTt0aGlzLl9ob3ZlckNsYXNzPXRoaXMucGFyYW1zLmhvdmVyQ2xhc3N8fGNzcy5ob3ZlcjtTdXBlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIGhvdmVyPWZhbHNlO3RoaXMuYWxsb3dMb29wYmFjaz10aGlzLnBhcmFtcy5hbGxvd0xvb3BiYWNrIT09ZmFsc2U7dGhpcy5zZXRBY3RpdmU9ZnVuY3Rpb24odmFsKXt0aGlzLnBhcmFtc1t2YWw/XCJhZGRDbGFzc1wiOlwicmVtb3ZlQ2xhc3NcIl0odGhpcy5lbCx0aGlzLl9hY3RpdmVDbGFzcyk7fTt0aGlzLnVwZGF0ZVBvc2l0aW9uPWZ1bmN0aW9uKCl7dGhpcy5wb3NpdGlvbj10aGlzLnBhcmFtcy5nZXRQb3NpdGlvbih0aGlzLmVsKTt0aGlzLnBhZ2VQb3NpdGlvbj10aGlzLnBhcmFtcy5nZXRQb3NpdGlvbih0aGlzLmVsLHRydWUpO3RoaXMuc2l6ZT10aGlzLnBhcmFtcy5nZXRTaXplKHRoaXMuZWwpO307dGhpcy5jYW5Ecm9wPXRoaXMucGFyYW1zLmNhbkRyb3B8fGZ1bmN0aW9uKGRyYWcpe3JldHVybiB0cnVlO307dGhpcy5pc0hvdmVyPWZ1bmN0aW9uKCl7cmV0dXJuIGhvdmVyO307dGhpcy5zZXRIb3Zlcj1mdW5jdGlvbihkcmFnLHZhbCxlKXsvLyBpZiB0dXJuaW5nIG9mZiBob3ZlciBidXQgdGhpcyB3YXMgbm90IHRoZSBkcmFnIHRoYXQgY2F1c2VkIHRoZSBob3ZlciwgaWdub3JlLlxuaWYodmFsfHx0aGlzLmVsLl9rYXRhdm9yaW9EcmFnSG92ZXI9PW51bGx8fHRoaXMuZWwuX2thdGF2b3Jpb0RyYWdIb3Zlcj09PWRyYWcuZWwuX2thdGF2b3Jpbyl7dGhpcy5wYXJhbXNbdmFsP1wiYWRkQ2xhc3NcIjpcInJlbW92ZUNsYXNzXCJdKHRoaXMuZWwsdGhpcy5faG92ZXJDbGFzcyk7Ly90aGlzLmVsLl9rYXRhdm9yaW9EcmFnSG92ZXIgPSB2YWwgPyBkcmFnLmVsLl9rYXRhdm9yaW8gOiBudWxsO1xudGhpcy5lbC5fa2F0YXZvcmlvRHJhZ0hvdmVyPXZhbD9kcmFnLmVsLl9rYXRhdm9yaW86bnVsbDtpZihob3ZlciE9PXZhbCl0aGlzLnBhcmFtcy5ldmVudHNbdmFsP1wib3ZlclwiOlwib3V0XCJdKHtlbDp0aGlzLmVsLGU6ZSxkcmFnOmRyYWcsZHJvcDp0aGlzfSk7aG92ZXI9dmFsO319O3RoaXMuZHJvcD1mdW5jdGlvbihkcmFnLGV2ZW50KXtyZXR1cm4gdGhpcy5wYXJhbXMuZXZlbnRzW1wiZHJvcFwiXSh7ZHJhZzpkcmFnLGU6ZXZlbnQsZHJvcDp0aGlzfSk7fTt0aGlzLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLl9jbGFzcz1udWxsO3RoaXMuX2FjdGl2ZUNsYXNzPW51bGw7dGhpcy5faG92ZXJDbGFzcz1udWxsOy8vdGhpcy5wYXJhbXMgPSBudWxsO1xuaG92ZXI9bnVsbDsvL3RoaXMuZWwgPSBudWxsO1xufTt9O3ZhciBfdXVpZD1mdW5jdGlvbiBfdXVpZCgpe3JldHVybid4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZyxmdW5jdGlvbihjKXt2YXIgcj1NYXRoLnJhbmRvbSgpKjE2fDAsdj1jPT09J3gnP3I6ciYweDN8MHg4O3JldHVybiB2LnRvU3RyaW5nKDE2KTt9KTt9O3ZhciBfcmFua1NvcnQ9ZnVuY3Rpb24gX3JhbmtTb3J0KGEsYil7cmV0dXJuIGEucmFuazxiLnJhbms/MTphLnJhbms+Yi5yYW5rPy0xOjA7fTt2YXIgX2dlbD1mdW5jdGlvbiBfZ2VsKGVsKXtpZihlbD09bnVsbClyZXR1cm4gbnVsbDtlbD10eXBlb2YgZWw9PT1cInN0cmluZ1wifHxlbC5jb25zdHJ1Y3Rvcj09PVN0cmluZz9kb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbCk6ZWw7aWYoZWw9PW51bGwpcmV0dXJuIG51bGw7ZWwuX2thdGF2b3Jpbz1lbC5fa2F0YXZvcmlvfHxfdXVpZCgpO3JldHVybiBlbDt9O3Jvb3QuS2F0YXZvcmlvPWZ1bmN0aW9uKGthdGF2b3Jpb1BhcmFtcyl7dmFyIF9zZWxlY3Rpb249W10sX3NlbGVjdGlvbk1hcD17fTt0aGlzLl9kcmFnc0J5U2NvcGU9e307dGhpcy5fZHJvcHNCeVNjb3BlPXt9O3ZhciBfem9vbT0xLF9yZWc9ZnVuY3Rpb24gX3JlZyhvYmosbWFwKXtfZWFjaChvYmosZnVuY3Rpb24oX29iail7Zm9yKHZhciBpPTA7aTxfb2JqLnNjb3Blcy5sZW5ndGg7aSsrKXttYXBbX29iai5zY29wZXNbaV1dPW1hcFtfb2JqLnNjb3Blc1tpXV18fFtdO21hcFtfb2JqLnNjb3Blc1tpXV0ucHVzaChfb2JqKTt9fSk7fSxfdW5yZWc9ZnVuY3Rpb24gX3VucmVnKG9iaixtYXApe3ZhciBjPTA7X2VhY2gob2JqLGZ1bmN0aW9uKF9vYmope2Zvcih2YXIgaT0wO2k8X29iai5zY29wZXMubGVuZ3RoO2krKyl7aWYobWFwW19vYmouc2NvcGVzW2ldXSl7dmFyIGlkeD1rYXRhdm9yaW9QYXJhbXMuaW5kZXhPZihtYXBbX29iai5zY29wZXNbaV1dLF9vYmopO2lmKGlkeCE9PS0xKXttYXBbX29iai5zY29wZXNbaV1dLnNwbGljZShpZHgsMSk7YysrO319fX0pO3JldHVybiBjPjA7fSxfZ2V0TWF0Y2hpbmdEcm9wcGFibGVzPXRoaXMuZ2V0TWF0Y2hpbmdEcm9wcGFibGVzPWZ1bmN0aW9uKGRyYWcpe3ZhciBkZD1bXSxfbT17fTtmb3IodmFyIGk9MDtpPGRyYWcuc2NvcGVzLmxlbmd0aDtpKyspe3ZhciBfZGQ9dGhpcy5fZHJvcHNCeVNjb3BlW2RyYWcuc2NvcGVzW2ldXTtpZihfZGQpe2Zvcih2YXIgaj0wO2o8X2RkLmxlbmd0aDtqKyspe2lmKF9kZFtqXS5jYW5Ecm9wKGRyYWcpJiYhX21bX2RkW2pdLnV1aWRdJiYoX2RkW2pdLmFsbG93TG9vcGJhY2t8fF9kZFtqXS5lbCE9PWRyYWcuZWwpKXtfbVtfZGRbal0udXVpZF09dHJ1ZTtkZC5wdXNoKF9kZFtqXSk7fX19fWRkLnNvcnQoX3JhbmtTb3J0KTtyZXR1cm4gZGQ7fSxfcHJlcGFyZVBhcmFtcz1mdW5jdGlvbihwKXtwPXB8fHt9O3ZhciBfcD17ZXZlbnRzOnt9fSxpO2ZvcihpIGluIGthdGF2b3Jpb1BhcmFtcyl7X3BbaV09a2F0YXZvcmlvUGFyYW1zW2ldO31mb3IoaSBpbiBwKXtfcFtpXT1wW2ldO30vLyBldmVudHNcbmZvcihpPTA7aTxfZXZlbnRzLmxlbmd0aDtpKyspe19wLmV2ZW50c1tfZXZlbnRzW2ldXT1wW19ldmVudHNbaV1dfHxfZGV2TnVsbDt9X3Aua2F0YXZvcmlvPXRoaXM7cmV0dXJuIF9wO30uYmluZCh0aGlzKSxfbWlzdGxldG9lPWZ1bmN0aW9uKGV4aXN0aW5nRHJhZyxwYXJhbXMpe2Zvcih2YXIgaT0wO2k8X2V2ZW50cy5sZW5ndGg7aSsrKXtpZihwYXJhbXNbX2V2ZW50c1tpXV0pe2V4aXN0aW5nRHJhZy5vbihfZXZlbnRzW2ldLHBhcmFtc1tfZXZlbnRzW2ldXSk7fX19LmJpbmQodGhpcyksX2Nzcz17fSxvdmVycmlkZUNzcz1rYXRhdm9yaW9QYXJhbXMuY3NzfHx7fSxfc2NvcGU9a2F0YXZvcmlvUGFyYW1zLnNjb3BlfHxfZGVmYXVsdFNjb3BlOy8vIHByZXBhcmUgbWFwIG9mIGNzcyBjbGFzc2VzIGJhc2VkIG9uIGRlZmF1bHRzIGZyc3QsIHRoZW4gb3B0aW9uYWwgb3ZlcnJpZGVzXG5mb3IodmFyIGkgaW4gX2NsYXNzZXMpe19jc3NbaV09X2NsYXNzZXNbaV07fWZvcih2YXIgaSBpbiBvdmVycmlkZUNzcyl7X2Nzc1tpXT1vdmVycmlkZUNzc1tpXTt9dmFyIGlucHV0RmlsdGVyU2VsZWN0b3I9a2F0YXZvcmlvUGFyYW1zLmlucHV0RmlsdGVyU2VsZWN0b3J8fF9kZWZhdWx0SW5wdXRGaWx0ZXJTZWxlY3RvcjsvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBzZWxlY3RvciBpZGVudGlmeWluZyB3aGljaCBpbnB1dCBlbGVtZW50cyB0byBmaWx0ZXIgZnJvbSBkcmFnIGV2ZW50cy5cclxuICAgICAgICAgKiBAbWV0aG9kIGdldElucHV0RmlsdGVyU2VsZWN0b3JcclxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IEN1cnJlbnQgaW5wdXQgZmlsdGVyIHNlbGVjdG9yLlxyXG4gICAgICAgICAqL3RoaXMuZ2V0SW5wdXRGaWx0ZXJTZWxlY3Rvcj1mdW5jdGlvbigpe3JldHVybiBpbnB1dEZpbHRlclNlbGVjdG9yO307LyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgc2VsZWN0b3IgaWRlbnRpZnlpbmcgd2hpY2ggaW5wdXQgZWxlbWVudHMgdG8gZmlsdGVyIGZyb20gZHJhZyBldmVudHMuXHJcbiAgICAgICAgICogQG1ldGhvZCBzZXRJbnB1dEZpbHRlclNlbGVjdG9yXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIElucHV0IGZpbHRlciBzZWxlY3RvciB0byBzZXQuXHJcbiAgICAgICAgICogQHJldHVybiB7S2F0YXZvcmlvfSBDdXJyZW50IGluc3RhbmNlOyBtZXRob2QgbWF5IGJlIGNoYWluZWQuXHJcbiAgICAgICAgICovdGhpcy5zZXRJbnB1dEZpbHRlclNlbGVjdG9yPWZ1bmN0aW9uKHNlbGVjdG9yKXtpbnB1dEZpbHRlclNlbGVjdG9yPXNlbGVjdG9yO3JldHVybiB0aGlzO307dGhpcy5kcmFnZ2FibGU9ZnVuY3Rpb24oZWwscGFyYW1zKXt2YXIgbz1bXTtfZWFjaChlbCxmdW5jdGlvbihfZWwpe19lbD1fZ2VsKF9lbCk7aWYoX2VsIT1udWxsKXtpZihfZWwuX2thdGF2b3Jpb0RyYWc9PW51bGwpe3ZhciBwPV9wcmVwYXJlUGFyYW1zKHBhcmFtcyk7X2VsLl9rYXRhdm9yaW9EcmFnPW5ldyBEcmFnKF9lbCxwLF9jc3MsX3Njb3BlKTtfcmVnKF9lbC5fa2F0YXZvcmlvRHJhZyx0aGlzLl9kcmFnc0J5U2NvcGUpO28ucHVzaChfZWwuX2thdGF2b3Jpb0RyYWcpO2thdGF2b3Jpb1BhcmFtcy5hZGRDbGFzcyhfZWwsX2Nzcy5kcmFnZ2FibGUpO31lbHNle19taXN0bGV0b2UoX2VsLl9rYXRhdm9yaW9EcmFnLHBhcmFtcyk7fX19LmJpbmQodGhpcykpO3JldHVybiBvO307dGhpcy5kcm9wcGFibGU9ZnVuY3Rpb24oZWwscGFyYW1zKXt2YXIgbz1bXTtfZWFjaChlbCxmdW5jdGlvbihfZWwpe19lbD1fZ2VsKF9lbCk7aWYoX2VsIT1udWxsKXt2YXIgZHJvcD1uZXcgRHJvcChfZWwsX3ByZXBhcmVQYXJhbXMocGFyYW1zKSxfY3NzLF9zY29wZSk7X2VsLl9rYXRhdm9yaW9Ecm9wPV9lbC5fa2F0YXZvcmlvRHJvcHx8W107X2VsLl9rYXRhdm9yaW9Ecm9wLnB1c2goZHJvcCk7X3JlZyhkcm9wLHRoaXMuX2Ryb3BzQnlTY29wZSk7by5wdXNoKGRyb3ApO2thdGF2b3Jpb1BhcmFtcy5hZGRDbGFzcyhfZWwsX2Nzcy5kcm9wcGFibGUpO319LmJpbmQodGhpcykpO3JldHVybiBvO307LyoqXHJcbiAgICAgICAgICogQG5hbWUgS2F0YXZvcmlvI3NlbGVjdFxyXG4gICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAqIEBkZXNjIEFkZHMgYW4gZWxlbWVudCB0byB0aGUgY3VycmVudCBzZWxlY3Rpb24gKGZvciBtdWx0aXBsZSBub2RlIGRyYWcpXHJcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ30gRE9NIGVsZW1lbnQgLSBvciBpZCBvZiB0aGUgZWxlbWVudCAtIHRvIGFkZC5cclxuICAgICAgICAgKi90aGlzLnNlbGVjdD1mdW5jdGlvbihlbCl7X2VhY2goZWwsZnVuY3Rpb24oKXt2YXIgX2VsPV9nZWwodGhpcyk7aWYoX2VsJiZfZWwuX2thdGF2b3Jpb0RyYWcpe2lmKCFfc2VsZWN0aW9uTWFwW19lbC5fa2F0YXZvcmlvXSl7X3NlbGVjdGlvbi5wdXNoKF9lbC5fa2F0YXZvcmlvRHJhZyk7X3NlbGVjdGlvbk1hcFtfZWwuX2thdGF2b3Jpb109W19lbCxfc2VsZWN0aW9uLmxlbmd0aC0xXTtrYXRhdm9yaW9QYXJhbXMuYWRkQ2xhc3MoX2VsLF9jc3Muc2VsZWN0ZWQpO319fSk7cmV0dXJuIHRoaXM7fTsvKipcclxuICAgICAgICAgKiBAbmFtZSBLYXRhdm9yaW8jZGVzZWxlY3RcclxuICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgKiBAZGVzYyBSZW1vdmVzIGFuIGVsZW1lbnQgZnJvbSB0aGUgY3VycmVudCBzZWxlY3Rpb24gKGZvciBtdWx0aXBsZSBub2RlIGRyYWcpXHJcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ30gRE9NIGVsZW1lbnQgLSBvciBpZCBvZiB0aGUgZWxlbWVudCAtIHRvIHJlbW92ZS5cclxuICAgICAgICAgKi90aGlzLmRlc2VsZWN0PWZ1bmN0aW9uKGVsKXtfZWFjaChlbCxmdW5jdGlvbigpe3ZhciBfZWw9X2dlbCh0aGlzKTtpZihfZWwmJl9lbC5fa2F0YXZvcmlvKXt2YXIgZT1fc2VsZWN0aW9uTWFwW19lbC5fa2F0YXZvcmlvXTtpZihlKXt2YXIgX3M9W107Zm9yKHZhciBpPTA7aTxfc2VsZWN0aW9uLmxlbmd0aDtpKyspe2lmKF9zZWxlY3Rpb25baV0uZWwhPT1fZWwpX3MucHVzaChfc2VsZWN0aW9uW2ldKTt9X3NlbGVjdGlvbj1fcztkZWxldGUgX3NlbGVjdGlvbk1hcFtfZWwuX2thdGF2b3Jpb107a2F0YXZvcmlvUGFyYW1zLnJlbW92ZUNsYXNzKF9lbCxfY3NzLnNlbGVjdGVkKTt9fX0pO3JldHVybiB0aGlzO307dGhpcy5kZXNlbGVjdEFsbD1mdW5jdGlvbigpe2Zvcih2YXIgaSBpbiBfc2VsZWN0aW9uTWFwKXt2YXIgZD1fc2VsZWN0aW9uTWFwW2ldO2thdGF2b3Jpb1BhcmFtcy5yZW1vdmVDbGFzcyhkWzBdLF9jc3Muc2VsZWN0ZWQpO31fc2VsZWN0aW9uLmxlbmd0aD0wO19zZWxlY3Rpb25NYXA9e307fTt0aGlzLm1hcmtTZWxlY3Rpb249ZnVuY3Rpb24oZHJhZyl7X2ZvcmVhY2goX3NlbGVjdGlvbixmdW5jdGlvbihlKXtlLm1hcmsoKTt9LGRyYWcpO307dGhpcy5tYXJrUG9zc2VzPWZ1bmN0aW9uKGRyYWcpe2lmKGRyYWcucG9zc2VzKXtfZWFjaChkcmFnLnBvc3NlcyxmdW5jdGlvbihwKXtpZihkcmFnLnBvc3NlUm9sZXNbcF0mJl9wb3NzZXNbcF0pe19mb3JlYWNoKF9wb3NzZXNbcF0ubWVtYmVycyxmdW5jdGlvbihkKXtkLm1hcmsoKTt9LGRyYWcpO319KTt9fTt0aGlzLnVubWFya1NlbGVjdGlvbj1mdW5jdGlvbihkcmFnLGV2ZW50KXtfZm9yZWFjaChfc2VsZWN0aW9uLGZ1bmN0aW9uKGUpe2UudW5tYXJrKGV2ZW50KTt9LGRyYWcpO307dGhpcy51bm1hcmtQb3NzZXM9ZnVuY3Rpb24oZHJhZyxldmVudCl7aWYoZHJhZy5wb3NzZXMpe19lYWNoKGRyYWcucG9zc2VzLGZ1bmN0aW9uKHApe2lmKGRyYWcucG9zc2VSb2xlc1twXSYmX3Bvc3Nlc1twXSl7X2ZvcmVhY2goX3Bvc3Nlc1twXS5tZW1iZXJzLGZ1bmN0aW9uKGQpe2QudW5tYXJrKGV2ZW50LHRydWUpO30sZHJhZyk7fX0pO319O3RoaXMuZ2V0U2VsZWN0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIF9zZWxlY3Rpb24uc2xpY2UoMCk7fTt0aGlzLnVwZGF0ZVNlbGVjdGlvbj1mdW5jdGlvbihkeCxkeSxkcmFnKXtfZm9yZWFjaChfc2VsZWN0aW9uLGZ1bmN0aW9uKGUpe2UubW92ZUJ5KGR4LGR5KTt9LGRyYWcpO307dmFyIF9wb3NzZUFjdGlvbj1mdW5jdGlvbiBfcG9zc2VBY3Rpb24oZm4sZHJhZyl7aWYoZHJhZy5wb3NzZXMpe19lYWNoKGRyYWcucG9zc2VzLGZ1bmN0aW9uKHApe2lmKGRyYWcucG9zc2VSb2xlc1twXSYmX3Bvc3Nlc1twXSl7X2ZvcmVhY2goX3Bvc3Nlc1twXS5tZW1iZXJzLGZ1bmN0aW9uKGUpe2ZuKGUpO30sZHJhZyk7fX0pO319O3RoaXMudXBkYXRlUG9zc2VzPWZ1bmN0aW9uKGR4LGR5LGRyYWcpe19wb3NzZUFjdGlvbihmdW5jdGlvbihlKXtlLm1vdmVCeShkeCxkeSk7fSxkcmFnKTt9O3RoaXMubm90aWZ5UG9zc2VEcmFnU3RvcD1mdW5jdGlvbihkcmFnLGV2dCl7X3Bvc3NlQWN0aW9uKGZ1bmN0aW9uKGUpe2Uuc3RvcChldnQsdHJ1ZSk7fSxkcmFnKTt9O3RoaXMubm90aWZ5U2VsZWN0aW9uRHJhZ1N0b3A9ZnVuY3Rpb24oZHJhZyxldnQpe19mb3JlYWNoKF9zZWxlY3Rpb24sZnVuY3Rpb24oZSl7ZS5zdG9wKGV2dCx0cnVlKTt9LGRyYWcpO307dGhpcy5ub3RpZnlTZWxlY3Rpb25EcmFnU3RhcnQ9ZnVuY3Rpb24oZHJhZyxldnQpe19mb3JlYWNoKF9zZWxlY3Rpb24sZnVuY3Rpb24oZSl7ZS5ub3RpZnlTdGFydChldnQpO30sZHJhZyk7fTt0aGlzLnNldFpvb209ZnVuY3Rpb24oeil7X3pvb209ejt9O3RoaXMuZ2V0Wm9vbT1mdW5jdGlvbigpe3JldHVybiBfem9vbTt9Oy8vIGRvZXMgdGhlIHdvcmsgb2YgY2hhbmdpbmcgc2NvcGVzXG52YXIgX3Njb3BlTWFuaXA9ZnVuY3Rpb24gX3Njb3BlTWFuaXAoa09iaixzY29wZXMsbWFwLGZuKXtfZWFjaChrT2JqLGZ1bmN0aW9uKF9rT2JqKXtfdW5yZWcoX2tPYmosbWFwKTsvLyBkZXJlZ2lzdGVyIGV4aXN0aW5nIHNjb3Blc1xuX2tPYmpbZm5dKHNjb3Blcyk7Ly8gc2V0IHNjb3Blc1xuX3JlZyhfa09iaixtYXApOy8vIHJlZ2lzdGVyIG5ldyBvbmVzXG59KTt9O19lYWNoKFtcInNldFwiLFwiYWRkXCIsXCJyZW1vdmVcIixcInRvZ2dsZVwiXSxmdW5jdGlvbih2KXt0aGlzW3YrXCJTY29wZVwiXT1mdW5jdGlvbihlbCxzY29wZXMpe19zY29wZU1hbmlwKGVsLl9rYXRhdm9yaW9EcmFnLHNjb3Blcyx0aGlzLl9kcmFnc0J5U2NvcGUsditcIlNjb3BlXCIpO19zY29wZU1hbmlwKGVsLl9rYXRhdm9yaW9Ecm9wLHNjb3Blcyx0aGlzLl9kcm9wc0J5U2NvcGUsditcIlNjb3BlXCIpO30uYmluZCh0aGlzKTt0aGlzW3YrXCJEcmFnU2NvcGVcIl09ZnVuY3Rpb24oZWwsc2NvcGVzKXtfc2NvcGVNYW5pcChlbC5jb25zdHJ1Y3Rvcj09PURyYWc/ZWw6ZWwuX2thdGF2b3Jpb0RyYWcsc2NvcGVzLHRoaXMuX2RyYWdzQnlTY29wZSx2K1wiU2NvcGVcIik7fS5iaW5kKHRoaXMpO3RoaXNbditcIkRyb3BTY29wZVwiXT1mdW5jdGlvbihlbCxzY29wZXMpe19zY29wZU1hbmlwKGVsLmNvbnN0cnVjdG9yPT09RHJvcD9lbDplbC5fa2F0YXZvcmlvRHJvcCxzY29wZXMsdGhpcy5fZHJvcHNCeVNjb3BlLHYrXCJTY29wZVwiKTt9LmJpbmQodGhpcyk7fS5iaW5kKHRoaXMpKTt0aGlzLnNuYXBUb0dyaWQ9ZnVuY3Rpb24oeCx5KXtmb3IodmFyIHMgaW4gdGhpcy5fZHJhZ3NCeVNjb3BlKXtfZm9yZWFjaCh0aGlzLl9kcmFnc0J5U2NvcGVbc10sZnVuY3Rpb24oZCl7ZC5zbmFwKHgseSk7fSk7fX07dGhpcy5nZXREcmFnc0ZvclNjb3BlPWZ1bmN0aW9uKHMpe3JldHVybiB0aGlzLl9kcmFnc0J5U2NvcGVbc107fTt0aGlzLmdldERyb3BzRm9yU2NvcGU9ZnVuY3Rpb24ocyl7cmV0dXJuIHRoaXMuX2Ryb3BzQnlTY29wZVtzXTt9O3ZhciBfZGVzdHJveT1mdW5jdGlvbiBfZGVzdHJveShlbCx0eXBlLG1hcCl7ZWw9X2dlbChlbCk7aWYoZWxbdHlwZV0pey8vIHJlbW92ZSBmcm9tIHNlbGVjdGlvbiwgaWYgcHJlc2VudC5cbnZhciBzZWxJZHg9X3NlbGVjdGlvbi5pbmRleE9mKGVsW3R5cGVdKTtpZihzZWxJZHg+PTApe19zZWxlY3Rpb24uc3BsaWNlKHNlbElkeCwxKTt9aWYoX3VucmVnKGVsW3R5cGVdLG1hcCkpe19lYWNoKGVsW3R5cGVdLGZ1bmN0aW9uKGtPYmope2tPYmouZGVzdHJveSgpO30pO31kZWxldGUgZWxbdHlwZV07fX07dmFyIF9yZW1vdmVMaXN0ZW5lcj1mdW5jdGlvbiBfcmVtb3ZlTGlzdGVuZXIoZWwsdHlwZSxldnQsZm4pe2VsPV9nZWwoZWwpO2lmKGVsW3R5cGVdKXtlbFt0eXBlXS5vZmYoZXZ0LGZuKTt9fTt0aGlzLmVsZW1lbnRSZW1vdmVkPWZ1bmN0aW9uKGVsKXt0aGlzLmRlc3Ryb3lEcmFnZ2FibGUoZWwpO3RoaXMuZGVzdHJveURyb3BwYWJsZShlbCk7fTsvKipcclxuICAgICAgICAgKiBFaXRoZXIgY29tcGxldGVseSByZW1vdmUgZHJhZyBmdW5jdGlvbmFsaXR5IGZyb20gdGhlIGdpdmVuIGVsZW1lbnQsIG9yIHJlbW92ZSBhIHNwZWNpZmljIGV2ZW50IGhhbmRsZXIuIElmIHlvdVxyXG4gICAgICAgICAqIGNhbGwgdGhpcyBtZXRob2Qgd2l0aCBhIHNpbmdsZSBhcmd1bWVudCAtIHRoZSBlbGVtZW50IC0gYWxsIGRyYWcgZnVuY3Rpb25hbGl0eSBpcyByZW1vdmVkIGZyb20gaXQuIE90aGVyd2lzZSwgaWZcclxuICAgICAgICAgKiB5b3UgcHJvdmlkZSBhbiBldmVudCBuYW1lIGFuZCBsaXN0ZW5lciBmdW5jdGlvbiwgdGhpcyBmdW5jdGlvbiBpcyBkZS1yZWdpc3RlcmVkIChpZiBmb3VuZCkuXHJcbiAgICAgICAgICogQHBhcmFtIGVsIEVsZW1lbnQgdG8gdXBkYXRlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtldnRdIE9wdGlvbmFsIGV2ZW50IG5hbWUgdG8gdW5zdWJzY3JpYmVcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIHVuc3Vic2NyaWJlXHJcbiAgICAgICAgICovdGhpcy5kZXN0cm95RHJhZ2dhYmxlPWZ1bmN0aW9uKGVsLGV2dCxmbil7aWYoYXJndW1lbnRzLmxlbmd0aD09PTEpe19kZXN0cm95KGVsLFwiX2thdGF2b3Jpb0RyYWdcIix0aGlzLl9kcmFnc0J5U2NvcGUpO31lbHNle19yZW1vdmVMaXN0ZW5lcihlbCxcIl9rYXRhdm9yaW9EcmFnXCIsZXZ0LGZuKTt9fTsvKipcclxuICAgICAgICAgKiBFaXRoZXIgY29tcGxldGVseSByZW1vdmUgZHJvcCBmdW5jdGlvbmFsaXR5IGZyb20gdGhlIGdpdmVuIGVsZW1lbnQsIG9yIHJlbW92ZSBhIHNwZWNpZmljIGV2ZW50IGhhbmRsZXIuIElmIHlvdVxyXG4gICAgICAgICAqIGNhbGwgdGhpcyBtZXRob2Qgd2l0aCBhIHNpbmdsZSBhcmd1bWVudCAtIHRoZSBlbGVtZW50IC0gYWxsIGRyb3AgZnVuY3Rpb25hbGl0eSBpcyByZW1vdmVkIGZyb20gaXQuIE90aGVyd2lzZSwgaWZcclxuICAgICAgICAgKiB5b3UgcHJvdmlkZSBhbiBldmVudCBuYW1lIGFuZCBsaXN0ZW5lciBmdW5jdGlvbiwgdGhpcyBmdW5jdGlvbiBpcyBkZS1yZWdpc3RlcmVkIChpZiBmb3VuZCkuXHJcbiAgICAgICAgICogQHBhcmFtIGVsIEVsZW1lbnQgdG8gdXBkYXRlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtldnRdIE9wdGlvbmFsIGV2ZW50IG5hbWUgdG8gdW5zdWJzY3JpYmVcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIHVuc3Vic2NyaWJlXHJcbiAgICAgICAgICovdGhpcy5kZXN0cm95RHJvcHBhYmxlPWZ1bmN0aW9uKGVsLGV2dCxmbil7aWYoYXJndW1lbnRzLmxlbmd0aD09PTEpe19kZXN0cm95KGVsLFwiX2thdGF2b3Jpb0Ryb3BcIix0aGlzLl9kcm9wc0J5U2NvcGUpO31lbHNle19yZW1vdmVMaXN0ZW5lcihlbCxcIl9rYXRhdm9yaW9Ecm9wXCIsZXZ0LGZuKTt9fTt0aGlzLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5fZHJhZ3NCeVNjb3BlPXt9O3RoaXMuX2Ryb3BzQnlTY29wZT17fTtfc2VsZWN0aW9uPVtdO19zZWxlY3Rpb25NYXA9e307X3Bvc3Nlcz17fTt9Oy8vIC0tLS0tIGdyb3Vwc1xudmFyIF9wb3NzZXM9e307dmFyIF9wcm9jZXNzT25lU3BlYz1mdW5jdGlvbiBfcHJvY2Vzc09uZVNwZWMoZWwsX3NwZWMsZG9udEFkZEV4aXN0aW5nKXt2YXIgcG9zc2VJZD1faXNTdHJpbmcoX3NwZWMpP19zcGVjOl9zcGVjLmlkO3ZhciBhY3RpdmU9X2lzU3RyaW5nKF9zcGVjKT90cnVlOl9zcGVjLmFjdGl2ZSE9PWZhbHNlO3ZhciBwb3NzZT1fcG9zc2VzW3Bvc3NlSWRdfHxmdW5jdGlvbigpe3ZhciBnPXtuYW1lOnBvc3NlSWQsbWVtYmVyczpbXX07X3Bvc3Nlc1twb3NzZUlkXT1nO3JldHVybiBnO30oKTtfZWFjaChlbCxmdW5jdGlvbihfZWwpe2lmKF9lbC5fa2F0YXZvcmlvRHJhZyl7aWYoZG9udEFkZEV4aXN0aW5nJiZfZWwuX2thdGF2b3Jpb0RyYWcucG9zc2VSb2xlc1twb3NzZS5uYW1lXSE9bnVsbClyZXR1cm47X3N1Z2dlc3QocG9zc2UubWVtYmVycyxfZWwuX2thdGF2b3Jpb0RyYWcpO19zdWdnZXN0KF9lbC5fa2F0YXZvcmlvRHJhZy5wb3NzZXMscG9zc2UubmFtZSk7X2VsLl9rYXRhdm9yaW9EcmFnLnBvc3NlUm9sZXNbcG9zc2UubmFtZV09YWN0aXZlO319KTtyZXR1cm4gcG9zc2U7fTsvKipcclxuICAgICAgICAgKiBBZGQgdGhlIGdpdmVuIGVsZW1lbnQgdG8gdGhlIHBvc3NlIHdpdGggdGhlIGdpdmVuIGlkLCBjcmVhdGluZyB0aGUgZ3JvdXAgaWYgaXQgYXQgZmlyc3QgZG9lcyBub3QgZXhpc3QuXHJcbiAgICAgICAgICogQG1ldGhvZCBhZGRUb1Bvc3NlXHJcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbCBFbGVtZW50IHRvIGFkZC5cclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZy4uLnxPYmplY3QuLi59IHNwZWMgVmFyaWFibGUgYXJncyBwYXJhbWV0ZXJzLiBFYWNoIGFyZ3VtZW50IGNhbiBiZSBhIGVpdGhlciBhIFN0cmluZywgaW5kaWNhdGluZ1xyXG4gICAgICAgICAqIHRoZSBJRCBvZiBhIFBvc3NlIHRvIHdoaWNoIHRoZSBlbGVtZW50IHNob3VsZCBiZSBhZGRlZCBhcyBhbiBhY3RpdmUgcGFydGljaXBhbnQsIG9yIGFuIE9iamVjdCBjb250YWluaW5nXHJcbiAgICAgICAgICogYHsgaWQ6XCJwb3NzZUlkXCIsIGFjdGl2ZTpmYWxzZS90cnVlfWAuIEluIHRoZSBsYXR0ZXIgY2FzZSwgaWYgYGFjdGl2ZWAgaXMgbm90IHByb3ZpZGVkIGl0IGlzIGFzc3VtZWQgdG8gYmVcclxuICAgICAgICAgKiB0cnVlLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQb3NzZXxQb3NzZVtdfSBUaGUgUG9zc2UocykgdG8gd2hpY2ggdGhlIGVsZW1lbnQocykgd2FzL3dlcmUgYWRkZWQuXHJcbiAgICAgICAgICovdGhpcy5hZGRUb1Bvc3NlPWZ1bmN0aW9uKGVsLHNwZWMpe3ZhciBwb3NzZXM9W107Zm9yKHZhciBpPTE7aTxhcmd1bWVudHMubGVuZ3RoO2krKyl7cG9zc2VzLnB1c2goX3Byb2Nlc3NPbmVTcGVjKGVsLGFyZ3VtZW50c1tpXSkpO31yZXR1cm4gcG9zc2VzLmxlbmd0aD09PTE/cG9zc2VzWzBdOnBvc3Nlczt9Oy8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIHBvc3NlKHMpIGZvciB0aGUgZWxlbWVudCB3aXRoIHRoZSBnaXZlbiBpZCwgY3JlYXRpbmcgdGhvc2UgdGhhdCBkbyBub3QgeWV0IGV4aXN0LCBhbmQgcmVtb3ZpbmcgZnJvbVxyXG4gICAgICAgICAqIHRoZSBlbGVtZW50IGFueSBjdXJyZW50IFBvc3NlcyB0aGF0IGFyZSBub3Qgc3BlY2lmaWVkIGJ5IHRoaXMgbWV0aG9kIGNhbGwuIFRoaXMgbWV0aG9kIHdpbGwgbm90IGNoYW5nZSB0aGVcclxuICAgICAgICAgKiBhY3RpdmUvcGFzc2l2ZSBzdGF0ZSBpZiBpdCBpcyBnaXZlbiBhIHBvc3NlIGluIHdoaWNoIHRoZSBlbGVtZW50IGlzIGFscmVhZHkgYSBtZW1iZXIuXHJcbiAgICAgICAgICogQG1ldGhvZCBzZXRQb3NzZVxyXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWwgRWxlbWVudCB0byBzZXQgcG9zc2Uocykgb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmcuLi58T2JqZWN0Li4ufSBzcGVjIFZhcmlhYmxlIGFyZ3MgcGFyYW1ldGVycy4gRWFjaCBhcmd1bWVudCBjYW4gYmUgYSBlaXRoZXIgYSBTdHJpbmcsIGluZGljYXRpbmdcclxuICAgICAgICAgKiB0aGUgSUQgb2YgYSBQb3NzZSB0byB3aGljaCB0aGUgZWxlbWVudCBzaG91bGQgYmUgYWRkZWQgYXMgYW4gYWN0aXZlIHBhcnRpY2lwYW50LCBvciBhbiBPYmplY3QgY29udGFpbmluZ1xyXG4gICAgICAgICAqIGB7IGlkOlwicG9zc2VJZFwiLCBhY3RpdmU6ZmFsc2UvdHJ1ZX1gLiBJbiB0aGUgbGF0dGVyIGNhc2UsIGlmIGBhY3RpdmVgIGlzIG5vdCBwcm92aWRlZCBpdCBpcyBhc3N1bWVkIHRvIGJlXHJcbiAgICAgICAgICogdHJ1ZS5cclxuICAgICAgICAgKiBAcmV0dXJucyB7UG9zc2V8UG9zc2VbXX0gVGhlIFBvc3NlKHMpIHRvIHdoaWNoIHRoZSBlbGVtZW50KHMpIG5vdyBiZWxvbmdzLlxyXG4gICAgICAgICAqL3RoaXMuc2V0UG9zc2U9ZnVuY3Rpb24oZWwsc3BlYyl7dmFyIHBvc3Nlcz1bXTtmb3IodmFyIGk9MTtpPGFyZ3VtZW50cy5sZW5ndGg7aSsrKXtwb3NzZXMucHVzaChfcHJvY2Vzc09uZVNwZWMoZWwsYXJndW1lbnRzW2ldLHRydWUpLm5hbWUpO31fZWFjaChlbCxmdW5jdGlvbihfZWwpe2lmKF9lbC5fa2F0YXZvcmlvRHJhZyl7dmFyIGRpZmY9X2RpZmZlcmVuY2UoX2VsLl9rYXRhdm9yaW9EcmFnLnBvc3Nlcyxwb3NzZXMpO3ZhciBwPVtdO0FycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHAsX2VsLl9rYXRhdm9yaW9EcmFnLnBvc3Nlcyk7Zm9yKHZhciBpPTA7aTxkaWZmLmxlbmd0aDtpKyspe3RoaXMucmVtb3ZlRnJvbVBvc3NlKF9lbCxkaWZmW2ldKTt9fX0uYmluZCh0aGlzKSk7cmV0dXJuIHBvc3Nlcy5sZW5ndGg9PT0xP3Bvc3Nlc1swXTpwb3NzZXM7fTsvKipcclxuICAgICAgICAgKiBSZW1vdmUgdGhlIGdpdmVuIGVsZW1lbnQgZnJvbSB0aGUgZ2l2ZW4gcG9zc2UocykuXHJcbiAgICAgICAgICogQG1ldGhvZCByZW1vdmVGcm9tUG9zc2VcclxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsIEVsZW1lbnQgdG8gcmVtb3ZlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nLi4ufSBwb3NzZUlkIFZhcmFyZ3MgcGFyYW1ldGVyOiBvbmUgdmFsdWUgZm9yIGVhY2ggcG9zc2UgdG8gcmVtb3ZlIHRoZSBlbGVtZW50IGZyb20uXHJcbiAgICAgICAgICovdGhpcy5yZW1vdmVGcm9tUG9zc2U9ZnVuY3Rpb24oZWwscG9zc2VJZCl7aWYoYXJndW1lbnRzLmxlbmd0aDwyKXRocm93IG5ldyBUeXBlRXJyb3IoXCJObyBwb3NzZSBpZCBwcm92aWRlZCBmb3IgcmVtb3ZlIG9wZXJhdGlvblwiKTtmb3IodmFyIGk9MTtpPGFyZ3VtZW50cy5sZW5ndGg7aSsrKXtwb3NzZUlkPWFyZ3VtZW50c1tpXTtfZWFjaChlbCxmdW5jdGlvbihfZWwpe2lmKF9lbC5fa2F0YXZvcmlvRHJhZyYmX2VsLl9rYXRhdm9yaW9EcmFnLnBvc3Nlcyl7dmFyIGQ9X2VsLl9rYXRhdm9yaW9EcmFnO19lYWNoKHBvc3NlSWQsZnVuY3Rpb24ocCl7X3ZhbnF1aXNoKF9wb3NzZXNbcF0ubWVtYmVycyxkKTtfdmFucXVpc2goZC5wb3NzZXMscCk7ZGVsZXRlIGQucG9zc2VSb2xlc1twXTt9KTt9fSk7fX07LyoqXHJcbiAgICAgICAgICogUmVtb3ZlIHRoZSBnaXZlbiBlbGVtZW50IGZyb20gYWxsIFBvc3NlcyB0byB3aGljaCBpdCBiZWxvbmdzLlxyXG4gICAgICAgICAqIEBtZXRob2QgcmVtb3ZlRnJvbUFsbFBvc3Nlc1xyXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudHxFbGVtZW50W119IGVsIEVsZW1lbnQgdG8gcmVtb3ZlIGZyb20gUG9zc2VzLlxyXG4gICAgICAgICAqL3RoaXMucmVtb3ZlRnJvbUFsbFBvc3Nlcz1mdW5jdGlvbihlbCl7X2VhY2goZWwsZnVuY3Rpb24oX2VsKXtpZihfZWwuX2thdGF2b3Jpb0RyYWcmJl9lbC5fa2F0YXZvcmlvRHJhZy5wb3NzZXMpe3ZhciBkPV9lbC5fa2F0YXZvcmlvRHJhZztfZWFjaChkLnBvc3NlcyxmdW5jdGlvbihwKXtfdmFucXVpc2goX3Bvc3Nlc1twXS5tZW1iZXJzLGQpO30pO2QucG9zc2VzLmxlbmd0aD0wO2QucG9zc2VSb2xlcz17fTt9fSk7fTsvKipcclxuICAgICAgICAgKiBDaGFuZ2VzIHRoZSBwYXJ0aWNpcGF0aW9uIHN0YXRlIGZvciB0aGUgZWxlbWVudCBpbiB0aGUgUG9zc2Ugd2l0aCB0aGUgZ2l2ZW4gSUQuXHJcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fEVsZW1lbnRbXX0gZWwgRWxlbWVudChzKSB0byBjaGFuZ2Ugc3RhdGUgZm9yLlxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwb3NzZUlkIElEIG9mIHRoZSBQb3NzZSB0byBjaGFuZ2UgZWxlbWVudCBzdGF0ZSBmb3IuXHJcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBzdGF0ZSBUcnVlIHRvIG1ha2UgYWN0aXZlLCBmYWxzZSB0byBtYWtlIHBhc3NpdmUuXHJcbiAgICAgICAgICovdGhpcy5zZXRQb3NzZVN0YXRlPWZ1bmN0aW9uKGVsLHBvc3NlSWQsc3RhdGUpe3ZhciBwb3NzZT1fcG9zc2VzW3Bvc3NlSWRdO2lmKHBvc3NlKXtfZWFjaChlbCxmdW5jdGlvbihfZWwpe2lmKF9lbC5fa2F0YXZvcmlvRHJhZyYmX2VsLl9rYXRhdm9yaW9EcmFnLnBvc3Nlcyl7X2VsLl9rYXRhdm9yaW9EcmFnLnBvc3NlUm9sZXNbcG9zc2UubmFtZV09c3RhdGU7fX0pO319O307cm9vdC5LYXRhdm9yaW8udmVyc2lvbj1cIjAuMjMuMFwiO2lmKHR5cGVvZiBleHBvcnRzIT09XCJ1bmRlZmluZWRcIil7ZXhwb3J0cy5LYXRhdm9yaW89cm9vdC5LYXRhdm9yaW87fX0pLmNhbGwodHlwZW9mIHdpbmRvdyE9PSd1bmRlZmluZWQnP3dpbmRvdzp0aGlzKTsvKlxyXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdXRpbGl0eSBmdW5jdGlvbnMgdGhhdCBydW4gaW4gYm90aCBicm93c2VycyBhbmQgaGVhZGxlc3MuXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMCAtIDIwMTgganNQbHVtYiAoaGVsbG9AanNwbHVtYnRvb2xraXQuY29tKVxyXG4gKlxyXG4gKiBodHRwczovL2pzcGx1bWJ0b29sa2l0LmNvbVxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vanNwbHVtYi9qc3BsdW1iXHJcbiAqXHJcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMMiBsaWNlbnNlcy5cclxuICovOyhmdW5jdGlvbigpe3ZhciBfaXNhPWZ1bmN0aW9uIF9pc2EoYSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKT09PVwiW29iamVjdCBBcnJheV1cIjt9LF9pc251bT1mdW5jdGlvbiBfaXNudW0obil7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuKT09PVwiW29iamVjdCBOdW1iZXJdXCI7fSxfaXNzPWZ1bmN0aW9uIF9pc3Mocyl7cmV0dXJuIHR5cGVvZiBzPT09XCJzdHJpbmdcIjt9LF9pc2I9ZnVuY3Rpb24gX2lzYihzKXtyZXR1cm4gdHlwZW9mIHM9PT1cImJvb2xlYW5cIjt9LF9pc251bGw9ZnVuY3Rpb24gX2lzbnVsbChzKXtyZXR1cm4gcz09bnVsbDt9LF9pc289ZnVuY3Rpb24gX2lzbyhvKXtyZXR1cm4gbz09bnVsbD9mYWxzZTpPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk9PT1cIltvYmplY3QgT2JqZWN0XVwiO30sX2lzZD1mdW5jdGlvbiBfaXNkKG8pe3JldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk9PT1cIltvYmplY3QgRGF0ZV1cIjt9LF9pc2Y9ZnVuY3Rpb24gX2lzZihvKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pPT09XCJbb2JqZWN0IEZ1bmN0aW9uXVwiO30sX2lzTmFtZWRGdW5jdGlvbj1mdW5jdGlvbiBfaXNOYW1lZEZ1bmN0aW9uKG8pe3JldHVybiBfaXNmKG8pJiZvLm5hbWUhPW51bGwmJm8ubmFtZS5sZW5ndGg+MDt9LF9pc2U9ZnVuY3Rpb24gX2lzZShvKXtmb3IodmFyIGkgaW4gbyl7aWYoby5oYXNPd25Qcm9wZXJ0eShpKSl7cmV0dXJuIGZhbHNlO319cmV0dXJuIHRydWU7fTt2YXIgcm9vdD10aGlzO3Jvb3QuanNQbHVtYlV0aWw9e2lzQXJyYXk6X2lzYSxpc1N0cmluZzpfaXNzLGlzQm9vbGVhbjpfaXNiLGlzTnVsbDpfaXNudWxsLGlzT2JqZWN0Ol9pc28saXNEYXRlOl9pc2QsaXNGdW5jdGlvbjpfaXNmLGlzRW1wdHk6X2lzZSxpc051bWJlcjpfaXNudW0sY2xvbmU6ZnVuY3Rpb24gY2xvbmUoYSl7aWYoX2lzcyhhKSl7cmV0dXJuXCJcIithO31lbHNlIGlmKF9pc2IoYSkpe3JldHVybiEhYTt9ZWxzZSBpZihfaXNkKGEpKXtyZXR1cm4gbmV3IERhdGUoYS5nZXRUaW1lKCkpO31lbHNlIGlmKF9pc2YoYSkpe3JldHVybiBhO31lbHNlIGlmKF9pc2EoYSkpe3ZhciBiPVtdO2Zvcih2YXIgaT0wO2k8YS5sZW5ndGg7aSsrKXtiLnB1c2godGhpcy5jbG9uZShhW2ldKSk7fXJldHVybiBiO31lbHNlIGlmKF9pc28oYSkpe3ZhciBjPXt9O2Zvcih2YXIgaiBpbiBhKXtjW2pdPXRoaXMuY2xvbmUoYVtqXSk7fXJldHVybiBjO31lbHNle3JldHVybiBhO319LG1lcmdlOmZ1bmN0aW9uIG1lcmdlKGEsYixjb2xsYXRpb25zKXsvLyBmaXJzdCBjaGFuZ2UgdGhlIGNvbGxhdGlvbnMgYXJyYXkgLSBpZiBwcmVzZW50IC0gaW50byBhIGxvb2t1cCB0YWJsZSwgYmVjYXVzZSBpdHMgZmFzdGVyLlxudmFyIGNNYXA9e30sYXIsaTtjb2xsYXRpb25zPWNvbGxhdGlvbnN8fFtdO2ZvcihpPTA7aTxjb2xsYXRpb25zLmxlbmd0aDtpKyspe2NNYXBbY29sbGF0aW9uc1tpXV09dHJ1ZTt9dmFyIGM9dGhpcy5jbG9uZShhKTtmb3IoaSBpbiBiKXtpZihjW2ldPT1udWxsKXtjW2ldPWJbaV07fWVsc2UgaWYoX2lzcyhiW2ldKXx8X2lzYihiW2ldKSl7aWYoIWNNYXBbaV0pe2NbaV09YltpXTsvLyBpZiB3ZSBkb250IHdhbnQgdG8gY29sbGF0ZSwganVzdCBjb3B5IGl0IGluLlxufWVsc2V7YXI9W107Ly8gaWYgYydzIG9iamVjdCBpcyBhbHNvIGFuIGFycmF5IHdlIGNhbiBrZWVwIGl0cyB2YWx1ZXMuXG5hci5wdXNoLmFwcGx5KGFyLF9pc2EoY1tpXSk/Y1tpXTpbY1tpXV0pO2FyLnB1c2guYXBwbHkoYXIsX2lzYShiW2ldKT9iW2ldOltiW2ldXSk7Y1tpXT1hcjt9fWVsc2V7aWYoX2lzYShiW2ldKSl7YXI9W107Ly8gaWYgYydzIG9iamVjdCBpcyBhbHNvIGFuIGFycmF5IHdlIGNhbiBrZWVwIGl0cyB2YWx1ZXMuXG5pZihfaXNhKGNbaV0pKXthci5wdXNoLmFwcGx5KGFyLGNbaV0pO31hci5wdXNoLmFwcGx5KGFyLGJbaV0pO2NbaV09YXI7fWVsc2UgaWYoX2lzbyhiW2ldKSl7Ly8gb3ZlcndpdGUgYydzIHZhbHVlIHdpdGggYW4gb2JqZWN0IGlmIGl0IGlzIG5vdCBhbHJlYWR5IG9uZS5cbmlmKCFfaXNvKGNbaV0pKXtjW2ldPXt9O31mb3IodmFyIGogaW4gYltpXSl7Y1tpXVtqXT1iW2ldW2pdO319fX1yZXR1cm4gYzt9LHJlcGxhY2U6ZnVuY3Rpb24gcmVwbGFjZShpbk9iaixwYXRoLHZhbHVlKXtpZihpbk9iaj09bnVsbCl7cmV0dXJuO312YXIgcT1pbk9iaix0PXE7cGF0aC5yZXBsYWNlKC8oW15cXC5dKSsvZyxmdW5jdGlvbih0ZXJtLGxjLHBvcyxzdHIpe3ZhciBhcnJheT10ZXJtLm1hdGNoKC8oW15cXFswLTldKyl7MX0oXFxbKShbMC05K10pLyksbGFzdD1wb3MrdGVybS5sZW5ndGg+PXN0ci5sZW5ndGgsX2dldEFycmF5PWZ1bmN0aW9uIF9nZXRBcnJheSgpe3JldHVybiB0W2FycmF5WzFdXXx8ZnVuY3Rpb24oKXt0W2FycmF5WzFdXT1bXTtyZXR1cm4gdFthcnJheVsxXV07fSgpO307aWYobGFzdCl7Ly8gc2V0IHRlcm0gPSB2YWx1ZSBvbiBjdXJyZW50IHQsIGNyZWF0aW5nIHRlcm0gYXMgYXJyYXkgaWYgbmVjZXNzYXJ5LlxuaWYoYXJyYXkpe19nZXRBcnJheSgpW2FycmF5WzNdXT12YWx1ZTt9ZWxzZXt0W3Rlcm1dPXZhbHVlO319ZWxzZXsvLyBzZXQgdG8gY3VycmVudCB0W3Rlcm1dLCBjcmVhdGluZyB0W3Rlcm1dIGlmIG5lY2Vzc2FyeS5cbmlmKGFycmF5KXt2YXIgYT1fZ2V0QXJyYXkoKTt0PWFbYXJyYXlbM11dfHxmdW5jdGlvbigpe2FbYXJyYXlbM11dPXt9O3JldHVybiBhW2FycmF5WzNdXTt9KCk7fWVsc2V7dD10W3Rlcm1dfHxmdW5jdGlvbigpe3RbdGVybV09e307cmV0dXJuIHRbdGVybV07fSgpO319fSk7cmV0dXJuIGluT2JqO30sLy9cbi8vIGNoYWluIGEgbGlzdCBvZiBmdW5jdGlvbnMsIHN1cHBsaWVkIGJ5IFsgb2JqZWN0LCBtZXRob2QgbmFtZSwgYXJncyBdLCBhbmQgcmV0dXJuIG9uIHRoZSBmaXJzdFxuLy8gb25lIHRoYXQgcmV0dXJucyB0aGUgZmFpbFZhbHVlLiBpZiBub25lIHJldHVybiB0aGUgZmFpbFZhbHVlLCByZXR1cm4gdGhlIHN1Y2Nlc3NWYWx1ZS5cbi8vXG5mdW5jdGlvbkNoYWluOmZ1bmN0aW9uIGZ1bmN0aW9uQ2hhaW4oc3VjY2Vzc1ZhbHVlLGZhaWxWYWx1ZSxmbnMpe2Zvcih2YXIgaT0wO2k8Zm5zLmxlbmd0aDtpKyspe3ZhciBvPWZuc1tpXVswXVtmbnNbaV1bMV1dLmFwcGx5KGZuc1tpXVswXSxmbnNbaV1bMl0pO2lmKG89PT1mYWlsVmFsdWUpe3JldHVybiBvO319cmV0dXJuIHN1Y2Nlc3NWYWx1ZTt9LC8vIHRha2UgdGhlIGdpdmVuIG1vZGVsIGFuZCBleHBhbmQgb3V0IGFueSBwYXJhbWV0ZXJzLlxuLy8gJ2Z1bmN0aW9uUHJlZml4JyBpcyBvcHRpb25hbCwgYW5kIGlmIHByZXNlbnQsIGhlbHBzIGpzcGx1bWIgZmlndXJlIG91dCB3aGF0IHRvIGRvIGlmIGEgdmFsdWUgaXMgYSBGdW5jdGlvbi5cbi8vIGlmIHlvdSBkbyBub3QgcHJvdmlkZSBpdCwganNwbHVtYiB3aWxsIHJ1biB0aGUgZ2l2ZW4gdmFsdWVzIHRocm91Z2ggYW55IGZ1bmN0aW9ucyBpdCBmaW5kcywgYW5kIHVzZSB0aGUgZnVuY3Rpb24nc1xuLy8gb3V0cHV0IGFzIHRoZSB2YWx1ZSBpbiB0aGUgcmVzdWx0LiBpZiB5b3UgZG8gcHJvdmlkZSB0aGUgcHJlZml4LCBvbmx5IGZ1bmN0aW9ucyB0aGF0IGFyZSBuYW1lZCBhbmQgaGF2ZSB0aGlzIHByZWZpeFxuLy8gd2lsbCBiZSBleGVjdXRlZDsgb3RoZXIgZnVuY3Rpb25zIHdpbGwgYmUgcGFzc2VkIGFzIHZhbHVlcyB0byB0aGUgb3V0cHV0LlxucG9wdWxhdGU6ZnVuY3Rpb24gcG9wdWxhdGUobW9kZWwsdmFsdWVzLGZ1bmN0aW9uUHJlZml4KXsvLyBmb3IgYSBzdHJpbmcsIHNlZSBpZiBpdCBoYXMgcGFyYW1ldGVyIG1hdGNoZXMsIGFuZCBpZiBzbywgdHJ5IHRvIG1ha2UgdGhlIHN1YnN0aXR1dGlvbnMuXG52YXIgZ2V0VmFsdWU9ZnVuY3Rpb24gZ2V0VmFsdWUoZnJvbVN0cmluZyl7dmFyIG1hdGNoZXM9ZnJvbVN0cmluZy5tYXRjaCgvKFxcJHsuKj99KS9nKTtpZihtYXRjaGVzIT1udWxsKXtmb3IodmFyIGk9MDtpPG1hdGNoZXMubGVuZ3RoO2krKyl7dmFyIHZhbD12YWx1ZXNbbWF0Y2hlc1tpXS5zdWJzdHJpbmcoMixtYXRjaGVzW2ldLmxlbmd0aC0xKV18fFwiXCI7aWYodmFsIT1udWxsKXtmcm9tU3RyaW5nPWZyb21TdHJpbmcucmVwbGFjZShtYXRjaGVzW2ldLHZhbCk7fX19cmV0dXJuIGZyb21TdHJpbmc7fSwvLyBwcm9jZXNzIG9uZSBlbnRyeS5cbl9vbmU9ZnVuY3Rpb24gX29uZShkKXtpZihkIT1udWxsKXtpZihfaXNzKGQpKXtyZXR1cm4gZ2V0VmFsdWUoZCk7fWVsc2UgaWYoX2lzZihkKSYmKGZ1bmN0aW9uUHJlZml4PT1udWxsfHwoZC5uYW1lfHxcIlwiKS5pbmRleE9mKGZ1bmN0aW9uUHJlZml4KT09PTApKXtyZXR1cm4gZCh2YWx1ZXMpO31lbHNlIGlmKF9pc2EoZCkpe3ZhciByPVtdO2Zvcih2YXIgaT0wO2k8ZC5sZW5ndGg7aSsrKXtyLnB1c2goX29uZShkW2ldKSk7fXJldHVybiByO31lbHNlIGlmKF9pc28oZCkpe3ZhciBzPXt9O2Zvcih2YXIgaiBpbiBkKXtzW2pdPV9vbmUoZFtqXSk7fXJldHVybiBzO31lbHNle3JldHVybiBkO319fTtyZXR1cm4gX29uZShtb2RlbCk7fSxmaW5kV2l0aEZ1bmN0aW9uOmZ1bmN0aW9uIGZpbmRXaXRoRnVuY3Rpb24oYSxmKXsvLyBDT05WRVJURURcbmlmKGEpe2Zvcih2YXIgaT0wO2k8YS5sZW5ndGg7aSsrKXtpZihmKGFbaV0pKXtyZXR1cm4gaTt9fX1yZXR1cm4tMTt9LHJlbW92ZVdpdGhGdW5jdGlvbjpmdW5jdGlvbiByZW1vdmVXaXRoRnVuY3Rpb24oYSxmKXsvLyBDT05WRVJURURcbnZhciBpZHg9cm9vdC5qc1BsdW1iVXRpbC5maW5kV2l0aEZ1bmN0aW9uKGEsZik7aWYoaWR4Pi0xKXthLnNwbGljZShpZHgsMSk7fXJldHVybiBpZHghPT0tMTt9LHJlbW92ZTpmdW5jdGlvbiByZW1vdmUobCx2KXsvLyBDT05WRVJURURcbnZhciBpZHg9bC5pbmRleE9mKHYpO2lmKGlkeD4tMSl7bC5zcGxpY2UoaWR4LDEpO31yZXR1cm4gaWR4IT09LTE7fSwvLyBUT0RPIHN1cHBvcnQgaW5zZXJ0IGluZGV4XG5hZGRXaXRoRnVuY3Rpb246ZnVuY3Rpb24gYWRkV2l0aEZ1bmN0aW9uKGxpc3QsaXRlbSxoYXNoRnVuY3Rpb24pe2lmKHJvb3QuanNQbHVtYlV0aWwuZmluZFdpdGhGdW5jdGlvbihsaXN0LGhhc2hGdW5jdGlvbik9PT0tMSl7bGlzdC5wdXNoKGl0ZW0pO319LGFkZFRvTGlzdDpmdW5jdGlvbiBhZGRUb0xpc3QobWFwLGtleSx2YWx1ZSxpbnNlcnRBdFN0YXJ0KXt2YXIgbD1tYXBba2V5XTtpZihsPT1udWxsKXtsPVtdO21hcFtrZXldPWw7fWxbaW5zZXJ0QXRTdGFydD9cInVuc2hpZnRcIjpcInB1c2hcIl0odmFsdWUpO3JldHVybiBsO30sc3VnZ2VzdDpmdW5jdGlvbiBzdWdnZXN0KGxpc3QsaXRlbSxpbnNlcnRBdEhlYWQpe2lmKGxpc3QuaW5kZXhPZihpdGVtKT09PS0xKXtpZihpbnNlcnRBdEhlYWQpe2xpc3QudW5zaGlmdChpdGVtKTt9ZWxzZXtsaXN0LnB1c2goaXRlbSk7fXJldHVybiB0cnVlO31yZXR1cm4gZmFsc2U7fSwvL1xuLy8gZXh0ZW5kcyB0aGUgZ2l2ZW4gb2JqICh3aGljaCBjYW4gYmUgYW4gYXJyYXkpIHdpdGggdGhlIGdpdmVuIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLCBwcm90b3R5cGUgZnVuY3Rpb25zLCBhbmRcbi8vIGNsYXNzIG1lbWJlcnMsIGFueSBvZiB3aGljaCBtYXkgYmUgbnVsbC5cbi8vXG5leHRlbmQ6ZnVuY3Rpb24gZXh0ZW5kKGNoaWxkLHBhcmVudCxfcHJvdG9Gbil7dmFyIGk7cGFyZW50PV9pc2EocGFyZW50KT9wYXJlbnQ6W3BhcmVudF07Zm9yKGk9MDtpPHBhcmVudC5sZW5ndGg7aSsrKXtmb3IodmFyIGogaW4gcGFyZW50W2ldLnByb3RvdHlwZSl7aWYocGFyZW50W2ldLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShqKSl7Y2hpbGQucHJvdG90eXBlW2pdPXBhcmVudFtpXS5wcm90b3R5cGVbal07fX19dmFyIF9tYWtlRm49ZnVuY3Rpb24gX21ha2VGbihuYW1lLHByb3RvRm4pe3JldHVybiBmdW5jdGlvbigpe2ZvcihpPTA7aTxwYXJlbnQubGVuZ3RoO2krKyl7aWYocGFyZW50W2ldLnByb3RvdHlwZVtuYW1lXSl7cGFyZW50W2ldLnByb3RvdHlwZVtuYW1lXS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7fX1yZXR1cm4gcHJvdG9Gbi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7fTt9O3ZhciBfb25lU2V0PWZ1bmN0aW9uIF9vbmVTZXQoZm5zKXtmb3IodmFyIGsgaW4gZm5zKXtjaGlsZC5wcm90b3R5cGVba109X21ha2VGbihrLGZuc1trXSk7fX07aWYoYXJndW1lbnRzLmxlbmd0aD4yKXtmb3IoaT0yO2k8YXJndW1lbnRzLmxlbmd0aDtpKyspe19vbmVTZXQoYXJndW1lbnRzW2ldKTt9fXJldHVybiBjaGlsZDt9LHV1aWQ6ZnVuY3Rpb24gdXVpZCgpe3JldHVybid4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZyxmdW5jdGlvbihjKXt2YXIgcj1NYXRoLnJhbmRvbSgpKjE2fDAsdj1jPT09J3gnP3I6ciYweDN8MHg4O3JldHVybiB2LnRvU3RyaW5nKDE2KTt9KTt9LGxvZ0VuYWJsZWQ6dHJ1ZSxsb2c6ZnVuY3Rpb24gbG9nKCl7aWYocm9vdC5qc1BsdW1iVXRpbC5sb2dFbmFibGVkJiZ0eXBlb2YgY29uc29sZSE9PVwidW5kZWZpbmVkXCIpe3RyeXt2YXIgbXNnPWFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoLTFdO2NvbnNvbGUubG9nKG1zZyk7fWNhdGNoKGUpe319fSwvKipcclxuICAgICAgICAgKiBXcmFwcyBvbmUgZnVuY3Rpb24gd2l0aCBhbm90aGVyLCBjcmVhdGluZyBhIHBsYWNlaG9sZGVyIGZvciB0aGVcclxuICAgICAgICAgKiB3cmFwcGVkIGZ1bmN0aW9uIGlmIGl0IHdhcyBudWxsLiB0aGlzIGlzIHVzZWQgdG8gd3JhcCB0aGUgdmFyaW91c1xyXG4gICAgICAgICAqIGRyYWcvZHJvcCBldmVudCBmdW5jdGlvbnMgLSB0byBhbGxvdyBqc1BsdW1iIHRvIGJlIG5vdGlmaWVkIG9mXHJcbiAgICAgICAgICogaW1wb3J0YW50IGxpZmVjeWNsZSBldmVudHMgd2l0aG91dCBpbXBvc2luZyBpdHNlbGYgb24gdGhlIHVzZXInc1xyXG4gICAgICAgICAqIGRyYWcvZHJvcCBmdW5jdGlvbmFsaXR5LlxyXG4gICAgICAgICAqIEBtZXRob2QganNQbHVtYlV0aWwud3JhcFxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBwZWRGdW5jdGlvbiBvcmlnaW5hbCBmdW5jdGlvbiB0byB3cmFwOyBtYXkgYmUgbnVsbC5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXdGdW5jdGlvbiBmdW5jdGlvbiB0byB3cmFwIHRoZSBvcmlnaW5hbCB3aXRoLlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcmV0dXJuT25UaGlzVmFsdWVdIE9wdGlvbmFsLiBJbmRpY2F0ZXMgdGhhdCB0aGUgd3JhcHBlZEZ1bmN0aW9uIHNob3VsZFxyXG4gICAgICAgICAqIG5vdCBiZSBleGVjdXRlZCBpZiB0aGUgbmV3RnVuY3Rpb24gcmV0dXJucyBhIHZhbHVlIG1hdGNoaW5nICdyZXR1cm5PblRoaXNWYWx1ZScuXHJcbiAgICAgICAgICogbm90ZSB0aGF0IHRoaXMgaXMgYSBzaW1wbGUgY29tcGFyaXNvbiBhbmQgb25seSB3b3JrcyBmb3IgcHJpbWl0aXZlcyByaWdodCBub3cuXHJcbiAgICAgICAgICovd3JhcDpmdW5jdGlvbiB3cmFwKHdyYXBwZWRGdW5jdGlvbixuZXdGdW5jdGlvbixyZXR1cm5PblRoaXNWYWx1ZSl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHI9bnVsbDt0cnl7aWYobmV3RnVuY3Rpb24hPW51bGwpe3I9bmV3RnVuY3Rpb24uYXBwbHkodGhpcyxhcmd1bWVudHMpO319Y2F0Y2goZSl7cm9vdC5qc1BsdW1iVXRpbC5sb2coXCJqc1BsdW1iIGZ1bmN0aW9uIGZhaWxlZCA6IFwiK2UpO31pZih3cmFwcGVkRnVuY3Rpb24hPW51bGwmJihyZXR1cm5PblRoaXNWYWx1ZT09bnVsbHx8ciE9PXJldHVybk9uVGhpc1ZhbHVlKSl7dHJ5e3I9d3JhcHBlZEZ1bmN0aW9uLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt9Y2F0Y2goZSl7cm9vdC5qc1BsdW1iVXRpbC5sb2coXCJ3cmFwcGVkIGZ1bmN0aW9uIGZhaWxlZCA6IFwiK2UpO319cmV0dXJuIHI7fTt9fTtyb290LmpzUGx1bWJVdGlsLkV2ZW50R2VuZXJhdG9yPWZ1bmN0aW9uKCl7dmFyIF9saXN0ZW5lcnM9e30sZXZlbnRzU3VzcGVuZGVkPWZhbHNlLHRpY2s9ZmFsc2UsLy8gdGhpcyBpcyBhIGxpc3Qgb2YgZXZlbnRzIHRoYXQgc2hvdWxkIHJlLXRocm93IGFueSBlcnJvcnMgdGhhdCBvY2N1ciBkdXJpbmcgdGhlaXIgZGlzcGF0Y2guIGl0IGlzIGN1cnJlbnQgcHJpdmF0ZS5cbmV2ZW50c1RvRGllT249e1wicmVhZHlcIjp0cnVlfSxxdWV1ZT1bXTt0aGlzLmJpbmQ9ZnVuY3Rpb24oZXZlbnQsbGlzdGVuZXIsaW5zZXJ0QXRTdGFydCl7dmFyIF9vbmU9ZnVuY3Rpb24gX29uZShldnQpe3Jvb3QuanNQbHVtYlV0aWwuYWRkVG9MaXN0KF9saXN0ZW5lcnMsZXZ0LGxpc3RlbmVyLGluc2VydEF0U3RhcnQpO2xpc3RlbmVyLl9fanNQbHVtYj1saXN0ZW5lci5fX2pzUGx1bWJ8fHt9O2xpc3RlbmVyLl9fanNQbHVtYltyb290LmpzUGx1bWJVdGlsLnV1aWQoKV09ZXZ0O307aWYodHlwZW9mIGV2ZW50PT09XCJzdHJpbmdcIil7X29uZShldmVudCk7fWVsc2UgaWYoZXZlbnQubGVuZ3RoIT1udWxsKXtmb3IodmFyIGk9MDtpPGV2ZW50Lmxlbmd0aDtpKyspe19vbmUoZXZlbnRbaV0pO319cmV0dXJuIHRoaXM7fTt0aGlzLmZpcmU9ZnVuY3Rpb24oZXZlbnQsdmFsdWUsb3JpZ2luYWxFdmVudCl7aWYoIXRpY2spe3RpY2s9dHJ1ZTtpZighZXZlbnRzU3VzcGVuZGVkJiZfbGlzdGVuZXJzW2V2ZW50XSl7dmFyIGw9X2xpc3RlbmVyc1tldmVudF0ubGVuZ3RoLGk9MCxfZ29uZT1mYWxzZSxyZXQ9bnVsbDtpZighdGhpcy5zaG91bGRGaXJlRXZlbnR8fHRoaXMuc2hvdWxkRmlyZUV2ZW50KGV2ZW50LHZhbHVlLG9yaWdpbmFsRXZlbnQpKXt3aGlsZSghX2dvbmUmJmk8bCYmcmV0IT09ZmFsc2Upey8vIGRvaW5nIGl0IHRoaXMgd2F5IHJhdGhlciB0aGFuIGNhdGNoaW5nIGFuZCB0aGVuIHBvc3NpYmx5IHJlLXRocm93aW5nIG1lYW5zIHRoYXQgYW4gZXJyb3IgcHJvcGFnYXRlZCBieSB0aGlzXG4vLyBtZXRob2Qgd2lsbCBoYXZlIHRoZSB3aG9sZSBjYWxsIHN0YWNrIGF2YWlsYWJsZSBpbiB0aGUgZGVidWdnZXIuXG5pZihldmVudHNUb0RpZU9uW2V2ZW50XSl7X2xpc3RlbmVyc1tldmVudF1baV0uYXBwbHkodGhpcyxbdmFsdWUsb3JpZ2luYWxFdmVudF0pO31lbHNle3RyeXtyZXQ9X2xpc3RlbmVyc1tldmVudF1baV0uYXBwbHkodGhpcyxbdmFsdWUsb3JpZ2luYWxFdmVudF0pO31jYXRjaChlKXtyb290LmpzUGx1bWJVdGlsLmxvZyhcImpzUGx1bWI6IGZpcmUgZmFpbGVkIGZvciBldmVudCBcIitldmVudCtcIiA6IFwiK2UpO319aSsrO2lmKF9saXN0ZW5lcnM9PW51bGx8fF9saXN0ZW5lcnNbZXZlbnRdPT1udWxsKXtfZ29uZT10cnVlO319fX10aWNrPWZhbHNlO19kcmFpbigpO31lbHNle3F1ZXVlLnVuc2hpZnQoYXJndW1lbnRzKTt9cmV0dXJuIHRoaXM7fTt2YXIgX2RyYWluPWZ1bmN0aW9uKCl7dmFyIG49cXVldWUucG9wKCk7aWYobil7dGhpcy5maXJlLmFwcGx5KHRoaXMsbik7fX0uYmluZCh0aGlzKTt0aGlzLnVuYmluZD1mdW5jdGlvbihldmVudE9yTGlzdGVuZXIsbGlzdGVuZXIpe2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0wKXtfbGlzdGVuZXJzPXt9O31lbHNlIGlmKGFyZ3VtZW50cy5sZW5ndGg9PT0xKXtpZih0eXBlb2YgZXZlbnRPckxpc3RlbmVyPT09XCJzdHJpbmdcIil7ZGVsZXRlIF9saXN0ZW5lcnNbZXZlbnRPckxpc3RlbmVyXTt9ZWxzZSBpZihldmVudE9yTGlzdGVuZXIuX19qc1BsdW1iKXt2YXIgZXZ0O2Zvcih2YXIgaSBpbiBldmVudE9yTGlzdGVuZXIuX19qc1BsdW1iKXtldnQ9ZXZlbnRPckxpc3RlbmVyLl9fanNQbHVtYltpXTtyb290LmpzUGx1bWJVdGlsLnJlbW92ZShfbGlzdGVuZXJzW2V2dF18fFtdLGV2ZW50T3JMaXN0ZW5lcik7fX19ZWxzZSBpZihhcmd1bWVudHMubGVuZ3RoPT09Mil7cm9vdC5qc1BsdW1iVXRpbC5yZW1vdmUoX2xpc3RlbmVyc1tldmVudE9yTGlzdGVuZXJdfHxbXSxsaXN0ZW5lcik7fXJldHVybiB0aGlzO307dGhpcy5nZXRMaXN0ZW5lcj1mdW5jdGlvbihmb3JFdmVudCl7cmV0dXJuIF9saXN0ZW5lcnNbZm9yRXZlbnRdO307dGhpcy5zZXRTdXNwZW5kRXZlbnRzPWZ1bmN0aW9uKHZhbCl7ZXZlbnRzU3VzcGVuZGVkPXZhbDt9O3RoaXMuaXNTdXNwZW5kRXZlbnRzPWZ1bmN0aW9uKCl7cmV0dXJuIGV2ZW50c1N1c3BlbmRlZDt9O3RoaXMuc2lsZW50bHk9ZnVuY3Rpb24oZm4pe3RoaXMuc2V0U3VzcGVuZEV2ZW50cyh0cnVlKTt0cnl7Zm4oKTt9Y2F0Y2goZSl7cm9vdC5qc1BsdW1iVXRpbC5sb2coXCJDYW5ub3QgZXhlY3V0ZSBzaWxlbnQgZnVuY3Rpb24gXCIrZSk7fXRoaXMuc2V0U3VzcGVuZEV2ZW50cyhmYWxzZSk7fTt0aGlzLmNsZWFudXBMaXN0ZW5lcnM9ZnVuY3Rpb24oKXtmb3IodmFyIGkgaW4gX2xpc3RlbmVycyl7X2xpc3RlbmVyc1tpXT1udWxsO319O307cm9vdC5qc1BsdW1iVXRpbC5FdmVudEdlbmVyYXRvci5wcm90b3R5cGU9e2NsZWFudXA6ZnVuY3Rpb24gY2xlYW51cCgpe3RoaXMuY2xlYW51cExpc3RlbmVycygpO319O2lmKHR5cGVvZiBleHBvcnRzIT09XCJ1bmRlZmluZWRcIil7ZXhwb3J0cy5qc1BsdW1iVXRpbD1yb290LmpzUGx1bWJVdGlsO319KS5jYWxsKHR5cGVvZiB3aW5kb3chPT0ndW5kZWZpbmVkJz93aW5kb3c6dGhpcyk7LypcclxuICogVGhpcyBmaWxlIGNvbnRhaW5zIHV0aWxpdHkgZnVuY3Rpb25zIHRoYXQgcnVuIGluIGJyb3dzZXJzIG9ubHkuXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMCAtIDIwMTgganNQbHVtYiAoaGVsbG9AanNwbHVtYnRvb2xraXQuY29tKVxyXG4gKlxyXG4gKiBodHRwczovL2pzcGx1bWJ0b29sa2l0LmNvbVxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vanNwbHVtYi9qc3BsdW1iXHJcbiAqXHJcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMMiBsaWNlbnNlcy5cclxuICovOyhmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3ZhciByb290PXRoaXM7cm9vdC5qc1BsdW1iVXRpbC5tYXRjaGVzU2VsZWN0b3I9ZnVuY3Rpb24oZWwsc2VsZWN0b3IsY3R4KXtjdHg9Y3R4fHxlbC5wYXJlbnROb2RlO3ZhciBwb3NzaWJsZXM9Y3R4LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO2Zvcih2YXIgaT0wO2k8cG9zc2libGVzLmxlbmd0aDtpKyspe2lmKHBvc3NpYmxlc1tpXT09PWVsKXtyZXR1cm4gdHJ1ZTt9fXJldHVybiBmYWxzZTt9O3Jvb3QuanNQbHVtYlV0aWwuY29uc3VtZT1mdW5jdGlvbihlLGRvTm90UHJldmVudERlZmF1bHQpe2lmKGUuc3RvcFByb3BhZ2F0aW9uKXtlLnN0b3BQcm9wYWdhdGlvbigpO31lbHNle2UucmV0dXJuVmFsdWU9ZmFsc2U7fWlmKCFkb05vdFByZXZlbnREZWZhdWx0JiZlLnByZXZlbnREZWZhdWx0KXtlLnByZXZlbnREZWZhdWx0KCk7fX07LypcclxuICAgICogRnVuY3Rpb246IHNpemVFbGVtZW50XHJcbiAgICAqIEhlbHBlciB0byBzaXplIGFuZCBwb3NpdGlvbiBhbiBlbGVtZW50LiBZb3Ugd291bGQgdHlwaWNhbGx5IHVzZVxyXG4gICAgKiB0aGlzIHdoZW4gd3JpdGluZyB5b3VyIG93biBDb25uZWN0b3Igb3IgRW5kcG9pbnQgaW1wbGVtZW50YXRpb24uXHJcbiAgICAqXHJcbiAgICAqIFBhcmFtZXRlcnM6XHJcbiAgICAqICB4IC0gW2ludF0geCBwb3NpdGlvbiBmb3IgdGhlIGVsZW1lbnQgb3JpZ2luXHJcbiAgICAqICB5IC0gW2ludF0geSBwb3NpdGlvbiBmb3IgdGhlIGVsZW1lbnQgb3JpZ2luXHJcbiAgICAqICB3IC0gW2ludF0gd2lkdGggb2YgdGhlIGVsZW1lbnRcclxuICAgICogIGggLSBbaW50XSBoZWlnaHQgb2YgdGhlIGVsZW1lbnRcclxuICAgICpcclxuICAgICovcm9vdC5qc1BsdW1iVXRpbC5zaXplRWxlbWVudD1mdW5jdGlvbihlbCx4LHksdyxoKXtpZihlbCl7ZWwuc3R5bGUuaGVpZ2h0PWgrXCJweFwiO2VsLmhlaWdodD1oO2VsLnN0eWxlLndpZHRoPXcrXCJweFwiO2VsLndpZHRoPXc7ZWwuc3R5bGUubGVmdD14K1wicHhcIjtlbC5zdHlsZS50b3A9eStcInB4XCI7fX07fSkuY2FsbCh0eXBlb2Ygd2luZG93IT09J3VuZGVmaW5lZCc/d2luZG93OnRoaXMpOy8qXHJcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUgY29yZSBjb2RlLlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgLSAyMDE4IGpzUGx1bWIgKGhlbGxvQGpzcGx1bWJ0b29sa2l0LmNvbSlcclxuICpcclxuICogaHR0cHM6Ly9qc3BsdW1idG9vbGtpdC5jb21cclxuICogaHR0cHM6Ly9naXRodWIuY29tL2pzcGx1bWIvanNwbHVtYlxyXG4gKlxyXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgYW5kIEdQTDIgbGljZW5zZXMuXHJcbiAqLzsoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgcm9vdD10aGlzO3ZhciBfanU9cm9vdC5qc1BsdW1iVXRpbCwvKipcclxuICAgICAgICAgKiBjcmVhdGVzIGEgdGltZXN0YW1wLCB1c2luZyBtaWxsaXNlY29uZHMgc2luY2UgMTk3MCwgYnV0IGFzIGEgc3RyaW5nLlxyXG4gICAgICAgICAqL190aW1lc3RhbXA9ZnVuY3Rpb24gX3RpbWVzdGFtcCgpe3JldHVyblwiXCIrbmV3IERhdGUoKS5nZXRUaW1lKCk7fSwvLyBoZWxwZXIgbWV0aG9kIHRvIHVwZGF0ZSB0aGUgaG92ZXIgc3R5bGUgd2hlbmV2ZXIgaXQsIG9yIHBhaW50U3R5bGUsIGNoYW5nZXMuXG4vLyB3ZSB1c2UgcGFpbnRTdHlsZSBhcyB0aGUgZm91bmRhdGlvbiBhbmQgbWVyZ2UgaG92ZXJQYWludFN0eWxlIG92ZXIgdGhlXG4vLyB0b3AuXG5fdXBkYXRlSG92ZXJTdHlsZT1mdW5jdGlvbiBfdXBkYXRlSG92ZXJTdHlsZShjb21wb25lbnQpe2lmKGNvbXBvbmVudC5fanNQbHVtYi5wYWludFN0eWxlJiZjb21wb25lbnQuX2pzUGx1bWIuaG92ZXJQYWludFN0eWxlKXt2YXIgbWVyZ2VkSG92ZXJTdHlsZT17fTtqc1BsdW1iLmV4dGVuZChtZXJnZWRIb3ZlclN0eWxlLGNvbXBvbmVudC5fanNQbHVtYi5wYWludFN0eWxlKTtqc1BsdW1iLmV4dGVuZChtZXJnZWRIb3ZlclN0eWxlLGNvbXBvbmVudC5fanNQbHVtYi5ob3ZlclBhaW50U3R5bGUpO2RlbGV0ZSBjb21wb25lbnQuX2pzUGx1bWIuaG92ZXJQYWludFN0eWxlOy8vIHdlIHdhbnQgdGhlIGZpbGwgb2YgcGFpbnRTdHlsZSB0byBvdmVycmlkZSBhIGdyYWRpZW50LCBpZiBwb3NzaWJsZS5cbmlmKG1lcmdlZEhvdmVyU3R5bGUuZ3JhZGllbnQmJmNvbXBvbmVudC5fanNQbHVtYi5wYWludFN0eWxlLmZpbGwpe2RlbGV0ZSBtZXJnZWRIb3ZlclN0eWxlLmdyYWRpZW50O31jb21wb25lbnQuX2pzUGx1bWIuaG92ZXJQYWludFN0eWxlPW1lcmdlZEhvdmVyU3R5bGU7fX0sZXZlbnRzPVtcInRhcFwiLFwiZGJsdGFwXCIsXCJjbGlja1wiLFwiZGJsY2xpY2tcIixcIm1vdXNlb3ZlclwiLFwibW91c2VvdXRcIixcIm1vdXNlbW92ZVwiLFwibW91c2Vkb3duXCIsXCJtb3VzZXVwXCIsXCJjb250ZXh0bWVudVwiXSxldmVudEZpbHRlcnM9e1wibW91c2VvdXRcIjpcIm1vdXNlbGVhdmVcIixcIm1vdXNlZXhpdFwiOlwibW91c2VsZWF2ZVwifSxfdXBkYXRlQXR0YWNoZWRFbGVtZW50cz1mdW5jdGlvbiBfdXBkYXRlQXR0YWNoZWRFbGVtZW50cyhjb21wb25lbnQsc3RhdGUsdGltZXN0YW1wLHNvdXJjZUVsZW1lbnQpe3ZhciBhZmZlY3RlZEVsZW1lbnRzPWNvbXBvbmVudC5nZXRBdHRhY2hlZEVsZW1lbnRzKCk7aWYoYWZmZWN0ZWRFbGVtZW50cyl7Zm9yKHZhciBpPTAsaj1hZmZlY3RlZEVsZW1lbnRzLmxlbmd0aDtpPGo7aSsrKXtpZighc291cmNlRWxlbWVudHx8c291cmNlRWxlbWVudCE9PWFmZmVjdGVkRWxlbWVudHNbaV0pe2FmZmVjdGVkRWxlbWVudHNbaV0uc2V0SG92ZXIoc3RhdGUsdHJ1ZSx0aW1lc3RhbXApOy8vIHRlbGwgdGhlIGF0dGFjaGVkIGVsZW1lbnRzIG5vdCB0byBpbmZvcm0gdGhlaXIgb3duIGF0dGFjaGVkIGVsZW1lbnRzLlxufX19fSxfc3BsaXRUeXBlPWZ1bmN0aW9uIF9zcGxpdFR5cGUodCl7cmV0dXJuIHQ9PW51bGw/bnVsbDp0LnNwbGl0KFwiIFwiKTt9LF9tYXBUeXBlPWZ1bmN0aW9uIF9tYXBUeXBlKG1hcCxvYmosdHlwZUlkKXtmb3IodmFyIGkgaW4gb2JqKXttYXBbaV09dHlwZUlkO319LF9lYWNoPWZ1bmN0aW9uIF9lYWNoKGZuLG9iail7b2JqPV9qdS5pc0FycmF5KG9iail8fG9iai5sZW5ndGghPW51bGwmJiFfanUuaXNTdHJpbmcob2JqKT9vYmo6W29ial07Zm9yKHZhciBpPTA7aTxvYmoubGVuZ3RoO2krKyl7dHJ5e2ZuLmFwcGx5KG9ialtpXSxbb2JqW2ldXSk7fWNhdGNoKGUpe19qdS5sb2coXCIuZWFjaCBpdGVyYXRpb24gZmFpbGVkIDogXCIrZSk7fX19LF9hcHBseVR5cGVzPWZ1bmN0aW9uIF9hcHBseVR5cGVzKGNvbXBvbmVudCxwYXJhbXMsZG9Ob3RSZXBhaW50KXtpZihjb21wb25lbnQuZ2V0RGVmYXVsdFR5cGUpe3ZhciB0ZD1jb21wb25lbnQuZ2V0VHlwZURlc2NyaXB0b3IoKSxtYXA9e307dmFyIGRlZlR5cGU9Y29tcG9uZW50LmdldERlZmF1bHRUeXBlKCk7dmFyIG89X2p1Lm1lcmdlKHt9LGRlZlR5cGUpO19tYXBUeXBlKG1hcCxkZWZUeXBlLFwiX19kZWZhdWx0XCIpO2Zvcih2YXIgaT0wLGo9Y29tcG9uZW50Ll9qc1BsdW1iLnR5cGVzLmxlbmd0aDtpPGo7aSsrKXt2YXIgdGlkPWNvbXBvbmVudC5fanNQbHVtYi50eXBlc1tpXTtpZih0aWQhPT1cIl9fZGVmYXVsdFwiKXt2YXIgX3Q9Y29tcG9uZW50Ll9qc1BsdW1iLmluc3RhbmNlLmdldFR5cGUodGlkLHRkKTtpZihfdCE9bnVsbCl7bz1fanUubWVyZ2UobyxfdCxbXCJjc3NDbGFzc1wiXSk7X21hcFR5cGUobWFwLF90LHRpZCk7fX19aWYocGFyYW1zKXtvPV9qdS5wb3B1bGF0ZShvLHBhcmFtcyxcIl9cIik7fWNvbXBvbmVudC5hcHBseVR5cGUobyxkb05vdFJlcGFpbnQsbWFwKTtpZighZG9Ob3RSZXBhaW50KXtjb21wb25lbnQucmVwYWludCgpO319fSwvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gQkVHSU4ganNQbHVtYlVJQ29tcG9uZW50IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5qc1BsdW1iVUlDb21wb25lbnQ9cm9vdC5qc1BsdW1iVUlDb21wb25lbnQ9ZnVuY3Rpb24ocGFyYW1zKXtfanUuRXZlbnRHZW5lcmF0b3IuYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciBzZWxmPXRoaXMsYT1hcmd1bWVudHMsaWRQcmVmaXg9c2VsZi5pZFByZWZpeCxpZD1pZFByZWZpeCtuZXcgRGF0ZSgpLmdldFRpbWUoKTt0aGlzLl9qc1BsdW1iPXtpbnN0YW5jZTpwYXJhbXMuX2pzUGx1bWIscGFyYW1ldGVyczpwYXJhbXMucGFyYW1ldGVyc3x8e30scGFpbnRTdHlsZTpudWxsLGhvdmVyUGFpbnRTdHlsZTpudWxsLHBhaW50U3R5bGVJblVzZTpudWxsLGhvdmVyOmZhbHNlLGJlZm9yZURldGFjaDpwYXJhbXMuYmVmb3JlRGV0YWNoLGJlZm9yZURyb3A6cGFyYW1zLmJlZm9yZURyb3Asb3ZlcmxheVBsYWNlbWVudHM6W10saG92ZXJDbGFzczpwYXJhbXMuaG92ZXJDbGFzc3x8cGFyYW1zLl9qc1BsdW1iLkRlZmF1bHRzLkhvdmVyQ2xhc3MsdHlwZXM6W10sdHlwZUNhY2hlOnt9fTt0aGlzLmNhY2hlVHlwZUl0ZW09ZnVuY3Rpb24oa2V5LGl0ZW0sdHlwZUlkKXt0aGlzLl9qc1BsdW1iLnR5cGVDYWNoZVt0eXBlSWRdPXRoaXMuX2pzUGx1bWIudHlwZUNhY2hlW3R5cGVJZF18fHt9O3RoaXMuX2pzUGx1bWIudHlwZUNhY2hlW3R5cGVJZF1ba2V5XT1pdGVtO307dGhpcy5nZXRDYWNoZWRUeXBlSXRlbT1mdW5jdGlvbihrZXksdHlwZUlkKXtyZXR1cm4gdGhpcy5fanNQbHVtYi50eXBlQ2FjaGVbdHlwZUlkXT90aGlzLl9qc1BsdW1iLnR5cGVDYWNoZVt0eXBlSWRdW2tleV06bnVsbDt9O3RoaXMuZ2V0SWQ9ZnVuY3Rpb24oKXtyZXR1cm4gaWQ7fTsvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBkZWZhdWx0IHR5cGUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBvPXBhcmFtcy5vdmVybGF5c3x8W10sb289e307aWYodGhpcy5kZWZhdWx0T3ZlcmxheUtleXMpe2Zvcih2YXIgaT0wO2k8dGhpcy5kZWZhdWx0T3ZlcmxheUtleXMubGVuZ3RoO2krKyl7QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobyx0aGlzLl9qc1BsdW1iLmluc3RhbmNlLkRlZmF1bHRzW3RoaXMuZGVmYXVsdE92ZXJsYXlLZXlzW2ldXXx8W10pO31mb3IoaT0wO2k8by5sZW5ndGg7aSsrKXsvLyBpZiBhIHN0cmluZywgY29udmVydCB0byBvYmplY3QgcmVwcmVzZW50YXRpb24gc28gdGhhdCB3ZSBjYW4gc3RvcmUgdGhlIHR5cGVpZCBvbiBpdC5cbi8vIGFsc28gYXNzaWduIGFuIGlkLlxudmFyIGZvPWpzUGx1bWIuY29udmVydFRvRnVsbE92ZXJsYXlTcGVjKG9baV0pO29vW2ZvWzFdLmlkXT1mbzt9fXZhciBfZGVmYXVsdFR5cGU9e292ZXJsYXlzOm9vLHBhcmFtZXRlcnM6cGFyYW1zLnBhcmFtZXRlcnN8fHt9LHNjb3BlOnBhcmFtcy5zY29wZXx8dGhpcy5fanNQbHVtYi5pbnN0YW5jZS5nZXREZWZhdWx0U2NvcGUoKX07dGhpcy5nZXREZWZhdWx0VHlwZT1mdW5jdGlvbigpe3JldHVybiBfZGVmYXVsdFR5cGU7fTt0aGlzLmFwcGVuZFRvRGVmYXVsdFR5cGU9ZnVuY3Rpb24ob2JqKXtmb3IodmFyIGkgaW4gb2JqKXtfZGVmYXVsdFR5cGVbaV09b2JqW2ldO319Oy8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGVuZCBkZWZhdWx0IHR5cGUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGFsbCBjb21wb25lbnRzIGNhbiBnZW5lcmF0ZSBldmVudHNcbmlmKHBhcmFtcy5ldmVudHMpe2Zvcih2YXIgZXZ0TmFtZSBpbiBwYXJhbXMuZXZlbnRzKXtzZWxmLmJpbmQoZXZ0TmFtZSxwYXJhbXMuZXZlbnRzW2V2dE5hbWVdKTt9fS8vIGFsbCBjb21wb25lbnRzIGdldCB0aGlzIGNsb25lIGZ1bmN0aW9uLlxuLy8gVE9ETyBpc3N1ZSAxMTYgc2hvd2VkIGEgcHJvYmxlbSB3aXRoIHRoaXMgLSBpdCBzZWVtcyAnYScgdGhhdCBpcyBpblxuLy8gdGhlIGNsb25lIGZ1bmN0aW9uJ3Mgc2NvcGUgaXMgc2hhcmVkIGJ5IGFsbCBpbnZvY2F0aW9ucyBvZiBpdCwgdGhlIGNsYXNzaWNcbi8vIEpTIGNsb3N1cmUgcHJvYmxlbS4gIGZvciBub3csIGpzUGx1bWIgZG9lcyBhIHZlcnNpb24gb2YgdGhpcyBpbmxpbmUgd2hlcmVcbi8vIGl0IHVzZWQgdG8gY2FsbCBjbG9uZS4gIGJ1dCBpdCB3b3VsZCBiZSBuaWNlIHRvIGZpbmQgc29tZSB0aW1lIHRvIGxvb2tcbi8vIGZ1cnRoZXIgYXQgdGhpcy5cbnRoaXMuY2xvbmU9ZnVuY3Rpb24oKXt2YXIgbz1PYmplY3QuY3JlYXRlKHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlKTt0aGlzLmNvbnN0cnVjdG9yLmFwcGx5KG8sYSk7cmV0dXJuIG87fS5iaW5kKHRoaXMpOy8vIHVzZXIgY2FuIHN1cHBseSBhIGJlZm9yZURldGFjaCBjYWxsYmFjaywgd2hpY2ggd2lsbCBiZSBleGVjdXRlZCBiZWZvcmUgYSBkZXRhY2hcbi8vIGlzIHBlcmZvcm1lZDsgcmV0dXJuaW5nIGZhbHNlIHByZXZlbnRzIHRoZSBkZXRhY2guXG50aGlzLmlzRGV0YWNoQWxsb3dlZD1mdW5jdGlvbihjb25uZWN0aW9uKXt2YXIgcj10cnVlO2lmKHRoaXMuX2pzUGx1bWIuYmVmb3JlRGV0YWNoKXt0cnl7cj10aGlzLl9qc1BsdW1iLmJlZm9yZURldGFjaChjb25uZWN0aW9uKTt9Y2F0Y2goZSl7X2p1LmxvZyhcImpzUGx1bWI6IGJlZm9yZURldGFjaCBjYWxsYmFjayBmYWlsZWRcIixlKTt9fXJldHVybiByO307Ly8gdXNlciBjYW4gc3VwcGx5IGEgYmVmb3JlRHJvcCBjYWxsYmFjaywgd2hpY2ggd2lsbCBiZSBleGVjdXRlZCBiZWZvcmUgYSBkcm9wcGVkXG4vLyBjb25uZWN0aW9uIGlzIGNvbmZpcm1lZC4gdXNlciBjYW4gcmV0dXJuIGZhbHNlIHRvIHJlamVjdCBjb25uZWN0aW9uLlxudGhpcy5pc0Ryb3BBbGxvd2VkPWZ1bmN0aW9uKHNvdXJjZUlkLHRhcmdldElkLHNjb3BlLGNvbm5lY3Rpb24sZHJvcEVuZHBvaW50LHNvdXJjZSx0YXJnZXQpe3ZhciByPXRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuY2hlY2tDb25kaXRpb24oXCJiZWZvcmVEcm9wXCIse3NvdXJjZUlkOnNvdXJjZUlkLHRhcmdldElkOnRhcmdldElkLHNjb3BlOnNjb3BlLGNvbm5lY3Rpb246Y29ubmVjdGlvbixkcm9wRW5kcG9pbnQ6ZHJvcEVuZHBvaW50LHNvdXJjZTpzb3VyY2UsdGFyZ2V0OnRhcmdldH0pO2lmKHRoaXMuX2pzUGx1bWIuYmVmb3JlRHJvcCl7dHJ5e3I9dGhpcy5fanNQbHVtYi5iZWZvcmVEcm9wKHtzb3VyY2VJZDpzb3VyY2VJZCx0YXJnZXRJZDp0YXJnZXRJZCxzY29wZTpzY29wZSxjb25uZWN0aW9uOmNvbm5lY3Rpb24sZHJvcEVuZHBvaW50OmRyb3BFbmRwb2ludCxzb3VyY2U6c291cmNlLHRhcmdldDp0YXJnZXR9KTt9Y2F0Y2goZSl7X2p1LmxvZyhcImpzUGx1bWI6IGJlZm9yZURyb3AgY2FsbGJhY2sgZmFpbGVkXCIsZSk7fX1yZXR1cm4gcjt9O3ZhciBkb21MaXN0ZW5lcnM9W107Ly8gc2V0cyB0aGUgY29tcG9uZW50IGFzc29jaWF0ZWQgd2l0aCBsaXN0ZW5lciBldmVudHMuIGZvciBpbnN0YW5jZSwgYW4gb3ZlcmxheSBkZWxlZ2F0ZXNcbi8vIGl0cyBldmVudHMgYmFjayB0byBhIGNvbm5lY3Rvci4gYnV0IGlmIHRoZSBjb25uZWN0b3IgaXMgc3dhcHBlZCBvbiB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uLFxuLy8gdGhlbiB0aGlzIGNvbXBvbmVudCBtdXN0IGJlIGNoYW5nZWQuIFRoaXMgaXMgY2FsbGVkIGJ5IHNldENvbm5lY3RvciBpbiB0aGUgQ29ubmVjdGlvbiBjbGFzcy5cbnRoaXMuc2V0TGlzdGVuZXJDb21wb25lbnQ9ZnVuY3Rpb24oYyl7Zm9yKHZhciBpPTA7aTxkb21MaXN0ZW5lcnMubGVuZ3RoO2krKyl7ZG9tTGlzdGVuZXJzW2ldWzNdPWM7fX07fTt2YXIgX3JlbW92ZVR5cGVDc3NIZWxwZXI9ZnVuY3Rpb24gX3JlbW92ZVR5cGVDc3NIZWxwZXIoY29tcG9uZW50LHR5cGVJbmRleCl7dmFyIHR5cGVJZD1jb21wb25lbnQuX2pzUGx1bWIudHlwZXNbdHlwZUluZGV4XSx0eXBlPWNvbXBvbmVudC5fanNQbHVtYi5pbnN0YW5jZS5nZXRUeXBlKHR5cGVJZCxjb21wb25lbnQuZ2V0VHlwZURlc2NyaXB0b3IoKSk7aWYodHlwZSE9bnVsbCYmdHlwZS5jc3NDbGFzcyYmY29tcG9uZW50LmNhbnZhcyl7Y29tcG9uZW50Ll9qc1BsdW1iLmluc3RhbmNlLnJlbW92ZUNsYXNzKGNvbXBvbmVudC5jYW52YXMsdHlwZS5jc3NDbGFzcyk7fX07X2p1LmV4dGVuZChyb290LmpzUGx1bWJVSUNvbXBvbmVudCxfanUuRXZlbnRHZW5lcmF0b3Ise2dldFBhcmFtZXRlcjpmdW5jdGlvbiBnZXRQYXJhbWV0ZXIobmFtZSl7cmV0dXJuIHRoaXMuX2pzUGx1bWIucGFyYW1ldGVyc1tuYW1lXTt9LHNldFBhcmFtZXRlcjpmdW5jdGlvbiBzZXRQYXJhbWV0ZXIobmFtZSx2YWx1ZSl7dGhpcy5fanNQbHVtYi5wYXJhbWV0ZXJzW25hbWVdPXZhbHVlO30sZ2V0UGFyYW1ldGVyczpmdW5jdGlvbiBnZXRQYXJhbWV0ZXJzKCl7cmV0dXJuIHRoaXMuX2pzUGx1bWIucGFyYW1ldGVyczt9LHNldFBhcmFtZXRlcnM6ZnVuY3Rpb24gc2V0UGFyYW1ldGVycyhwKXt0aGlzLl9qc1BsdW1iLnBhcmFtZXRlcnM9cDt9LGdldENsYXNzOmZ1bmN0aW9uIGdldENsYXNzKCl7cmV0dXJuIGpzUGx1bWIuZ2V0Q2xhc3ModGhpcy5jYW52YXMpO30saGFzQ2xhc3M6ZnVuY3Rpb24gaGFzQ2xhc3MoY2xhenope3JldHVybiBqc1BsdW1iLmhhc0NsYXNzKHRoaXMuY2FudmFzLGNsYXp6KTt9LGFkZENsYXNzOmZ1bmN0aW9uIGFkZENsYXNzKGNsYXp6KXtqc1BsdW1iLmFkZENsYXNzKHRoaXMuY2FudmFzLGNsYXp6KTt9LHJlbW92ZUNsYXNzOmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGNsYXp6KXtqc1BsdW1iLnJlbW92ZUNsYXNzKHRoaXMuY2FudmFzLGNsYXp6KTt9LHVwZGF0ZUNsYXNzZXM6ZnVuY3Rpb24gdXBkYXRlQ2xhc3NlcyhjbGFzc2VzVG9BZGQsY2xhc3Nlc1RvUmVtb3ZlKXtqc1BsdW1iLnVwZGF0ZUNsYXNzZXModGhpcy5jYW52YXMsY2xhc3Nlc1RvQWRkLGNsYXNzZXNUb1JlbW92ZSk7fSxzZXRUeXBlOmZ1bmN0aW9uIHNldFR5cGUodHlwZUlkLHBhcmFtcyxkb05vdFJlcGFpbnQpe3RoaXMuY2xlYXJUeXBlcygpO3RoaXMuX2pzUGx1bWIudHlwZXM9X3NwbGl0VHlwZSh0eXBlSWQpfHxbXTtfYXBwbHlUeXBlcyh0aGlzLHBhcmFtcyxkb05vdFJlcGFpbnQpO30sZ2V0VHlwZTpmdW5jdGlvbiBnZXRUeXBlKCl7cmV0dXJuIHRoaXMuX2pzUGx1bWIudHlwZXM7fSxyZWFwcGx5VHlwZXM6ZnVuY3Rpb24gcmVhcHBseVR5cGVzKHBhcmFtcyxkb05vdFJlcGFpbnQpe19hcHBseVR5cGVzKHRoaXMscGFyYW1zLGRvTm90UmVwYWludCk7fSxoYXNUeXBlOmZ1bmN0aW9uIGhhc1R5cGUodHlwZUlkKXtyZXR1cm4gdGhpcy5fanNQbHVtYi50eXBlcy5pbmRleE9mKHR5cGVJZCkhPT0tMTt9LGFkZFR5cGU6ZnVuY3Rpb24gYWRkVHlwZSh0eXBlSWQscGFyYW1zLGRvTm90UmVwYWludCl7dmFyIHQ9X3NwbGl0VHlwZSh0eXBlSWQpLF9jb250PWZhbHNlO2lmKHQhPW51bGwpe2Zvcih2YXIgaT0wLGo9dC5sZW5ndGg7aTxqO2krKyl7aWYoIXRoaXMuaGFzVHlwZSh0W2ldKSl7dGhpcy5fanNQbHVtYi50eXBlcy5wdXNoKHRbaV0pO19jb250PXRydWU7fX1pZihfY29udCl7X2FwcGx5VHlwZXModGhpcyxwYXJhbXMsZG9Ob3RSZXBhaW50KTt9fX0scmVtb3ZlVHlwZTpmdW5jdGlvbiByZW1vdmVUeXBlKHR5cGVJZCxwYXJhbXMsZG9Ob3RSZXBhaW50KXt2YXIgdD1fc3BsaXRUeXBlKHR5cGVJZCksX2NvbnQ9ZmFsc2UsX29uZT1mdW5jdGlvbih0dCl7dmFyIGlkeD10aGlzLl9qc1BsdW1iLnR5cGVzLmluZGV4T2YodHQpO2lmKGlkeCE9PS0xKXsvLyByZW1vdmUgY3NzIGNsYXNzIGlmIG5lY2Vzc2FyeVxuX3JlbW92ZVR5cGVDc3NIZWxwZXIodGhpcyxpZHgpO3RoaXMuX2pzUGx1bWIudHlwZXMuc3BsaWNlKGlkeCwxKTtyZXR1cm4gdHJ1ZTt9cmV0dXJuIGZhbHNlO30uYmluZCh0aGlzKTtpZih0IT1udWxsKXtmb3IodmFyIGk9MCxqPXQubGVuZ3RoO2k8ajtpKyspe19jb250PV9vbmUodFtpXSl8fF9jb250O31pZihfY29udCl7X2FwcGx5VHlwZXModGhpcyxwYXJhbXMsZG9Ob3RSZXBhaW50KTt9fX0sY2xlYXJUeXBlczpmdW5jdGlvbiBjbGVhclR5cGVzKHBhcmFtcyxkb05vdFJlcGFpbnQpe3ZhciBpPXRoaXMuX2pzUGx1bWIudHlwZXMubGVuZ3RoO2Zvcih2YXIgaj0wO2o8aTtqKyspe19yZW1vdmVUeXBlQ3NzSGVscGVyKHRoaXMsMCk7dGhpcy5fanNQbHVtYi50eXBlcy5zcGxpY2UoMCwxKTt9X2FwcGx5VHlwZXModGhpcyxwYXJhbXMsZG9Ob3RSZXBhaW50KTt9LHRvZ2dsZVR5cGU6ZnVuY3Rpb24gdG9nZ2xlVHlwZSh0eXBlSWQscGFyYW1zLGRvTm90UmVwYWludCl7dmFyIHQ9X3NwbGl0VHlwZSh0eXBlSWQpO2lmKHQhPW51bGwpe2Zvcih2YXIgaT0wLGo9dC5sZW5ndGg7aTxqO2krKyl7dmFyIGlkeD10aGlzLl9qc1BsdW1iLnR5cGVzLmluZGV4T2YodFtpXSk7aWYoaWR4IT09LTEpe19yZW1vdmVUeXBlQ3NzSGVscGVyKHRoaXMsaWR4KTt0aGlzLl9qc1BsdW1iLnR5cGVzLnNwbGljZShpZHgsMSk7fWVsc2V7dGhpcy5fanNQbHVtYi50eXBlcy5wdXNoKHRbaV0pO319X2FwcGx5VHlwZXModGhpcyxwYXJhbXMsZG9Ob3RSZXBhaW50KTt9fSxhcHBseVR5cGU6ZnVuY3Rpb24gYXBwbHlUeXBlKHQsZG9Ob3RSZXBhaW50KXt0aGlzLnNldFBhaW50U3R5bGUodC5wYWludFN0eWxlLGRvTm90UmVwYWludCk7dGhpcy5zZXRIb3ZlclBhaW50U3R5bGUodC5ob3ZlclBhaW50U3R5bGUsZG9Ob3RSZXBhaW50KTtpZih0LnBhcmFtZXRlcnMpe2Zvcih2YXIgaSBpbiB0LnBhcmFtZXRlcnMpe3RoaXMuc2V0UGFyYW1ldGVyKGksdC5wYXJhbWV0ZXJzW2ldKTt9fXRoaXMuX2pzUGx1bWIucGFpbnRTdHlsZUluVXNlPXRoaXMuZ2V0UGFpbnRTdHlsZSgpO30sc2V0UGFpbnRTdHlsZTpmdW5jdGlvbiBzZXRQYWludFN0eWxlKHN0eWxlLGRvTm90UmVwYWludCl7Ly8gdGhpcy5fanNQbHVtYi5wYWludFN0eWxlID0ganNQbHVtYi5leHRlbmQoe30sIHN0eWxlKTtcbi8vIFRPRE8gZmlndXJlIG91dCBpZiB3ZSB3YW50IGNvbXBvbmVudHMgdG8gY2xvbmUgcGFpbnRTdHlsZSBzbyBhcyBub3QgdG8gc2hhcmUgaXQuXG50aGlzLl9qc1BsdW1iLnBhaW50U3R5bGU9c3R5bGU7dGhpcy5fanNQbHVtYi5wYWludFN0eWxlSW5Vc2U9dGhpcy5fanNQbHVtYi5wYWludFN0eWxlO191cGRhdGVIb3ZlclN0eWxlKHRoaXMpO2lmKCFkb05vdFJlcGFpbnQpe3RoaXMucmVwYWludCgpO319LGdldFBhaW50U3R5bGU6ZnVuY3Rpb24gZ2V0UGFpbnRTdHlsZSgpe3JldHVybiB0aGlzLl9qc1BsdW1iLnBhaW50U3R5bGU7fSxzZXRIb3ZlclBhaW50U3R5bGU6ZnVuY3Rpb24gc2V0SG92ZXJQYWludFN0eWxlKHN0eWxlLGRvTm90UmVwYWludCl7Ly90aGlzLl9qc1BsdW1iLmhvdmVyUGFpbnRTdHlsZSA9IGpzUGx1bWIuZXh0ZW5kKHt9LCBzdHlsZSk7XG4vLyBUT0RPIGZpZ3VyZSBvdXQgaWYgd2Ugd2FudCBjb21wb25lbnRzIHRvIGNsb25lIHBhaW50U3R5bGUgc28gYXMgbm90IHRvIHNoYXJlIGl0LlxudGhpcy5fanNQbHVtYi5ob3ZlclBhaW50U3R5bGU9c3R5bGU7X3VwZGF0ZUhvdmVyU3R5bGUodGhpcyk7aWYoIWRvTm90UmVwYWludCl7dGhpcy5yZXBhaW50KCk7fX0sZ2V0SG92ZXJQYWludFN0eWxlOmZ1bmN0aW9uIGdldEhvdmVyUGFpbnRTdHlsZSgpe3JldHVybiB0aGlzLl9qc1BsdW1iLmhvdmVyUGFpbnRTdHlsZTt9LGRlc3Ryb3k6ZnVuY3Rpb24gZGVzdHJveShmb3JjZSl7aWYoZm9yY2V8fHRoaXMudHlwZUlkPT1udWxsKXt0aGlzLmNsZWFudXBMaXN0ZW5lcnMoKTsvLyB0aGlzIGlzIG9uIEV2ZW50R2VuZXJhdG9yXG50aGlzLmNsb25lPW51bGw7dGhpcy5fanNQbHVtYj1udWxsO319LGlzSG92ZXI6ZnVuY3Rpb24gaXNIb3Zlcigpe3JldHVybiB0aGlzLl9qc1BsdW1iLmhvdmVyO30sc2V0SG92ZXI6ZnVuY3Rpb24gc2V0SG92ZXIoaG92ZXIsaWdub3JlQXR0YWNoZWRFbGVtZW50cyx0aW1lc3RhbXApey8vIHdoaWxlIGRyYWdnaW5nLCB3ZSBpZ25vcmUgdGhlc2UgZXZlbnRzLiAgdGhpcyBrZWVwcyB0aGUgVUkgZnJvbSBmbGFzaGluZyBhbmRcbi8vIHN3aXNoaW5nIGFuZCB3aGF0ZXZlcmluZy5cbmlmKHRoaXMuX2pzUGx1bWImJiF0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmN1cnJlbnRseURyYWdnaW5nJiYhdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5pc0hvdmVyU3VzcGVuZGVkKCkpe3RoaXMuX2pzUGx1bWIuaG92ZXI9aG92ZXI7dmFyIG1ldGhvZD1ob3Zlcj9cImFkZENsYXNzXCI6XCJyZW1vdmVDbGFzc1wiO2lmKHRoaXMuY2FudmFzIT1udWxsKXtpZih0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmhvdmVyQ2xhc3MhPW51bGwpe3RoaXMuX2pzUGx1bWIuaW5zdGFuY2VbbWV0aG9kXSh0aGlzLmNhbnZhcyx0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmhvdmVyQ2xhc3MpO31pZih0aGlzLl9qc1BsdW1iLmhvdmVyQ2xhc3MhPW51bGwpe3RoaXMuX2pzUGx1bWIuaW5zdGFuY2VbbWV0aG9kXSh0aGlzLmNhbnZhcyx0aGlzLl9qc1BsdW1iLmhvdmVyQ2xhc3MpO319aWYodGhpcy5fanNQbHVtYi5ob3ZlclBhaW50U3R5bGUhPW51bGwpe3RoaXMuX2pzUGx1bWIucGFpbnRTdHlsZUluVXNlPWhvdmVyP3RoaXMuX2pzUGx1bWIuaG92ZXJQYWludFN0eWxlOnRoaXMuX2pzUGx1bWIucGFpbnRTdHlsZTtpZighdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5pc1N1c3BlbmREcmF3aW5nKCkpe3RpbWVzdGFtcD10aW1lc3RhbXB8fF90aW1lc3RhbXAoKTt0aGlzLnJlcGFpbnQoe3RpbWVzdGFtcDp0aW1lc3RhbXAscmVjYWxjOmZhbHNlfSk7fX0vLyBnZXQgdGhlIGxpc3Qgb2Ygb3RoZXIgYWZmZWN0ZWQgZWxlbWVudHMsIGlmIHN1cHBvcnRlZCBieSB0aGlzIGNvbXBvbmVudC5cbi8vIGZvciBhIGNvbm5lY3Rpb24sIGl0cyB0aGUgZW5kcG9pbnRzLiAgZm9yIGFuIGVuZHBvaW50LCBpdHMgdGhlIGNvbm5lY3Rpb25zISBzdXJwcmlzZS5cbmlmKHRoaXMuZ2V0QXR0YWNoZWRFbGVtZW50cyYmIWlnbm9yZUF0dGFjaGVkRWxlbWVudHMpe191cGRhdGVBdHRhY2hlZEVsZW1lbnRzKHRoaXMsaG92ZXIsX3RpbWVzdGFtcCgpLHRoaXMpO319fX0pOy8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFTkQganNQbHVtYlVJQ29tcG9uZW50IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgX2pzUGx1bWJJbnN0YW5jZUluZGV4PTAsZ2V0SW5zdGFuY2VJbmRleD1mdW5jdGlvbiBnZXRJbnN0YW5jZUluZGV4KCl7dmFyIGk9X2pzUGx1bWJJbnN0YW5jZUluZGV4KzE7X2pzUGx1bWJJbnN0YW5jZUluZGV4Kys7cmV0dXJuIGk7fTt2YXIganNQbHVtYkluc3RhbmNlPXJvb3QuanNQbHVtYkluc3RhbmNlPWZ1bmN0aW9uKF9kZWZhdWx0cyl7dGhpcy52ZXJzaW9uPVwiMi42LjlcIjtpZihfZGVmYXVsdHMpe2pzUGx1bWIuZXh0ZW5kKHRoaXMuRGVmYXVsdHMsX2RlZmF1bHRzKTt9dGhpcy5sb2dFbmFibGVkPXRoaXMuRGVmYXVsdHMuTG9nRW5hYmxlZDt0aGlzLl9jb25uZWN0aW9uVHlwZXM9e307dGhpcy5fZW5kcG9pbnRUeXBlcz17fTtfanUuRXZlbnRHZW5lcmF0b3IuYXBwbHkodGhpcyk7dmFyIF9jdXJyZW50SW5zdGFuY2U9dGhpcyxfaW5zdGFuY2VJbmRleD1nZXRJbnN0YW5jZUluZGV4KCksX2JiPV9jdXJyZW50SW5zdGFuY2UuYmluZCxfaW5pdGlhbERlZmF1bHRzPXt9LF96b29tPTEsX2luZm89ZnVuY3Rpb24gX2luZm8oZWwpe2lmKGVsPT1udWxsKXtyZXR1cm4gbnVsbDt9ZWxzZSBpZihlbC5ub2RlVHlwZT09PTN8fGVsLm5vZGVUeXBlPT09OCl7cmV0dXJue2VsOmVsLHRleHQ6dHJ1ZX07fWVsc2V7dmFyIF9lbD1fY3VycmVudEluc3RhbmNlLmdldEVsZW1lbnQoZWwpO3JldHVybntlbDpfZWwsaWQ6X2p1LmlzU3RyaW5nKGVsKSYmX2VsPT1udWxsP2VsOl9nZXRJZChfZWwpfTt9fTt0aGlzLmdldEluc3RhbmNlSW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4gX2luc3RhbmNlSW5kZXg7fTsvLyBDT05WRVJURURcbnRoaXMuc2V0Wm9vbT1mdW5jdGlvbih6LHJlcGFpbnRFdmVyeXRoaW5nKXtfem9vbT16O19jdXJyZW50SW5zdGFuY2UuZmlyZShcInpvb21cIixfem9vbSk7aWYocmVwYWludEV2ZXJ5dGhpbmcpe19jdXJyZW50SW5zdGFuY2UucmVwYWludEV2ZXJ5dGhpbmcoKTt9cmV0dXJuIHRydWU7fTsvLyBDT05WRVJURURcbnRoaXMuZ2V0Wm9vbT1mdW5jdGlvbigpe3JldHVybiBfem9vbTt9O2Zvcih2YXIgaSBpbiB0aGlzLkRlZmF1bHRzKXtfaW5pdGlhbERlZmF1bHRzW2ldPXRoaXMuRGVmYXVsdHNbaV07fXZhciBfY29udGFpbmVyLF9jb250YWluZXJEZWxlZ2F0aW9ucz1bXTt0aGlzLnVuYmluZENvbnRhaW5lcj1mdW5jdGlvbigpe2lmKF9jb250YWluZXIhPW51bGwmJl9jb250YWluZXJEZWxlZ2F0aW9ucy5sZW5ndGg+MCl7Zm9yKHZhciBpPTA7aTxfY29udGFpbmVyRGVsZWdhdGlvbnMubGVuZ3RoO2krKyl7X2N1cnJlbnRJbnN0YW5jZS5vZmYoX2NvbnRhaW5lcixfY29udGFpbmVyRGVsZWdhdGlvbnNbaV1bMF0sX2NvbnRhaW5lckRlbGVnYXRpb25zW2ldWzFdKTt9fX07dGhpcy5zZXRDb250YWluZXI9ZnVuY3Rpb24oYyl7dGhpcy51bmJpbmRDb250YWluZXIoKTsvLyBnZXQgY29udGFpbmVyIGFzIGRvbSBlbGVtZW50LlxuYz10aGlzLmdldEVsZW1lbnQoYyk7Ly8gbW92ZSBleGlzdGluZyBjb25uZWN0aW9ucyBhbmQgZW5kcG9pbnRzLCBpZiBhbnkuXG50aGlzLnNlbGVjdCgpLmVhY2goZnVuY3Rpb24oY29ubil7Y29ubi5tb3ZlUGFyZW50KGMpO30pO3RoaXMuc2VsZWN0RW5kcG9pbnRzKCkuZWFjaChmdW5jdGlvbihlcCl7ZXAubW92ZVBhcmVudChjKTt9KTsvLyBzZXQgY29udGFpbmVyLlxudmFyIHByZXZpb3VzQ29udGFpbmVyPV9jb250YWluZXI7X2NvbnRhaW5lcj1jO19jb250YWluZXJEZWxlZ2F0aW9ucy5sZW5ndGg9MDt2YXIgZXZlbnRBbGlhc2VzPXtcImVuZHBvaW50Y2xpY2tcIjpcImVuZHBvaW50Q2xpY2tcIixcImVuZHBvaW50ZGJsY2xpY2tcIjpcImVuZHBvaW50RGJsQ2xpY2tcIn07dmFyIF9vbmVEZWxlZ2F0ZUhhbmRsZXI9ZnVuY3Rpb24gX29uZURlbGVnYXRlSGFuZGxlcihpZCxlLGNvbXBvbmVudFR5cGUpe3ZhciB0PWUuc3JjRWxlbWVudHx8ZS50YXJnZXQsanA9KHQmJnQucGFyZW50Tm9kZT90LnBhcmVudE5vZGUuX2pzUGx1bWI6bnVsbCl8fCh0P3QuX2pzUGx1bWI6bnVsbCl8fCh0JiZ0LnBhcmVudE5vZGUmJnQucGFyZW50Tm9kZS5wYXJlbnROb2RlP3QucGFyZW50Tm9kZS5wYXJlbnROb2RlLl9qc1BsdW1iOm51bGwpO2lmKGpwKXtqcC5maXJlKGlkLGpwLGUpO3ZhciBhbGlhcz1jb21wb25lbnRUeXBlP2V2ZW50QWxpYXNlc1tjb21wb25lbnRUeXBlK2lkXXx8aWQ6aWQ7Ly8ganNwbHVtYiBhbHNvIGZpcmVzIGV2ZXJ5IGV2ZW50IGNvbWluZyBmcm9tIGNvbXBvbmVudHMvb3ZlcmxheXMuIFRoYXQncyB3aGF0IHRoZSB0ZXN0IGZvciBganAuY29tcG9uZW50YCBpcyBmb3IuXG5fY3VycmVudEluc3RhbmNlLmZpcmUoYWxpYXMsanAuY29tcG9uZW50fHxqcCxlKTt9fTt2YXIgX2FkZE9uZURlbGVnYXRlPWZ1bmN0aW9uIF9hZGRPbmVEZWxlZ2F0ZShldmVudElkLHNlbGVjdG9yLGZuKXtfY29udGFpbmVyRGVsZWdhdGlvbnMucHVzaChbZXZlbnRJZCxmbl0pO19jdXJyZW50SW5zdGFuY2Uub24oX2NvbnRhaW5lcixldmVudElkLHNlbGVjdG9yLGZuKTt9Oy8vIGRlbGVnYXRlIG9uZSBldmVudCBvbiB0aGUgY29udGFpbmVyIHRvIGpzcGx1bWIgZWxlbWVudHMuIGl0IG1pZ2h0IGJlIHBvc3NpYmxlIHRvXG4vLyBhYnN0cmFjdCB0aGlzIG91dDogZWFjaCBvZiBlbmRwb2ludCwgY29ubmVjdGlvbiBhbmQgb3ZlcmxheSBjb3VsZCByZWdpc3RlciB0aGVtc2VsdmVzIHdpdGhcbi8vIGpzcGx1bWIgYXMgXCJjb21wb25lbnQgdHlwZXNcIiBvciB3aGF0ZXZlciwgYW5kIHByb3ZpZGUgYSBzdWl0YWJsZSBzZWxlY3Rvci4gdGhpcyB3b3VsZCBiZVxuLy8gZG9uZSBieSB0aGUgcmVuZGVyZXIgKGFsdGhvdWdoIGFkbWl0dGVkbHkgZnJvbSAyLjAgb253YXJkcyB3ZSdyZSBub3Qgc3VwcG9ydGluZyB2bWwgYW55bW9yZSlcbnZhciBfb25lRGVsZWdhdGU9ZnVuY3Rpb24gX29uZURlbGVnYXRlKGlkKXsvLyBjb25uZWN0aW9ucy5cbl9hZGRPbmVEZWxlZ2F0ZShpZCxcIi5qdGstY29ubmVjdG9yXCIsZnVuY3Rpb24oZSl7X29uZURlbGVnYXRlSGFuZGxlcihpZCxlKTt9KTsvLyBlbmRwb2ludHMuIG5vdGUgdGhleSBjYW4gaGF2ZSBhbiBlbmNsb3NpbmcgZGl2LCBvciBub3QuXG5fYWRkT25lRGVsZWdhdGUoaWQsXCIuanRrLWVuZHBvaW50XCIsZnVuY3Rpb24oZSl7X29uZURlbGVnYXRlSGFuZGxlcihpZCxlLFwiZW5kcG9pbnRcIik7fSk7Ly8gb3ZlcmxheXNcbl9hZGRPbmVEZWxlZ2F0ZShpZCxcIi5qdGstb3ZlcmxheVwiLGZ1bmN0aW9uKGUpe19vbmVEZWxlZ2F0ZUhhbmRsZXIoaWQsZSk7fSk7fTtmb3IodmFyIGk9MDtpPGV2ZW50cy5sZW5ndGg7aSsrKXtfb25lRGVsZWdhdGUoZXZlbnRzW2ldKTt9Ly8gbWFuYWdlZCBlbGVtZW50c1xuZm9yKHZhciBlbElkIGluIG1hbmFnZWRFbGVtZW50cyl7dmFyIGVsPW1hbmFnZWRFbGVtZW50c1tlbElkXS5lbDtpZihlbC5wYXJlbnROb2RlPT09cHJldmlvdXNDb250YWluZXIpe3ByZXZpb3VzQ29udGFpbmVyLnJlbW92ZUNoaWxkKGVsKTtfY29udGFpbmVyLmFwcGVuZENoaWxkKGVsKTt9fX07dGhpcy5nZXRDb250YWluZXI9ZnVuY3Rpb24oKXtyZXR1cm4gX2NvbnRhaW5lcjt9O3RoaXMuYmluZD1mdW5jdGlvbihldmVudCxmbil7aWYoXCJyZWFkeVwiPT09ZXZlbnQmJmluaXRpYWxpemVkKXtmbigpO31lbHNle19iYi5hcHBseShfY3VycmVudEluc3RhbmNlLFtldmVudCxmbl0pO319O19jdXJyZW50SW5zdGFuY2UuaW1wb3J0RGVmYXVsdHM9ZnVuY3Rpb24oZCl7Zm9yKHZhciBpIGluIGQpe19jdXJyZW50SW5zdGFuY2UuRGVmYXVsdHNbaV09ZFtpXTt9aWYoZC5Db250YWluZXIpe19jdXJyZW50SW5zdGFuY2Uuc2V0Q29udGFpbmVyKGQuQ29udGFpbmVyKTt9cmV0dXJuIF9jdXJyZW50SW5zdGFuY2U7fTtfY3VycmVudEluc3RhbmNlLnJlc3RvcmVEZWZhdWx0cz1mdW5jdGlvbigpe19jdXJyZW50SW5zdGFuY2UuRGVmYXVsdHM9anNQbHVtYi5leHRlbmQoe30sX2luaXRpYWxEZWZhdWx0cyk7cmV0dXJuIF9jdXJyZW50SW5zdGFuY2U7fTt2YXIgbG9nPW51bGwsaW5pdGlhbGl6ZWQ9ZmFsc2UsLy8gVE9ETyByZW1vdmUgZnJvbSB3aW5kb3cgc2NvcGVcbmNvbm5lY3Rpb25zPVtdLC8vIG1hcCBvZiBlbGVtZW50IGlkIC0+IGVuZHBvaW50IGxpc3RzLiBhbiBlbGVtZW50IGNhbiBoYXZlIGFuIGFyYml0cmFyeVxuLy8gbnVtYmVyIG9mIGVuZHBvaW50cyBvbiBpdCwgYW5kIG5vdCBhbGwgb2YgdGhlbSBoYXZlIHRvIGJlIGNvbm5lY3RlZFxuLy8gdG8gYW55dGhpbmcuXG5lbmRwb2ludHNCeUVsZW1lbnQ9e30sZW5kcG9pbnRzQnlVVUlEPXt9LG1hbmFnZWRFbGVtZW50cz17fSxvZmZzZXRzPXt9LG9mZnNldFRpbWVzdGFtcHM9e30sZHJhZ2dhYmxlU3RhdGVzPXt9LGNvbm5lY3Rpb25CZWluZ0RyYWdnZWQ9ZmFsc2Usc2l6ZXM9W10sX3N1c3BlbmREcmF3aW5nPWZhbHNlLF9zdXNwZW5kZWRBdD1udWxsLERFRkFVTFRfU0NPUEU9dGhpcy5EZWZhdWx0cy5TY29wZSxfY3VySWRTdGFtcD0xLF9pZHN0YW1wPWZ1bmN0aW9uIF9pZHN0YW1wKCl7cmV0dXJuXCJcIitfY3VySWRTdGFtcCsrO30sLy9cbi8vIGFwcGVuZHMgYW4gZWxlbWVudCB0byBzb21lIG90aGVyIGVsZW1lbnQsIHdoaWNoIGlzIGNhbGN1bGF0ZWQgYXMgZm9sbG93czpcbi8vXG4vLyAxLiBpZiBDb250YWluZXIgZXhpc3RzLCB1c2UgdGhhdCBlbGVtZW50LlxuLy8gMi4gaWYgdGhlICdwYXJlbnQnIHBhcmFtZXRlciBleGlzdHMsIHVzZSB0aGF0LlxuLy8gMy4gb3RoZXJ3aXNlIGp1c3QgdXNlIHRoZSByb290IGVsZW1lbnQuXG4vL1xuLy9cbl9hcHBlbmRFbGVtZW50PWZ1bmN0aW9uKGVsLHBhcmVudCl7aWYoX2NvbnRhaW5lcil7X2NvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7fWVsc2UgaWYoIXBhcmVudCl7dGhpcy5hcHBlbmRUb1Jvb3QoZWwpO31lbHNle3RoaXMuZ2V0RWxlbWVudChwYXJlbnQpLmFwcGVuZENoaWxkKGVsKTt9fS5iaW5kKHRoaXMpLC8vXG4vLyBEcmF3cyBhbiBlbmRwb2ludCBhbmQgaXRzIGNvbm5lY3Rpb25zLiB0aGlzIGlzIHRoZSBtYWluIGVudHJ5IHBvaW50IGludG8gZHJhd2luZyBjb25uZWN0aW9ucyBhcyB3ZWxsXG4vLyBhcyBlbmRwb2ludHMsIHNpbmNlIGpzUGx1bWIgaXMgZW5kcG9pbnQtY2VudHJpYyB1bmRlciB0aGUgaG9vZC5cbi8vXG4vLyBAcGFyYW0gZWxlbWVudCBlbGVtZW50IHRvIGRyYXcgKG9mIHR5cGUgbGlicmFyeSBzcGVjaWZpYyBlbGVtZW50IG9iamVjdClcbi8vIEBwYXJhbSB1aSBVSSBvYmplY3QgZnJvbSBjdXJyZW50IGxpYnJhcnkncyBldmVudCBzeXN0ZW0uIG9wdGlvbmFsLlxuLy8gQHBhcmFtIHRpbWVzdGFtcCB0aW1lc3RhbXAgZm9yIHRoaXMgcGFpbnQgY3ljbGUuIHVzZWQgdG8gc3BlZWQgdGhpbmdzIHVwIGEgbGl0dGxlIGJ5IGN1dHRpbmcgZG93biB0aGUgYW1vdW50IG9mIG9mZnNldCBjYWxjdWxhdGlvbnMgd2UgZG8uXG4vLyBAcGFyYW0gY2xlYXJFZGl0cyBkZWZhdWx0cyB0byBmYWxzZTsgaW5kaWNhdGVzIHRoYXQgbW91c2UgZWRpdHMgZm9yIGNvbm5lY3RvcnMgc2hvdWxkIGJlIGNsZWFyZWRcbi8vL1xuX2RyYXc9ZnVuY3Rpb24gX2RyYXcoZWxlbWVudCx1aSx0aW1lc3RhbXAsY2xlYXJFZGl0cyl7aWYoIV9zdXNwZW5kRHJhd2luZyl7dmFyIGlkPV9nZXRJZChlbGVtZW50KSxyZXBhaW50RWxzLGRtPV9jdXJyZW50SW5zdGFuY2UuZ2V0RHJhZ01hbmFnZXIoKTtpZihkbSl7cmVwYWludEVscz1kbS5nZXRFbGVtZW50c0ZvckRyYWdnYWJsZShpZCk7fWlmKHRpbWVzdGFtcD09bnVsbCl7dGltZXN0YW1wPV90aW1lc3RhbXAoKTt9Ly8gdXBkYXRlIHRoZSBvZmZzZXQgb2YgZXZlcnl0aGluZyBfYmVmb3JlXyB3ZSB0cnkgdG8gZHJhdyBhbnl0aGluZy5cbnZhciBvPV91cGRhdGVPZmZzZXQoe2VsSWQ6aWQsb2Zmc2V0OnVpLHJlY2FsYzpmYWxzZSx0aW1lc3RhbXA6dGltZXN0YW1wfSk7aWYocmVwYWludEVscyYmbyYmby5vKXtmb3IodmFyIGkgaW4gcmVwYWludEVscyl7X3VwZGF0ZU9mZnNldCh7ZWxJZDpyZXBhaW50RWxzW2ldLmlkLG9mZnNldDp7bGVmdDpvLm8ubGVmdCtyZXBhaW50RWxzW2ldLm9mZnNldC5sZWZ0LHRvcDpvLm8udG9wK3JlcGFpbnRFbHNbaV0ub2Zmc2V0LnRvcH0scmVjYWxjOmZhbHNlLHRpbWVzdGFtcDp0aW1lc3RhbXB9KTt9fV9jdXJyZW50SW5zdGFuY2UuYW5jaG9yTWFuYWdlci5yZWRyYXcoaWQsdWksdGltZXN0YW1wLG51bGwsY2xlYXJFZGl0cyk7aWYocmVwYWludEVscyl7Zm9yKHZhciBqIGluIHJlcGFpbnRFbHMpe19jdXJyZW50SW5zdGFuY2UuYW5jaG9yTWFuYWdlci5yZWRyYXcocmVwYWludEVsc1tqXS5pZCx1aSx0aW1lc3RhbXAscmVwYWludEVsc1tqXS5vZmZzZXQsY2xlYXJFZGl0cyx0cnVlKTt9fX19LC8vXG4vLyBnZXRzIGFuIEVuZHBvaW50IGJ5IHV1aWQuXG4vL1xuX2dldEVuZHBvaW50PWZ1bmN0aW9uIF9nZXRFbmRwb2ludCh1dWlkKXtyZXR1cm4gZW5kcG9pbnRzQnlVVUlEW3V1aWRdO30sLyoqXHJcbiAgICAgICAgICAgICAqIGluaXRzIGEgZHJhZ2dhYmxlIGlmIGl0J3Mgbm90IGFscmVhZHkgaW5pdGlhbGlzZWQuXHJcbiAgICAgICAgICAgICAqIFRPRE86IHNvbWVob3cgYWJzdHJhY3QgdGhpcyB0byB0aGUgYWRhcHRlciwgYmVjYXVzZSB0aGUgY29uY2VwdCBvZiBcImRyYWdnYWJsZVwiIGhhcyBub1xyXG4gICAgICAgICAgICAgKiBwbGFjZSBvbiB0aGUgc2VydmVyLlxyXG4gICAgICAgICAgICAgKi9faW5pdERyYWdnYWJsZUlmTmVjZXNzYXJ5PWZ1bmN0aW9uIF9pbml0RHJhZ2dhYmxlSWZOZWNlc3NhcnkoZWxlbWVudCxpc0RyYWdnYWJsZSxkcmFnT3B0aW9ucyxpZCxmaXJlRXZlbnQpey8vIG1vdmUgdG8gRHJhZ01hbmFnZXI/XG5pZighanNQbHVtYi5oZWFkbGVzcyl7dmFyIF9kcmFnZ2FibGU9aXNEcmFnZ2FibGU9PW51bGw/ZmFsc2U6aXNEcmFnZ2FibGU7aWYoX2RyYWdnYWJsZSl7aWYoanNQbHVtYi5pc0RyYWdTdXBwb3J0ZWQoZWxlbWVudCxfY3VycmVudEluc3RhbmNlKSl7dmFyIG9wdGlvbnM9ZHJhZ09wdGlvbnN8fF9jdXJyZW50SW5zdGFuY2UuRGVmYXVsdHMuRHJhZ09wdGlvbnM7b3B0aW9ucz1qc1BsdW1iLmV4dGVuZCh7fSxvcHRpb25zKTsvLyBtYWtlIGEgY29weS5cbmlmKCFqc1BsdW1iLmlzQWxyZWFkeURyYWdnYWJsZShlbGVtZW50LF9jdXJyZW50SW5zdGFuY2UpKXt2YXIgZHJhZ0V2ZW50PWpzUGx1bWIuZHJhZ0V2ZW50cy5kcmFnLHN0b3BFdmVudD1qc1BsdW1iLmRyYWdFdmVudHMuc3RvcCxzdGFydEV2ZW50PWpzUGx1bWIuZHJhZ0V2ZW50cy5zdGFydCxfc3RhcnRlZD1mYWxzZTtfbWFuYWdlKGlkLGVsZW1lbnQpO29wdGlvbnNbc3RhcnRFdmVudF09X2p1LndyYXAob3B0aW9uc1tzdGFydEV2ZW50XSxmdW5jdGlvbigpe19jdXJyZW50SW5zdGFuY2Uuc2V0SG92ZXJTdXNwZW5kZWQodHJ1ZSk7X2N1cnJlbnRJbnN0YW5jZS5zZWxlY3Qoe3NvdXJjZTplbGVtZW50fSkuYWRkQ2xhc3MoX2N1cnJlbnRJbnN0YW5jZS5lbGVtZW50RHJhZ2dpbmdDbGFzcytcIiBcIitfY3VycmVudEluc3RhbmNlLnNvdXJjZUVsZW1lbnREcmFnZ2luZ0NsYXNzLHRydWUpO19jdXJyZW50SW5zdGFuY2Uuc2VsZWN0KHt0YXJnZXQ6ZWxlbWVudH0pLmFkZENsYXNzKF9jdXJyZW50SW5zdGFuY2UuZWxlbWVudERyYWdnaW5nQ2xhc3MrXCIgXCIrX2N1cnJlbnRJbnN0YW5jZS50YXJnZXRFbGVtZW50RHJhZ2dpbmdDbGFzcyx0cnVlKTtfY3VycmVudEluc3RhbmNlLnNldENvbm5lY3Rpb25CZWluZ0RyYWdnZWQodHJ1ZSk7aWYob3B0aW9ucy5jYW5EcmFnKXtyZXR1cm4gZHJhZ09wdGlvbnMuY2FuRHJhZygpO319LGZhbHNlKTtvcHRpb25zW2RyYWdFdmVudF09X2p1LndyYXAob3B0aW9uc1tkcmFnRXZlbnRdLGZ1bmN0aW9uKCl7dmFyIHVpPV9jdXJyZW50SW5zdGFuY2UuZ2V0VUlQb3NpdGlvbihhcmd1bWVudHMsX2N1cnJlbnRJbnN0YW5jZS5nZXRab29tKCkpO2lmKHVpIT1udWxsKXtfZHJhdyhlbGVtZW50LHVpLG51bGwsdHJ1ZSk7aWYoX3N0YXJ0ZWQpe19jdXJyZW50SW5zdGFuY2UuYWRkQ2xhc3MoZWxlbWVudCxcImp0ay1kcmFnZ2VkXCIpO31fc3RhcnRlZD10cnVlO319KTtvcHRpb25zW3N0b3BFdmVudF09X2p1LndyYXAob3B0aW9uc1tzdG9wRXZlbnRdLGZ1bmN0aW9uKCl7dmFyIGVsZW1lbnRzPWFyZ3VtZW50c1swXS5zZWxlY3Rpb24sdWlwO3ZhciBfb25lPWZ1bmN0aW9uIF9vbmUoX2Upe2lmKF9lWzFdIT1udWxsKXsvLyBydW4gdGhlIHJlcG9ydGVkIG9mZnNldCB0aHJvdWdoIHRoZSBjb2RlIHRoYXQgdGFrZXMgcGFyZW50IGNvbnRhaW5lcnNcbi8vIGludG8gYWNjb3VudCwgdG8gYWRqdXN0IGlmIG5lY2Vzc2FyeSAoaXNzdWUgNTU0KVxudWlwPV9jdXJyZW50SW5zdGFuY2UuZ2V0VUlQb3NpdGlvbihbe2VsOl9lWzJdLmVsLHBvczpbX2VbMV0ubGVmdCxfZVsxXS50b3BdfV0pO19kcmF3KF9lWzJdLmVsLHVpcCk7fV9jdXJyZW50SW5zdGFuY2UucmVtb3ZlQ2xhc3MoX2VbMF0sXCJqdGstZHJhZ2dlZFwiKTtfY3VycmVudEluc3RhbmNlLnNlbGVjdCh7c291cmNlOl9lWzJdLmVsfSkucmVtb3ZlQ2xhc3MoX2N1cnJlbnRJbnN0YW5jZS5lbGVtZW50RHJhZ2dpbmdDbGFzcytcIiBcIitfY3VycmVudEluc3RhbmNlLnNvdXJjZUVsZW1lbnREcmFnZ2luZ0NsYXNzLHRydWUpO19jdXJyZW50SW5zdGFuY2Uuc2VsZWN0KHt0YXJnZXQ6X2VbMl0uZWx9KS5yZW1vdmVDbGFzcyhfY3VycmVudEluc3RhbmNlLmVsZW1lbnREcmFnZ2luZ0NsYXNzK1wiIFwiK19jdXJyZW50SW5zdGFuY2UudGFyZ2V0RWxlbWVudERyYWdnaW5nQ2xhc3MsdHJ1ZSk7X2N1cnJlbnRJbnN0YW5jZS5nZXREcmFnTWFuYWdlcigpLmRyYWdFbmRlZChfZVsyXS5lbCk7fTtmb3IodmFyIGk9MDtpPGVsZW1lbnRzLmxlbmd0aDtpKyspe19vbmUoZWxlbWVudHNbaV0pO31fc3RhcnRlZD1mYWxzZTtfY3VycmVudEluc3RhbmNlLnNldEhvdmVyU3VzcGVuZGVkKGZhbHNlKTtfY3VycmVudEluc3RhbmNlLnNldENvbm5lY3Rpb25CZWluZ0RyYWdnZWQoZmFsc2UpO30pO3ZhciBlbElkPV9nZXRJZChlbGVtZW50KTsvLyBuZWVkIElEXG5kcmFnZ2FibGVTdGF0ZXNbZWxJZF09dHJ1ZTt2YXIgZHJhZ2dhYmxlPWRyYWdnYWJsZVN0YXRlc1tlbElkXTtvcHRpb25zLmRpc2FibGVkPWRyYWdnYWJsZT09bnVsbD9mYWxzZTohZHJhZ2dhYmxlO19jdXJyZW50SW5zdGFuY2UuaW5pdERyYWdnYWJsZShlbGVtZW50LG9wdGlvbnMpO19jdXJyZW50SW5zdGFuY2UuZ2V0RHJhZ01hbmFnZXIoKS5yZWdpc3RlcihlbGVtZW50KTtpZihmaXJlRXZlbnQpe19jdXJyZW50SW5zdGFuY2UuZmlyZShcImVsZW1lbnREcmFnZ2FibGVcIix7ZWw6ZWxlbWVudCxvcHRpb25zOm9wdGlvbnN9KTt9fWVsc2V7Ly8gYWxyZWFkeSBkcmFnZ2FibGUuIGF0dGFjaCBhbnkgc3RhcnQsIGRyYWcgb3Igc3RvcCBsaXN0ZW5lcnMgdG8gdGhlIGN1cnJlbnQgRHJhZy5cbmlmKGRyYWdPcHRpb25zLmZvcmNlKXtfY3VycmVudEluc3RhbmNlLmluaXREcmFnZ2FibGUoZWxlbWVudCxvcHRpb25zKTt9fX19fX0sX3Njb3BlTWF0Y2g9ZnVuY3Rpb24gX3Njb3BlTWF0Y2goZTEsZTIpe3ZhciBzMT1lMS5zY29wZS5zcGxpdCgvXFxzLyksczI9ZTIuc2NvcGUuc3BsaXQoL1xccy8pO2Zvcih2YXIgaT0wO2k8czEubGVuZ3RoO2krKyl7Zm9yKHZhciBqPTA7ajxzMi5sZW5ndGg7aisrKXtpZihzMltqXT09PXMxW2ldKXtyZXR1cm4gdHJ1ZTt9fX1yZXR1cm4gZmFsc2U7fSxfbWVyZ2VPdmVycmlkZXM9ZnVuY3Rpb24gX21lcmdlT3ZlcnJpZGVzKGRlZix2YWx1ZXMpe3ZhciBtPWpzUGx1bWIuZXh0ZW5kKHt9LGRlZik7Zm9yKHZhciBpIGluIHZhbHVlcyl7aWYodmFsdWVzW2ldKXttW2ldPXZhbHVlc1tpXTt9fXJldHVybiBtO30sLypcclxuICAgICAgICAgKiBwcmVwYXJlcyBhIGZpbmFsIHBhcmFtcyBvYmplY3QgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIF9uZXdDb25uZWN0aW9uLCB0YWtpbmcgaW50byBhY2NvdW50IGRlZmF1bHRzLCBldmVudHMsIGV0Yy5cclxuICAgICAgICAgKi9fcHJlcGFyZUNvbm5lY3Rpb25QYXJhbXM9ZnVuY3Rpb24ocGFyYW1zLHJlZmVyZW5jZVBhcmFtcyl7dmFyIF9wPWpzUGx1bWIuZXh0ZW5kKHt9LHBhcmFtcyk7aWYocmVmZXJlbmNlUGFyYW1zKXtqc1BsdW1iLmV4dGVuZChfcCxyZWZlcmVuY2VQYXJhbXMpO30vLyBob3R3aXJlIGVuZHBvaW50cyBwYXNzZWQgYXMgc291cmNlIG9yIHRhcmdldCB0byBzb3VyY2VFbmRwb2ludC90YXJnZXRFbmRwb2ludCwgcmVzcGVjdGl2ZWx5LlxuaWYoX3Auc291cmNlKXtpZihfcC5zb3VyY2UuZW5kcG9pbnQpe19wLnNvdXJjZUVuZHBvaW50PV9wLnNvdXJjZTt9ZWxzZXtfcC5zb3VyY2U9X2N1cnJlbnRJbnN0YW5jZS5nZXRFbGVtZW50KF9wLnNvdXJjZSk7fX1pZihfcC50YXJnZXQpe2lmKF9wLnRhcmdldC5lbmRwb2ludCl7X3AudGFyZ2V0RW5kcG9pbnQ9X3AudGFyZ2V0O31lbHNle19wLnRhcmdldD1fY3VycmVudEluc3RhbmNlLmdldEVsZW1lbnQoX3AudGFyZ2V0KTt9fS8vIHRlc3QgZm9yIGVuZHBvaW50IHV1aWRzIHRvIGNvbm5lY3RcbmlmKHBhcmFtcy51dWlkcyl7X3Auc291cmNlRW5kcG9pbnQ9X2dldEVuZHBvaW50KHBhcmFtcy51dWlkc1swXSk7X3AudGFyZ2V0RW5kcG9pbnQ9X2dldEVuZHBvaW50KHBhcmFtcy51dWlkc1sxXSk7fS8vIG5vdyBlbnN1cmUgdGhhdCBpZiB3ZSBkbyBoYXZlIEVuZHBvaW50cyBhbHJlYWR5LCB0aGV5J3JlIG5vdCBmdWxsLlxuLy8gc291cmNlOlxuaWYoX3Auc291cmNlRW5kcG9pbnQmJl9wLnNvdXJjZUVuZHBvaW50LmlzRnVsbCgpKXtfanUubG9nKF9jdXJyZW50SW5zdGFuY2UsXCJjb3VsZCBub3QgYWRkIGNvbm5lY3Rpb247IHNvdXJjZSBlbmRwb2ludCBpcyBmdWxsXCIpO3JldHVybjt9Ly8gdGFyZ2V0OlxuaWYoX3AudGFyZ2V0RW5kcG9pbnQmJl9wLnRhcmdldEVuZHBvaW50LmlzRnVsbCgpKXtfanUubG9nKF9jdXJyZW50SW5zdGFuY2UsXCJjb3VsZCBub3QgYWRkIGNvbm5lY3Rpb247IHRhcmdldCBlbmRwb2ludCBpcyBmdWxsXCIpO3JldHVybjt9Ly8gaWYgc291cmNlIGVuZHBvaW50IG1hbmRhdGVzIGNvbm5lY3Rpb24gdHlwZSBhbmQgbm90aGluZyBzcGVjaWZpZWQgaW4gb3VyIHBhcmFtcywgdXNlIGl0LlxuaWYoIV9wLnR5cGUmJl9wLnNvdXJjZUVuZHBvaW50KXtfcC50eXBlPV9wLnNvdXJjZUVuZHBvaW50LmNvbm5lY3Rpb25UeXBlO30vLyBjb3B5IGluIGFueSBjb25uZWN0b3JPdmVybGF5cyB0aGF0IHdlcmUgc3BlY2lmaWVkIG9uIHRoZSBzb3VyY2UgZW5kcG9pbnQuXG4vLyBpdCBkb2VzbnQgY29weSB0YXJnZXQgZW5kcG9pbnQgb3ZlcmxheXMuICBpJ20gbm90IHN1cmUgaWYgd2Ugd2FudCBpdCB0byBvciBub3QuXG5pZihfcC5zb3VyY2VFbmRwb2ludCYmX3Auc291cmNlRW5kcG9pbnQuY29ubmVjdG9yT3ZlcmxheXMpe19wLm92ZXJsYXlzPV9wLm92ZXJsYXlzfHxbXTtmb3IodmFyIGk9MCxqPV9wLnNvdXJjZUVuZHBvaW50LmNvbm5lY3Rvck92ZXJsYXlzLmxlbmd0aDtpPGo7aSsrKXtfcC5vdmVybGF5cy5wdXNoKF9wLnNvdXJjZUVuZHBvaW50LmNvbm5lY3Rvck92ZXJsYXlzW2ldKTt9fS8vIHNjb3BlXG5pZihfcC5zb3VyY2VFbmRwb2ludCYmX3Auc291cmNlRW5kcG9pbnQuc2NvcGUpe19wLnNjb3BlPV9wLnNvdXJjZUVuZHBvaW50LnNjb3BlO30vLyBwb2ludGVyIGV2ZW50c1xuaWYoIV9wW1wicG9pbnRlci1ldmVudHNcIl0mJl9wLnNvdXJjZUVuZHBvaW50JiZfcC5zb3VyY2VFbmRwb2ludC5jb25uZWN0b3JQb2ludGVyRXZlbnRzKXtfcFtcInBvaW50ZXItZXZlbnRzXCJdPV9wLnNvdXJjZUVuZHBvaW50LmNvbm5lY3RvclBvaW50ZXJFdmVudHM7fXZhciBfYWRkRW5kcG9pbnQ9ZnVuY3Rpb24gX2FkZEVuZHBvaW50KGVsLGRlZixpZHgpe3JldHVybiBfY3VycmVudEluc3RhbmNlLmFkZEVuZHBvaW50KGVsLF9tZXJnZU92ZXJyaWRlcyhkZWYse2FuY2hvcjpfcC5hbmNob3JzP19wLmFuY2hvcnNbaWR4XTpfcC5hbmNob3IsZW5kcG9pbnQ6X3AuZW5kcG9pbnRzP19wLmVuZHBvaW50c1tpZHhdOl9wLmVuZHBvaW50LHBhaW50U3R5bGU6X3AuZW5kcG9pbnRTdHlsZXM/X3AuZW5kcG9pbnRTdHlsZXNbaWR4XTpfcC5lbmRwb2ludFN0eWxlLGhvdmVyUGFpbnRTdHlsZTpfcC5lbmRwb2ludEhvdmVyU3R5bGVzP19wLmVuZHBvaW50SG92ZXJTdHlsZXNbaWR4XTpfcC5lbmRwb2ludEhvdmVyU3R5bGV9KSk7fTsvLyBjaGVjayBmb3IgbWFrZVNvdXJjZS9tYWtlVGFyZ2V0IHNwZWNzLlxudmFyIF9vbmVFbGVtZW50RGVmPWZ1bmN0aW9uIF9vbmVFbGVtZW50RGVmKHR5cGUsaWR4LGRlZnMsbWF0Y2hUeXBlKXtpZihfcFt0eXBlXSYmIV9wW3R5cGVdLmVuZHBvaW50JiYhX3BbdHlwZStcIkVuZHBvaW50XCJdJiYhX3AubmV3Q29ubmVjdGlvbil7dmFyIHRpZD1fZ2V0SWQoX3BbdHlwZV0pLHRlcD1kZWZzW3RpZF07dGVwPXRlcD90ZXBbbWF0Y2hUeXBlXTpudWxsO2lmKHRlcCl7Ly8gaWYgbm90IGVuYWJsZWQsIHJldHVybi5cbmlmKCF0ZXAuZW5hYmxlZCl7cmV0dXJuIGZhbHNlO312YXIgbmV3RW5kcG9pbnQ9dGVwLmVuZHBvaW50IT1udWxsJiZ0ZXAuZW5kcG9pbnQuX2pzUGx1bWI/dGVwLmVuZHBvaW50Ol9hZGRFbmRwb2ludChfcFt0eXBlXSx0ZXAuZGVmLGlkeCk7aWYobmV3RW5kcG9pbnQuaXNGdWxsKCkpe3JldHVybiBmYWxzZTt9X3BbdHlwZStcIkVuZHBvaW50XCJdPW5ld0VuZHBvaW50O2lmKCFfcC5zY29wZSYmdGVwLmRlZi5zY29wZSl7X3Auc2NvcGU9dGVwLmRlZi5zY29wZTt9Ly8gcHJvdmlkZSBzY29wZSBpZiBub3QgYWxyZWFkeSBwcm92aWRlZCBhbmQgZW5kcG9pbnQgZGVmIGhhcyBvbmUuXG5pZih0ZXAudW5pcXVlRW5kcG9pbnQpe2lmKCF0ZXAuZW5kcG9pbnQpe3RlcC5lbmRwb2ludD1uZXdFbmRwb2ludDtuZXdFbmRwb2ludC5zZXREZWxldGVPbkVtcHR5KGZhbHNlKTt9ZWxzZXtuZXdFbmRwb2ludC5maW5hbEVuZHBvaW50PXRlcC5lbmRwb2ludDt9fWVsc2V7bmV3RW5kcG9pbnQuc2V0RGVsZXRlT25FbXB0eSh0cnVlKTt9Ly9cbi8vIGNvcHkgaW4gY29ubmVjdG9yIG92ZXJsYXlzIGlmIHByZXNlbnQgb24gdGhlIHNvdXJjZSBkZWZpbml0aW9uLlxuLy9cbmlmKGlkeD09PTAmJnRlcC5kZWYuY29ubmVjdG9yT3ZlcmxheXMpe19wLm92ZXJsYXlzPV9wLm92ZXJsYXlzfHxbXTtBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShfcC5vdmVybGF5cyx0ZXAuZGVmLmNvbm5lY3Rvck92ZXJsYXlzKTt9fX19O2lmKF9vbmVFbGVtZW50RGVmKFwic291cmNlXCIsMCx0aGlzLnNvdXJjZUVuZHBvaW50RGVmaW5pdGlvbnMsX3AudHlwZXx8XCJkZWZhdWx0XCIpPT09ZmFsc2Upe3JldHVybjt9aWYoX29uZUVsZW1lbnREZWYoXCJ0YXJnZXRcIiwxLHRoaXMudGFyZ2V0RW5kcG9pbnREZWZpbml0aW9ucyxfcC50eXBlfHxcImRlZmF1bHRcIik9PT1mYWxzZSl7cmV0dXJuO30vLyBsYXN0LCBlbnN1cmUgc2NvcGVzIG1hdGNoXG5pZihfcC5zb3VyY2VFbmRwb2ludCYmX3AudGFyZ2V0RW5kcG9pbnQpe2lmKCFfc2NvcGVNYXRjaChfcC5zb3VyY2VFbmRwb2ludCxfcC50YXJnZXRFbmRwb2ludCkpe19wPW51bGw7fX1yZXR1cm4gX3A7fS5iaW5kKF9jdXJyZW50SW5zdGFuY2UpLF9uZXdDb25uZWN0aW9uPWZ1bmN0aW9uIF9uZXdDb25uZWN0aW9uKHBhcmFtcyl7dmFyIGNvbm5lY3Rpb25GdW5jPV9jdXJyZW50SW5zdGFuY2UuRGVmYXVsdHMuQ29ubmVjdGlvblR5cGV8fF9jdXJyZW50SW5zdGFuY2UuZ2V0RGVmYXVsdENvbm5lY3Rpb25UeXBlKCk7cGFyYW1zLl9qc1BsdW1iPV9jdXJyZW50SW5zdGFuY2U7cGFyYW1zLm5ld0Nvbm5lY3Rpb249X25ld0Nvbm5lY3Rpb247cGFyYW1zLm5ld0VuZHBvaW50PV9uZXdFbmRwb2ludDtwYXJhbXMuZW5kcG9pbnRzQnlVVUlEPWVuZHBvaW50c0J5VVVJRDtwYXJhbXMuZW5kcG9pbnRzQnlFbGVtZW50PWVuZHBvaW50c0J5RWxlbWVudDtwYXJhbXMuZmluYWxpc2VDb25uZWN0aW9uPV9maW5hbGlzZUNvbm5lY3Rpb247cGFyYW1zLmlkPVwiY29uX1wiK19pZHN0YW1wKCk7dmFyIGNvbj1uZXcgY29ubmVjdGlvbkZ1bmMocGFyYW1zKTsvLyBpZiB0aGUgY29ubmVjdGlvbiBpcyBkcmFnZ2FibGUsIHRoZW4gbWF5YmUgd2UgbmVlZCB0byB0ZWxsIHRoZSB0YXJnZXQgZW5kcG9pbnQgdG8gaW5pdCB0aGVcbi8vIGRyYWdnaW5nIGNvZGUuIGl0IHdvbid0IHJ1biBhZ2FpbiBpZiBpdCBhbHJlYWR5IGNvbmZpZ3VyZWQgdG8gYmUgZHJhZ2dhYmxlLlxuaWYoY29uLmlzRGV0YWNoYWJsZSgpKXtjb24uZW5kcG9pbnRzWzBdLmluaXREcmFnZ2FibGUoXCJfanNQbHVtYlNvdXJjZVwiKTtjb24uZW5kcG9pbnRzWzFdLmluaXREcmFnZ2FibGUoXCJfanNQbHVtYlRhcmdldFwiKTt9cmV0dXJuIGNvbjt9LC8vXG4vLyBhZGRzIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBiYWNraW5nIG1vZGVsLCBmaXJlcyBhbiBldmVudCBpZiBuZWNlc3NhcnkgYW5kIHRoZW4gcmVkcmF3c1xuLy9cbl9maW5hbGlzZUNvbm5lY3Rpb249X2N1cnJlbnRJbnN0YW5jZS5maW5hbGlzZUNvbm5lY3Rpb249ZnVuY3Rpb24oanBjLHBhcmFtcyxvcmlnaW5hbEV2ZW50LGRvSW5mb3JtQW5jaG9yTWFuYWdlcil7cGFyYW1zPXBhcmFtc3x8e307Ly8gYWRkIHRvIGxpc3Qgb2YgY29ubmVjdGlvbnMgKGJ5IHNjb3BlKS5cbmlmKCFqcGMuc3VzcGVuZGVkRW5kcG9pbnQpe2Nvbm5lY3Rpb25zLnB1c2goanBjKTt9anBjLnBlbmRpbmc9bnVsbDsvLyB0dXJuIG9mZiBpc1RlbXBvcmFyeVNvdXJjZSBvbiB0aGUgc291cmNlIGVuZHBvaW50IChvbmx5IHZpYWJsZSBvbiBmaXJzdCBkcmF3KVxuanBjLmVuZHBvaW50c1swXS5pc1RlbXBvcmFyeVNvdXJjZT1mYWxzZTsvLyBhbHdheXMgaW5mb3JtIHRoZSBhbmNob3IgbWFuYWdlclxuLy8gZXhjZXB0IHRoYXQgaWYganBjIGhhcyBhIHN1c3BlbmRlZCBlbmRwb2ludCBpdCdzIG5vdCB0cnVlIHRvIHNheSB0aGVcbi8vIGNvbm5lY3Rpb24gaXMgbmV3OyBpdCBoYXMganVzdCAocG9zc2libHkpIG1vdmVkLiB0aGUgcXVlc3Rpb24gaXMgd2hldGhlclxuLy8gdG8gbWFrZSB0aGF0IGNhbGwgaGVyZSBvciBpbiB0aGUgYW5jaG9yIG1hbmFnZXIuICBpIHRoaW5rIHBlcmhhcHMgaGVyZS5cbmlmKGRvSW5mb3JtQW5jaG9yTWFuYWdlciE9PWZhbHNlKXtfY3VycmVudEluc3RhbmNlLmFuY2hvck1hbmFnZXIubmV3Q29ubmVjdGlvbihqcGMpO30vLyBmb3JjZSBhIHBhaW50XG5fZHJhdyhqcGMuc291cmNlKTsvLyBmaXJlIGFuIGV2ZW50XG5pZighcGFyYW1zLmRvTm90RmlyZUNvbm5lY3Rpb25FdmVudCYmcGFyYW1zLmZpcmVFdmVudCE9PWZhbHNlKXt2YXIgZXZlbnRBcmdzPXtjb25uZWN0aW9uOmpwYyxzb3VyY2U6anBjLnNvdXJjZSx0YXJnZXQ6anBjLnRhcmdldCxzb3VyY2VJZDpqcGMuc291cmNlSWQsdGFyZ2V0SWQ6anBjLnRhcmdldElkLHNvdXJjZUVuZHBvaW50OmpwYy5lbmRwb2ludHNbMF0sdGFyZ2V0RW5kcG9pbnQ6anBjLmVuZHBvaW50c1sxXX07X2N1cnJlbnRJbnN0YW5jZS5maXJlKFwiY29ubmVjdGlvblwiLGV2ZW50QXJncyxvcmlnaW5hbEV2ZW50KTt9fSwvKlxyXG4gICAgICAgICBmYWN0b3J5IG1ldGhvZCB0byBwcmVwYXJlIGEgbmV3IGVuZHBvaW50LiAgdGhpcyBzaG91bGQgYWx3YXlzIGJlIHVzZWQgaW5zdGVhZCBvZiBjcmVhdGluZyBFbmRwb2ludHNcclxuICAgICAgICAgbWFudWFsbHksIHNpbmNlIHRoaXMgbWV0aG9kIGF0dGFjaGVzIGV2ZW50IGxpc3RlbmVycyBhbmQgYW4gaWQuXHJcbiAgICAgICAgICovX25ld0VuZHBvaW50PWZ1bmN0aW9uIF9uZXdFbmRwb2ludChwYXJhbXMsaWQpe3ZhciBlbmRwb2ludEZ1bmM9X2N1cnJlbnRJbnN0YW5jZS5EZWZhdWx0cy5FbmRwb2ludFR5cGV8fGpzUGx1bWIuRW5kcG9pbnQ7dmFyIF9wPWpzUGx1bWIuZXh0ZW5kKHt9LHBhcmFtcyk7X3AuX2pzUGx1bWI9X2N1cnJlbnRJbnN0YW5jZTtfcC5uZXdDb25uZWN0aW9uPV9uZXdDb25uZWN0aW9uO19wLm5ld0VuZHBvaW50PV9uZXdFbmRwb2ludDtfcC5lbmRwb2ludHNCeVVVSUQ9ZW5kcG9pbnRzQnlVVUlEO19wLmVuZHBvaW50c0J5RWxlbWVudD1lbmRwb2ludHNCeUVsZW1lbnQ7X3AuZmlyZURldGFjaEV2ZW50PWZpcmVEZXRhY2hFdmVudDtfcC5lbGVtZW50SWQ9aWR8fF9nZXRJZChfcC5zb3VyY2UpO3ZhciBlcD1uZXcgZW5kcG9pbnRGdW5jKF9wKTtlcC5pZD1cImVwX1wiK19pZHN0YW1wKCk7X21hbmFnZShfcC5lbGVtZW50SWQsX3Auc291cmNlKTtpZighanNQbHVtYi5oZWFkbGVzcyl7X2N1cnJlbnRJbnN0YW5jZS5nZXREcmFnTWFuYWdlcigpLmVuZHBvaW50QWRkZWQoX3Auc291cmNlLGlkKTt9cmV0dXJuIGVwO30sLypcclxuICAgICAgICAgKiBwZXJmb3JtcyB0aGUgZ2l2ZW4gZnVuY3Rpb24gb3BlcmF0aW9uIG9uIGFsbCB0aGUgY29ubmVjdGlvbnMgZm91bmRcclxuICAgICAgICAgKiBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgaWQ7IHRoaXMgbWVhbnMgd2UgZmluZCBhbGwgdGhlIGVuZHBvaW50cyBmb3JcclxuICAgICAgICAgKiB0aGUgZ2l2ZW4gZWxlbWVudCwgYW5kIHRoZW4gZm9yIGVhY2ggZW5kcG9pbnQgZmluZCB0aGUgY29ubmVjdG9yc1xyXG4gICAgICAgICAqIGNvbm5lY3RlZCB0byBpdC4gdGhlbiB3ZSBwYXNzIGVhY2ggY29ubmVjdGlvbiBpbiB0byB0aGUgZ2l2ZW5cclxuICAgICAgICAgKiBmdW5jdGlvbi5cclxuICAgICAgICAgKi9fb3BlcmF0aW9uPWZ1bmN0aW9uIF9vcGVyYXRpb24oZWxJZCxmdW5jLGVuZHBvaW50RnVuYyl7dmFyIGVuZHBvaW50cz1lbmRwb2ludHNCeUVsZW1lbnRbZWxJZF07aWYoZW5kcG9pbnRzJiZlbmRwb2ludHMubGVuZ3RoKXtmb3IodmFyIGk9MCxpaT1lbmRwb2ludHMubGVuZ3RoO2k8aWk7aSsrKXtmb3IodmFyIGo9MCxqaj1lbmRwb2ludHNbaV0uY29ubmVjdGlvbnMubGVuZ3RoO2o8amo7aisrKXt2YXIgcmV0VmFsPWZ1bmMoZW5kcG9pbnRzW2ldLmNvbm5lY3Rpb25zW2pdKTsvLyBpZiB0aGUgZnVuY3Rpb24gcGFzc2VkIGluIHJldHVybnMgdHJ1ZSwgd2UgZXhpdC5cbi8vIG1vc3QgZnVuY3Rpb25zIHJldHVybiBmYWxzZS5cbmlmKHJldFZhbCl7cmV0dXJuO319aWYoZW5kcG9pbnRGdW5jKXtlbmRwb2ludEZ1bmMoZW5kcG9pbnRzW2ldKTt9fX19LF9zZXREcmFnZ2FibGU9ZnVuY3Rpb24gX3NldERyYWdnYWJsZShlbGVtZW50LGRyYWdnYWJsZSl7cmV0dXJuIGpzUGx1bWIuZWFjaChlbGVtZW50LGZ1bmN0aW9uKGVsKXtpZihfY3VycmVudEluc3RhbmNlLmlzRHJhZ1N1cHBvcnRlZChlbCkpe2RyYWdnYWJsZVN0YXRlc1tfY3VycmVudEluc3RhbmNlLmdldEF0dHJpYnV0ZShlbCxcImlkXCIpXT1kcmFnZ2FibGU7X2N1cnJlbnRJbnN0YW5jZS5zZXRFbGVtZW50RHJhZ2dhYmxlKGVsLGRyYWdnYWJsZSk7fX0pO30sLypcclxuICAgICAgICAgKiBwcml2YXRlIG1ldGhvZCB0byBkbyB0aGUgYnVzaW5lc3Mgb2YgaGlkaW5nL3Nob3dpbmcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gZWxcclxuICAgICAgICAgKiAgICAgICAgICAgIGVpdGhlciBJZCBvZiB0aGUgZWxlbWVudCBpbiBxdWVzdGlvbiBvciBhIGxpYnJhcnkgc3BlY2lmaWNcclxuICAgICAgICAgKiAgICAgICAgICAgIG9iamVjdCBmb3IgdGhlIGVsZW1lbnQuXHJcbiAgICAgICAgICogQHBhcmFtIHN0YXRlXHJcbiAgICAgICAgICogICAgICAgICAgICBTdHJpbmcgc3BlY2lmeWluZyBhIHZhbHVlIGZvciB0aGUgY3NzICdkaXNwbGF5JyBwcm9wZXJ0eVxyXG4gICAgICAgICAqICAgICAgICAgICAgKCdibG9jaycgb3IgJ25vbmUnKS5cclxuICAgICAgICAgKi9fc2V0VmlzaWJsZT1mdW5jdGlvbiBfc2V0VmlzaWJsZShlbCxzdGF0ZSxhbHNvQ2hhbmdlRW5kcG9pbnRzKXtzdGF0ZT1zdGF0ZT09PVwiYmxvY2tcIjt2YXIgZW5kcG9pbnRGdW5jPW51bGw7aWYoYWxzb0NoYW5nZUVuZHBvaW50cyl7ZW5kcG9pbnRGdW5jPWZ1bmN0aW9uIGVuZHBvaW50RnVuYyhlcCl7ZXAuc2V0VmlzaWJsZShzdGF0ZSx0cnVlLHRydWUpO307fXZhciBpbmZvPV9pbmZvKGVsKTtfb3BlcmF0aW9uKGluZm8uaWQsZnVuY3Rpb24oanBjKXtpZihzdGF0ZSYmYWxzb0NoYW5nZUVuZHBvaW50cyl7Ly8gdGhpcyB0ZXN0IGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRoaXMgZnVuY3Rpb25hbGl0eSBpcyBuZXcsIGFuZCBpIHdhbnRlZCB0byBtYWludGFpbiBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbi8vIHRoaXMgYmxvY2sgd2lsbCBvbmx5IHNldCBhIGNvbm5lY3Rpb24gdG8gYmUgdmlzaWJsZSBpZiB0aGUgb3RoZXIgZW5kcG9pbnQgaW4gdGhlIGNvbm5lY3Rpb24gaXMgYWxzbyB2aXNpYmxlLlxudmFyIG9pZHg9anBjLnNvdXJjZUlkPT09aW5mby5pZD8xOjA7aWYoanBjLmVuZHBvaW50c1tvaWR4XS5pc1Zpc2libGUoKSl7anBjLnNldFZpc2libGUodHJ1ZSk7fX1lbHNley8vIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBmb3Igc2hvdywgYW5kIHdoYXQgYWx3YXlzIGhhcHBlbnMgZm9yIGhpZGUsIGlzIHRvIGp1c3Qgc2V0IHRoZSB2aXNpYmlsaXR5IHdpdGhvdXQgZ2V0dGluZyBjbGV2ZXIuXG5qcGMuc2V0VmlzaWJsZShzdGF0ZSk7fX0sZW5kcG9pbnRGdW5jKTt9LC8qXHJcbiAgICAgICAgICogdG9nZ2xlcyB0aGUgZHJhZ2dhYmxlIHN0YXRlIG9mIHRoZSBnaXZlbiBlbGVtZW50KHMpLlxyXG4gICAgICAgICAqIGVsIGlzIGVpdGhlciBhbiBpZCwgb3IgYW4gZWxlbWVudCBvYmplY3QsIG9yIGEgbGlzdCBvZiBpZHMvZWxlbWVudCBvYmplY3RzLlxyXG4gICAgICAgICAqL190b2dnbGVEcmFnZ2FibGU9ZnVuY3Rpb24gX3RvZ2dsZURyYWdnYWJsZShlbCl7dmFyIHN0YXRlO2pzUGx1bWIuZWFjaChlbCxmdW5jdGlvbihlbCl7dmFyIGVsSWQ9X2N1cnJlbnRJbnN0YW5jZS5nZXRBdHRyaWJ1dGUoZWwsXCJpZFwiKTtzdGF0ZT1kcmFnZ2FibGVTdGF0ZXNbZWxJZF09PW51bGw/ZmFsc2U6ZHJhZ2dhYmxlU3RhdGVzW2VsSWRdO3N0YXRlPSFzdGF0ZTtkcmFnZ2FibGVTdGF0ZXNbZWxJZF09c3RhdGU7X2N1cnJlbnRJbnN0YW5jZS5zZXREcmFnZ2FibGUoZWwsc3RhdGUpO3JldHVybiBzdGF0ZTt9LmJpbmQodGhpcykpO3JldHVybiBzdGF0ZTt9LC8qKlxyXG4gICAgICAgICAgICAgKiBwcml2YXRlIG1ldGhvZCB0byBkbyB0aGUgYnVzaW5lc3Mgb2YgdG9nZ2xpbmcgaGlkaW5nL3Nob3dpbmcuXHJcbiAgICAgICAgICAgICAqL190b2dnbGVWaXNpYmxlPWZ1bmN0aW9uIF90b2dnbGVWaXNpYmxlKGVsSWQsY2hhbmdlRW5kcG9pbnRzKXt2YXIgZW5kcG9pbnRGdW5jPW51bGw7aWYoY2hhbmdlRW5kcG9pbnRzKXtlbmRwb2ludEZ1bmM9ZnVuY3Rpb24gZW5kcG9pbnRGdW5jKGVwKXt2YXIgc3RhdGU9ZXAuaXNWaXNpYmxlKCk7ZXAuc2V0VmlzaWJsZSghc3RhdGUpO307fV9vcGVyYXRpb24oZWxJZCxmdW5jdGlvbihqcGMpe3ZhciBzdGF0ZT1qcGMuaXNWaXNpYmxlKCk7anBjLnNldFZpc2libGUoIXN0YXRlKTt9LGVuZHBvaW50RnVuYyk7fSwvLyBUT0RPIGNvbXBhcmlzb24gcGVyZm9ybWFuY2Vcbl9nZXRDYWNoZWREYXRhPWZ1bmN0aW9uIF9nZXRDYWNoZWREYXRhKGVsSWQpe3ZhciBvPW9mZnNldHNbZWxJZF07aWYoIW8pe3JldHVybiBfdXBkYXRlT2Zmc2V0KHtlbElkOmVsSWR9KTt9ZWxzZXtyZXR1cm57bzpvLHM6c2l6ZXNbZWxJZF19O319LC8qKlxyXG4gICAgICAgICAgICAgKiBnZXRzIGFuIGlkIGZvciB0aGUgZ2l2ZW4gZWxlbWVudCwgY3JlYXRpbmcgYW5kIHNldHRpbmcgb25lIGlmXHJcbiAgICAgICAgICAgICAqIG5lY2Vzc2FyeS4gIHRoZSBpZCBpcyBvZiB0aGUgZm9ybVxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgICBqc1BsdW1iXzxpbnN0YW5jZSBpbmRleD5fPGluZGV4IGluIGluc3RhbmNlPlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiB3aGVyZSBcImluZGV4IGluIGluc3RhbmNlXCIgaXMgYSBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcgaW50ZWdlciB0aGF0IHN0YXJ0cyBhdCAwLFxyXG4gICAgICAgICAgICAgKiBmb3IgZWFjaCBpbnN0YW5jZS4gIHRoaXMgbWV0aG9kIGlzIHVzZWQgbm90IG9ubHkgdG8gYXNzaWduIGlkcyB0byBlbGVtZW50cyB0aGF0IGRvIG5vdFxyXG4gICAgICAgICAgICAgKiBoYXZlIHRoZW0gYnV0IGFsc28gdG8gY29ubmVjdGlvbnMgYW5kIGVuZHBvaW50cy5cclxuICAgICAgICAgICAgICovX2dldElkPWZ1bmN0aW9uIF9nZXRJZChlbGVtZW50LHV1aWQsZG9Ob3RDcmVhdGVJZk5vdEZvdW5kKXtpZihfanUuaXNTdHJpbmcoZWxlbWVudCkpe3JldHVybiBlbGVtZW50O31pZihlbGVtZW50PT1udWxsKXtyZXR1cm4gbnVsbDt9dmFyIGlkPV9jdXJyZW50SW5zdGFuY2UuZ2V0QXR0cmlidXRlKGVsZW1lbnQsXCJpZFwiKTtpZighaWR8fGlkPT09XCJ1bmRlZmluZWRcIil7Ly8gY2hlY2sgaWYgZml4ZWQgdXVpZCBwYXJhbWV0ZXIgaXMgZ2l2ZW5cbmlmKGFyZ3VtZW50cy5sZW5ndGg9PT0yJiZhcmd1bWVudHNbMV0hPT11bmRlZmluZWQpe2lkPXV1aWQ7fWVsc2UgaWYoYXJndW1lbnRzLmxlbmd0aD09PTF8fGFyZ3VtZW50cy5sZW5ndGg9PT0zJiYhYXJndW1lbnRzWzJdKXtpZD1cImpzUGx1bWJfXCIrX2luc3RhbmNlSW5kZXgrXCJfXCIrX2lkc3RhbXAoKTt9aWYoIWRvTm90Q3JlYXRlSWZOb3RGb3VuZCl7X2N1cnJlbnRJbnN0YW5jZS5zZXRBdHRyaWJ1dGUoZWxlbWVudCxcImlkXCIsaWQpO319cmV0dXJuIGlkO307dGhpcy5zZXRDb25uZWN0aW9uQmVpbmdEcmFnZ2VkPWZ1bmN0aW9uKHYpe2Nvbm5lY3Rpb25CZWluZ0RyYWdnZWQ9djt9O3RoaXMuaXNDb25uZWN0aW9uQmVpbmdEcmFnZ2VkPWZ1bmN0aW9uKCl7cmV0dXJuIGNvbm5lY3Rpb25CZWluZ0RyYWdnZWQ7fTsvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgbWFwIG9mIGFsbCB0aGUgZWxlbWVudHMgdGhpcyBqc1BsdW1iSW5zdGFuY2UgaXMgY3VycmVudGx5IG1hbmFnaW5nLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IE1hcCBvZiBbaWQtPiB7ZWwsIGVuZHBvaW50W10sIGNvbm5lY3Rpb24sIHBvc2l0aW9ufV0gaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICovdGhpcy5nZXRNYW5hZ2VkRWxlbWVudHM9ZnVuY3Rpb24oKXtyZXR1cm4gbWFuYWdlZEVsZW1lbnRzO307dGhpcy5jb25uZWN0b3JDbGFzcz1cImp0ay1jb25uZWN0b3JcIjt0aGlzLmNvbm5lY3Rvck91dGxpbmVDbGFzcz1cImp0ay1jb25uZWN0b3Itb3V0bGluZVwiO3RoaXMuY29ubmVjdGVkQ2xhc3M9XCJqdGstY29ubmVjdGVkXCI7dGhpcy5ob3ZlckNsYXNzPVwianRrLWhvdmVyXCI7dGhpcy5lbmRwb2ludENsYXNzPVwianRrLWVuZHBvaW50XCI7dGhpcy5lbmRwb2ludENvbm5lY3RlZENsYXNzPVwianRrLWVuZHBvaW50LWNvbm5lY3RlZFwiO3RoaXMuZW5kcG9pbnRGdWxsQ2xhc3M9XCJqdGstZW5kcG9pbnQtZnVsbFwiO3RoaXMuZW5kcG9pbnREcm9wQWxsb3dlZENsYXNzPVwianRrLWVuZHBvaW50LWRyb3AtYWxsb3dlZFwiO3RoaXMuZW5kcG9pbnREcm9wRm9yYmlkZGVuQ2xhc3M9XCJqdGstZW5kcG9pbnQtZHJvcC1mb3JiaWRkZW5cIjt0aGlzLm92ZXJsYXlDbGFzcz1cImp0ay1vdmVybGF5XCI7dGhpcy5kcmFnZ2luZ0NsYXNzPVwianRrLWRyYWdnaW5nXCI7Ly8gQ09OVkVSVEVEXG50aGlzLmVsZW1lbnREcmFnZ2luZ0NsYXNzPVwianRrLWVsZW1lbnQtZHJhZ2dpbmdcIjsvLyBDT05WRVJURURcbnRoaXMuc291cmNlRWxlbWVudERyYWdnaW5nQ2xhc3M9XCJqdGstc291cmNlLWVsZW1lbnQtZHJhZ2dpbmdcIjsvLyBDT05WRVJURURcbnRoaXMudGFyZ2V0RWxlbWVudERyYWdnaW5nQ2xhc3M9XCJqdGstdGFyZ2V0LWVsZW1lbnQtZHJhZ2dpbmdcIjsvLyBDT05WRVJURURcbnRoaXMuZW5kcG9pbnRBbmNob3JDbGFzc1ByZWZpeD1cImp0ay1lbmRwb2ludC1hbmNob3JcIjt0aGlzLmhvdmVyU291cmNlQ2xhc3M9XCJqdGstc291cmNlLWhvdmVyXCI7dGhpcy5ob3ZlclRhcmdldENsYXNzPVwianRrLXRhcmdldC1ob3ZlclwiO3RoaXMuZHJhZ1NlbGVjdENsYXNzPVwianRrLWRyYWctc2VsZWN0XCI7dGhpcy5BbmNob3JzPXt9O3RoaXMuQ29ubmVjdG9ycz17XCJzdmdcIjp7fX07dGhpcy5FbmRwb2ludHM9e1wic3ZnXCI6e319O3RoaXMuT3ZlcmxheXM9e1wic3ZnXCI6e319O3RoaXMuQ29ubmVjdG9yUmVuZGVyZXJzPXt9O3RoaXMuU1ZHPVwic3ZnXCI7Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGpzUGx1bWJJbnN0YW5jZSBwdWJsaWMgQVBJIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudGhpcy5hZGRFbmRwb2ludD1mdW5jdGlvbihlbCxwYXJhbXMscmVmZXJlbmNlUGFyYW1zKXtyZWZlcmVuY2VQYXJhbXM9cmVmZXJlbmNlUGFyYW1zfHx7fTt2YXIgcD1qc1BsdW1iLmV4dGVuZCh7fSxyZWZlcmVuY2VQYXJhbXMpO2pzUGx1bWIuZXh0ZW5kKHAscGFyYW1zKTtwLmVuZHBvaW50PXAuZW5kcG9pbnR8fF9jdXJyZW50SW5zdGFuY2UuRGVmYXVsdHMuRW5kcG9pbnQ7cC5wYWludFN0eWxlPXAucGFpbnRTdHlsZXx8X2N1cnJlbnRJbnN0YW5jZS5EZWZhdWx0cy5FbmRwb2ludFN0eWxlO3ZhciByZXN1bHRzPVtdLGlucHV0cz1fanUuaXNBcnJheShlbCl8fGVsLmxlbmd0aCE9bnVsbCYmIV9qdS5pc1N0cmluZyhlbCk/ZWw6W2VsXTtmb3IodmFyIGk9MCxqPWlucHV0cy5sZW5ndGg7aTxqO2krKyl7cC5zb3VyY2U9X2N1cnJlbnRJbnN0YW5jZS5nZXRFbGVtZW50KGlucHV0c1tpXSk7X2Vuc3VyZUNvbnRhaW5lcihwLnNvdXJjZSk7dmFyIGlkPV9nZXRJZChwLnNvdXJjZSksZT1fbmV3RW5kcG9pbnQocCxpZCk7Ly8gZW5zdXJlIGVsZW1lbnQgaXMgbWFuYWdlZC5cbnZhciBteU9mZnNldD1fbWFuYWdlKGlkLHAuc291cmNlKS5pbmZvLm87X2p1LmFkZFRvTGlzdChlbmRwb2ludHNCeUVsZW1lbnQsaWQsZSk7aWYoIV9zdXNwZW5kRHJhd2luZyl7ZS5wYWludCh7YW5jaG9yTG9jOmUuYW5jaG9yLmNvbXB1dGUoe3h5OltteU9mZnNldC5sZWZ0LG15T2Zmc2V0LnRvcF0sd2g6c2l6ZXNbaWRdLGVsZW1lbnQ6ZSx0aW1lc3RhbXA6X3N1c3BlbmRlZEF0fSksdGltZXN0YW1wOl9zdXNwZW5kZWRBdH0pO31yZXN1bHRzLnB1c2goZSk7fXJldHVybiByZXN1bHRzLmxlbmd0aD09PTE/cmVzdWx0c1swXTpyZXN1bHRzO307dGhpcy5hZGRFbmRwb2ludHM9ZnVuY3Rpb24oZWwsZW5kcG9pbnRzLHJlZmVyZW5jZVBhcmFtcyl7dmFyIHJlc3VsdHM9W107Zm9yKHZhciBpPTAsaj1lbmRwb2ludHMubGVuZ3RoO2k8ajtpKyspe3ZhciBlPV9jdXJyZW50SW5zdGFuY2UuYWRkRW5kcG9pbnQoZWwsZW5kcG9pbnRzW2ldLHJlZmVyZW5jZVBhcmFtcyk7aWYoX2p1LmlzQXJyYXkoZSkpe0FycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHJlc3VsdHMsZSk7fWVsc2V7cmVzdWx0cy5wdXNoKGUpO319cmV0dXJuIHJlc3VsdHM7fTt0aGlzLmFuaW1hdGU9ZnVuY3Rpb24oZWwscHJvcGVydGllcyxvcHRpb25zKXtpZighdGhpcy5hbmltYXRpb25TdXBwb3J0ZWQpe3JldHVybiBmYWxzZTt9b3B0aW9ucz1vcHRpb25zfHx7fTt2YXIgZGVsPV9jdXJyZW50SW5zdGFuY2UuZ2V0RWxlbWVudChlbCksaWQ9X2dldElkKGRlbCksc3RlcEZ1bmN0aW9uPWpzUGx1bWIuYW5pbUV2ZW50cy5zdGVwLGNvbXBsZXRlRnVuY3Rpb249anNQbHVtYi5hbmltRXZlbnRzLmNvbXBsZXRlO29wdGlvbnNbc3RlcEZ1bmN0aW9uXT1fanUud3JhcChvcHRpb25zW3N0ZXBGdW5jdGlvbl0sZnVuY3Rpb24oKXtfY3VycmVudEluc3RhbmNlLnJldmFsaWRhdGUoaWQpO30pOy8vIG9uQ29tcGxldGUgcmVwYWludHMsIGp1c3QgdG8gbWFrZSBzdXJlIGV2ZXJ5dGhpbmcgbG9va3MgZ29vZCBhdCB0aGUgZW5kIG9mIHRoZSBhbmltYXRpb24uXG5vcHRpb25zW2NvbXBsZXRlRnVuY3Rpb25dPV9qdS53cmFwKG9wdGlvbnNbY29tcGxldGVGdW5jdGlvbl0sZnVuY3Rpb24oKXtfY3VycmVudEluc3RhbmNlLnJldmFsaWRhdGUoaWQpO30pO19jdXJyZW50SW5zdGFuY2UuZG9BbmltYXRlKGRlbCxwcm9wZXJ0aWVzLG9wdGlvbnMpO307LyoqXHJcbiAgICAgICAgICogY2hlY2tzIGZvciBhIGxpc3RlbmVyIGZvciB0aGUgZ2l2ZW4gY29uZGl0aW9uLCBleGVjdXRpbmcgaXQgaWYgZm91bmQsIHBhc3NpbmcgaW4gdGhlIGdpdmVuIHZhbHVlLlxyXG4gICAgICAgICAqIGNvbmRpdGlvbiBsaXN0ZW5lcnMgd291bGQgaGF2ZSBiZWVuIGF0dGFjaGVkIHVzaW5nIFwiYmluZFwiICh3aGljaCBpcywgeW91IGNvdWxkIGFyZ3VlLCBub3cgb3ZlcmxvYWRlZCwgc2luY2VcclxuICAgICAgICAgKiBmaXJpbmcgY2xpY2sgZXZlbnRzIGV0YyBpcyBhIGJpdCBkaWZmZXJlbnQgdG8gd2hhdCB0aGlzIGRvZXMpLiAgaSB0aG91Z2h0IGFib3V0IGFkZGluZyBhIFwiYmluZENvbmRpdGlvblwiXHJcbiAgICAgICAgICogb3Igc29tZXRoaW5nLCBidXQgZGVjaWRlZCBhZ2FpbnN0IGl0LCBmb3IgdGhlIHNha2Ugb2Ygc2ltcGxpY2l0eS4ganNQbHVtYiB3aWxsIG5ldmVyIGZpcmUgb25lIG9mIHRoZXNlXHJcbiAgICAgICAgICogY29uZGl0aW9uIGV2ZW50cyBhbnl3YXkuXHJcbiAgICAgICAgICovdGhpcy5jaGVja0NvbmRpdGlvbj1mdW5jdGlvbihjb25kaXRpb25OYW1lLGFyZ3Mpe3ZhciBsPV9jdXJyZW50SW5zdGFuY2UuZ2V0TGlzdGVuZXIoY29uZGl0aW9uTmFtZSkscj10cnVlO2lmKGwmJmwubGVuZ3RoPjApe3ZhciB2YWx1ZXM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpO3RyeXtmb3IodmFyIGk9MCxqPWwubGVuZ3RoO2k8ajtpKyspe3I9ciYmbFtpXS5hcHBseShsW2ldLHZhbHVlcyk7fX1jYXRjaChlKXtfanUubG9nKF9jdXJyZW50SW5zdGFuY2UsXCJjYW5ub3QgY2hlY2sgY29uZGl0aW9uIFtcIitjb25kaXRpb25OYW1lK1wiXVwiK2UpO319cmV0dXJuIHI7fTt0aGlzLmNvbm5lY3Q9ZnVuY3Rpb24ocGFyYW1zLHJlZmVyZW5jZVBhcmFtcyl7Ly8gcHJlcGFyZSBhIGZpbmFsIHNldCBvZiBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBjb25uZWN0aW9uIHdpdGhcbnZhciBfcD1fcHJlcGFyZUNvbm5lY3Rpb25QYXJhbXMocGFyYW1zLHJlZmVyZW5jZVBhcmFtcyksanBjOy8vIFRPRE8gcHJvYmFibHkgYSBuaWNlciByZXR1cm4gdmFsdWUgaWYgdGhlIGNvbm5lY3Rpb24gd2FzIG5vdCBtYWRlLiAgX3ByZXBhcmVDb25uZWN0aW9uUGFyYW1zXG4vLyB3aWxsIHJldHVybiBudWxsIChhbmQgbG9nIHNvbWV0aGluZykgaWYgZWl0aGVyIGVuZHBvaW50IHdhcyBmdWxsLiAgd2hhdCB3b3VsZCBiZSBuaWNlciBpcyB0b1xuLy8gY3JlYXRlIGEgZGVkaWNhdGVkICdlcnJvcicgb2JqZWN0LlxuaWYoX3Ape2lmKF9wLnNvdXJjZT09bnVsbCYmX3Auc291cmNlRW5kcG9pbnQ9PW51bGwpe19qdS5sb2coXCJDYW5ub3QgZXN0YWJsaXNoIGNvbm5lY3Rpb24gLSBzb3VyY2UgZG9lcyBub3QgZXhpc3RcIik7cmV0dXJuO31pZihfcC50YXJnZXQ9PW51bGwmJl9wLnRhcmdldEVuZHBvaW50PT1udWxsKXtfanUubG9nKFwiQ2Fubm90IGVzdGFibGlzaCBjb25uZWN0aW9uIC0gdGFyZ2V0IGRvZXMgbm90IGV4aXN0XCIpO3JldHVybjt9X2Vuc3VyZUNvbnRhaW5lcihfcC5zb3VyY2UpOy8vIGNyZWF0ZSB0aGUgY29ubmVjdGlvbi4gIGl0IGlzIG5vdCB5ZXQgcmVnaXN0ZXJlZFxuanBjPV9uZXdDb25uZWN0aW9uKF9wKTsvLyBub3cgYWRkIGl0IHRoZSBtb2RlbCwgZmlyZSBhbiBldmVudCwgYW5kIHJlZHJhd1xuX2ZpbmFsaXNlQ29ubmVjdGlvbihqcGMsX3ApO31yZXR1cm4ganBjO307dmFyIHN0VHlwZXM9W3tlbDpcInNvdXJjZVwiLGVsSWQ6XCJzb3VyY2VJZFwiLGVwRGVmczpcInNvdXJjZUVuZHBvaW50RGVmaW5pdGlvbnNcIn0se2VsOlwidGFyZ2V0XCIsZWxJZDpcInRhcmdldElkXCIsZXBEZWZzOlwidGFyZ2V0RW5kcG9pbnREZWZpbml0aW9uc1wifV07dmFyIF9zZXQ9ZnVuY3Rpb24oYyxlbCxpZHgsZG9Ob3RSZXBhaW50KXt2YXIgZXAsX3N0PXN0VHlwZXNbaWR4XSxjSWQ9Y1tfc3QuZWxJZF0sY0VsPWNbX3N0LmVsXSxzaWQsc2VwLG9sZEVuZHBvaW50PWMuZW5kcG9pbnRzW2lkeF07dmFyIGV2dFBhcmFtcz17aW5kZXg6aWR4LG9yaWdpbmFsU291cmNlSWQ6aWR4PT09MD9jSWQ6Yy5zb3VyY2VJZCxuZXdTb3VyY2VJZDpjLnNvdXJjZUlkLG9yaWdpbmFsVGFyZ2V0SWQ6aWR4PT09MT9jSWQ6Yy50YXJnZXRJZCxuZXdUYXJnZXRJZDpjLnRhcmdldElkLGNvbm5lY3Rpb246Y307aWYoZWwuY29uc3RydWN0b3I9PT1qc1BsdW1iLkVuZHBvaW50KXtlcD1lbDtlcC5hZGRDb25uZWN0aW9uKGMpO2VsPWVwLmVsZW1lbnQ7fWVsc2V7c2lkPV9nZXRJZChlbCk7c2VwPXRoaXNbX3N0LmVwRGVmc11bc2lkXTtpZihzaWQ9PT1jW19zdC5lbElkXSl7ZXA9bnVsbDsvLyBkb250IGNoYW5nZSBzb3VyY2UvdGFyZ2V0IGlmIHRoZSBlbGVtZW50IGlzIGFscmVhZHkgdGhlIG9uZSBnaXZlbi5cbn1lbHNlIGlmKHNlcCl7Zm9yKHZhciB0IGluIHNlcCl7aWYoIXNlcFt0XS5lbmFibGVkKXtyZXR1cm47fWVwPXNlcFt0XS5lbmRwb2ludCE9bnVsbCYmc2VwW3RdLmVuZHBvaW50Ll9qc1BsdW1iP3NlcFt0XS5lbmRwb2ludDp0aGlzLmFkZEVuZHBvaW50KGVsLHNlcFt0XS5kZWYpO2lmKHNlcFt0XS51bmlxdWVFbmRwb2ludCl7c2VwW3RdLmVuZHBvaW50PWVwO31lcC5hZGRDb25uZWN0aW9uKGMpO319ZWxzZXtlcD1jLm1ha2VFbmRwb2ludChpZHg9PT0wLGVsLHNpZCk7fX1pZihlcCE9bnVsbCl7b2xkRW5kcG9pbnQuZGV0YWNoRnJvbUNvbm5lY3Rpb24oYyk7Yy5lbmRwb2ludHNbaWR4XT1lcDtjW19zdC5lbF09ZXAuZWxlbWVudDtjW19zdC5lbElkXT1lcC5lbGVtZW50SWQ7ZXZ0UGFyYW1zW2lkeD09PTA/XCJuZXdTb3VyY2VJZFwiOlwibmV3VGFyZ2V0SWRcIl09ZXAuZWxlbWVudElkO2ZpcmVNb3ZlRXZlbnQoZXZ0UGFyYW1zKTtpZighZG9Ob3RSZXBhaW50KXtjLnJlcGFpbnQoKTt9fWV2dFBhcmFtcy5lbGVtZW50PWVsO3JldHVybiBldnRQYXJhbXM7fS5iaW5kKHRoaXMpO3RoaXMuc2V0U291cmNlPWZ1bmN0aW9uKGNvbm5lY3Rpb24sZWwsZG9Ob3RSZXBhaW50KXt2YXIgcD1fc2V0KGNvbm5lY3Rpb24sZWwsMCxkb05vdFJlcGFpbnQpO3RoaXMuYW5jaG9yTWFuYWdlci5zb3VyY2VDaGFuZ2VkKHAub3JpZ2luYWxTb3VyY2VJZCxwLm5ld1NvdXJjZUlkLGNvbm5lY3Rpb24scC5lbCk7fTt0aGlzLnNldFRhcmdldD1mdW5jdGlvbihjb25uZWN0aW9uLGVsLGRvTm90UmVwYWludCl7dmFyIHA9X3NldChjb25uZWN0aW9uLGVsLDEsZG9Ob3RSZXBhaW50KTt0aGlzLmFuY2hvck1hbmFnZXIudXBkYXRlT3RoZXJFbmRwb2ludChwLm9yaWdpbmFsU291cmNlSWQscC5vcmlnaW5hbFRhcmdldElkLHAubmV3VGFyZ2V0SWQsY29ubmVjdGlvbik7fTt0aGlzLmRlbGV0ZUVuZHBvaW50PWZ1bmN0aW9uKG9iamVjdCxkb250VXBkYXRlSG92ZXIsZGVsZXRlQXR0YWNoZWRPYmplY3RzKXt2YXIgZW5kcG9pbnQ9dHlwZW9mIG9iamVjdD09PVwic3RyaW5nXCI/ZW5kcG9pbnRzQnlVVUlEW29iamVjdF06b2JqZWN0O2lmKGVuZHBvaW50KXtfY3VycmVudEluc3RhbmNlLmRlbGV0ZU9iamVjdCh7ZW5kcG9pbnQ6ZW5kcG9pbnQsZG9udFVwZGF0ZUhvdmVyOmRvbnRVcGRhdGVIb3ZlcixkZWxldGVBdHRhY2hlZE9iamVjdHM6ZGVsZXRlQXR0YWNoZWRPYmplY3RzfSk7fXJldHVybiBfY3VycmVudEluc3RhbmNlO307dGhpcy5kZWxldGVFdmVyeUVuZHBvaW50PWZ1bmN0aW9uKCl7dmFyIF9pcz1fY3VycmVudEluc3RhbmNlLnNldFN1c3BlbmREcmF3aW5nKHRydWUpO2Zvcih2YXIgaWQgaW4gZW5kcG9pbnRzQnlFbGVtZW50KXt2YXIgZW5kcG9pbnRzPWVuZHBvaW50c0J5RWxlbWVudFtpZF07aWYoZW5kcG9pbnRzJiZlbmRwb2ludHMubGVuZ3RoKXtmb3IodmFyIGk9MCxqPWVuZHBvaW50cy5sZW5ndGg7aTxqO2krKyl7X2N1cnJlbnRJbnN0YW5jZS5kZWxldGVFbmRwb2ludChlbmRwb2ludHNbaV0sdHJ1ZSk7fX19ZW5kcG9pbnRzQnlFbGVtZW50PXt9O21hbmFnZWRFbGVtZW50cz17fTtlbmRwb2ludHNCeVVVSUQ9e307b2Zmc2V0cz17fTtvZmZzZXRUaW1lc3RhbXBzPXt9O19jdXJyZW50SW5zdGFuY2UuYW5jaG9yTWFuYWdlci5yZXNldCgpO3ZhciBkbT1fY3VycmVudEluc3RhbmNlLmdldERyYWdNYW5hZ2VyKCk7aWYoZG0pe2RtLnJlc2V0KCk7fWlmKCFfaXMpe19jdXJyZW50SW5zdGFuY2Uuc2V0U3VzcGVuZERyYXdpbmcoZmFsc2UpO31yZXR1cm4gX2N1cnJlbnRJbnN0YW5jZTt9O3ZhciBmaXJlRGV0YWNoRXZlbnQ9ZnVuY3Rpb24gZmlyZURldGFjaEV2ZW50KGpwYyxkb0ZpcmVFdmVudCxvcmlnaW5hbEV2ZW50KXsvLyBtYXkgaGF2ZSBiZWVuIGdpdmVuIGEgY29ubmVjdGlvbiwgb3IgaW4gc3BlY2lhbCBjYXNlcywgYW4gb2JqZWN0XG52YXIgY29ublR5cGU9X2N1cnJlbnRJbnN0YW5jZS5EZWZhdWx0cy5Db25uZWN0aW9uVHlwZXx8X2N1cnJlbnRJbnN0YW5jZS5nZXREZWZhdWx0Q29ubmVjdGlvblR5cGUoKSxhcmdJc0Nvbm5lY3Rpb249anBjLmNvbnN0cnVjdG9yPT09Y29ublR5cGUscGFyYW1zPWFyZ0lzQ29ubmVjdGlvbj97Y29ubmVjdGlvbjpqcGMsc291cmNlOmpwYy5zb3VyY2UsdGFyZ2V0OmpwYy50YXJnZXQsc291cmNlSWQ6anBjLnNvdXJjZUlkLHRhcmdldElkOmpwYy50YXJnZXRJZCxzb3VyY2VFbmRwb2ludDpqcGMuZW5kcG9pbnRzWzBdLHRhcmdldEVuZHBvaW50OmpwYy5lbmRwb2ludHNbMV19OmpwYztpZihkb0ZpcmVFdmVudCl7X2N1cnJlbnRJbnN0YW5jZS5maXJlKFwiY29ubmVjdGlvbkRldGFjaGVkXCIscGFyYW1zLG9yaWdpbmFsRXZlbnQpO30vLyBhbHdheXMgZmlyZSB0aGlzLiB1c2VkIGJ5IGludGVybmFsIGpzcGx1bWIgc3R1ZmYuXG5fY3VycmVudEluc3RhbmNlLmZpcmUoXCJpbnRlcm5hbC5jb25uZWN0aW9uRGV0YWNoZWRcIixwYXJhbXMsb3JpZ2luYWxFdmVudCk7X2N1cnJlbnRJbnN0YW5jZS5hbmNob3JNYW5hZ2VyLmNvbm5lY3Rpb25EZXRhY2hlZChwYXJhbXMpO307dmFyIGZpcmVNb3ZlRXZlbnQ9X2N1cnJlbnRJbnN0YW5jZS5maXJlTW92ZUV2ZW50PWZ1bmN0aW9uKHBhcmFtcyxldnQpe19jdXJyZW50SW5zdGFuY2UuZmlyZShcImNvbm5lY3Rpb25Nb3ZlZFwiLHBhcmFtcyxldnQpO307dGhpcy51bnJlZ2lzdGVyRW5kcG9pbnQ9ZnVuY3Rpb24oZW5kcG9pbnQpe2lmKGVuZHBvaW50Ll9qc1BsdW1iLnV1aWQpe2VuZHBvaW50c0J5VVVJRFtlbmRwb2ludC5fanNQbHVtYi51dWlkXT1udWxsO31fY3VycmVudEluc3RhbmNlLmFuY2hvck1hbmFnZXIuZGVsZXRlRW5kcG9pbnQoZW5kcG9pbnQpOy8vIFRPRE8gYXQgbGVhc3QgcmVwbGFjZSB0aGlzIHdpdGggYSByZW1vdmVXaXRoRnVuY3Rpb24gY2FsbC5cbmZvcih2YXIgZSBpbiBlbmRwb2ludHNCeUVsZW1lbnQpe3ZhciBlbmRwb2ludHM9ZW5kcG9pbnRzQnlFbGVtZW50W2VdO2lmKGVuZHBvaW50cyl7dmFyIG5ld0VuZHBvaW50cz1bXTtmb3IodmFyIGk9MCxqPWVuZHBvaW50cy5sZW5ndGg7aTxqO2krKyl7aWYoZW5kcG9pbnRzW2ldIT09ZW5kcG9pbnQpe25ld0VuZHBvaW50cy5wdXNoKGVuZHBvaW50c1tpXSk7fX1lbmRwb2ludHNCeUVsZW1lbnRbZV09bmV3RW5kcG9pbnRzO31pZihlbmRwb2ludHNCeUVsZW1lbnRbZV0ubGVuZ3RoPDEpe2RlbGV0ZSBlbmRwb2ludHNCeUVsZW1lbnRbZV07fX19O3ZhciBJU19ERVRBQ0hfQUxMT1dFRD1cImlzRGV0YWNoQWxsb3dlZFwiO3ZhciBCRUZPUkVfREVUQUNIPVwiYmVmb3JlRGV0YWNoXCI7dmFyIENIRUNLX0NPTkRJVElPTj1cImNoZWNrQ29uZGl0aW9uXCI7LyoqXHJcbiAgICAgICAgICogRGVsZXRlcyBhIENvbm5lY3Rpb24uXHJcbiAgICAgICAgICogQG1ldGhvZCBkZWxldGVDb25uZWN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIGNvbm5lY3Rpb24gQ29ubmVjdGlvbiB0byBkZWxldGVcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gT3B0aW9uYWwgZGVsZXRlIHBhcmFtZXRlcnNcclxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbXMuZG9Ob3RGaXJlRXZlbnQ9ZmFsc2VdIElmIHRydWUsIGEgY29ubmVjdGlvbiBkZXRhY2hlZCBldmVudCB3aWxsIG5vdCBiZSBmaXJlZC4gT3RoZXJ3aXNlIG9uZSB3aWxsLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtcy5mb3JjZT1mYWxzZV0gSWYgdHJ1ZSwgdGhlIGNvbm5lY3Rpb24gd2lsbCBiZSBkZWxldGVkIGV2ZW4gaWYgYSBiZWZvcmVEZXRhY2ggaW50ZXJjZXB0b3IgdHJpZXMgdG8gc3RvcCB0aGUgZGVsZXRpb24uXHJcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIGNvbm5lY3Rpb24gd2FzIGRlbGV0ZWQsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAgICAgKi90aGlzLmRlbGV0ZUNvbm5lY3Rpb249ZnVuY3Rpb24oY29ubmVjdGlvbixwYXJhbXMpe2lmKGNvbm5lY3Rpb24hPW51bGwpe3BhcmFtcz1wYXJhbXN8fHt9O2lmKHBhcmFtcy5mb3JjZXx8X2p1LmZ1bmN0aW9uQ2hhaW4odHJ1ZSxmYWxzZSxbW2Nvbm5lY3Rpb24uZW5kcG9pbnRzWzBdLElTX0RFVEFDSF9BTExPV0VELFtjb25uZWN0aW9uXV0sW2Nvbm5lY3Rpb24uZW5kcG9pbnRzWzFdLElTX0RFVEFDSF9BTExPV0VELFtjb25uZWN0aW9uXV0sW2Nvbm5lY3Rpb24sSVNfREVUQUNIX0FMTE9XRUQsW2Nvbm5lY3Rpb25dXSxbX2N1cnJlbnRJbnN0YW5jZSxDSEVDS19DT05ESVRJT04sW0JFRk9SRV9ERVRBQ0gsY29ubmVjdGlvbl1dXSkpe2Nvbm5lY3Rpb24uc2V0SG92ZXIoZmFsc2UpO2ZpcmVEZXRhY2hFdmVudChjb25uZWN0aW9uLCFjb25uZWN0aW9uLnBlbmRpbmcmJnBhcmFtcy5maXJlRXZlbnQhPT1mYWxzZSxwYXJhbXMub3JpZ2luYWxFdmVudCk7Y29ubmVjdGlvbi5lbmRwb2ludHNbMF0uZGV0YWNoRnJvbUNvbm5lY3Rpb24oY29ubmVjdGlvbik7Y29ubmVjdGlvbi5lbmRwb2ludHNbMV0uZGV0YWNoRnJvbUNvbm5lY3Rpb24oY29ubmVjdGlvbik7X2p1LnJlbW92ZVdpdGhGdW5jdGlvbihjb25uZWN0aW9ucyxmdW5jdGlvbihfYyl7cmV0dXJuIGNvbm5lY3Rpb24uaWQ9PT1fYy5pZDt9KTtjb25uZWN0aW9uLmNsZWFudXAoKTtjb25uZWN0aW9uLmRlc3Ryb3koKTtyZXR1cm4gdHJ1ZTt9fXJldHVybiBmYWxzZTt9Oy8qKlxyXG4gICAgICAgICAqIFJlbW92ZSBhbGwgQ29ubmVjdGlvbnMgZnJvbSBhbGwgZWxlbWVudHMsIGJ1dCBsZWF2ZXMgRW5kcG9pbnRzIGluIHBsYWNlICgodW5sZXNzIGEgY29ubmVjdGlvbiBpcyBzZXQgdG8gYXV0byBkZWxldGUgaXRzIEVuZHBvaW50cykuXHJcbiAgICAgICAgICogQG1ldGhvZCBkZWxldGVFdmVyeUNvbm5lY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gb3B0aW9uYWwgcGFyYW1zIG9iamVjdCBmb3IgdGhlIGNhbGxcclxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbXMuZmlyZUV2ZW50PXRydWVdIFdoZXRoZXIgb3Igbm90IHRvIGZpcmUgZGV0YWNoIGV2ZW50c1xyXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtcy5mb3JjZURldGFjaD1mYWxzZV0gSWYgdHJ1ZSwgdGhpcyBjYWxsIHdpbGwgaWdub3JlIGFueSBgYmVmb3JlRGV0YWNoYCBpbnRlcmNlcHRvcnMuXHJcbiAgICAgICAgICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBjb25uZWN0aW9ucyB0aGF0IHdlcmUgZGVsZXRlZC5cclxuICAgICAgICAgKi90aGlzLmRlbGV0ZUV2ZXJ5Q29ubmVjdGlvbj1mdW5jdGlvbihwYXJhbXMpe3BhcmFtcz1wYXJhbXN8fHt9O3ZhciBjb3VudD1jb25uZWN0aW9ucy5sZW5ndGgsZGVsZXRlZENvdW50PTA7X2N1cnJlbnRJbnN0YW5jZS5iYXRjaChmdW5jdGlvbigpe2Zvcih2YXIgaT0wO2k8Y291bnQ7aSsrKXtkZWxldGVkQ291bnQrPV9jdXJyZW50SW5zdGFuY2UuZGVsZXRlQ29ubmVjdGlvbihjb25uZWN0aW9uc1swXSxwYXJhbXMpPzE6MDt9fSk7cmV0dXJuIGRlbGV0ZWRDb3VudDt9Oy8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgYWxsIGFuIGVsZW1lbnQncyBDb25uZWN0aW9ucy5cclxuICAgICAgICAgKiBAbWV0aG9kIGRlbGV0ZUNvbm5lY3Rpb25zRm9yRWxlbWVudFxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbCBFaXRoZXIgdGhlIGlkIG9mIHRoZSBlbGVtZW50LCBvciBhIHNlbGVjdG9yIGZvciB0aGUgZWxlbWVudC5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gT3B0aW9uYWwgcGFyYW1ldGVycy5cclxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbXMuZmlyZUV2ZW50PXRydWVdIFdoZXRoZXIgb3Igbm90IHRvIGZpcmUgdGhlIGRldGFjaCBldmVudC5cclxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbXMuZm9yY2VEZXRhY2g9ZmFsc2VdIElmIHRydWUsIHRoaXMgY2FsbCB3aWxsIGlnbm9yZSBhbnkgYGJlZm9yZURldGFjaGAgaW50ZXJjZXB0b3JzLlxyXG4gICAgICAgICAqIEByZXR1cm4ge2pzUGx1bWJJbnN0YW5jZX0gVGhlIGN1cnJlbnQganNQbHVtYiBpbnN0YW5jZS5cclxuICAgICAgICAgKi90aGlzLmRlbGV0ZUNvbm5lY3Rpb25zRm9yRWxlbWVudD1mdW5jdGlvbihlbCxwYXJhbXMpe3BhcmFtcz1wYXJhbXN8fHt9O2VsPV9jdXJyZW50SW5zdGFuY2UuZ2V0RWxlbWVudChlbCk7dmFyIGlkPV9nZXRJZChlbCksZW5kcG9pbnRzPWVuZHBvaW50c0J5RWxlbWVudFtpZF07aWYoZW5kcG9pbnRzJiZlbmRwb2ludHMubGVuZ3RoKXtmb3IodmFyIGk9MCxqPWVuZHBvaW50cy5sZW5ndGg7aTxqO2krKyl7ZW5kcG9pbnRzW2ldLmRlbGV0ZUV2ZXJ5Q29ubmVjdGlvbihwYXJhbXMpO319cmV0dXJuIF9jdXJyZW50SW5zdGFuY2U7fTsvLy8gbm90IHB1YmxpYy4gIGJ1dCBvZiBjb3Vyc2UgaXRzIGV4cG9zZWQuIGhvdyB0byBjaGFuZ2UgdGhpcy5cbnRoaXMuZGVsZXRlT2JqZWN0PWZ1bmN0aW9uKHBhcmFtcyl7dmFyIHJlc3VsdD17ZW5kcG9pbnRzOnt9LGNvbm5lY3Rpb25zOnt9LGVuZHBvaW50Q291bnQ6MCxjb25uZWN0aW9uQ291bnQ6MH0sZGVsZXRlQXR0YWNoZWRPYmplY3RzPXBhcmFtcy5kZWxldGVBdHRhY2hlZE9iamVjdHMhPT1mYWxzZTt2YXIgdW5yYXZlbENvbm5lY3Rpb249ZnVuY3Rpb24gdW5yYXZlbENvbm5lY3Rpb24oY29ubmVjdGlvbil7aWYoY29ubmVjdGlvbiE9bnVsbCYmcmVzdWx0LmNvbm5lY3Rpb25zW2Nvbm5lY3Rpb24uaWRdPT1udWxsKXtpZighcGFyYW1zLmRvbnRVcGRhdGVIb3ZlciYmY29ubmVjdGlvbi5fanNQbHVtYiE9bnVsbCl7Y29ubmVjdGlvbi5zZXRIb3ZlcihmYWxzZSk7fXJlc3VsdC5jb25uZWN0aW9uc1tjb25uZWN0aW9uLmlkXT1jb25uZWN0aW9uO3Jlc3VsdC5jb25uZWN0aW9uQ291bnQrKzt9fTt2YXIgdW5yYXZlbEVuZHBvaW50PWZ1bmN0aW9uIHVucmF2ZWxFbmRwb2ludChlbmRwb2ludCl7aWYoZW5kcG9pbnQhPW51bGwmJnJlc3VsdC5lbmRwb2ludHNbZW5kcG9pbnQuaWRdPT1udWxsKXtpZighcGFyYW1zLmRvbnRVcGRhdGVIb3ZlciYmZW5kcG9pbnQuX2pzUGx1bWIhPW51bGwpe2VuZHBvaW50LnNldEhvdmVyKGZhbHNlKTt9cmVzdWx0LmVuZHBvaW50c1tlbmRwb2ludC5pZF09ZW5kcG9pbnQ7cmVzdWx0LmVuZHBvaW50Q291bnQrKztpZihkZWxldGVBdHRhY2hlZE9iamVjdHMpe2Zvcih2YXIgaT0wO2k8ZW5kcG9pbnQuY29ubmVjdGlvbnMubGVuZ3RoO2krKyl7dmFyIGM9ZW5kcG9pbnQuY29ubmVjdGlvbnNbaV07dW5yYXZlbENvbm5lY3Rpb24oYyk7fX19fTtpZihwYXJhbXMuY29ubmVjdGlvbil7dW5yYXZlbENvbm5lY3Rpb24ocGFyYW1zLmNvbm5lY3Rpb24pO31lbHNle3VucmF2ZWxFbmRwb2ludChwYXJhbXMuZW5kcG9pbnQpO30vLyBsb29wIHRocm91Z2ggY29ubmVjdGlvbnNcbmZvcih2YXIgaSBpbiByZXN1bHQuY29ubmVjdGlvbnMpe3ZhciBjPXJlc3VsdC5jb25uZWN0aW9uc1tpXTtpZihjLl9qc1BsdW1iKXtfanUucmVtb3ZlV2l0aEZ1bmN0aW9uKGNvbm5lY3Rpb25zLGZ1bmN0aW9uKF9jKXtyZXR1cm4gYy5pZD09PV9jLmlkO30pO2ZpcmVEZXRhY2hFdmVudChjLHBhcmFtcy5maXJlRXZlbnQ9PT1mYWxzZT9mYWxzZTohYy5wZW5kaW5nLHBhcmFtcy5vcmlnaW5hbEV2ZW50KTt2YXIgZG9Ob3RDbGVhbnVwPXBhcmFtcy5kZWxldGVBdHRhY2hlZE9iamVjdHM9PW51bGw/bnVsbDohcGFyYW1zLmRlbGV0ZUF0dGFjaGVkT2JqZWN0cztjLmVuZHBvaW50c1swXS5kZXRhY2hGcm9tQ29ubmVjdGlvbihjLG51bGwsZG9Ob3RDbGVhbnVwKTtjLmVuZHBvaW50c1sxXS5kZXRhY2hGcm9tQ29ubmVjdGlvbihjLG51bGwsZG9Ob3RDbGVhbnVwKTtjLmNsZWFudXAodHJ1ZSk7Yy5kZXN0cm95KHRydWUpO319Ly8gbG9vcCB0aHJvdWdoIGVuZHBvaW50c1xuZm9yKHZhciBqIGluIHJlc3VsdC5lbmRwb2ludHMpe3ZhciBlPXJlc3VsdC5lbmRwb2ludHNbal07aWYoZS5fanNQbHVtYil7X2N1cnJlbnRJbnN0YW5jZS51bnJlZ2lzdGVyRW5kcG9pbnQoZSk7Ly8gRklSRSBzb21lIGVuZHBvaW50IGRlbGV0ZWQgZXZlbnQ/XG5lLmNsZWFudXAodHJ1ZSk7ZS5kZXN0cm95KHRydWUpO319cmV0dXJuIHJlc3VsdDt9O3RoaXMuZHJhZ2dhYmxlPWZ1bmN0aW9uKGVsLG9wdGlvbnMpe3ZhciBpbmZvO19lYWNoKGZ1bmN0aW9uKF9lbCl7aW5mbz1faW5mbyhfZWwpO2lmKGluZm8uZWwpe19pbml0RHJhZ2dhYmxlSWZOZWNlc3NhcnkoaW5mby5lbCx0cnVlLG9wdGlvbnMsaW5mby5pZCx0cnVlKTt9fSxlbCk7cmV0dXJuIF9jdXJyZW50SW5zdGFuY2U7fTt0aGlzLmRyb3BwYWJsZT1mdW5jdGlvbihlbCxvcHRpb25zKXt2YXIgaW5mbztvcHRpb25zPW9wdGlvbnN8fHt9O29wdGlvbnMuYWxsb3dMb29wYmFjaz1mYWxzZTtfZWFjaChmdW5jdGlvbihfZWwpe2luZm89X2luZm8oX2VsKTtpZihpbmZvLmVsKXtfY3VycmVudEluc3RhbmNlLmluaXREcm9wcGFibGUoaW5mby5lbCxvcHRpb25zKTt9fSxlbCk7cmV0dXJuIF9jdXJyZW50SW5zdGFuY2U7fTsvLyBoZWxwZXJzIGZvciBzZWxlY3Qvc2VsZWN0RW5kcG9pbnRzXG52YXIgX3NldE9wZXJhdGlvbj1mdW5jdGlvbiBfc2V0T3BlcmF0aW9uKGxpc3QsZnVuYyxhcmdzLHNlbGVjdG9yKXtmb3IodmFyIGk9MCxqPWxpc3QubGVuZ3RoO2k8ajtpKyspe2xpc3RbaV1bZnVuY10uYXBwbHkobGlzdFtpXSxhcmdzKTt9cmV0dXJuIHNlbGVjdG9yKGxpc3QpO30sX2dldE9wZXJhdGlvbj1mdW5jdGlvbiBfZ2V0T3BlcmF0aW9uKGxpc3QsZnVuYyxhcmdzKXt2YXIgb3V0PVtdO2Zvcih2YXIgaT0wLGo9bGlzdC5sZW5ndGg7aTxqO2krKyl7b3V0LnB1c2goW2xpc3RbaV1bZnVuY10uYXBwbHkobGlzdFtpXSxhcmdzKSxsaXN0W2ldXSk7fXJldHVybiBvdXQ7fSxzZXR0ZXI9ZnVuY3Rpb24gc2V0dGVyKGxpc3QsZnVuYyxzZWxlY3Rvcil7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIF9zZXRPcGVyYXRpb24obGlzdCxmdW5jLGFyZ3VtZW50cyxzZWxlY3Rvcik7fTt9LGdldHRlcj1mdW5jdGlvbiBnZXR0ZXIobGlzdCxmdW5jKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gX2dldE9wZXJhdGlvbihsaXN0LGZ1bmMsYXJndW1lbnRzKTt9O30scHJlcGFyZUxpc3Q9ZnVuY3Rpb24gcHJlcGFyZUxpc3QoaW5wdXQsZG9Ob3RHZXRJZHMpe3ZhciByPVtdO2lmKGlucHV0KXtpZih0eXBlb2YgaW5wdXQ9PT0nc3RyaW5nJyl7aWYoaW5wdXQ9PT1cIipcIil7cmV0dXJuIGlucHV0O31yLnB1c2goaW5wdXQpO31lbHNle2lmKGRvTm90R2V0SWRzKXtyPWlucHV0O31lbHNle2lmKGlucHV0Lmxlbmd0aCl7Zm9yKHZhciBpPTAsaj1pbnB1dC5sZW5ndGg7aTxqO2krKyl7ci5wdXNoKF9pbmZvKGlucHV0W2ldKS5pZCk7fX1lbHNle3IucHVzaChfaW5mbyhpbnB1dCkuaWQpO319fX1yZXR1cm4gcjt9LGZpbHRlckxpc3Q9ZnVuY3Rpb24gZmlsdGVyTGlzdChsaXN0LHZhbHVlLG1pc3NpbmdJc0ZhbHNlKXtpZihsaXN0PT09XCIqXCIpe3JldHVybiB0cnVlO31yZXR1cm4gbGlzdC5sZW5ndGg+MD9saXN0LmluZGV4T2YodmFsdWUpIT09LTE6IW1pc3NpbmdJc0ZhbHNlO307Ly8gZ2V0IHNvbWUgY29ubmVjdGlvbnMsIHNwZWNpZnlpbmcgc291cmNlL3RhcmdldC9zY29wZVxudGhpcy5nZXRDb25uZWN0aW9ucz1mdW5jdGlvbihvcHRpb25zLGZsYXQpe2lmKCFvcHRpb25zKXtvcHRpb25zPXt9O31lbHNlIGlmKG9wdGlvbnMuY29uc3RydWN0b3I9PT1TdHJpbmcpe29wdGlvbnM9e1wic2NvcGVcIjpvcHRpb25zfTt9dmFyIHNjb3BlPW9wdGlvbnMuc2NvcGV8fF9jdXJyZW50SW5zdGFuY2UuZ2V0RGVmYXVsdFNjb3BlKCksc2NvcGVzPXByZXBhcmVMaXN0KHNjb3BlLHRydWUpLHNvdXJjZXM9cHJlcGFyZUxpc3Qob3B0aW9ucy5zb3VyY2UpLHRhcmdldHM9cHJlcGFyZUxpc3Qob3B0aW9ucy50YXJnZXQpLHJlc3VsdHM9IWZsYXQmJnNjb3Blcy5sZW5ndGg+MT97fTpbXSxfYWRkT25lPWZ1bmN0aW9uIF9hZGRPbmUoc2NvcGUsb2JqKXtpZighZmxhdCYmc2NvcGVzLmxlbmd0aD4xKXt2YXIgc3M9cmVzdWx0c1tzY29wZV07aWYoc3M9PW51bGwpe3NzPXJlc3VsdHNbc2NvcGVdPVtdO31zcy5wdXNoKG9iaik7fWVsc2V7cmVzdWx0cy5wdXNoKG9iaik7fX07Zm9yKHZhciBqPTAsamo9Y29ubmVjdGlvbnMubGVuZ3RoO2o8amo7aisrKXt2YXIgYz1jb25uZWN0aW9uc1tqXSxzb3VyY2VJZD1jLnByb3hpZXMmJmMucHJveGllc1swXT9jLnByb3hpZXNbMF0ub3JpZ2luYWxFcC5lbGVtZW50SWQ6Yy5zb3VyY2VJZCx0YXJnZXRJZD1jLnByb3hpZXMmJmMucHJveGllc1sxXT9jLnByb3hpZXNbMV0ub3JpZ2luYWxFcC5lbGVtZW50SWQ6Yy50YXJnZXRJZDtpZihmaWx0ZXJMaXN0KHNjb3BlcyxjLnNjb3BlKSYmZmlsdGVyTGlzdChzb3VyY2VzLHNvdXJjZUlkKSYmZmlsdGVyTGlzdCh0YXJnZXRzLHRhcmdldElkKSl7X2FkZE9uZShjLnNjb3BlLGMpO319cmV0dXJuIHJlc3VsdHM7fTt2YXIgX2N1cnJ5RWFjaD1mdW5jdGlvbiBfY3VycnlFYWNoKGxpc3QsZXhlY3V0b3Ipe3JldHVybiBmdW5jdGlvbihmKXtmb3IodmFyIGk9MCxpaT1saXN0Lmxlbmd0aDtpPGlpO2krKyl7ZihsaXN0W2ldKTt9cmV0dXJuIGV4ZWN1dG9yKGxpc3QpO307fSxfY3VycnlHZXQ9ZnVuY3Rpb24gX2N1cnJ5R2V0KGxpc3Qpe3JldHVybiBmdW5jdGlvbihpZHgpe3JldHVybiBsaXN0W2lkeF07fTt9O3ZhciBfbWFrZUNvbW1vblNlbGVjdEhhbmRsZXI9ZnVuY3Rpb24gX21ha2VDb21tb25TZWxlY3RIYW5kbGVyKGxpc3QsZXhlY3V0b3Ipe3ZhciBvdXQ9e2xlbmd0aDpsaXN0Lmxlbmd0aCxlYWNoOl9jdXJyeUVhY2gobGlzdCxleGVjdXRvciksZ2V0Ol9jdXJyeUdldChsaXN0KX0sc2V0dGVycz1bXCJzZXRIb3ZlclwiLFwicmVtb3ZlQWxsT3ZlcmxheXNcIixcInNldExhYmVsXCIsXCJhZGRDbGFzc1wiLFwiYWRkT3ZlcmxheVwiLFwicmVtb3ZlT3ZlcmxheVwiLFwicmVtb3ZlT3ZlcmxheXNcIixcInNob3dPdmVybGF5XCIsXCJoaWRlT3ZlcmxheVwiLFwic2hvd092ZXJsYXlzXCIsXCJoaWRlT3ZlcmxheXNcIixcInNldFBhaW50U3R5bGVcIixcInNldEhvdmVyUGFpbnRTdHlsZVwiLFwic2V0U3VzcGVuZEV2ZW50c1wiLFwic2V0UGFyYW1ldGVyXCIsXCJzZXRQYXJhbWV0ZXJzXCIsXCJzZXRWaXNpYmxlXCIsXCJyZXBhaW50XCIsXCJhZGRUeXBlXCIsXCJ0b2dnbGVUeXBlXCIsXCJyZW1vdmVUeXBlXCIsXCJyZW1vdmVDbGFzc1wiLFwic2V0VHlwZVwiLFwiYmluZFwiLFwidW5iaW5kXCJdLGdldHRlcnM9W1wiZ2V0TGFiZWxcIixcImdldE92ZXJsYXlcIixcImlzSG92ZXJcIixcImdldFBhcmFtZXRlclwiLFwiZ2V0UGFyYW1ldGVyc1wiLFwiZ2V0UGFpbnRTdHlsZVwiLFwiZ2V0SG92ZXJQYWludFN0eWxlXCIsXCJpc1Zpc2libGVcIixcImhhc1R5cGVcIixcImdldFR5cGVcIixcImlzU3VzcGVuZEV2ZW50c1wiXSxpLGlpO2ZvcihpPTAsaWk9c2V0dGVycy5sZW5ndGg7aTxpaTtpKyspe291dFtzZXR0ZXJzW2ldXT1zZXR0ZXIobGlzdCxzZXR0ZXJzW2ldLGV4ZWN1dG9yKTt9Zm9yKGk9MCxpaT1nZXR0ZXJzLmxlbmd0aDtpPGlpO2krKyl7b3V0W2dldHRlcnNbaV1dPWdldHRlcihsaXN0LGdldHRlcnNbaV0pO31yZXR1cm4gb3V0O307dmFyIF9tYWtlQ29ubmVjdGlvblNlbGVjdEhhbmRsZXI9ZnVuY3Rpb24gX21ha2VDb25uZWN0aW9uU2VsZWN0SGFuZGxlcihsaXN0KXt2YXIgY29tbW9uPV9tYWtlQ29tbW9uU2VsZWN0SGFuZGxlcihsaXN0LF9tYWtlQ29ubmVjdGlvblNlbGVjdEhhbmRsZXIpO3JldHVybiBqc1BsdW1iLmV4dGVuZChjb21tb24sey8vIHNldHRlcnNcbnNldERldGFjaGFibGU6c2V0dGVyKGxpc3QsXCJzZXREZXRhY2hhYmxlXCIsX21ha2VDb25uZWN0aW9uU2VsZWN0SGFuZGxlciksc2V0UmVhdHRhY2g6c2V0dGVyKGxpc3QsXCJzZXRSZWF0dGFjaFwiLF9tYWtlQ29ubmVjdGlvblNlbGVjdEhhbmRsZXIpLHNldENvbm5lY3RvcjpzZXR0ZXIobGlzdCxcInNldENvbm5lY3RvclwiLF9tYWtlQ29ubmVjdGlvblNlbGVjdEhhbmRsZXIpLGRlbGV0ZTpmdW5jdGlvbiBfZGVsZXRlKCl7Zm9yKHZhciBpPTAsaWk9bGlzdC5sZW5ndGg7aTxpaTtpKyspe19jdXJyZW50SW5zdGFuY2UuZGVsZXRlQ29ubmVjdGlvbihsaXN0W2ldKTt9fSwvLyBnZXR0ZXJzXG5pc0RldGFjaGFibGU6Z2V0dGVyKGxpc3QsXCJpc0RldGFjaGFibGVcIiksaXNSZWF0dGFjaDpnZXR0ZXIobGlzdCxcImlzUmVhdHRhY2hcIil9KTt9O3ZhciBfbWFrZUVuZHBvaW50U2VsZWN0SGFuZGxlcj1mdW5jdGlvbiBfbWFrZUVuZHBvaW50U2VsZWN0SGFuZGxlcihsaXN0KXt2YXIgY29tbW9uPV9tYWtlQ29tbW9uU2VsZWN0SGFuZGxlcihsaXN0LF9tYWtlRW5kcG9pbnRTZWxlY3RIYW5kbGVyKTtyZXR1cm4ganNQbHVtYi5leHRlbmQoY29tbW9uLHtzZXRFbmFibGVkOnNldHRlcihsaXN0LFwic2V0RW5hYmxlZFwiLF9tYWtlRW5kcG9pbnRTZWxlY3RIYW5kbGVyKSxzZXRBbmNob3I6c2V0dGVyKGxpc3QsXCJzZXRBbmNob3JcIixfbWFrZUVuZHBvaW50U2VsZWN0SGFuZGxlciksaXNFbmFibGVkOmdldHRlcihsaXN0LFwiaXNFbmFibGVkXCIpLGRlbGV0ZUV2ZXJ5Q29ubmVjdGlvbjpmdW5jdGlvbiBkZWxldGVFdmVyeUNvbm5lY3Rpb24oKXtmb3IodmFyIGk9MCxpaT1saXN0Lmxlbmd0aDtpPGlpO2krKyl7bGlzdFtpXS5kZWxldGVFdmVyeUNvbm5lY3Rpb24oKTt9fSxcImRlbGV0ZVwiOmZ1bmN0aW9uIF9kZWxldGUoKXtmb3IodmFyIGk9MCxpaT1saXN0Lmxlbmd0aDtpPGlpO2krKyl7X2N1cnJlbnRJbnN0YW5jZS5kZWxldGVFbmRwb2ludChsaXN0W2ldKTt9fX0pO307dGhpcy5zZWxlY3Q9ZnVuY3Rpb24ocGFyYW1zKXtwYXJhbXM9cGFyYW1zfHx7fTtwYXJhbXMuc2NvcGU9cGFyYW1zLnNjb3BlfHxcIipcIjtyZXR1cm4gX21ha2VDb25uZWN0aW9uU2VsZWN0SGFuZGxlcihwYXJhbXMuY29ubmVjdGlvbnN8fF9jdXJyZW50SW5zdGFuY2UuZ2V0Q29ubmVjdGlvbnMocGFyYW1zLHRydWUpKTt9O3RoaXMuc2VsZWN0RW5kcG9pbnRzPWZ1bmN0aW9uKHBhcmFtcyl7cGFyYW1zPXBhcmFtc3x8e307cGFyYW1zLnNjb3BlPXBhcmFtcy5zY29wZXx8XCIqXCI7dmFyIG5vRWxlbWVudEZpbHRlcnM9IXBhcmFtcy5lbGVtZW50JiYhcGFyYW1zLnNvdXJjZSYmIXBhcmFtcy50YXJnZXQsZWxlbWVudHM9bm9FbGVtZW50RmlsdGVycz9cIipcIjpwcmVwYXJlTGlzdChwYXJhbXMuZWxlbWVudCksc291cmNlcz1ub0VsZW1lbnRGaWx0ZXJzP1wiKlwiOnByZXBhcmVMaXN0KHBhcmFtcy5zb3VyY2UpLHRhcmdldHM9bm9FbGVtZW50RmlsdGVycz9cIipcIjpwcmVwYXJlTGlzdChwYXJhbXMudGFyZ2V0KSxzY29wZXM9cHJlcGFyZUxpc3QocGFyYW1zLnNjb3BlLHRydWUpO3ZhciBlcD1bXTtmb3IodmFyIGVsIGluIGVuZHBvaW50c0J5RWxlbWVudCl7dmFyIGVpdGhlcj1maWx0ZXJMaXN0KGVsZW1lbnRzLGVsLHRydWUpLHNvdXJjZT1maWx0ZXJMaXN0KHNvdXJjZXMsZWwsdHJ1ZSksc291cmNlTWF0Y2hFeGFjdD1zb3VyY2VzIT09XCIqXCIsdGFyZ2V0PWZpbHRlckxpc3QodGFyZ2V0cyxlbCx0cnVlKSx0YXJnZXRNYXRjaEV4YWN0PXRhcmdldHMhPT1cIipcIjsvLyBpZiB0aGV5IHJlcXVlc3RlZCAnZWl0aGVyJyB0aGVuIGp1c3QgbWF0Y2ggc2NvcGUuIG90aGVyd2lzZSBpZiB0aGV5IHJlcXVlc3RlZCAnc291cmNlJyAobm90IGFzIGEgd2lsZGNhcmQpIHRoZW4gd2UgaGF2ZSB0byBtYXRjaCBvbmx5IGVuZHBvaW50cyB0aGF0IGhhdmUgaXNTb3VyY2Ugc2V0IHRvIHRvIHRydWUsIGFuZCB0aGUgc2FtZSB0aGluZyB3aXRoIGlzVGFyZ2V0LlxuaWYoZWl0aGVyfHxzb3VyY2V8fHRhcmdldCl7aW5uZXI6Zm9yKHZhciBpPTAsaWk9ZW5kcG9pbnRzQnlFbGVtZW50W2VsXS5sZW5ndGg7aTxpaTtpKyspe3ZhciBfZXA9ZW5kcG9pbnRzQnlFbGVtZW50W2VsXVtpXTtpZihmaWx0ZXJMaXN0KHNjb3BlcyxfZXAuc2NvcGUsdHJ1ZSkpe3ZhciBub01hdGNoU291cmNlPXNvdXJjZU1hdGNoRXhhY3QmJnNvdXJjZXMubGVuZ3RoPjAmJiFfZXAuaXNTb3VyY2Usbm9NYXRjaFRhcmdldD10YXJnZXRNYXRjaEV4YWN0JiZ0YXJnZXRzLmxlbmd0aD4wJiYhX2VwLmlzVGFyZ2V0O2lmKG5vTWF0Y2hTb3VyY2V8fG5vTWF0Y2hUYXJnZXQpe2NvbnRpbnVlIGlubmVyO31lcC5wdXNoKF9lcCk7fX19fXJldHVybiBfbWFrZUVuZHBvaW50U2VsZWN0SGFuZGxlcihlcCk7fTsvLyBnZXQgYWxsIGNvbm5lY3Rpb25zIG1hbmFnZWQgYnkgdGhlIGluc3RhbmNlIG9mIGpzcGx1bWIuXG50aGlzLmdldEFsbENvbm5lY3Rpb25zPWZ1bmN0aW9uKCl7cmV0dXJuIGNvbm5lY3Rpb25zO307dGhpcy5nZXREZWZhdWx0U2NvcGU9ZnVuY3Rpb24oKXtyZXR1cm4gREVGQVVMVF9TQ09QRTt9Oy8vIGdldCBhbiBlbmRwb2ludCBieSB1dWlkLlxudGhpcy5nZXRFbmRwb2ludD1fZ2V0RW5kcG9pbnQ7LyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgbGlzdCBvZiBFbmRwb2ludHMgZm9yIGEgZ2l2ZW4gZWxlbWVudC5cclxuICAgICAgICAgKiBAbWV0aG9kIGdldEVuZHBvaW50c1xyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR8U2VsZWN0b3J9IGVsIFRoZSBlbGVtZW50IHRvIGdldCBlbmRwb2ludHMgZm9yLlxyXG4gICAgICAgICAqIEByZXR1cm4ge0VuZHBvaW50W119IEFuIGFycmF5IG9mIEVuZHBvaW50cyBmb3IgdGhlIHNwZWNpZmllZCBlbGVtZW50LlxyXG4gICAgICAgICAqL3RoaXMuZ2V0RW5kcG9pbnRzPWZ1bmN0aW9uKGVsKXtyZXR1cm4gZW5kcG9pbnRzQnlFbGVtZW50W19pbmZvKGVsKS5pZF18fFtdO307Ly8gZ2V0cyB0aGUgZGVmYXVsdCBlbmRwb2ludCB0eXBlLiB1c2VkIHdoZW4gc3ViY2xhc3NpbmcuIHNlZSB3aWtpLlxudGhpcy5nZXREZWZhdWx0RW5kcG9pbnRUeXBlPWZ1bmN0aW9uKCl7cmV0dXJuIGpzUGx1bWIuRW5kcG9pbnQ7fTsvLyBnZXRzIHRoZSBkZWZhdWx0IGNvbm5lY3Rpb24gdHlwZS4gdXNlZCB3aGVuIHN1YmNsYXNzaW5nLiAgc2VlIHdpa2kuXG50aGlzLmdldERlZmF1bHRDb25uZWN0aW9uVHlwZT1mdW5jdGlvbigpe3JldHVybiBqc1BsdW1iLkNvbm5lY3Rpb247fTsvKlxyXG4gICAgICAgICAqIEdldHMgYW4gZWxlbWVudCdzIGlkLCBjcmVhdGluZyBvbmUgaWYgbmVjZXNzYXJ5LiByZWFsbHkgb25seSBleHBvc2VkXHJcbiAgICAgICAgICogZm9yIHRoZSBsaWItc3BlY2lmaWMgZnVuY3Rpb25hbGl0eSB0byBhY2Nlc3M7IHdvdWxkIGJlIGJldHRlciB0byBwYXNzXHJcbiAgICAgICAgICogdGhlIGN1cnJlbnQgaW5zdGFuY2UgaW50byB0aGUgbGliLXNwZWNpZmljIGNvZGUgKGV2ZW4gdGhvdWdoIHRoaXMgaXNcclxuICAgICAgICAgKiBhIHN0YXRpYyBjYWxsLiBpIGp1c3QgZG9uJ3Qgd2FudCB0byBleHBvc2UgaXQgdG8gdGhlIHB1YmxpYyBBUEkpLlxyXG4gICAgICAgICAqL3RoaXMuZ2V0SWQ9X2dldElkO3RoaXMuYXBwZW5kRWxlbWVudD1fYXBwZW5kRWxlbWVudDt2YXIgX2hvdmVyU3VzcGVuZGVkPWZhbHNlO3RoaXMuaXNIb3ZlclN1c3BlbmRlZD1mdW5jdGlvbigpe3JldHVybiBfaG92ZXJTdXNwZW5kZWQ7fTt0aGlzLnNldEhvdmVyU3VzcGVuZGVkPWZ1bmN0aW9uKHMpe19ob3ZlclN1c3BlbmRlZD1zO307Ly8gc2V0IGFuIGVsZW1lbnQncyBjb25uZWN0aW9ucyB0byBiZSBoaWRkZW5cbnRoaXMuaGlkZT1mdW5jdGlvbihlbCxjaGFuZ2VFbmRwb2ludHMpe19zZXRWaXNpYmxlKGVsLFwibm9uZVwiLGNoYW5nZUVuZHBvaW50cyk7cmV0dXJuIF9jdXJyZW50SW5zdGFuY2U7fTsvLyBleHBvc2VkIGZvciBvdGhlciBvYmplY3RzIHRvIHVzZSB0byBnZXQgYSB1bmlxdWUgaWQuXG50aGlzLmlkc3RhbXA9X2lkc3RhbXA7Ly8gdGhpcy5jb25uZWN0b3JzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbi8vIHRoaXMucmVnaXN0ZXJDb25uZWN0b3JUeXBlID0gZnVuY3Rpb24gKGNvbm5lY3RvciwgbmFtZSkge1xuLy8gICAgIGNvbm5lY3RvclR5cGVzLnB1c2goW2Nvbm5lY3RvciwgbmFtZV0pO1xuLy8gfTtcbi8vIGVuc3VyZSB0aGF0LCBpZiB0aGUgY3VycmVudCBjb250YWluZXIgZXhpc3RzLCBpdCBpcyBhIERPTSBlbGVtZW50IGFuZCBub3QgYSBzZWxlY3Rvci5cbi8vIGlmIGl0IGRvZXMgbm90IGV4aXN0IGFuZCBgY2FuZGlkYXRlYCBpcyBzdXBwbGllZCwgdGhlIG9mZnNldCBwYXJlbnQgb2YgdGhhdCBlbGVtZW50IHdpbGwgYmUgc2V0IGFzIHRoZSBDb250YWluZXIuXG4vLyB0aGlzIGlzIHVzZWQgdG8gZG8gYSBiZXR0ZXIgZGVmYXVsdCBiZWhhdmlvdXIgZm9yIHRoZSBjYXNlIHRoYXQgdGhlIHVzZXIgaGFzIG5vdCBzZXQgYSBjb250YWluZXI6XG4vLyBhZGRFbmRwb2ludCwgbWFrZVNvdXJjZSwgbWFrZVRhcmdldCBhbmQgY29ubmVjdCBhbGwgY2FsbCB0aGlzIG1ldGhvZCB3aXRoIHRoZSBvZmZzZXRQYXJlbnQgb2YgdGhlXG4vLyBlbGVtZW50IGluIHF1ZXN0aW9uIChmb3IgY29ubmVjdCBpdCBpcyB0aGUgc291cmNlIGVsZW1lbnQpLiBTbyBpZiBubyBjb250YWluZXIgaXMgc2V0LCBpdCBpcyBpbmZlcnJlZFxuLy8gdG8gYmUgdGhlIG9mZnNldFBhcmVudCBvZiB0aGUgZmlyc3QgZWxlbWVudCB0aGUgdXNlciB0cmllcyB0byBjb25uZWN0LlxudmFyIF9lbnN1cmVDb250YWluZXI9ZnVuY3Rpb24gX2Vuc3VyZUNvbnRhaW5lcihjYW5kaWRhdGUpe2lmKCFfY29udGFpbmVyJiZjYW5kaWRhdGUpe3ZhciBjYW49X2N1cnJlbnRJbnN0YW5jZS5nZXRFbGVtZW50KGNhbmRpZGF0ZSk7aWYoY2FuLm9mZnNldFBhcmVudCl7X2N1cnJlbnRJbnN0YW5jZS5zZXRDb250YWluZXIoY2FuLm9mZnNldFBhcmVudCk7fX19O3ZhciBfZ2V0Q29udGFpbmVyRnJvbURlZmF1bHRzPWZ1bmN0aW9uIF9nZXRDb250YWluZXJGcm9tRGVmYXVsdHMoKXtpZihfY3VycmVudEluc3RhbmNlLkRlZmF1bHRzLkNvbnRhaW5lcil7X2N1cnJlbnRJbnN0YW5jZS5zZXRDb250YWluZXIoX2N1cnJlbnRJbnN0YW5jZS5EZWZhdWx0cy5Db250YWluZXIpO319Oy8vIGNoZWNrIGlmIGEgZ2l2ZW4gZWxlbWVudCBpcyBtYW5hZ2VkIG9yIG5vdC4gaWYgbm90LCBhZGQgdG8gb3VyIG1hcC4gaWYgZHJhd2luZyBpcyBub3Qgc3VzcGVuZGVkIHRoZW5cbi8vIHdlJ2xsIGFsc28gc3Rhc2ggaXRzIGRpbWVuc2lvbnM7IG90aGVyd2lzZSB3ZSdsbCBkbyB0aGlzIGluIGEgbGF6eSB3YXkgdGhyb3VnaCB1cGRhdGVPZmZzZXQuXG52YXIgX21hbmFnZT1fY3VycmVudEluc3RhbmNlLm1hbmFnZT1mdW5jdGlvbihpZCxlbGVtZW50LF90cmFuc2llbnQpe2lmKCFtYW5hZ2VkRWxlbWVudHNbaWRdKXttYW5hZ2VkRWxlbWVudHNbaWRdPXtlbDplbGVtZW50LGVuZHBvaW50czpbXSxjb25uZWN0aW9uczpbXX07bWFuYWdlZEVsZW1lbnRzW2lkXS5pbmZvPV91cGRhdGVPZmZzZXQoe2VsSWQ6aWQsdGltZXN0YW1wOl9zdXNwZW5kZWRBdH0pO2lmKCFfdHJhbnNpZW50KXtfY3VycmVudEluc3RhbmNlLmZpcmUoXCJtYW5hZ2VFbGVtZW50XCIse2lkOmlkLGluZm86bWFuYWdlZEVsZW1lbnRzW2lkXS5pbmZvLGVsOmVsZW1lbnR9KTt9fXJldHVybiBtYW5hZ2VkRWxlbWVudHNbaWRdO307dmFyIF91bm1hbmFnZT1mdW5jdGlvbiBfdW5tYW5hZ2UoaWQpe2lmKG1hbmFnZWRFbGVtZW50c1tpZF0pe2RlbGV0ZSBtYW5hZ2VkRWxlbWVudHNbaWRdO19jdXJyZW50SW5zdGFuY2UuZmlyZShcInVubWFuYWdlRWxlbWVudFwiLGlkKTt9fTsvKipcclxuICAgICAgICAgKiB1cGRhdGVzIHRoZSBvZmZzZXQgYW5kIHNpemUgZm9yIGEgZ2l2ZW4gZWxlbWVudCwgYW5kIHN0b3JlcyB0aGVcclxuICAgICAgICAgKiB2YWx1ZXMuIGlmICdvZmZzZXQnIGlzIG5vdCBudWxsIHdlIHVzZSB0aGF0IChpdCB3b3VsZCBoYXZlIGJlZW5cclxuICAgICAgICAgKiBwYXNzZWQgaW4gZnJvbSBhIGRyYWcgY2FsbCkgYmVjYXVzZSBpdCdzIGZhc3RlcjsgYnV0IGlmIGl0IGlzIG51bGwsXHJcbiAgICAgICAgICogb3IgaWYgJ3JlY2FsYycgaXMgdHJ1ZSBpbiBvcmRlciB0byBmb3JjZSBhIHJlY2FsY3VsYXRpb24sIHdlIGdldCB0aGUgY3VycmVudCB2YWx1ZXMuXHJcbiAgICAgICAgICovdmFyIF91cGRhdGVPZmZzZXQ9dGhpcy51cGRhdGVPZmZzZXQ9ZnVuY3Rpb24ocGFyYW1zKXt2YXIgdGltZXN0YW1wPXBhcmFtcy50aW1lc3RhbXAscmVjYWxjPXBhcmFtcy5yZWNhbGMsb2Zmc2V0PXBhcmFtcy5vZmZzZXQsZWxJZD1wYXJhbXMuZWxJZCxzO2lmKF9zdXNwZW5kRHJhd2luZyYmIXRpbWVzdGFtcCl7dGltZXN0YW1wPV9zdXNwZW5kZWRBdDt9aWYoIXJlY2FsYyl7aWYodGltZXN0YW1wJiZ0aW1lc3RhbXA9PT1vZmZzZXRUaW1lc3RhbXBzW2VsSWRdKXtyZXR1cm57bzpwYXJhbXMub2Zmc2V0fHxvZmZzZXRzW2VsSWRdLHM6c2l6ZXNbZWxJZF19O319aWYocmVjYWxjfHwhb2Zmc2V0JiZvZmZzZXRzW2VsSWRdPT1udWxsKXsvLyBpZiBmb3JjZWQgcmVwYWludCBvciBubyBvZmZzZXQgYXZhaWxhYmxlLCB3ZSByZWNhbGN1bGF0ZS5cbi8vIGdldCB0aGUgY3VycmVudCBzaXplIGFuZCBvZmZzZXQsIGFuZCBzdG9yZSB0aGVtXG5zPW1hbmFnZWRFbGVtZW50c1tlbElkXT9tYW5hZ2VkRWxlbWVudHNbZWxJZF0uZWw6bnVsbDtpZihzIT1udWxsKXtzaXplc1tlbElkXT1fY3VycmVudEluc3RhbmNlLmdldFNpemUocyk7b2Zmc2V0c1tlbElkXT1fY3VycmVudEluc3RhbmNlLmdldE9mZnNldChzKTtvZmZzZXRUaW1lc3RhbXBzW2VsSWRdPXRpbWVzdGFtcDt9fWVsc2V7b2Zmc2V0c1tlbElkXT1vZmZzZXR8fG9mZnNldHNbZWxJZF07aWYoc2l6ZXNbZWxJZF09PW51bGwpe3M9bWFuYWdlZEVsZW1lbnRzW2VsSWRdLmVsO2lmKHMhPW51bGwpe3NpemVzW2VsSWRdPV9jdXJyZW50SW5zdGFuY2UuZ2V0U2l6ZShzKTt9fW9mZnNldFRpbWVzdGFtcHNbZWxJZF09dGltZXN0YW1wO31pZihvZmZzZXRzW2VsSWRdJiYhb2Zmc2V0c1tlbElkXS5yaWdodCl7b2Zmc2V0c1tlbElkXS5yaWdodD1vZmZzZXRzW2VsSWRdLmxlZnQrc2l6ZXNbZWxJZF1bMF07b2Zmc2V0c1tlbElkXS5ib3R0b209b2Zmc2V0c1tlbElkXS50b3Arc2l6ZXNbZWxJZF1bMV07b2Zmc2V0c1tlbElkXS53aWR0aD1zaXplc1tlbElkXVswXTtvZmZzZXRzW2VsSWRdLmhlaWdodD1zaXplc1tlbElkXVsxXTtvZmZzZXRzW2VsSWRdLmNlbnRlcng9b2Zmc2V0c1tlbElkXS5sZWZ0K29mZnNldHNbZWxJZF0ud2lkdGgvMjtvZmZzZXRzW2VsSWRdLmNlbnRlcnk9b2Zmc2V0c1tlbElkXS50b3Arb2Zmc2V0c1tlbElkXS5oZWlnaHQvMjt9cmV0dXJue286b2Zmc2V0c1tlbElkXSxzOnNpemVzW2VsSWRdfTt9Oy8qKlxyXG4gICAgICAgICAqIGNhbGxiYWNrIGZyb20gdGhlIGN1cnJlbnQgbGlicmFyeSB0byB0ZWxsIHVzIHRvIHByZXBhcmUgb3Vyc2VsdmVzIChhdHRhY2hcclxuICAgICAgICAgKiBtb3VzZSBsaXN0ZW5lcnMgZXRjOyBjYW4ndCBkbyB0aGF0IHVudGlsIHRoZSBsaWJyYXJ5IGhhcyBwcm92aWRlZCBhIGJpbmQgbWV0aG9kKVxyXG4gICAgICAgICAqL3RoaXMuaW5pdD1mdW5jdGlvbigpe2lmKCFpbml0aWFsaXplZCl7X2dldENvbnRhaW5lckZyb21EZWZhdWx0cygpO19jdXJyZW50SW5zdGFuY2UuYW5jaG9yTWFuYWdlcj1uZXcgcm9vdC5qc1BsdW1iLkFuY2hvck1hbmFnZXIoe2pzUGx1bWJJbnN0YW5jZTpfY3VycmVudEluc3RhbmNlfSk7aW5pdGlhbGl6ZWQ9dHJ1ZTtfY3VycmVudEluc3RhbmNlLmZpcmUoXCJyZWFkeVwiLF9jdXJyZW50SW5zdGFuY2UpO319LmJpbmQodGhpcyk7dGhpcy5sb2c9bG9nO3RoaXMuanNQbHVtYlVJQ29tcG9uZW50PWpzUGx1bWJVSUNvbXBvbmVudDsvKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYW4gYW5jaG9yIHdpdGggdGhlIGdpdmVuIHBhcmFtcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogUmV0dXJuczogVGhlIG5ld2x5IGNyZWF0ZWQgQW5jaG9yLlxyXG4gICAgICAgICAqIFRocm93czogYW4gZXJyb3IgaWYgYSBuYW1lZCBhbmNob3Igd2FzIG5vdCBmb3VuZC5cclxuICAgICAgICAgKi90aGlzLm1ha2VBbmNob3I9ZnVuY3Rpb24oKXt2YXIgcHAsX2E9ZnVuY3Rpb24gX2EodCxwKXtpZihyb290LmpzUGx1bWIuQW5jaG9yc1t0XSl7cmV0dXJuIG5ldyByb290LmpzUGx1bWIuQW5jaG9yc1t0XShwKTt9aWYoIV9jdXJyZW50SW5zdGFuY2UuRGVmYXVsdHMuRG9Ob3RUaHJvd0Vycm9ycyl7dGhyb3d7bXNnOlwianNQbHVtYjogdW5rbm93biBhbmNob3IgdHlwZSAnXCIrdCtcIidcIn07fX07aWYoYXJndW1lbnRzLmxlbmd0aD09PTApe3JldHVybiBudWxsO312YXIgc3BlY2ltZW49YXJndW1lbnRzWzBdLGVsZW1lbnRJZD1hcmd1bWVudHNbMV0sanNQbHVtYkluc3RhbmNlPWFyZ3VtZW50c1syXSxuZXdBbmNob3I9bnVsbDsvLyBpZiBpdCBhcHBlYXJzIHRvIGJlIGFuIGFuY2hvciBhbHJlYWR5Li4uXG5pZihzcGVjaW1lbi5jb21wdXRlJiZzcGVjaW1lbi5nZXRPcmllbnRhdGlvbil7cmV0dXJuIHNwZWNpbWVuO30vL1RPRE8gaGF6eSBoZXJlIGFib3V0IHdoZXRoZXIgaXQgc2hvdWxkIGJlIGFkZGVkIG9yIGlzIGFscmVhZHkgYWRkZWQgc29tZWhvdy5cbi8vIGlzIGl0IHRoZSBuYW1lIG9mIGFuIGFuY2hvciB0eXBlP1xuZWxzZSBpZih0eXBlb2Ygc3BlY2ltZW49PT1cInN0cmluZ1wiKXtuZXdBbmNob3I9X2EoYXJndW1lbnRzWzBdLHtlbGVtZW50SWQ6ZWxlbWVudElkLGpzUGx1bWJJbnN0YW5jZTpfY3VycmVudEluc3RhbmNlfSk7fS8vIGlzIGl0IGFuIGFycmF5PyBpdCB3aWxsIGJlIG9uZSBvZjpcbi8vIGFuIGFycmF5IG9mIFtzcGVjLCBwYXJhbXNdIC0gdGhpcyBkZWZpbmVzIGEgc2luZ2xlIGFuY2hvciwgd2hpY2ggbWF5IGJlIGR5bmFtaWMsIGJ1dCBoYXMgcGFyYW1ldGVycy5cbi8vIGFuIGFycmF5IG9mIGFycmF5cyAtIHRoaXMgZGVmaW5lcyBzb21lIGR5bmFtaWMgYW5jaG9yc1xuLy8gYW4gYXJyYXkgb2YgbnVtYmVycyAtIHRoaXMgZGVmaW5lcyBhIHNpbmdsZSBhbmNob3IuXG5lbHNlIGlmKF9qdS5pc0FycmF5KHNwZWNpbWVuKSl7aWYoX2p1LmlzQXJyYXkoc3BlY2ltZW5bMF0pfHxfanUuaXNTdHJpbmcoc3BlY2ltZW5bMF0pKXsvLyBpZiBbc3BlYywgcGFyYW1zXSBmb3JtYXRcbmlmKHNwZWNpbWVuLmxlbmd0aD09PTImJl9qdS5pc09iamVjdChzcGVjaW1lblsxXSkpey8vIGlmIGZpcnN0IGFyZyBpcyBhIHN0cmluZywgaXRzIGEgbmFtZWQgYW5jaG9yIHdpdGggcGFyYW1zXG5pZihfanUuaXNTdHJpbmcoc3BlY2ltZW5bMF0pKXtwcD1yb290LmpzUGx1bWIuZXh0ZW5kKHtlbGVtZW50SWQ6ZWxlbWVudElkLGpzUGx1bWJJbnN0YW5jZTpfY3VycmVudEluc3RhbmNlfSxzcGVjaW1lblsxXSk7bmV3QW5jaG9yPV9hKHNwZWNpbWVuWzBdLHBwKTt9Ly8gb3RoZXJ3aXNlIGZpcnN0IGFyZyBpcyBhcnJheSwgc2Vjb25kIGlzIHBhcmFtcy4gd2UgdHJlYXQgYXMgYSBkeW5hbWljIGFuY2hvciwgd2hpY2ggaXMgZmluZVxuLy8gZXZlbiBpZiB0aGUgZmlyc3QgYXJnIGhhcyBvbmx5IG9uZSBlbnRyeS4geW91IGNvdWxkIGFyZ3VlIGFsbCBhbmNob3JzIHNob3VsZCBiZSBpbXBsaWNpdGx5IGR5bmFtaWMgaW4gZmFjdC5cbmVsc2V7cHA9cm9vdC5qc1BsdW1iLmV4dGVuZCh7ZWxlbWVudElkOmVsZW1lbnRJZCxqc1BsdW1iSW5zdGFuY2U6X2N1cnJlbnRJbnN0YW5jZSxhbmNob3JzOnNwZWNpbWVuWzBdfSxzcGVjaW1lblsxXSk7bmV3QW5jaG9yPW5ldyByb290LmpzUGx1bWIuRHluYW1pY0FuY2hvcihwcCk7fX1lbHNle25ld0FuY2hvcj1uZXcganNQbHVtYi5EeW5hbWljQW5jaG9yKHthbmNob3JzOnNwZWNpbWVuLHNlbGVjdG9yOm51bGwsZWxlbWVudElkOmVsZW1lbnRJZCxqc1BsdW1iSW5zdGFuY2U6X2N1cnJlbnRJbnN0YW5jZX0pO319ZWxzZXt2YXIgYW5jaG9yUGFyYW1zPXt4OnNwZWNpbWVuWzBdLHk6c3BlY2ltZW5bMV0sb3JpZW50YXRpb246c3BlY2ltZW4ubGVuZ3RoPj00P1tzcGVjaW1lblsyXSxzcGVjaW1lblszXV06WzAsMF0sb2Zmc2V0czpzcGVjaW1lbi5sZW5ndGg+PTY/W3NwZWNpbWVuWzRdLHNwZWNpbWVuWzVdXTpbMCwwXSxlbGVtZW50SWQ6ZWxlbWVudElkLGpzUGx1bWJJbnN0YW5jZTpfY3VycmVudEluc3RhbmNlLGNzc0NsYXNzOnNwZWNpbWVuLmxlbmd0aD09PTc/c3BlY2ltZW5bNl06bnVsbH07bmV3QW5jaG9yPW5ldyByb290LmpzUGx1bWIuQW5jaG9yKGFuY2hvclBhcmFtcyk7bmV3QW5jaG9yLmNsb25lPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyByb290LmpzUGx1bWIuQW5jaG9yKGFuY2hvclBhcmFtcyk7fTt9fWlmKCFuZXdBbmNob3IuaWQpe25ld0FuY2hvci5pZD1cImFuY2hvcl9cIitfaWRzdGFtcCgpO31yZXR1cm4gbmV3QW5jaG9yO307LyoqXHJcbiAgICAgICAgICogbWFrZXMgYSBsaXN0IG9mIGFuY2hvcnMgZnJvbSB0aGUgZ2l2ZW4gbGlzdCBvZiB0eXBlcyBvciBjb29yZHMsIGVnXHJcbiAgICAgICAgICogW1wiVG9wQ2VudGVyXCIsIFwiUmlnaHRNaWRkbGVcIiwgXCJCb3R0b21DZW50ZXJcIiwgWzAsIDEsIC0xLCAtMV0gXVxyXG4gICAgICAgICAqL3RoaXMubWFrZUFuY2hvcnM9ZnVuY3Rpb24odHlwZXMsZWxlbWVudElkLGpzUGx1bWJJbnN0YW5jZSl7dmFyIHI9W107Zm9yKHZhciBpPTAsaWk9dHlwZXMubGVuZ3RoO2k8aWk7aSsrKXtpZih0eXBlb2YgdHlwZXNbaV09PT1cInN0cmluZ1wiKXtyLnB1c2gocm9vdC5qc1BsdW1iLkFuY2hvcnNbdHlwZXNbaV1dKHtlbGVtZW50SWQ6ZWxlbWVudElkLGpzUGx1bWJJbnN0YW5jZTpqc1BsdW1iSW5zdGFuY2V9KSk7fWVsc2UgaWYoX2p1LmlzQXJyYXkodHlwZXNbaV0pKXtyLnB1c2goX2N1cnJlbnRJbnN0YW5jZS5tYWtlQW5jaG9yKHR5cGVzW2ldLGVsZW1lbnRJZCxqc1BsdW1iSW5zdGFuY2UpKTt9fXJldHVybiByO307LyoqXHJcbiAgICAgICAgICogTWFrZXMgYSBkeW5hbWljIGFuY2hvciBmcm9tIHRoZSBnaXZlbiBsaXN0IG9mIGFuY2hvcnMgKHdoaWNoIG1heSBiZSBpbiBzaG9ydGhhbmQgbm90YXRpb24gYXMgc3RyaW5ncyBvciBkaW1lbnNpb24gYXJyYXlzLCBvciBBbmNob3JcclxuICAgICAgICAgKiBvYmplY3RzIHRoZW1zZWx2ZXMpIGFuZCB0aGUgZ2l2ZW4sIG9wdGlvbmFsLCBhbmNob3JTZWxlY3RvciBmdW5jdGlvbiAoanNQbHVtYiB1c2VzIGEgZGVmYXVsdCBpZiB0aGlzIGlzIG5vdCBwcm92aWRlZDsgbW9zdCBwZW9wbGUgd2lsbFxyXG4gICAgICAgICAqIG5vdCBuZWVkIHRvIHByb3ZpZGUgdGhpcyAtIGkgdGhpbmspLlxyXG4gICAgICAgICAqL3RoaXMubWFrZUR5bmFtaWNBbmNob3I9ZnVuY3Rpb24oYW5jaG9ycyxhbmNob3JTZWxlY3Rvcil7cmV0dXJuIG5ldyByb290LmpzUGx1bWIuRHluYW1pY0FuY2hvcih7YW5jaG9yczphbmNob3JzLHNlbGVjdG9yOmFuY2hvclNlbGVjdG9yLGVsZW1lbnRJZDpudWxsLGpzUGx1bWJJbnN0YW5jZTpfY3VycmVudEluc3RhbmNlfSk7fTsvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0gbWFrZVNvdXJjZS9tYWtlVGFyZ2V0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gXG50aGlzLnRhcmdldEVuZHBvaW50RGVmaW5pdGlvbnM9e307dGhpcy5zb3VyY2VFbmRwb2ludERlZmluaXRpb25zPXt9O3ZhciBzZWxlY3RvckZpbHRlcj1mdW5jdGlvbiBzZWxlY3RvckZpbHRlcihldnQsX2VsLHNlbGVjdG9yLF9pbnN0YW5jZSxuZWdhdGUpe3ZhciB0PWV2dC50YXJnZXR8fGV2dC5zcmNFbGVtZW50LG9rPWZhbHNlLHNlbD1faW5zdGFuY2UuZ2V0U2VsZWN0b3IoX2VsLHNlbGVjdG9yKTtmb3IodmFyIGo9MDtqPHNlbC5sZW5ndGg7aisrKXtpZihzZWxbal09PT10KXtvaz10cnVlO2JyZWFrO319cmV0dXJuIG5lZ2F0ZT8hb2s6b2s7fTt2YXIgX21ha2VFbGVtZW50RHJvcEhhbmRsZXI9ZnVuY3Rpb24gX21ha2VFbGVtZW50RHJvcEhhbmRsZXIoZWxJbmZvLHAsZHJvcE9wdGlvbnMsaXNTb3VyY2UsaXNUYXJnZXQpe3ZhciBwcm94eUNvbXBvbmVudD1uZXcganNQbHVtYlVJQ29tcG9uZW50KHApO3ZhciBfZHJvcD1wLl9qc1BsdW1iLkVuZHBvaW50RHJvcEhhbmRsZXIoe2pzUGx1bWI6X2N1cnJlbnRJbnN0YW5jZSxlbmFibGVkOmZ1bmN0aW9uIGVuYWJsZWQoKXtyZXR1cm4gZWxJbmZvLmRlZi5lbmFibGVkO30saXNGdWxsOmZ1bmN0aW9uIGlzRnVsbCgpe3ZhciB0YXJnZXRDb3VudD1fY3VycmVudEluc3RhbmNlLnNlbGVjdCh7dGFyZ2V0OmVsSW5mby5pZH0pLmxlbmd0aDtyZXR1cm4gZWxJbmZvLmRlZi5tYXhDb25uZWN0aW9ucz4wJiZ0YXJnZXRDb3VudD49ZWxJbmZvLmRlZi5tYXhDb25uZWN0aW9uczt9LGVsZW1lbnQ6ZWxJbmZvLmVsLGVsZW1lbnRJZDplbEluZm8uaWQsaXNTb3VyY2U6aXNTb3VyY2UsaXNUYXJnZXQ6aXNUYXJnZXQsYWRkQ2xhc3M6ZnVuY3Rpb24gYWRkQ2xhc3MoY2xhenope19jdXJyZW50SW5zdGFuY2UuYWRkQ2xhc3MoZWxJbmZvLmVsLGNsYXp6KTt9LHJlbW92ZUNsYXNzOmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGNsYXp6KXtfY3VycmVudEluc3RhbmNlLnJlbW92ZUNsYXNzKGVsSW5mby5lbCxjbGF6eik7fSxvbkRyb3A6ZnVuY3Rpb24gb25Ecm9wKGpwYyl7dmFyIHNvdXJjZT1qcGMuZW5kcG9pbnRzWzBdO3NvdXJjZS5hbmNob3IubG9ja2VkPWZhbHNlO30saXNEcm9wQWxsb3dlZDpmdW5jdGlvbiBpc0Ryb3BBbGxvd2VkKCl7cmV0dXJuIHByb3h5Q29tcG9uZW50LmlzRHJvcEFsbG93ZWQuYXBwbHkocHJveHlDb21wb25lbnQsYXJndW1lbnRzKTt9LGlzUmVkcm9wOmZ1bmN0aW9uIGlzUmVkcm9wKGpwYyl7cmV0dXJuIGpwYy5zdXNwZW5kZWRFbGVtZW50IT1udWxsJiZqcGMuc3VzcGVuZGVkRW5kcG9pbnQhPW51bGwmJmpwYy5zdXNwZW5kZWRFbmRwb2ludC5lbGVtZW50PT09ZWxJbmZvLmVsO30sZ2V0RW5kcG9pbnQ6ZnVuY3Rpb24gZ2V0RW5kcG9pbnQoanBjKXsvLyBtYWtlIGEgbmV3IEVuZHBvaW50IGZvciB0aGUgdGFyZ2V0LCBvciBnZXQgaXQgZnJvbSB0aGUgY2FjaGUgaWYgdW5pcXVlRW5kcG9pbnRcbi8vIGlzIHNldC4gaWYgaXRzIGEgcmVkcm9wIHRoZSBuZXcgZW5kcG9pbnQgd2lsbCBiZSBpbW1lZGlhdGVseSBjbGVhbmVkIHVwLlxudmFyIG5ld0VuZHBvaW50PWVsSW5mby5kZWYuZW5kcG9pbnQ7Ly8gaWYgbm8gY2FjaGVkIGVuZHBvaW50LCBvciB0aGVyZSB3YXMgb25lIGJ1dCBpdCBoYXMgYmVlbiBjbGVhbmVkIHVwXG4vLyAoaWUuIGRldGFjaGVkKSwgY3JlYXRlIGEgbmV3IG9uZVxuaWYobmV3RW5kcG9pbnQ9PW51bGx8fG5ld0VuZHBvaW50Ll9qc1BsdW1iPT1udWxsKXt2YXIgZXBzPV9jdXJyZW50SW5zdGFuY2UuZGVyaXZlRW5kcG9pbnRBbmRBbmNob3JTcGVjKGpwYy5nZXRUeXBlKCkuam9pbihcIiBcIiksdHJ1ZSk7dmFyIHBwPWVwcy5lbmRwb2ludHM/cm9vdC5qc1BsdW1iLmV4dGVuZChwLHtlbmRwb2ludDplbEluZm8uZGVmLmRlZi5lbmRwb2ludHx8ZXBzLmVuZHBvaW50c1sxXX0pOnA7aWYoZXBzLmFuY2hvcnMpe3BwPXJvb3QuanNQbHVtYi5leHRlbmQocHAse2FuY2hvcjplbEluZm8uZGVmLmRlZi5hbmNob3J8fGVwcy5hbmNob3JzWzFdfSk7fW5ld0VuZHBvaW50PV9jdXJyZW50SW5zdGFuY2UuYWRkRW5kcG9pbnQoZWxJbmZvLmVsLHBwKTtuZXdFbmRwb2ludC5fbXROZXc9dHJ1ZTt9aWYocC51bmlxdWVFbmRwb2ludCl7ZWxJbmZvLmRlZi5lbmRwb2ludD1uZXdFbmRwb2ludDt9bmV3RW5kcG9pbnQuc2V0RGVsZXRlT25FbXB0eSh0cnVlKTsvLyBpZiBjb25uZWN0aW9uIGlzIGRldGFjaGFibGUsIGluaXQgdGhlIG5ldyBlbmRwb2ludCB0byBiZSBkcmFnZ2FibGUsIHRvIHN1cHBvcnQgdGhhdCBoYXBwZW5pbmcuXG5pZihqcGMuaXNEZXRhY2hhYmxlKCkpe25ld0VuZHBvaW50LmluaXREcmFnZ2FibGUoKTt9Ly8gaWYgdGhlIGFuY2hvciBoYXMgYSAncG9zaXRpb25GaW5kZXInIHNldCwgdGhlbiBkZWxlZ2F0ZSB0byB0aGF0IGZ1bmN0aW9uIHRvIGZpbmRcbi8vIG91dCB3aGVyZSB0byBsb2NhdGUgdGhlIGFuY2hvci5cbmlmKG5ld0VuZHBvaW50LmFuY2hvci5wb3NpdGlvbkZpbmRlciE9bnVsbCl7dmFyIGRyb3BQb3NpdGlvbj1fY3VycmVudEluc3RhbmNlLmdldFVJUG9zaXRpb24oYXJndW1lbnRzLF9jdXJyZW50SW5zdGFuY2UuZ2V0Wm9vbSgpKSxlbFBvc2l0aW9uPV9jdXJyZW50SW5zdGFuY2UuZ2V0T2Zmc2V0KGVsSW5mby5lbCksZWxTaXplPV9jdXJyZW50SW5zdGFuY2UuZ2V0U2l6ZShlbEluZm8uZWwpLGFwPWRyb3BQb3NpdGlvbj09bnVsbD9bMCwwXTpuZXdFbmRwb2ludC5hbmNob3IucG9zaXRpb25GaW5kZXIoZHJvcFBvc2l0aW9uLGVsUG9zaXRpb24sZWxTaXplLG5ld0VuZHBvaW50LmFuY2hvci5jb25zdHJ1Y3RvclBhcmFtcyk7bmV3RW5kcG9pbnQuYW5jaG9yLng9YXBbMF07bmV3RW5kcG9pbnQuYW5jaG9yLnk9YXBbMV07Ly8gbm93IGZpZ3VyZSBhbiBvcmllbnRhdGlvbiBmb3IgaXQuLmtpbmQgb2YgaGFyZCB0byBrbm93IHdoYXQgdG8gZG8gYWN0dWFsbHkuIHByb2JhYmx5IHRoZSBiZXN0IHRoaW5nIGkgY2FuIGRvIGlzIHRvXG4vLyBzdXBwb3J0IHNwZWNpZnlpbmcgYW4gb3JpZW50YXRpb24gaW4gdGhlIGFuY2hvcidzIHNwZWMuIGlmIG9uZSBpcyBub3Qgc3VwcGxpZWQgdGhlbiBpIHdpbGwgbWFrZSB0aGUgb3JpZW50YXRpb25cbi8vIGJlIHdoYXQgd2lsbCBjYXVzZSB0aGUgbW9zdCBuYXR1cmFsIGxpbmsgdG8gdGhlIHNvdXJjZTogaXQgd2lsbCBiZSBwb2ludGluZyBhdCB0aGUgc291cmNlLCBidXQgaXQgbmVlZHMgdG8gYmVcbi8vIHNwZWNpZmllZCBpbiBvbmUgYXhpcyBvbmx5LCBhbmQgc28gaG93IHRvIG1ha2UgdGhhdCBjaG9pY2U/IGkgdGhpbmsgaSB3aWxsIHVzZSB3aGljaGV2ZXIgYXhpcyBpcyB0aGUgb25lIGluIHdoaWNoXG4vLyB0aGUgdGFyZ2V0IGlzIGZ1cnRoZXN0IGF3YXkgZnJvbSB0aGUgc291cmNlLlxufXJldHVybiBuZXdFbmRwb2ludDt9LG1heWJlQ2xlYW51cDpmdW5jdGlvbiBtYXliZUNsZWFudXAoZXApe2lmKGVwLl9tdE5ldyYmZXAuY29ubmVjdGlvbnMubGVuZ3RoPT09MCl7X2N1cnJlbnRJbnN0YW5jZS5kZWxldGVPYmplY3Qoe2VuZHBvaW50OmVwfSk7fWVsc2V7ZGVsZXRlIGVwLl9tdE5ldzt9fX0pOy8vIHdyYXAgZHJvcCBldmVudHMgYXMgbmVlZGVkIGFuZCBpbml0aWFsaXNlIGRyb3BwYWJsZVxudmFyIGRyb3BFdmVudD1yb290LmpzUGx1bWIuZHJhZ0V2ZW50cy5kcm9wO2Ryb3BPcHRpb25zLnNjb3BlPWRyb3BPcHRpb25zLnNjb3BlfHxwLnNjb3BlfHxfY3VycmVudEluc3RhbmNlLkRlZmF1bHRzLlNjb3BlO2Ryb3BPcHRpb25zW2Ryb3BFdmVudF09X2p1LndyYXAoZHJvcE9wdGlvbnNbZHJvcEV2ZW50XSxfZHJvcCx0cnVlKTsvLyBpZiB0YXJnZXQsIHJldHVybiB0cnVlIGZyb20gdGhlIG92ZXIgZXZlbnQuIHRoaXMgd2lsbCBjYXVzZSBrYXRhdm9yaW8gdG8gc3RvcCBzZXR0aW5nIGRyb3BzIHRvIGhvdmVyXG4vLyBpZiBtdWx0aXBsZURyb3AgaXMgc2V0IHRvIGZhbHNlLlxuaWYoaXNUYXJnZXQpe2Ryb3BPcHRpb25zW3Jvb3QuanNQbHVtYi5kcmFnRXZlbnRzLm92ZXJdPWZ1bmN0aW9uKCl7cmV0dXJuIHRydWU7fTt9Ly8gdmFuaWxsYSBqc3BsdW1iIG9ubHlcbmlmKHAuYWxsb3dMb29wYmFjaz09PWZhbHNlKXtkcm9wT3B0aW9ucy5jYW5Ecm9wPWZ1bmN0aW9uKF9kcmFnKXt2YXIgZGU9X2RyYWcuZ2V0RHJhZ0VsZW1lbnQoKS5fanNQbHVtYlJlbGF0ZWRFbGVtZW50O3JldHVybiBkZSE9PWVsSW5mby5lbDt9O31fY3VycmVudEluc3RhbmNlLmluaXREcm9wcGFibGUoZWxJbmZvLmVsLGRyb3BPcHRpb25zLFwiaW50ZXJuYWxcIik7cmV0dXJuIF9kcm9wO307Ly8gc2VlIEFQSSBkb2NzXG50aGlzLm1ha2VUYXJnZXQ9ZnVuY3Rpb24oZWwscGFyYW1zLHJlZmVyZW5jZVBhcmFtcyl7Ly8gcHV0IGpzcGx1bWIgcmVmIGludG8gcGFyYW1zIHdpdGhvdXQgYWx0ZXJpbmcgdGhlIHBhcmFtcyBwYXNzZWQgaW5cbnZhciBwPXJvb3QuanNQbHVtYi5leHRlbmQoe19qc1BsdW1iOnRoaXN9LHJlZmVyZW5jZVBhcmFtcyk7cm9vdC5qc1BsdW1iLmV4dGVuZChwLHBhcmFtcyk7dmFyIG1heENvbm5lY3Rpb25zPXAubWF4Q29ubmVjdGlvbnN8fC0xLF9kb09uZT1mdW5jdGlvbihlbCl7Ly8gZ2V0IHRoZSBlbGVtZW50J3MgaWQgYW5kIHN0b3JlIHRoZSBlbmRwb2ludCBkZWZpbml0aW9uIGZvciBpdC4gIGpzUGx1bWIuY29ubmVjdCBjYWxscyB3aWxsIGxvb2sgZm9yIG9uZSBvZiB0aGVzZSxcbi8vIGFuZCB1c2UgdGhlIGVuZHBvaW50IGRlZmluaXRpb24gaWYgZm91bmQuXG4vLyBkZWNvZGUgdGhlIGluZm8gZm9yIHRoaXMgZWxlbWVudCAoaWQgYW5kIGVsZW1lbnQpXG52YXIgZWxJbmZvPV9pbmZvKGVsKSxlbGlkPWVsSW5mby5pZCxkcm9wT3B0aW9ucz1yb290LmpzUGx1bWIuZXh0ZW5kKHt9LHAuZHJvcE9wdGlvbnN8fHt9KSx0eXBlPXAuY29ubmVjdGlvblR5cGV8fFwiZGVmYXVsdFwiO3RoaXMudGFyZ2V0RW5kcG9pbnREZWZpbml0aW9uc1tlbGlkXT10aGlzLnRhcmdldEVuZHBvaW50RGVmaW5pdGlvbnNbZWxpZF18fHt9O19lbnN1cmVDb250YWluZXIoZWxpZCk7Ly8gaWYgdGhpcyBpcyBhIGdyb3VwIGFuZCB0aGUgdXNlciBoYXMgbm90IG1hbmRhdGVkIGEgcmFuaywgc2V0IHRvIC0xIHNvIHRoYXQgTm9kZXMgdGFrZXNcbi8vIHByZWNlZGVuY2UuXG5pZihlbEluZm8uZWwuX2lzSnNQbHVtYkdyb3VwJiZkcm9wT3B0aW9ucy5yYW5rPT1udWxsKXtkcm9wT3B0aW9ucy5yYW5rPS0xO30vLyBzdG9yZSB0aGUgZGVmaW5pdGlvblxudmFyIF9kZWY9e2RlZjpyb290LmpzUGx1bWIuZXh0ZW5kKHt9LHApLHVuaXF1ZUVuZHBvaW50OnAudW5pcXVlRW5kcG9pbnQsbWF4Q29ubmVjdGlvbnM6bWF4Q29ubmVjdGlvbnMsZW5hYmxlZDp0cnVlfTtpZihwLmNyZWF0ZUVuZHBvaW50KXtfZGVmLnVuaXF1ZUVuZHBvaW50PXRydWU7X2RlZi5lbmRwb2ludD1fY3VycmVudEluc3RhbmNlLmFkZEVuZHBvaW50KGVsLF9kZWYuZGVmKTtfZGVmLmVuZHBvaW50LnNldERlbGV0ZU9uRW1wdHkoZmFsc2UpO31lbEluZm8uZGVmPV9kZWY7dGhpcy50YXJnZXRFbmRwb2ludERlZmluaXRpb25zW2VsaWRdW3R5cGVdPV9kZWY7X21ha2VFbGVtZW50RHJvcEhhbmRsZXIoZWxJbmZvLHAsZHJvcE9wdGlvbnMscC5pc1NvdXJjZT09PXRydWUsdHJ1ZSk7Ly8gc3Rhc2ggdGhlIGRlZmluaXRpb24gb24gdGhlIGRyb3BcbmVsSW5mby5lbC5fa2F0YXZvcmlvRHJvcFtlbEluZm8uZWwuX2thdGF2b3Jpb0Ryb3AubGVuZ3RoLTFdLnRhcmdldERlZj1fZGVmO30uYmluZCh0aGlzKTsvLyBtYWtlIGFuIGFycmF5IGlmIG9ubHkgZ2l2ZW4gb25lIGVsZW1lbnRcbnZhciBpbnB1dHM9ZWwubGVuZ3RoJiZlbC5jb25zdHJ1Y3RvciE9PVN0cmluZz9lbDpbZWxdOy8vIHJlZ2lzdGVyIGVhY2ggb25lIGluIHRoZSBsaXN0LlxuZm9yKHZhciBpPTAsaWk9aW5wdXRzLmxlbmd0aDtpPGlpO2krKyl7X2RvT25lKGlucHV0c1tpXSk7fXJldHVybiB0aGlzO307Ly8gc2VlIGFwaSBkb2NzXG50aGlzLnVubWFrZVRhcmdldD1mdW5jdGlvbihlbCxkb05vdENsZWFyQXJyYXlzKXt2YXIgaW5mbz1faW5mbyhlbCk7X2N1cnJlbnRJbnN0YW5jZS5kZXN0cm95RHJvcHBhYmxlKGluZm8uZWwsXCJpbnRlcm5hbFwiKTtpZighZG9Ob3RDbGVhckFycmF5cyl7ZGVsZXRlIHRoaXMudGFyZ2V0RW5kcG9pbnREZWZpbml0aW9uc1tpbmZvLmlkXTt9cmV0dXJuIHRoaXM7fTsvLyBzZWUgYXBpIGRvY3NcbnRoaXMubWFrZVNvdXJjZT1mdW5jdGlvbihlbCxwYXJhbXMscmVmZXJlbmNlUGFyYW1zKXt2YXIgcD1yb290LmpzUGx1bWIuZXh0ZW5kKHtfanNQbHVtYjp0aGlzfSxyZWZlcmVuY2VQYXJhbXMpO3Jvb3QuanNQbHVtYi5leHRlbmQocCxwYXJhbXMpO3ZhciB0eXBlPXAuY29ubmVjdGlvblR5cGV8fFwiZGVmYXVsdFwiO3ZhciBhYWU9X2N1cnJlbnRJbnN0YW5jZS5kZXJpdmVFbmRwb2ludEFuZEFuY2hvclNwZWModHlwZSk7cC5lbmRwb2ludD1wLmVuZHBvaW50fHxhYWUuZW5kcG9pbnRzWzBdO3AuYW5jaG9yPXAuYW5jaG9yfHxhYWUuYW5jaG9yc1swXTt2YXIgbWF4Q29ubmVjdGlvbnM9cC5tYXhDb25uZWN0aW9uc3x8LTEsb25NYXhDb25uZWN0aW9ucz1wLm9uTWF4Q29ubmVjdGlvbnMsX2RvT25lPWZ1bmN0aW9uKGVsSW5mbyl7Ly8gZ2V0IHRoZSBlbGVtZW50J3MgaWQgYW5kIHN0b3JlIHRoZSBlbmRwb2ludCBkZWZpbml0aW9uIGZvciBpdC4gIGpzUGx1bWIuY29ubmVjdCBjYWxscyB3aWxsIGxvb2sgZm9yIG9uZSBvZiB0aGVzZSxcbi8vIGFuZCB1c2UgdGhlIGVuZHBvaW50IGRlZmluaXRpb24gaWYgZm91bmQuXG52YXIgZWxpZD1lbEluZm8uaWQsX2RlbD10aGlzLmdldEVsZW1lbnQoZWxJbmZvLmVsKTt0aGlzLnNvdXJjZUVuZHBvaW50RGVmaW5pdGlvbnNbZWxpZF09dGhpcy5zb3VyY2VFbmRwb2ludERlZmluaXRpb25zW2VsaWRdfHx7fTtfZW5zdXJlQ29udGFpbmVyKGVsaWQpO3ZhciBfZGVmPXtkZWY6cm9vdC5qc1BsdW1iLmV4dGVuZCh7fSxwKSx1bmlxdWVFbmRwb2ludDpwLnVuaXF1ZUVuZHBvaW50LG1heENvbm5lY3Rpb25zOm1heENvbm5lY3Rpb25zLGVuYWJsZWQ6dHJ1ZX07aWYocC5jcmVhdGVFbmRwb2ludCl7X2RlZi51bmlxdWVFbmRwb2ludD10cnVlO19kZWYuZW5kcG9pbnQ9X2N1cnJlbnRJbnN0YW5jZS5hZGRFbmRwb2ludChlbCxfZGVmLmRlZik7X2RlZi5lbmRwb2ludC5zZXREZWxldGVPbkVtcHR5KGZhbHNlKTt9dGhpcy5zb3VyY2VFbmRwb2ludERlZmluaXRpb25zW2VsaWRdW3R5cGVdPV9kZWY7ZWxJbmZvLmRlZj1fZGVmO3ZhciBzdG9wRXZlbnQ9cm9vdC5qc1BsdW1iLmRyYWdFdmVudHMuc3RvcCxkcmFnRXZlbnQ9cm9vdC5qc1BsdW1iLmRyYWdFdmVudHMuZHJhZyxkcmFnT3B0aW9ucz1yb290LmpzUGx1bWIuZXh0ZW5kKHt9LHAuZHJhZ09wdGlvbnN8fHt9KSxleGlzdGluZ0RyYWc9ZHJhZ09wdGlvbnMuZHJhZyxleGlzdGluZ1N0b3A9ZHJhZ09wdGlvbnMuc3RvcCxlcD1udWxsLGVuZHBvaW50QWRkZWRCdXROb0RyYWdZZXQ9ZmFsc2U7Ly8gc2V0IHNjb3BlIGlmIGl0cyBub3Qgc2V0IGluIGRyYWdPcHRpb25zIGJ1dCB3YXMgcGFzc2VkIGluIGluIHBhcmFtc1xuZHJhZ09wdGlvbnMuc2NvcGU9ZHJhZ09wdGlvbnMuc2NvcGV8fHAuc2NvcGU7ZHJhZ09wdGlvbnNbZHJhZ0V2ZW50XT1fanUud3JhcChkcmFnT3B0aW9uc1tkcmFnRXZlbnRdLGZ1bmN0aW9uKCl7aWYoZXhpc3RpbmdEcmFnKXtleGlzdGluZ0RyYWcuYXBwbHkodGhpcyxhcmd1bWVudHMpO31lbmRwb2ludEFkZGVkQnV0Tm9EcmFnWWV0PWZhbHNlO30pO2RyYWdPcHRpb25zW3N0b3BFdmVudF09X2p1LndyYXAoZHJhZ09wdGlvbnNbc3RvcEV2ZW50XSxmdW5jdGlvbigpe2lmKGV4aXN0aW5nU3RvcCl7ZXhpc3RpbmdTdG9wLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt9dGhpcy5jdXJyZW50bHlEcmFnZ2luZz1mYWxzZTtpZihlcC5fanNQbHVtYiE9bnVsbCl7Ly8gaWYgbm90IGNsZWFuZWQgdXAuLi5cbi8vIHJlc2V0IHRoZSBhbmNob3IgdG8gdGhlIGFuY2hvciB0aGF0IHdhcyBpbml0aWFsbHkgcHJvdmlkZWQuIHRoZSBvbmUgd2Ugd2VyZSB1c2luZyB0byBkcmFnXG4vLyB0aGUgY29ubmVjdGlvbiB3YXMganVzdCBhIHBsYWNlaG9sZGVyIHRoYXQgd2FzIGxvY2F0ZWQgYXQgdGhlIHBsYWNlIHRoZSB1c2VyIHByZXNzZWQgdGhlXG4vLyBtb3VzZSBidXR0b24gdG8gaW5pdGlhdGUgdGhlIGRyYWcuXG52YXIgYW5jaG9yRGVmPXAuYW5jaG9yfHx0aGlzLkRlZmF1bHRzLkFuY2hvcixvbGRBbmNob3I9ZXAuYW5jaG9yLG9sZENvbm5lY3Rpb249ZXAuY29ubmVjdGlvbnNbMF07dmFyIG5ld0FuY2hvcj10aGlzLm1ha2VBbmNob3IoYW5jaG9yRGVmLGVsaWQsdGhpcyksX2VsPWVwLmVsZW1lbnQ7Ly8gaWYgdGhlIGFuY2hvciBoYXMgYSAncG9zaXRpb25GaW5kZXInIHNldCwgdGhlbiBkZWxlZ2F0ZSB0byB0aGF0IGZ1bmN0aW9uIHRvIGZpbmRcbi8vIG91dCB3aGVyZSB0byBsb2NhdGUgdGhlIGFuY2hvci4gaXNzdWUgMTE3LlxuaWYobmV3QW5jaG9yLnBvc2l0aW9uRmluZGVyIT1udWxsKXt2YXIgZWxQb3NpdGlvbj1fY3VycmVudEluc3RhbmNlLmdldE9mZnNldChfZWwpLGVsU2l6ZT10aGlzLmdldFNpemUoX2VsKSxkcm9wUG9zaXRpb249e2xlZnQ6ZWxQb3NpdGlvbi5sZWZ0K29sZEFuY2hvci54KmVsU2l6ZVswXSx0b3A6ZWxQb3NpdGlvbi50b3Arb2xkQW5jaG9yLnkqZWxTaXplWzFdfSxhcD1uZXdBbmNob3IucG9zaXRpb25GaW5kZXIoZHJvcFBvc2l0aW9uLGVsUG9zaXRpb24sZWxTaXplLG5ld0FuY2hvci5jb25zdHJ1Y3RvclBhcmFtcyk7bmV3QW5jaG9yLng9YXBbMF07bmV3QW5jaG9yLnk9YXBbMV07fWVwLnNldEFuY2hvcihuZXdBbmNob3IsdHJ1ZSk7ZXAucmVwYWludCgpO3RoaXMucmVwYWludChlcC5lbGVtZW50SWQpO2lmKG9sZENvbm5lY3Rpb24hPW51bGwpe3RoaXMucmVwYWludChvbGRDb25uZWN0aW9uLnRhcmdldElkKTt9fX0uYmluZCh0aGlzKSk7Ly8gd2hlbiB0aGUgdXNlciBwcmVzc2VzIHRoZSBtb3VzZSwgYWRkIGFuIEVuZHBvaW50LCBpZiB3ZSBhcmUgZW5hYmxlZC5cbnZhciBtb3VzZURvd25MaXN0ZW5lcj1mdW5jdGlvbihlKXsvLyBvbiByaWdodCBtb3VzZSBidXR0b24sIGFib3J0LlxuaWYoZS53aGljaD09PTN8fGUuYnV0dG9uPT09Mil7cmV0dXJuO30vLyBUT0RPIHN0b3JlIGRlZiBvbiBlbGVtZW50LlxudmFyIGRlZj10aGlzLnNvdXJjZUVuZHBvaW50RGVmaW5pdGlvbnNbZWxpZF1bdHlwZV07Ly8gaWYgZGlzYWJsZWQsIHJldHVybi5cbmlmKCFkZWYuZW5hYmxlZCl7cmV0dXJuO31lbGlkPXRoaXMuZ2V0SWQodGhpcy5nZXRFbGVtZW50KGVsSW5mby5lbCkpOy8vIGVsaWQgbWlnaHQgaGF2ZSBjaGFuZ2VkIHNpbmNlIHRoaXMgbWV0aG9kIHdhcyBjYWxsZWQgdG8gY29uZmlndXJlIHRoZSBlbGVtZW50LlxuLy8gaWYgYSBmaWx0ZXIgd2FzIGdpdmVuLCBydW4gaXQsIGFuZCByZXR1cm4gaWYgaXQgc2F5cyBuby5cbmlmKHAuZmlsdGVyKXt2YXIgcj1fanUuaXNTdHJpbmcocC5maWx0ZXIpP3NlbGVjdG9yRmlsdGVyKGUsZWxJbmZvLmVsLHAuZmlsdGVyLHRoaXMscC5maWx0ZXJFeGNsdWRlKTpwLmZpbHRlcihlLGVsSW5mby5lbCk7aWYocj09PWZhbHNlKXtyZXR1cm47fX0vLyBpZiBtYXhDb25uZWN0aW9ucyByZWFjaGVkXG52YXIgc291cmNlQ291bnQ9dGhpcy5zZWxlY3Qoe3NvdXJjZTplbGlkfSkubGVuZ3RoO2lmKGRlZi5tYXhDb25uZWN0aW9ucz49MCYmc291cmNlQ291bnQ+PWRlZi5tYXhDb25uZWN0aW9ucyl7aWYob25NYXhDb25uZWN0aW9ucyl7b25NYXhDb25uZWN0aW9ucyh7ZWxlbWVudDplbEluZm8uZWwsbWF4Q29ubmVjdGlvbnM6bWF4Q29ubmVjdGlvbnN9LGUpO31yZXR1cm4gZmFsc2U7fS8vIGZpbmQgdGhlIHBvc2l0aW9uIG9uIHRoZSBlbGVtZW50IGF0IHdoaWNoIHRoZSBtb3VzZSB3YXMgcHJlc3NlZDsgdGhpcyBpcyB3aGVyZSB0aGUgZW5kcG9pbnRcbi8vIHdpbGwgYmUgbG9jYXRlZC5cbnZhciBlbHh5PXJvb3QuanNQbHVtYi5nZXRQb3NpdGlvbk9uRWxlbWVudChlLF9kZWwsX3pvb20pOy8vIHdlIG5lZWQgdG8gb3ZlcnJpZGUgdGhlIGFuY2hvciBpbiBoZXJlLCBhbmQgZm9yY2UgJ2lzU291cmNlJywgYnV0IHdlIGRvbid0IHdhbnQgdG8gbWVzcyB3aXRoXG4vLyB0aGUgcGFyYW1zIHBhc3NlZCBpbiwgYmVjYXVzZSBhZnRlciBhIGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQgd2UncmUgZ29pbmcgdG8gcmVzZXQgdGhlIGVuZHBvaW50XG4vLyB0byBoYXZlIHRoZSBhbmNob3Igd2Ugd2VyZSBnaXZlbi5cbnZhciB0ZW1wRW5kcG9pbnRQYXJhbXM9e307cm9vdC5qc1BsdW1iLmV4dGVuZCh0ZW1wRW5kcG9pbnRQYXJhbXMscCk7dGVtcEVuZHBvaW50UGFyYW1zLmlzVGVtcG9yYXJ5U291cmNlPXRydWU7dGVtcEVuZHBvaW50UGFyYW1zLmFuY2hvcj1bZWx4eVswXSxlbHh5WzFdLDAsMF07dGVtcEVuZHBvaW50UGFyYW1zLmRyYWdPcHRpb25zPWRyYWdPcHRpb25zO2lmKGRlZi5kZWYuc2NvcGUpe3RlbXBFbmRwb2ludFBhcmFtcy5zY29wZT1kZWYuZGVmLnNjb3BlO31lcD10aGlzLmFkZEVuZHBvaW50KGVsaWQsdGVtcEVuZHBvaW50UGFyYW1zKTtlbmRwb2ludEFkZGVkQnV0Tm9EcmFnWWV0PXRydWU7ZXAuc2V0RGVsZXRlT25FbXB0eSh0cnVlKTsvLyBpZiB1bmlxdWUgZW5kcG9pbnQgYW5kIGl0J3MgYWxyZWFkeSBiZWVuIGNyZWF0ZWQsIHB1c2ggaXQgb250byB0aGUgZW5kcG9pbnQgd2UgY3JlYXRlLiBhdCB0aGUgZW5kXG4vLyBvZiBhIHN1Y2Nlc3NmdWwgY29ubmVjdGlvbiB3ZSdsbCBzd2l0Y2ggdG8gdGhhdCBlbmRwb2ludC5cbi8vIFRPRE8gdGhpcyBpcyB0aGUgc2FtZSBjb2RlIGFzIHRoZSBwcm9ncmFtbWF0aWMgZW5kcG9pbnRzIGNyZWF0ZSBvbiBsaW5lIDEwNTAgaXNoXG5pZihkZWYudW5pcXVlRW5kcG9pbnQpe2lmKCFkZWYuZW5kcG9pbnQpe2RlZi5lbmRwb2ludD1lcDtlcC5zZXREZWxldGVPbkVtcHR5KGZhbHNlKTt9ZWxzZXtlcC5maW5hbEVuZHBvaW50PWRlZi5lbmRwb2ludDt9fXZhciBfZGVsVGVtcEVuZHBvaW50PWZ1bmN0aW9uIF9kZWxUZW1wRW5kcG9pbnQoKXsvLyB0aGlzIG1vdXNldXAgZXZlbnQgaXMgZmlyZWQgb25seSBpZiBubyBkcmFnZ2luZyBvY2N1cnJlZCwgYnkganF1ZXJ5IGFuZCB5dWksIGJ1dCBmb3IgbW9vdG9vbHNcbi8vIGl0IGlzIGZpcmVkIGV2ZW4gaWYgZHJhZ2dpbmcgaGFzIG9jY3VycmVkLCBpbiB3aGljaCBjYXNlIHdlIHdvdWxkIGJsb3cgYXdheSBhIHBlcmZlY3RseVxuLy8gbGVnaXRpbWF0ZSBlbmRwb2ludCwgd2VyZSBpdCBub3QgZm9yIHRoaXMgY2hlY2suICB0aGUgZmxhZyBpcyBzZXQgYWZ0ZXIgYWRkaW5nIGFuXG4vLyBlbmRwb2ludCBhbmQgY2xlYXJlZCBpbiBhIGRyYWcgbGlzdGVuZXIgd2Ugc2V0IGluIHRoZSBkcmFnT3B0aW9ucyBhYm92ZS5cbl9jdXJyZW50SW5zdGFuY2Uub2ZmKGVwLmNhbnZhcyxcIm1vdXNldXBcIixfZGVsVGVtcEVuZHBvaW50KTtfY3VycmVudEluc3RhbmNlLm9mZihlbEluZm8uZWwsXCJtb3VzZXVwXCIsX2RlbFRlbXBFbmRwb2ludCk7aWYoZW5kcG9pbnRBZGRlZEJ1dE5vRHJhZ1lldCl7ZW5kcG9pbnRBZGRlZEJ1dE5vRHJhZ1lldD1mYWxzZTtfY3VycmVudEluc3RhbmNlLmRlbGV0ZUVuZHBvaW50KGVwKTt9fTtfY3VycmVudEluc3RhbmNlLm9uKGVwLmNhbnZhcyxcIm1vdXNldXBcIixfZGVsVGVtcEVuZHBvaW50KTtfY3VycmVudEluc3RhbmNlLm9uKGVsSW5mby5lbCxcIm1vdXNldXBcIixfZGVsVGVtcEVuZHBvaW50KTsvLyBvcHRpb25hbGx5IGNoZWNrIGZvciBhdHRyaWJ1dGVzIHRvIGV4dHJhY3QgZnJvbSB0aGUgc291cmNlIGVsZW1lbnRcbnZhciBwYXlsb2FkPXt9O2lmKGRlZi5kZWYuZXh0cmFjdCl7Zm9yKHZhciBhdHQgaW4gZGVmLmRlZi5leHRyYWN0KXt2YXIgdj0oZS5zcmNFbGVtZW50fHxlLnRhcmdldCkuZ2V0QXR0cmlidXRlKGF0dCk7aWYodil7cGF5bG9hZFtkZWYuZGVmLmV4dHJhY3RbYXR0XV09djt9fX0vLyBhbmQgdGhlbiB0cmlnZ2VyIGl0cyBtb3VzZWRvd24gZXZlbnQsIHdoaWNoIHdpbGwga2ljayBvZmYgYSBkcmFnLCB3aGljaCB3aWxsIHN0YXJ0IGRyYWdnaW5nXG4vLyBhIG5ldyBjb25uZWN0aW9uIGZyb20gdGhpcyBlbmRwb2ludC5cbl9jdXJyZW50SW5zdGFuY2UudHJpZ2dlcihlcC5jYW52YXMsXCJtb3VzZWRvd25cIixlLHBheWxvYWQpO19qdS5jb25zdW1lKGUpO30uYmluZCh0aGlzKTt0aGlzLm9uKGVsSW5mby5lbCxcIm1vdXNlZG93blwiLG1vdXNlRG93bkxpc3RlbmVyKTtfZGVmLnRyaWdnZXI9bW91c2VEb3duTGlzdGVuZXI7Ly8gaWYgYSBmaWx0ZXIgd2FzIHByb3ZpZGVkLCBzZXQgaXQgYXMgYSBkcmFnRmlsdGVyIG9uIHRoZSBlbGVtZW50LFxuLy8gdG8gcHJldmVudCB0aGUgZWxlbWVudCBkcmFnIGZ1bmN0aW9uIGZyb20ga2lja2luZyBpbiB3aGVuIHdlIHdhbnQgdG9cbi8vIGRyYWcgYSBuZXcgY29ubmVjdGlvblxuaWYocC5maWx0ZXImJihfanUuaXNTdHJpbmcocC5maWx0ZXIpfHxfanUuaXNGdW5jdGlvbihwLmZpbHRlcikpKXtfY3VycmVudEluc3RhbmNlLnNldERyYWdGaWx0ZXIoZWxJbmZvLmVsLHAuZmlsdGVyKTt9dmFyIGRyb3BPcHRpb25zPXJvb3QuanNQbHVtYi5leHRlbmQoe30scC5kcm9wT3B0aW9uc3x8e30pO19tYWtlRWxlbWVudERyb3BIYW5kbGVyKGVsSW5mbyxwLGRyb3BPcHRpb25zLHRydWUscC5pc1RhcmdldD09PXRydWUpO30uYmluZCh0aGlzKTt2YXIgaW5wdXRzPWVsLmxlbmd0aCYmZWwuY29uc3RydWN0b3IhPT1TdHJpbmc/ZWw6W2VsXTtmb3IodmFyIGk9MCxpaT1pbnB1dHMubGVuZ3RoO2k8aWk7aSsrKXtfZG9PbmUoX2luZm8oaW5wdXRzW2ldKSk7fXJldHVybiB0aGlzO307Ly8gc2VlIGFwaSBkb2NzXG50aGlzLnVubWFrZVNvdXJjZT1mdW5jdGlvbihlbCxjb25uZWN0aW9uVHlwZSxkb05vdENsZWFyQXJyYXlzKXt2YXIgaW5mbz1faW5mbyhlbCk7X2N1cnJlbnRJbnN0YW5jZS5kZXN0cm95RHJvcHBhYmxlKGluZm8uZWwsXCJpbnRlcm5hbFwiKTt2YXIgZWxkZWZzPXRoaXMuc291cmNlRW5kcG9pbnREZWZpbml0aW9uc1tpbmZvLmlkXTtpZihlbGRlZnMpe2Zvcih2YXIgZGVmIGluIGVsZGVmcyl7aWYoY29ubmVjdGlvblR5cGU9PW51bGx8fGNvbm5lY3Rpb25UeXBlPT09ZGVmKXt2YXIgbW91c2VEb3duTGlzdGVuZXI9ZWxkZWZzW2RlZl0udHJpZ2dlcjtpZihtb3VzZURvd25MaXN0ZW5lcil7X2N1cnJlbnRJbnN0YW5jZS5vZmYoaW5mby5lbCxcIm1vdXNlZG93blwiLG1vdXNlRG93bkxpc3RlbmVyKTt9aWYoIWRvTm90Q2xlYXJBcnJheXMpe2RlbGV0ZSB0aGlzLnNvdXJjZUVuZHBvaW50RGVmaW5pdGlvbnNbaW5mby5pZF1bZGVmXTt9fX19cmV0dXJuIHRoaXM7fTsvLyBzZWUgYXBpIGRvY3NcbnRoaXMudW5tYWtlRXZlcnlTb3VyY2U9ZnVuY3Rpb24oKXtmb3IodmFyIGkgaW4gdGhpcy5zb3VyY2VFbmRwb2ludERlZmluaXRpb25zKXtfY3VycmVudEluc3RhbmNlLnVubWFrZVNvdXJjZShpLG51bGwsdHJ1ZSk7fXRoaXMuc291cmNlRW5kcG9pbnREZWZpbml0aW9ucz17fTtyZXR1cm4gdGhpczt9O3ZhciBfZ2V0U2NvcGU9ZnVuY3Rpb24oZWwsdHlwZXMsY29ubmVjdGlvblR5cGUpe3R5cGVzPV9qdS5pc0FycmF5KHR5cGVzKT90eXBlczpbdHlwZXNdO3ZhciBpZD1fZ2V0SWQoZWwpO2Nvbm5lY3Rpb25UeXBlPWNvbm5lY3Rpb25UeXBlfHxcImRlZmF1bHRcIjtmb3IodmFyIGk9MDtpPHR5cGVzLmxlbmd0aDtpKyspe3ZhciBlbGRlZnM9dGhpc1t0eXBlc1tpXV1baWRdO2lmKGVsZGVmcyYmZWxkZWZzW2Nvbm5lY3Rpb25UeXBlXSl7cmV0dXJuIGVsZGVmc1tjb25uZWN0aW9uVHlwZV0uZGVmLnNjb3BlfHx0aGlzLkRlZmF1bHRzLlNjb3BlO319fS5iaW5kKHRoaXMpO3ZhciBfc2V0U2NvcGU9ZnVuY3Rpb24oZWwsc2NvcGUsdHlwZXMsY29ubmVjdGlvblR5cGUpe3R5cGVzPV9qdS5pc0FycmF5KHR5cGVzKT90eXBlczpbdHlwZXNdO3ZhciBpZD1fZ2V0SWQoZWwpO2Nvbm5lY3Rpb25UeXBlPWNvbm5lY3Rpb25UeXBlfHxcImRlZmF1bHRcIjtmb3IodmFyIGk9MDtpPHR5cGVzLmxlbmd0aDtpKyspe3ZhciBlbGRlZnM9dGhpc1t0eXBlc1tpXV1baWRdO2lmKGVsZGVmcyYmZWxkZWZzW2Nvbm5lY3Rpb25UeXBlXSl7ZWxkZWZzW2Nvbm5lY3Rpb25UeXBlXS5kZWYuc2NvcGU9c2NvcGU7fX19LmJpbmQodGhpcyk7dGhpcy5nZXRTY29wZT1mdW5jdGlvbihlbCxzY29wZSl7cmV0dXJuIF9nZXRTY29wZShlbCxbXCJzb3VyY2VFbmRwb2ludERlZmluaXRpb25zXCIsXCJ0YXJnZXRFbmRwb2ludERlZmluaXRpb25zXCJdKTt9O3RoaXMuZ2V0U291cmNlU2NvcGU9ZnVuY3Rpb24oZWwpe3JldHVybiBfZ2V0U2NvcGUoZWwsXCJzb3VyY2VFbmRwb2ludERlZmluaXRpb25zXCIpO307dGhpcy5nZXRUYXJnZXRTY29wZT1mdW5jdGlvbihlbCl7cmV0dXJuIF9nZXRTY29wZShlbCxcInRhcmdldEVuZHBvaW50RGVmaW5pdGlvbnNcIik7fTt0aGlzLnNldFNjb3BlPWZ1bmN0aW9uKGVsLHNjb3BlLGNvbm5lY3Rpb25UeXBlKXt0aGlzLnNldFNvdXJjZVNjb3BlKGVsLHNjb3BlLGNvbm5lY3Rpb25UeXBlKTt0aGlzLnNldFRhcmdldFNjb3BlKGVsLHNjb3BlLGNvbm5lY3Rpb25UeXBlKTt9O3RoaXMuc2V0U291cmNlU2NvcGU9ZnVuY3Rpb24oZWwsc2NvcGUsY29ubmVjdGlvblR5cGUpe19zZXRTY29wZShlbCxzY29wZSxcInNvdXJjZUVuZHBvaW50RGVmaW5pdGlvbnNcIixjb25uZWN0aW9uVHlwZSk7Ly8gd2UgZ2V0IHRoZSBzb3VyY2Ugc2NvcGUgZHVyaW5nIHRoZSBtb3VzZWRvd24gZXZlbnQsIGJ1dCB3ZSBhbHNvIHdhbnQgdG8gc2V0IHRoaXMuXG50aGlzLnNldERyYWdTY29wZShlbCxzY29wZSk7fTt0aGlzLnNldFRhcmdldFNjb3BlPWZ1bmN0aW9uKGVsLHNjb3BlLGNvbm5lY3Rpb25UeXBlKXtfc2V0U2NvcGUoZWwsc2NvcGUsXCJ0YXJnZXRFbmRwb2ludERlZmluaXRpb25zXCIsY29ubmVjdGlvblR5cGUpO3RoaXMuc2V0RHJvcFNjb3BlKGVsLHNjb3BlKTt9Oy8vIHNlZSBhcGkgZG9jc1xudGhpcy51bm1ha2VFdmVyeVRhcmdldD1mdW5jdGlvbigpe2Zvcih2YXIgaSBpbiB0aGlzLnRhcmdldEVuZHBvaW50RGVmaW5pdGlvbnMpe19jdXJyZW50SW5zdGFuY2UudW5tYWtlVGFyZ2V0KGksdHJ1ZSk7fXRoaXMudGFyZ2V0RW5kcG9pbnREZWZpbml0aW9ucz17fTtyZXR1cm4gdGhpczt9Oy8vIGRvZXMgdGhlIHdvcmsgb2Ygc2V0dGluZyBhIHNvdXJjZSBlbmFibGVkIG9yIGRpc2FibGVkLlxudmFyIF9zZXRFbmFibGVkPWZ1bmN0aW9uKHR5cGUsZWwsc3RhdGUsdG9nZ2xlLGNvbm5lY3Rpb25UeXBlKXt2YXIgYT10eXBlPT09XCJzb3VyY2VcIj90aGlzLnNvdXJjZUVuZHBvaW50RGVmaW5pdGlvbnM6dGhpcy50YXJnZXRFbmRwb2ludERlZmluaXRpb25zLG9yaWdpbmFsU3RhdGUsaW5mbyxuZXdTdGF0ZTtjb25uZWN0aW9uVHlwZT1jb25uZWN0aW9uVHlwZXx8XCJkZWZhdWx0XCI7Ly8gYSBzZWxlY3RvciBvciBhbiBhcnJheVxuaWYoZWwubGVuZ3RoJiYhX2p1LmlzU3RyaW5nKGVsKSl7b3JpZ2luYWxTdGF0ZT1bXTtmb3IodmFyIGk9MCxpaT1lbC5sZW5ndGg7aTxpaTtpKyspe2luZm89X2luZm8oZWxbaV0pO2lmKGFbaW5mby5pZF0mJmFbaW5mby5pZF1bY29ubmVjdGlvblR5cGVdKXtvcmlnaW5hbFN0YXRlW2ldPWFbaW5mby5pZF1bY29ubmVjdGlvblR5cGVdLmVuYWJsZWQ7bmV3U3RhdGU9dG9nZ2xlPyFvcmlnaW5hbFN0YXRlW2ldOnN0YXRlO2FbaW5mby5pZF1bY29ubmVjdGlvblR5cGVdLmVuYWJsZWQ9bmV3U3RhdGU7X2N1cnJlbnRJbnN0YW5jZVtuZXdTdGF0ZT9cInJlbW92ZUNsYXNzXCI6XCJhZGRDbGFzc1wiXShpbmZvLmVsLFwianRrLVwiK3R5cGUrXCItZGlzYWJsZWRcIik7fX19Ly8gb3RoZXJ3aXNlIGEgRE9NIGVsZW1lbnQgb3IgYSBTdHJpbmcgSUQuXG5lbHNle2luZm89X2luZm8oZWwpO3ZhciBpZD1pbmZvLmlkO2lmKGFbaWRdJiZhW2lkXVtjb25uZWN0aW9uVHlwZV0pe29yaWdpbmFsU3RhdGU9YVtpZF1bY29ubmVjdGlvblR5cGVdLmVuYWJsZWQ7bmV3U3RhdGU9dG9nZ2xlPyFvcmlnaW5hbFN0YXRlOnN0YXRlO2FbaWRdW2Nvbm5lY3Rpb25UeXBlXS5lbmFibGVkPW5ld1N0YXRlO19jdXJyZW50SW5zdGFuY2VbbmV3U3RhdGU/XCJyZW1vdmVDbGFzc1wiOlwiYWRkQ2xhc3NcIl0oaW5mby5lbCxcImp0ay1cIit0eXBlK1wiLWRpc2FibGVkXCIpO319cmV0dXJuIG9yaWdpbmFsU3RhdGU7fS5iaW5kKHRoaXMpO3ZhciBfZmlyc3Q9ZnVuY3Rpb24oZWwsZm4pe2lmKF9qdS5pc1N0cmluZyhlbCl8fCFlbC5sZW5ndGgpe3JldHVybiBmbi5hcHBseSh0aGlzLFtlbF0pO31lbHNlIGlmKGVsLmxlbmd0aCl7cmV0dXJuIGZuLmFwcGx5KHRoaXMsW2VsWzBdXSk7fX0uYmluZCh0aGlzKTt0aGlzLnRvZ2dsZVNvdXJjZUVuYWJsZWQ9ZnVuY3Rpb24oZWwsY29ubmVjdGlvblR5cGUpe19zZXRFbmFibGVkKFwic291cmNlXCIsZWwsbnVsbCx0cnVlLGNvbm5lY3Rpb25UeXBlKTtyZXR1cm4gdGhpcy5pc1NvdXJjZUVuYWJsZWQoZWwsY29ubmVjdGlvblR5cGUpO307dGhpcy5zZXRTb3VyY2VFbmFibGVkPWZ1bmN0aW9uKGVsLHN0YXRlLGNvbm5lY3Rpb25UeXBlKXtyZXR1cm4gX3NldEVuYWJsZWQoXCJzb3VyY2VcIixlbCxzdGF0ZSxudWxsLGNvbm5lY3Rpb25UeXBlKTt9O3RoaXMuaXNTb3VyY2U9ZnVuY3Rpb24oZWwsY29ubmVjdGlvblR5cGUpe2Nvbm5lY3Rpb25UeXBlPWNvbm5lY3Rpb25UeXBlfHxcImRlZmF1bHRcIjtyZXR1cm4gX2ZpcnN0KGVsLGZ1bmN0aW9uKF9lbCl7dmFyIGVsZGVmcz10aGlzLnNvdXJjZUVuZHBvaW50RGVmaW5pdGlvbnNbX2luZm8oX2VsKS5pZF07cmV0dXJuIGVsZGVmcyE9bnVsbCYmZWxkZWZzW2Nvbm5lY3Rpb25UeXBlXSE9bnVsbDt9LmJpbmQodGhpcykpO307dGhpcy5pc1NvdXJjZUVuYWJsZWQ9ZnVuY3Rpb24oZWwsY29ubmVjdGlvblR5cGUpe2Nvbm5lY3Rpb25UeXBlPWNvbm5lY3Rpb25UeXBlfHxcImRlZmF1bHRcIjtyZXR1cm4gX2ZpcnN0KGVsLGZ1bmN0aW9uKF9lbCl7dmFyIHNlcD10aGlzLnNvdXJjZUVuZHBvaW50RGVmaW5pdGlvbnNbX2luZm8oX2VsKS5pZF07cmV0dXJuIHNlcCYmc2VwW2Nvbm5lY3Rpb25UeXBlXSYmc2VwW2Nvbm5lY3Rpb25UeXBlXS5lbmFibGVkPT09dHJ1ZTt9LmJpbmQodGhpcykpO307dGhpcy50b2dnbGVUYXJnZXRFbmFibGVkPWZ1bmN0aW9uKGVsLGNvbm5lY3Rpb25UeXBlKXtfc2V0RW5hYmxlZChcInRhcmdldFwiLGVsLG51bGwsdHJ1ZSxjb25uZWN0aW9uVHlwZSk7cmV0dXJuIHRoaXMuaXNUYXJnZXRFbmFibGVkKGVsLGNvbm5lY3Rpb25UeXBlKTt9O3RoaXMuaXNUYXJnZXQ9ZnVuY3Rpb24oZWwsY29ubmVjdGlvblR5cGUpe2Nvbm5lY3Rpb25UeXBlPWNvbm5lY3Rpb25UeXBlfHxcImRlZmF1bHRcIjtyZXR1cm4gX2ZpcnN0KGVsLGZ1bmN0aW9uKF9lbCl7dmFyIGVsZGVmcz10aGlzLnRhcmdldEVuZHBvaW50RGVmaW5pdGlvbnNbX2luZm8oX2VsKS5pZF07cmV0dXJuIGVsZGVmcyE9bnVsbCYmZWxkZWZzW2Nvbm5lY3Rpb25UeXBlXSE9bnVsbDt9LmJpbmQodGhpcykpO307dGhpcy5pc1RhcmdldEVuYWJsZWQ9ZnVuY3Rpb24oZWwsY29ubmVjdGlvblR5cGUpe2Nvbm5lY3Rpb25UeXBlPWNvbm5lY3Rpb25UeXBlfHxcImRlZmF1bHRcIjtyZXR1cm4gX2ZpcnN0KGVsLGZ1bmN0aW9uKF9lbCl7dmFyIHRlcD10aGlzLnRhcmdldEVuZHBvaW50RGVmaW5pdGlvbnNbX2luZm8oX2VsKS5pZF07cmV0dXJuIHRlcCYmdGVwW2Nvbm5lY3Rpb25UeXBlXSYmdGVwW2Nvbm5lY3Rpb25UeXBlXS5lbmFibGVkPT09dHJ1ZTt9LmJpbmQodGhpcykpO307dGhpcy5zZXRUYXJnZXRFbmFibGVkPWZ1bmN0aW9uKGVsLHN0YXRlLGNvbm5lY3Rpb25UeXBlKXtyZXR1cm4gX3NldEVuYWJsZWQoXCJ0YXJnZXRcIixlbCxzdGF0ZSxudWxsLGNvbm5lY3Rpb25UeXBlKTt9Oy8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLSBlbmQgbWFrZVNvdXJjZS9tYWtlVGFyZ2V0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnRoaXMucmVhZHk9ZnVuY3Rpb24oZm4pe19jdXJyZW50SW5zdGFuY2UuYmluZChcInJlYWR5XCIsZm4pO307dmFyIF9lbEVhY2g9ZnVuY3Rpb24gX2VsRWFjaChlbCxmbil7Ly8gc3VwcG9ydCBib3RoIGxpc3RzLi4uXG5pZigodHlwZW9mIGVsPT09XCJ1bmRlZmluZWRcIj9cInVuZGVmaW5lZFwiOl90eXBlb2YoZWwpKT09PSdvYmplY3QnJiZlbC5sZW5ndGgpe2Zvcih2YXIgaT0wLGlpPWVsLmxlbmd0aDtpPGlpO2krKyl7Zm4oZWxbaV0pO319ZWxzZXsvLyAuLi5hbmQgc2luZ2xlIHN0cmluZ3Mgb3IgZWxlbWVudHMuXG5mbihlbCk7fXJldHVybiBfY3VycmVudEluc3RhbmNlO307Ly8gcmVwYWludCBzb21lIGVsZW1lbnQncyBlbmRwb2ludHMgYW5kIGNvbm5lY3Rpb25zXG50aGlzLnJlcGFpbnQ9ZnVuY3Rpb24oZWwsdWksdGltZXN0YW1wKXtyZXR1cm4gX2VsRWFjaChlbCxmdW5jdGlvbihfZWwpe19kcmF3KF9lbCx1aSx0aW1lc3RhbXApO30pO307dGhpcy5yZXZhbGlkYXRlPWZ1bmN0aW9uKGVsLHRpbWVzdGFtcCxpc0lkQWxyZWFkeSl7cmV0dXJuIF9lbEVhY2goZWwsZnVuY3Rpb24oX2VsKXt2YXIgZWxJZD1pc0lkQWxyZWFkeT9fZWw6X2N1cnJlbnRJbnN0YW5jZS5nZXRJZChfZWwpO19jdXJyZW50SW5zdGFuY2UudXBkYXRlT2Zmc2V0KHtlbElkOmVsSWQscmVjYWxjOnRydWUsdGltZXN0YW1wOnRpbWVzdGFtcH0pO3ZhciBkbT1fY3VycmVudEluc3RhbmNlLmdldERyYWdNYW5hZ2VyKCk7aWYoZG0pe2RtLnVwZGF0ZU9mZnNldHMoZWxJZCk7fV9jdXJyZW50SW5zdGFuY2UucmVwYWludChfZWwpO30pO307Ly8gcmVwYWludCBldmVyeSBlbmRwb2ludCBhbmQgY29ubmVjdGlvbi5cbnRoaXMucmVwYWludEV2ZXJ5dGhpbmc9ZnVuY3Rpb24oKXsvLyBUT0RPIHRoaXMgdGltZXN0YW1wIGNhdXNlcyBjb250aW51b3VzIGFuY2hvcnMgdG8gbm90IHJlcGFpbnQgcHJvcGVybHkuXG4vLyBmaXggdGhpcy4gZG8gbm90IGp1c3QgdGFrZSBvdXQgdGhlIHRpbWVzdGFtcC4gaXQgcnVucyBhIGxvdCBmYXN0ZXIgd2l0aFxuLy8gdGhlIHRpbWVzdGFtcCBpbmNsdWRlZC5cbnZhciB0aW1lc3RhbXA9X3RpbWVzdGFtcCgpLGVsSWQ7Zm9yKGVsSWQgaW4gZW5kcG9pbnRzQnlFbGVtZW50KXtfY3VycmVudEluc3RhbmNlLnVwZGF0ZU9mZnNldCh7ZWxJZDplbElkLHJlY2FsYzp0cnVlLHRpbWVzdGFtcDp0aW1lc3RhbXB9KTt9Zm9yKGVsSWQgaW4gZW5kcG9pbnRzQnlFbGVtZW50KXtfZHJhdyhlbElkLG51bGwsdGltZXN0YW1wKTt9cmV0dXJuIHRoaXM7fTt0aGlzLnJlbW92ZUFsbEVuZHBvaW50cz1mdW5jdGlvbihlbCxyZWN1cnNlLGFmZmVjdGVkRWxlbWVudHMpe2FmZmVjdGVkRWxlbWVudHM9YWZmZWN0ZWRFbGVtZW50c3x8W107dmFyIF9vbmU9ZnVuY3Rpb24gX29uZShfZWwpe3ZhciBpbmZvPV9pbmZvKF9lbCksZWJlPWVuZHBvaW50c0J5RWxlbWVudFtpbmZvLmlkXSxpLGlpO2lmKGViZSl7YWZmZWN0ZWRFbGVtZW50cy5wdXNoKGluZm8pO2ZvcihpPTAsaWk9ZWJlLmxlbmd0aDtpPGlpO2krKyl7X2N1cnJlbnRJbnN0YW5jZS5kZWxldGVFbmRwb2ludChlYmVbaV0sZmFsc2UpO319ZGVsZXRlIGVuZHBvaW50c0J5RWxlbWVudFtpbmZvLmlkXTtpZihyZWN1cnNlKXtpZihpbmZvLmVsJiZpbmZvLmVsLm5vZGVUeXBlIT09MyYmaW5mby5lbC5ub2RlVHlwZSE9PTgpe2ZvcihpPTAsaWk9aW5mby5lbC5jaGlsZE5vZGVzLmxlbmd0aDtpPGlpO2krKyl7X29uZShpbmZvLmVsLmNoaWxkTm9kZXNbaV0pO319fX07X29uZShlbCk7cmV0dXJuIHRoaXM7fTt2YXIgX2RvUmVtb3ZlPWZ1bmN0aW9uIF9kb1JlbW92ZShpbmZvLGFmZmVjdGVkRWxlbWVudHMpe19jdXJyZW50SW5zdGFuY2UucmVtb3ZlQWxsRW5kcG9pbnRzKGluZm8uaWQsdHJ1ZSxhZmZlY3RlZEVsZW1lbnRzKTt2YXIgZG09X2N1cnJlbnRJbnN0YW5jZS5nZXREcmFnTWFuYWdlcigpO3ZhciBfb25lPWZ1bmN0aW9uIF9vbmUoX2luZm8pe2lmKGRtKXtkbS5lbGVtZW50UmVtb3ZlZChfaW5mby5pZCk7fV9jdXJyZW50SW5zdGFuY2UuYW5jaG9yTWFuYWdlci5jbGVhckZvcihfaW5mby5pZCk7X2N1cnJlbnRJbnN0YW5jZS5hbmNob3JNYW5hZ2VyLnJlbW92ZUZsb2F0aW5nQ29ubmVjdGlvbihfaW5mby5pZCk7aWYoX2N1cnJlbnRJbnN0YW5jZS5pc1NvdXJjZShfaW5mby5lbCkpe19jdXJyZW50SW5zdGFuY2UudW5tYWtlU291cmNlKF9pbmZvLmVsKTt9aWYoX2N1cnJlbnRJbnN0YW5jZS5pc1RhcmdldChfaW5mby5lbCkpe19jdXJyZW50SW5zdGFuY2UudW5tYWtlVGFyZ2V0KF9pbmZvLmVsKTt9X2N1cnJlbnRJbnN0YW5jZS5kZXN0cm95RHJhZ2dhYmxlKF9pbmZvLmVsKTtfY3VycmVudEluc3RhbmNlLmRlc3Ryb3lEcm9wcGFibGUoX2luZm8uZWwpO2RlbGV0ZSBfY3VycmVudEluc3RhbmNlLmZsb2F0aW5nQ29ubmVjdGlvbnNbX2luZm8uaWRdO2RlbGV0ZSBtYW5hZ2VkRWxlbWVudHNbX2luZm8uaWRdO2RlbGV0ZSBvZmZzZXRzW19pbmZvLmlkXTtpZihfaW5mby5lbCl7X2N1cnJlbnRJbnN0YW5jZS5yZW1vdmVFbGVtZW50KF9pbmZvLmVsKTtfaW5mby5lbC5fanNQbHVtYj1udWxsO319Oy8vIHJlbW92ZSBhbGwgYWZmZWN0ZWQgY2hpbGQgZWxlbWVudHNcbmZvcih2YXIgYWU9MTthZTxhZmZlY3RlZEVsZW1lbnRzLmxlbmd0aDthZSsrKXtfb25lKGFmZmVjdGVkRWxlbWVudHNbYWVdKTt9Ly8gYW5kIGFsd2F5cyByZW1vdmUgdGhlIHJlcXVlc3RlZCBvbmUgZnJvbSB0aGUgZG9tLlxuX29uZShpbmZvKTt9Oy8qKlxyXG4gICAgICAgICAqIFJlbW92ZSB0aGUgZ2l2ZW4gZWxlbWVudCwgaW5jbHVkaW5nIGNsZWFuaW5nIHVwIGFsbCBlbmRwb2ludHMgcmVnaXN0ZXJlZCBmb3IgaXQuXHJcbiAgICAgICAgICogVGhpcyBpcyBleHBvc2VkIGluIHRoZSBwdWJsaWMgQVBJIGJ1dCBhbHNvIHVzZWQgaW50ZXJuYWxseSBieSBqc1BsdW1iIHdoZW4gcmVtb3ZpbmcgdGhlXHJcbiAgICAgICAgICogZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggYSBjb25uZWN0aW9uIGRyYWcuXHJcbiAgICAgICAgICovdGhpcy5yZW1vdmU9ZnVuY3Rpb24oZWwsZG9Ob3RSZXBhaW50KXt2YXIgaW5mbz1faW5mbyhlbCksYWZmZWN0ZWRFbGVtZW50cz1bXTtpZihpbmZvLnRleHQpe2luZm8uZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpbmZvLmVsKTt9ZWxzZSBpZihpbmZvLmlkKXtfY3VycmVudEluc3RhbmNlLmJhdGNoKGZ1bmN0aW9uKCl7X2RvUmVtb3ZlKGluZm8sYWZmZWN0ZWRFbGVtZW50cyk7fSxkb05vdFJlcGFpbnQ9PT1mYWxzZSk7fXJldHVybiBfY3VycmVudEluc3RhbmNlO307dGhpcy5lbXB0eT1mdW5jdGlvbihlbCxkb05vdFJlcGFpbnQpe3ZhciBhZmZlY3RlZEVsZW1lbnRzPVtdO3ZhciBfb25lPWZ1bmN0aW9uIF9vbmUoZWwsZG9udFJlbW92ZUZvY3VzKXt2YXIgaW5mbz1faW5mbyhlbCk7aWYoaW5mby50ZXh0KXtpbmZvLmVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaW5mby5lbCk7fWVsc2UgaWYoaW5mby5lbCl7d2hpbGUoaW5mby5lbC5jaGlsZE5vZGVzLmxlbmd0aD4wKXtfb25lKGluZm8uZWwuY2hpbGROb2Rlc1swXSk7fWlmKCFkb250UmVtb3ZlRm9jdXMpe19kb1JlbW92ZShpbmZvLGFmZmVjdGVkRWxlbWVudHMpO319fTtfY3VycmVudEluc3RhbmNlLmJhdGNoKGZ1bmN0aW9uKCl7X29uZShlbCx0cnVlKTt9LGRvTm90UmVwYWludD09PWZhbHNlKTtyZXR1cm4gX2N1cnJlbnRJbnN0YW5jZTt9O3RoaXMucmVzZXQ9ZnVuY3Rpb24oZG9Ob3RVbmJpbmRJbnN0YW5jZUV2ZW50TGlzdGVuZXJzKXtfY3VycmVudEluc3RhbmNlLnNpbGVudGx5KGZ1bmN0aW9uKCl7X2hvdmVyU3VzcGVuZGVkPWZhbHNlO19jdXJyZW50SW5zdGFuY2UucmVtb3ZlQWxsR3JvdXBzKCk7X2N1cnJlbnRJbnN0YW5jZS5yZW1vdmVHcm91cE1hbmFnZXIoKTtfY3VycmVudEluc3RhbmNlLmRlbGV0ZUV2ZXJ5RW5kcG9pbnQoKTtpZighZG9Ob3RVbmJpbmRJbnN0YW5jZUV2ZW50TGlzdGVuZXJzKXtfY3VycmVudEluc3RhbmNlLnVuYmluZCgpO310aGlzLnRhcmdldEVuZHBvaW50RGVmaW5pdGlvbnM9e307dGhpcy5zb3VyY2VFbmRwb2ludERlZmluaXRpb25zPXt9O2Nvbm5lY3Rpb25zLmxlbmd0aD0wO2lmKHRoaXMuZG9SZXNldCl7dGhpcy5kb1Jlc2V0KCk7fX0uYmluZCh0aGlzKSk7fTt2YXIgX2NsZWFyT2JqZWN0PWZ1bmN0aW9uIF9jbGVhck9iamVjdChvYmope2lmKG9iai5jYW52YXMmJm9iai5jYW52YXMucGFyZW50Tm9kZSl7b2JqLmNhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG9iai5jYW52YXMpO31vYmouY2xlYW51cCgpO29iai5kZXN0cm95KCk7fTt0aGlzLmNsZWFyPWZ1bmN0aW9uKCl7X2N1cnJlbnRJbnN0YW5jZS5zZWxlY3QoKS5lYWNoKF9jbGVhck9iamVjdCk7X2N1cnJlbnRJbnN0YW5jZS5zZWxlY3RFbmRwb2ludHMoKS5lYWNoKF9jbGVhck9iamVjdCk7ZW5kcG9pbnRzQnlFbGVtZW50PXt9O2VuZHBvaW50c0J5VVVJRD17fTt9O3RoaXMuc2V0RGVmYXVsdFNjb3BlPWZ1bmN0aW9uKHNjb3BlKXtERUZBVUxUX1NDT1BFPXNjb3BlO3JldHVybiBfY3VycmVudEluc3RhbmNlO307Ly8gc2V0cyB3aGV0aGVyIG9yIG5vdCBzb21lIGVsZW1lbnQgc2hvdWxkIGJlIGN1cnJlbnRseSBkcmFnZ2FibGUuXG50aGlzLnNldERyYWdnYWJsZT1fc2V0RHJhZ2dhYmxlO3RoaXMuZGVyaXZlRW5kcG9pbnRBbmRBbmNob3JTcGVjPWZ1bmN0aW9uKHR5cGUsZG9udFByZXBlbmREZWZhdWx0KXt2YXIgYml0cz0oKGRvbnRQcmVwZW5kRGVmYXVsdD9cIlwiOlwiZGVmYXVsdCBcIikrdHlwZSkuc3BsaXQoL1tcXHNdLyksZXBzPW51bGwsZXA9bnVsbCxhPW51bGwsYXM9bnVsbDtmb3IodmFyIGk9MDtpPGJpdHMubGVuZ3RoO2krKyl7dmFyIF90PV9jdXJyZW50SW5zdGFuY2UuZ2V0VHlwZShiaXRzW2ldLFwiY29ubmVjdGlvblwiKTtpZihfdCl7aWYoX3QuZW5kcG9pbnRzKXtlcHM9X3QuZW5kcG9pbnRzO31pZihfdC5lbmRwb2ludCl7ZXA9X3QuZW5kcG9pbnQ7fWlmKF90LmFuY2hvcnMpe2FzPV90LmFuY2hvcnM7fWlmKF90LmFuY2hvcil7YT1fdC5hbmNob3I7fX19cmV0dXJue2VuZHBvaW50czplcHM/ZXBzOltlcCxlcF0sYW5jaG9yczphcz9hczpbYSxhXX07fTsvLyBzZXRzIHRoZSBpZCBvZiBzb21lIGVsZW1lbnQsIGNoYW5naW5nIHdoYXRldmVyIHdlIG5lZWQgdG8gdG8ga2VlcCB0cmFjay5cbnRoaXMuc2V0SWQ9ZnVuY3Rpb24oZWwsbmV3SWQsZG9Ob3RTZXRBdHRyaWJ1dGUpey8vXG52YXIgaWQ7aWYoX2p1LmlzU3RyaW5nKGVsKSl7aWQ9ZWw7fWVsc2V7ZWw9dGhpcy5nZXRFbGVtZW50KGVsKTtpZD10aGlzLmdldElkKGVsKTt9dmFyIHNDb25ucz10aGlzLmdldENvbm5lY3Rpb25zKHtzb3VyY2U6aWQsc2NvcGU6JyonfSx0cnVlKSx0Q29ubnM9dGhpcy5nZXRDb25uZWN0aW9ucyh7dGFyZ2V0OmlkLHNjb3BlOicqJ30sdHJ1ZSk7bmV3SWQ9XCJcIituZXdJZDtpZighZG9Ob3RTZXRBdHRyaWJ1dGUpe2VsPXRoaXMuZ2V0RWxlbWVudChpZCk7dGhpcy5zZXRBdHRyaWJ1dGUoZWwsXCJpZFwiLG5ld0lkKTt9ZWxzZXtlbD10aGlzLmdldEVsZW1lbnQobmV3SWQpO31lbmRwb2ludHNCeUVsZW1lbnRbbmV3SWRdPWVuZHBvaW50c0J5RWxlbWVudFtpZF18fFtdO2Zvcih2YXIgaT0wLGlpPWVuZHBvaW50c0J5RWxlbWVudFtuZXdJZF0ubGVuZ3RoO2k8aWk7aSsrKXtlbmRwb2ludHNCeUVsZW1lbnRbbmV3SWRdW2ldLnNldEVsZW1lbnRJZChuZXdJZCk7ZW5kcG9pbnRzQnlFbGVtZW50W25ld0lkXVtpXS5zZXRSZWZlcmVuY2VFbGVtZW50KGVsKTt9ZGVsZXRlIGVuZHBvaW50c0J5RWxlbWVudFtpZF07dGhpcy5zb3VyY2VFbmRwb2ludERlZmluaXRpb25zW25ld0lkXT10aGlzLnNvdXJjZUVuZHBvaW50RGVmaW5pdGlvbnNbaWRdO2RlbGV0ZSB0aGlzLnNvdXJjZUVuZHBvaW50RGVmaW5pdGlvbnNbaWRdO3RoaXMudGFyZ2V0RW5kcG9pbnREZWZpbml0aW9uc1tuZXdJZF09dGhpcy50YXJnZXRFbmRwb2ludERlZmluaXRpb25zW2lkXTtkZWxldGUgdGhpcy50YXJnZXRFbmRwb2ludERlZmluaXRpb25zW2lkXTt0aGlzLmFuY2hvck1hbmFnZXIuY2hhbmdlSWQoaWQsbmV3SWQpO3ZhciBkbT10aGlzLmdldERyYWdNYW5hZ2VyKCk7aWYoZG0pe2RtLmNoYW5nZUlkKGlkLG5ld0lkKTt9bWFuYWdlZEVsZW1lbnRzW25ld0lkXT1tYW5hZ2VkRWxlbWVudHNbaWRdO2RlbGV0ZSBtYW5hZ2VkRWxlbWVudHNbaWRdO3ZhciBfY29ubnM9ZnVuY3Rpb24gX2Nvbm5zKGxpc3QsZXBJZHgsdHlwZSl7Zm9yKHZhciBpPTAsaWk9bGlzdC5sZW5ndGg7aTxpaTtpKyspe2xpc3RbaV0uZW5kcG9pbnRzW2VwSWR4XS5zZXRFbGVtZW50SWQobmV3SWQpO2xpc3RbaV0uZW5kcG9pbnRzW2VwSWR4XS5zZXRSZWZlcmVuY2VFbGVtZW50KGVsKTtsaXN0W2ldW3R5cGUrXCJJZFwiXT1uZXdJZDtsaXN0W2ldW3R5cGVdPWVsO319O19jb25ucyhzQ29ubnMsMCxcInNvdXJjZVwiKTtfY29ubnModENvbm5zLDEsXCJ0YXJnZXRcIik7dGhpcy5yZXBhaW50KG5ld0lkKTt9O3RoaXMuc2V0RGVidWdMb2c9ZnVuY3Rpb24oZGVidWdMb2cpe2xvZz1kZWJ1Z0xvZzt9O3RoaXMuc2V0U3VzcGVuZERyYXdpbmc9ZnVuY3Rpb24odmFsLHJlcGFpbnRBZnRlcndhcmRzKXt2YXIgY3VyVmFsPV9zdXNwZW5kRHJhd2luZztfc3VzcGVuZERyYXdpbmc9dmFsO2lmKHZhbCl7X3N1c3BlbmRlZEF0PW5ldyBEYXRlKCkuZ2V0VGltZSgpO31lbHNle19zdXNwZW5kZWRBdD1udWxsO31pZihyZXBhaW50QWZ0ZXJ3YXJkcyl7dGhpcy5yZXBhaW50RXZlcnl0aGluZygpO31yZXR1cm4gY3VyVmFsO307Ly8gcmV0dXJucyB3aGV0aGVyIG9yIG5vdCBkcmF3aW5nIGlzIGN1cnJlbnRseSBzdXNwZW5kZWQuXG50aGlzLmlzU3VzcGVuZERyYXdpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gX3N1c3BlbmREcmF3aW5nO307Ly8gcmV0dXJuIHRpbWVzdGFtcCBmb3Igd2hlbiBkcmF3aW5nIHdhcyBzdXNwZW5kZWQuXG50aGlzLmdldFN1c3BlbmRlZEF0PWZ1bmN0aW9uKCl7cmV0dXJuIF9zdXNwZW5kZWRBdDt9O3RoaXMuYmF0Y2g9ZnVuY3Rpb24oZm4sZG9Ob3RSZXBhaW50QWZ0ZXJ3YXJkcyl7dmFyIF93YXNTdXNwZW5kZWQ9dGhpcy5pc1N1c3BlbmREcmF3aW5nKCk7aWYoIV93YXNTdXNwZW5kZWQpe3RoaXMuc2V0U3VzcGVuZERyYXdpbmcodHJ1ZSk7fXRyeXtmbigpO31jYXRjaChlKXtfanUubG9nKFwiRnVuY3Rpb24gcnVuIHdoaWxlIHN1c3BlbmRlZCBmYWlsZWRcIixlKTt9aWYoIV93YXNTdXNwZW5kZWQpe3RoaXMuc2V0U3VzcGVuZERyYXdpbmcoZmFsc2UsIWRvTm90UmVwYWludEFmdGVyd2FyZHMpO319O3RoaXMuZG9XaGlsZVN1c3BlbmRlZD10aGlzLmJhdGNoO3RoaXMuZ2V0Q2FjaGVkRGF0YT1fZ2V0Q2FjaGVkRGF0YTt0aGlzLnRpbWVzdGFtcD1fdGltZXN0YW1wO3RoaXMuc2hvdz1mdW5jdGlvbihlbCxjaGFuZ2VFbmRwb2ludHMpe19zZXRWaXNpYmxlKGVsLFwiYmxvY2tcIixjaGFuZ2VFbmRwb2ludHMpO3JldHVybiBfY3VycmVudEluc3RhbmNlO307Ly8gVE9ETzogdXBkYXRlIHRoaXMgbWV0aG9kIHRvIHJldHVybiB0aGUgY3VycmVudCBzdGF0ZS5cbnRoaXMudG9nZ2xlVmlzaWJsZT1fdG9nZ2xlVmlzaWJsZTt0aGlzLnRvZ2dsZURyYWdnYWJsZT1fdG9nZ2xlRHJhZ2dhYmxlO3RoaXMuYWRkTGlzdGVuZXI9dGhpcy5iaW5kO3ZhciBmbG9hdGluZ0Nvbm5lY3Rpb25zPVtdO3RoaXMucmVnaXN0ZXJGbG9hdGluZ0Nvbm5lY3Rpb249ZnVuY3Rpb24oaW5mbyxjb25uLGVwKXtmbG9hdGluZ0Nvbm5lY3Rpb25zW2luZm8uaWRdPWNvbm47Ly8gb25seSByZWdpc3RlciBmb3IgdGhlIHRhcmdldCBlbmRwb2ludDsgd2Ugd2lsbCBub3QgYmUgZHJhZ2dpbmcgdGhlIHNvdXJjZSBhdCBhbnkgdGltZVxuLy8gYmVmb3JlIHRoaXMgY29ubmVjdGlvbiBpcyBlaXRoZXIgZGlzY2FyZGVkIG9yIG1hZGUgaW50byBhIHBlcm1hbmVudCBjb25uZWN0aW9uLlxuX2p1LmFkZFRvTGlzdChlbmRwb2ludHNCeUVsZW1lbnQsaW5mby5pZCxlcCk7fTt0aGlzLmdldEZsb2F0aW5nQ29ubmVjdGlvbkZvcj1mdW5jdGlvbihpZCl7cmV0dXJuIGZsb2F0aW5nQ29ubmVjdGlvbnNbaWRdO307fTtfanUuZXh0ZW5kKHJvb3QuanNQbHVtYkluc3RhbmNlLF9qdS5FdmVudEdlbmVyYXRvcix7c2V0QXR0cmlidXRlOmZ1bmN0aW9uIHNldEF0dHJpYnV0ZShlbCxhLHYpe3RoaXMuc2V0QXR0cmlidXRlKGVsLGEsdik7fSxnZXRBdHRyaWJ1dGU6ZnVuY3Rpb24gZ2V0QXR0cmlidXRlKGVsLGEpe3JldHVybiB0aGlzLmdldEF0dHJpYnV0ZShyb290LmpzUGx1bWIuZ2V0RWxlbWVudChlbCksYSk7fSxjb252ZXJ0VG9GdWxsT3ZlcmxheVNwZWM6ZnVuY3Rpb24gY29udmVydFRvRnVsbE92ZXJsYXlTcGVjKHNwZWMpe2lmKF9qdS5pc1N0cmluZyhzcGVjKSl7c3BlYz1bc3BlYyx7fV07fXNwZWNbMV0uaWQ9c3BlY1sxXS5pZHx8X2p1LnV1aWQoKTtyZXR1cm4gc3BlYzt9LHJlZ2lzdGVyQ29ubmVjdGlvblR5cGU6ZnVuY3Rpb24gcmVnaXN0ZXJDb25uZWN0aW9uVHlwZShpZCx0eXBlKXt0aGlzLl9jb25uZWN0aW9uVHlwZXNbaWRdPXJvb3QuanNQbHVtYi5leHRlbmQoe30sdHlwZSk7aWYodHlwZS5vdmVybGF5cyl7dmFyIHRvPXt9O2Zvcih2YXIgaT0wO2k8dHlwZS5vdmVybGF5cy5sZW5ndGg7aSsrKXsvLyBpZiBhIHN0cmluZywgY29udmVydCB0byBvYmplY3QgcmVwcmVzZW50YXRpb24gc28gdGhhdCB3ZSBjYW4gc3RvcmUgdGhlIHR5cGVpZCBvbiBpdC5cbi8vIGFsc28gYXNzaWduIGFuIGlkLlxudmFyIGZvPXRoaXMuY29udmVydFRvRnVsbE92ZXJsYXlTcGVjKHR5cGUub3ZlcmxheXNbaV0pO3RvW2ZvWzFdLmlkXT1mbzt9dGhpcy5fY29ubmVjdGlvblR5cGVzW2lkXS5vdmVybGF5cz10bzt9fSxyZWdpc3RlckNvbm5lY3Rpb25UeXBlczpmdW5jdGlvbiByZWdpc3RlckNvbm5lY3Rpb25UeXBlcyh0eXBlcyl7Zm9yKHZhciBpIGluIHR5cGVzKXt0aGlzLnJlZ2lzdGVyQ29ubmVjdGlvblR5cGUoaSx0eXBlc1tpXSk7fX0scmVnaXN0ZXJFbmRwb2ludFR5cGU6ZnVuY3Rpb24gcmVnaXN0ZXJFbmRwb2ludFR5cGUoaWQsdHlwZSl7dGhpcy5fZW5kcG9pbnRUeXBlc1tpZF09cm9vdC5qc1BsdW1iLmV4dGVuZCh7fSx0eXBlKTtpZih0eXBlLm92ZXJsYXlzKXt2YXIgdG89e307Zm9yKHZhciBpPTA7aTx0eXBlLm92ZXJsYXlzLmxlbmd0aDtpKyspey8vIGlmIGEgc3RyaW5nLCBjb252ZXJ0IHRvIG9iamVjdCByZXByZXNlbnRhdGlvbiBzbyB0aGF0IHdlIGNhbiBzdG9yZSB0aGUgdHlwZWlkIG9uIGl0LlxuLy8gYWxzbyBhc3NpZ24gYW4gaWQuXG52YXIgZm89dGhpcy5jb252ZXJ0VG9GdWxsT3ZlcmxheVNwZWModHlwZS5vdmVybGF5c1tpXSk7dG9bZm9bMV0uaWRdPWZvO310aGlzLl9lbmRwb2ludFR5cGVzW2lkXS5vdmVybGF5cz10bzt9fSxyZWdpc3RlckVuZHBvaW50VHlwZXM6ZnVuY3Rpb24gcmVnaXN0ZXJFbmRwb2ludFR5cGVzKHR5cGVzKXtmb3IodmFyIGkgaW4gdHlwZXMpe3RoaXMucmVnaXN0ZXJFbmRwb2ludFR5cGUoaSx0eXBlc1tpXSk7fX0sZ2V0VHlwZTpmdW5jdGlvbiBnZXRUeXBlKGlkLHR5cGVEZXNjcmlwdG9yKXtyZXR1cm4gdHlwZURlc2NyaXB0b3I9PT1cImNvbm5lY3Rpb25cIj90aGlzLl9jb25uZWN0aW9uVHlwZXNbaWRdOnRoaXMuX2VuZHBvaW50VHlwZXNbaWRdO30sc2V0SWRDaGFuZ2VkOmZ1bmN0aW9uIHNldElkQ2hhbmdlZChvbGRJZCxuZXdJZCl7dGhpcy5zZXRJZChvbGRJZCxuZXdJZCx0cnVlKTt9LC8vIHNldCBwYXJlbnQ6IGNoYW5nZSB0aGUgcGFyZW50IGZvciBzb21lIG5vZGUgYW5kIHVwZGF0ZSBhbGwgdGhlIHJlZ2lzdHJhdGlvbnMgd2UgbmVlZCB0by5cbnNldFBhcmVudDpmdW5jdGlvbiBzZXRQYXJlbnQoZWwsbmV3UGFyZW50KXt2YXIgX2RvbT10aGlzLmdldEVsZW1lbnQoZWwpLF9pZD10aGlzLmdldElkKF9kb20pLF9wZG9tPXRoaXMuZ2V0RWxlbWVudChuZXdQYXJlbnQpLF9waWQ9dGhpcy5nZXRJZChfcGRvbSksZG09dGhpcy5nZXREcmFnTWFuYWdlcigpO19kb20ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChfZG9tKTtfcGRvbS5hcHBlbmRDaGlsZChfZG9tKTtpZihkbSl7ZG0uc2V0UGFyZW50KF9kb20sX2lkLF9wZG9tLF9waWQpO319LGV4dGVuZDpmdW5jdGlvbiBleHRlbmQobzEsbzIsbmFtZXMpe3ZhciBpO2lmKG5hbWVzKXtmb3IoaT0wO2k8bmFtZXMubGVuZ3RoO2krKyl7bzFbbmFtZXNbaV1dPW8yW25hbWVzW2ldXTt9fWVsc2V7Zm9yKGkgaW4gbzIpe28xW2ldPW8yW2ldO319cmV0dXJuIG8xO30sZmxvYXRpbmdDb25uZWN0aW9uczp7fSxnZXRGbG9hdGluZ0FuY2hvckluZGV4OmZ1bmN0aW9uIGdldEZsb2F0aW5nQW5jaG9ySW5kZXgoanBjKXtyZXR1cm4ganBjLmVuZHBvaW50c1swXS5pc0Zsb2F0aW5nKCk/MDpqcGMuZW5kcG9pbnRzWzFdLmlzRmxvYXRpbmcoKT8xOi0xO319KTtqc1BsdW1iSW5zdGFuY2UucHJvdG90eXBlLkRlZmF1bHRzPXtBbmNob3I6XCJCb3R0b21cIixBbmNob3JzOltudWxsLG51bGxdLENvbm5lY3Rpb25zRGV0YWNoYWJsZTp0cnVlLENvbm5lY3Rpb25PdmVybGF5czpbXSxDb25uZWN0b3I6XCJCZXppZXJcIixDb250YWluZXI6bnVsbCxEb05vdFRocm93RXJyb3JzOmZhbHNlLERyYWdPcHRpb25zOnt9LERyb3BPcHRpb25zOnt9LEVuZHBvaW50OlwiRG90XCIsRW5kcG9pbnRPdmVybGF5czpbXSxFbmRwb2ludHM6W251bGwsbnVsbF0sRW5kcG9pbnRTdHlsZTp7ZmlsbDpcIiM0NTZcIn0sRW5kcG9pbnRTdHlsZXM6W251bGwsbnVsbF0sRW5kcG9pbnRIb3ZlclN0eWxlOm51bGwsRW5kcG9pbnRIb3ZlclN0eWxlczpbbnVsbCxudWxsXSxIb3ZlclBhaW50U3R5bGU6bnVsbCxMYWJlbFN0eWxlOntjb2xvcjpcImJsYWNrXCJ9LExvZ0VuYWJsZWQ6ZmFsc2UsT3ZlcmxheXM6W10sTWF4Q29ubmVjdGlvbnM6MSxQYWludFN0eWxlOntcInN0cm9rZS13aWR0aFwiOjQsc3Ryb2tlOlwiIzQ1NlwifSxSZWF0dGFjaENvbm5lY3Rpb25zOmZhbHNlLFJlbmRlck1vZGU6XCJzdmdcIixTY29wZTpcImpzUGx1bWJfRGVmYXVsdFNjb3BlXCJ9Oy8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLSBzdGF0aWMgaW5zdGFuY2UgKyBtb2R1bGUgcmVnaXN0cmF0aW9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGNyZWF0ZSBzdGF0aWMgaW5zdGFuY2UgYW5kIGFzc2lnbiB0byB3aW5kb3cgaWYgd2luZG93IGV4aXN0cy5cdFxudmFyIGpzUGx1bWI9bmV3IGpzUGx1bWJJbnN0YW5jZSgpOy8vIHJlZ2lzdGVyIG9uICdyb290JyAobGV0cyB1cyBydW4gb24gc2VydmVyIG9yIGJyb3dzZXIpXG5yb290LmpzUGx1bWI9anNQbHVtYjsvLyBhZGQgJ2dldEluc3RhbmNlJyBtZXRob2QgdG8gc3RhdGljIGluc3RhbmNlXG5qc1BsdW1iLmdldEluc3RhbmNlPWZ1bmN0aW9uKF9kZWZhdWx0cyxvdmVycmlkZUZucyl7dmFyIGo9bmV3IGpzUGx1bWJJbnN0YW5jZShfZGVmYXVsdHMpO2lmKG92ZXJyaWRlRm5zKXtmb3IodmFyIG92ZiBpbiBvdmVycmlkZUZucyl7altvdmZdPW92ZXJyaWRlRm5zW292Zl07fX1qLmluaXQoKTtyZXR1cm4gajt9O2pzUGx1bWIuZWFjaD1mdW5jdGlvbihzcGVjLGZuKXtpZihzcGVjPT1udWxsKXtyZXR1cm47fWlmKHR5cGVvZiBzcGVjPT09XCJzdHJpbmdcIil7Zm4oanNQbHVtYi5nZXRFbGVtZW50KHNwZWMpKTt9ZWxzZSBpZihzcGVjLmxlbmd0aCE9bnVsbCl7Zm9yKHZhciBpPTA7aTxzcGVjLmxlbmd0aDtpKyspe2ZuKGpzUGx1bWIuZ2V0RWxlbWVudChzcGVjW2ldKSk7fX1lbHNle2ZuKHNwZWMpO30vLyBhc3N1bWUgaXQncyBhbiBlbGVtZW50LlxufTsvLyBDb21tb25KU1xuaWYodHlwZW9mIGV4cG9ydHMhPT0ndW5kZWZpbmVkJyl7ZXhwb3J0cy5qc1BsdW1iPWpzUGx1bWI7fS8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLSBlbmQgc3RhdGljIGluc3RhbmNlICsgQU1EIHJlZ2lzdHJhdGlvbiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHRcdFxufSkuY2FsbCh0eXBlb2Ygd2luZG93IT09J3VuZGVmaW5lZCc/d2luZG93OnRoaXMpOy8qXHJcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUgYmFzZSBmdW5jdGlvbmFsaXR5IGZvciBET00gdHlwZSBhZGFwdGVycy5cclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDEwIC0gMjAxOCBqc1BsdW1iIChoZWxsb0Bqc3BsdW1idG9vbGtpdC5jb20pXHJcbiAqXHJcbiAqIGh0dHBzOi8vanNwbHVtYnRvb2xraXQuY29tXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qc3BsdW1iL2pzcGx1bWJcclxuICpcclxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwyIGxpY2Vuc2VzLlxyXG4gKi87KGZ1bmN0aW9uKCl7dmFyIHJvb3Q9dGhpcyxfanU9cm9vdC5qc1BsdW1iVXRpbDt2YXIgX2dlbkxvYz1mdW5jdGlvbiBfZ2VuTG9jKHByZWZpeCxlKXtpZihlPT1udWxsKXtyZXR1cm5bMCwwXTt9dmFyIHRzPV90b3VjaGVzKGUpLHQ9X2dldFRvdWNoKHRzLDApO3JldHVyblt0W3ByZWZpeCtcIlhcIl0sdFtwcmVmaXgrXCJZXCJdXTt9LF9wYWdlTG9jYXRpb249X2dlbkxvYy5iaW5kKHRoaXMsXCJwYWdlXCIpLF9zY3JlZW5Mb2NhdGlvbj1fZ2VuTG9jLmJpbmQodGhpcyxcInNjcmVlblwiKSxfY2xpZW50TG9jYXRpb249X2dlbkxvYy5iaW5kKHRoaXMsXCJjbGllbnRcIiksX2dldFRvdWNoPWZ1bmN0aW9uIF9nZXRUb3VjaCh0b3VjaGVzLGlkeCl7cmV0dXJuIHRvdWNoZXMuaXRlbT90b3VjaGVzLml0ZW0oaWR4KTp0b3VjaGVzW2lkeF07fSxfdG91Y2hlcz1mdW5jdGlvbiBfdG91Y2hlcyhlKXtyZXR1cm4gZS50b3VjaGVzJiZlLnRvdWNoZXMubGVuZ3RoPjA/ZS50b3VjaGVzOmUuY2hhbmdlZFRvdWNoZXMmJmUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoPjA/ZS5jaGFuZ2VkVG91Y2hlczplLnRhcmdldFRvdWNoZXMmJmUudGFyZ2V0VG91Y2hlcy5sZW5ndGg+MD9lLnRhcmdldFRvdWNoZXM6W2VdO307LyoqXHJcbiAgICAgTWFuYWdlcyBkcmFnZ2luZyBmb3Igc29tZSBpbnN0YW5jZSBvZiBqc1BsdW1iLlxyXG5cclxuICAgICBUT0RPIGluc3RlYWQgb2YgdGhpcyBiZWluZyBhY2Nlc3NlZCBkaXJlY3RseSwgaXQgc2hvdWxkIHN1YnNjcmliZSB0byBldmVudHMgb24gdGhlIGpzUGx1bWIgaW5zdGFuY2U6IGV2ZXJ5IG1ldGhvZFxyXG4gICAgIGluIGhlcmUgaXMgY2FsbGVkIGRpcmVjdGx5IGJ5IGpzUGx1bWIuIEJ1dCB3aGF0IHNob3VsZCBoYXBwZW4gaXMgdGhhdCB3ZSBoYXZlIHVucHVibGlzaGVkIGV2ZW50cyB0aGF0IHRoaXMgbGlzdGVuc1xyXG4gICAgIHRvLiAgVGhlIG9ubHkgdHJpY2sgaXMgZ2V0dGluZyBvbmUgb2YgdGhlc2UgaW5zdGFudGlhdGVkIHdpdGggZXZlcnkganNQbHVtYiBpbnN0YW5jZTogaXQgbmVlZHMgdG8gaGF2ZSBhIGhvb2sgc29tZWhvdy5cclxuICAgICBCYXNpY2FsbHkgdGhlIGdlbmVyYWwgaWRlYSBpcyB0byBwdWxsIEFMTCB0aGUgZHJhZyBjb2RlIG91dCAocHJvdG90eXBlIG1ldGhvZCByZWdpc3RyYXRpb25zIHBsdXMgdGhpcykgaW50byBhXHJcbiAgICAgZGVkaWNhdGVkIGRyYWcgc2NyaXB0KSwgdGhhdCBkb2VzIG5vdCBuZWNlc3NhcmlseSBuZWVkIHRvIGJlIGluY2x1ZGVkLlxyXG5cclxuXHJcbiAgICAgKi92YXIgRHJhZ01hbmFnZXI9ZnVuY3Rpb24gRHJhZ01hbmFnZXIoX2N1cnJlbnRJbnN0YW5jZSl7dmFyIF9kcmFnZ2FibGVzPXt9LF9kbGlzdD1bXSxfZGVsZW1lbnRzPXt9LF9lbGVtZW50c1dpdGhFbmRwb2ludHM9e30sLy8gZWxlbWVudGlkcyBtYXBwZWQgdG8gdGhlIGRyYWdnYWJsZSB0byB3aGljaCB0aGV5IGJlbG9uZy5cbl9kcmFnZ2FibGVzRm9yRWxlbWVudHM9e307LyoqXHJcbiAgICAgICAgIHJlZ2lzdGVyIHNvbWUgZWxlbWVudCBhcyBkcmFnZ2FibGUuICByaWdodCBub3cgdGhlIGRyYWcgaW5pdCBzdHVmZiBpcyBkb25lIGVsc2V3aGVyZSwgYW5kIGl0IGlzXHJcbiAgICAgICAgIHBvc3NpYmxlIHRoYXQgd2lsbCBjb250aW51ZSB0byBiZSB0aGUgY2FzZS5cclxuICAgICAgICAgKi90aGlzLnJlZ2lzdGVyPWZ1bmN0aW9uKGVsKXt2YXIgaWQ9X2N1cnJlbnRJbnN0YW5jZS5nZXRJZChlbCkscGFyZW50T2Zmc2V0PV9jdXJyZW50SW5zdGFuY2UuZ2V0T2Zmc2V0KGVsKTtpZighX2RyYWdnYWJsZXNbaWRdKXtfZHJhZ2dhYmxlc1tpZF09ZWw7X2RsaXN0LnB1c2goZWwpO19kZWxlbWVudHNbaWRdPXt9O30vLyBsb29rIGZvciBjaGlsZCBlbGVtZW50cyB0aGF0IGhhdmUgZW5kcG9pbnRzIGFuZCByZWdpc3RlciB0aGVtIGFnYWluc3QgdGhpcyBkcmFnZ2FibGUuXG52YXIgX29uZUxldmVsPWZ1bmN0aW9uIF9vbmVMZXZlbChwKXtpZihwKXtmb3IodmFyIGk9MDtpPHAuY2hpbGROb2Rlcy5sZW5ndGg7aSsrKXtpZihwLmNoaWxkTm9kZXNbaV0ubm9kZVR5cGUhPT0zJiZwLmNoaWxkTm9kZXNbaV0ubm9kZVR5cGUhPT04KXt2YXIgY0VsPWpzUGx1bWIuZ2V0RWxlbWVudChwLmNoaWxkTm9kZXNbaV0pLGNpZD1fY3VycmVudEluc3RhbmNlLmdldElkKHAuY2hpbGROb2Rlc1tpXSxudWxsLHRydWUpO2lmKGNpZCYmX2VsZW1lbnRzV2l0aEVuZHBvaW50c1tjaWRdJiZfZWxlbWVudHNXaXRoRW5kcG9pbnRzW2NpZF0+MCl7dmFyIGNPZmY9X2N1cnJlbnRJbnN0YW5jZS5nZXRPZmZzZXQoY0VsKTtfZGVsZW1lbnRzW2lkXVtjaWRdPXtpZDpjaWQsb2Zmc2V0OntsZWZ0OmNPZmYubGVmdC1wYXJlbnRPZmZzZXQubGVmdCx0b3A6Y09mZi50b3AtcGFyZW50T2Zmc2V0LnRvcH19O19kcmFnZ2FibGVzRm9yRWxlbWVudHNbY2lkXT1pZDt9X29uZUxldmVsKHAuY2hpbGROb2Rlc1tpXSk7fX19fTtfb25lTGV2ZWwoZWwpO307Ly8gcmVmcmVzaCB0aGUgb2Zmc2V0cyBmb3IgY2hpbGQgZWxlbWVudHMgb2YgdGhpcyBlbGVtZW50LlxudGhpcy51cGRhdGVPZmZzZXRzPWZ1bmN0aW9uKGVsSWQsY2hpbGRPZmZzZXRPdmVycmlkZXMpe2lmKGVsSWQhPW51bGwpe2NoaWxkT2Zmc2V0T3ZlcnJpZGVzPWNoaWxkT2Zmc2V0T3ZlcnJpZGVzfHx7fTt2YXIgZG9tRWw9anNQbHVtYi5nZXRFbGVtZW50KGVsSWQpLGlkPV9jdXJyZW50SW5zdGFuY2UuZ2V0SWQoZG9tRWwpLGNoaWxkcmVuPV9kZWxlbWVudHNbaWRdLHBhcmVudE9mZnNldD1fY3VycmVudEluc3RhbmNlLmdldE9mZnNldChkb21FbCk7aWYoY2hpbGRyZW4pe2Zvcih2YXIgaSBpbiBjaGlsZHJlbil7aWYoY2hpbGRyZW4uaGFzT3duUHJvcGVydHkoaSkpe3ZhciBjZWw9anNQbHVtYi5nZXRFbGVtZW50KGkpLGNPZmY9Y2hpbGRPZmZzZXRPdmVycmlkZXNbaV18fF9jdXJyZW50SW5zdGFuY2UuZ2V0T2Zmc2V0KGNlbCk7Ly8gZG8gbm90IHVwZGF0ZSBpZiB3ZSBoYXZlIGEgdmFsdWUgYWxyZWFkeSBhbmQgd2UnZCBqdXN0IGJlIHdyaXRpbmcgMCwwXG5pZihjZWwub2Zmc2V0UGFyZW50PT1udWxsJiZfZGVsZW1lbnRzW2lkXVtpXSE9bnVsbCl7Y29udGludWU7fV9kZWxlbWVudHNbaWRdW2ldPXtpZDppLG9mZnNldDp7bGVmdDpjT2ZmLmxlZnQtcGFyZW50T2Zmc2V0LmxlZnQsdG9wOmNPZmYudG9wLXBhcmVudE9mZnNldC50b3B9fTtfZHJhZ2dhYmxlc0ZvckVsZW1lbnRzW2ldPWlkO319fX19Oy8qKlxyXG4gICAgICAgICBub3RpZmljYXRpb24gdGhhdCBhbiBlbmRwb2ludCB3YXMgYWRkZWQgdG8gdGhlIGdpdmVuIGVsLiAgd2UgZ28gdXAgZnJvbSB0aGF0IGVsJ3MgcGFyZW50XHJcbiAgICAgICAgIG5vZGUsIGxvb2tpbmcgZm9yIGEgcGFyZW50IHRoYXQgaGFzIGJlZW4gcmVnaXN0ZXJlZCBhcyBhIGRyYWdnYWJsZS4gaWYgd2UgZmluZCBvbmUsIHdlIGFkZCB0aGlzXHJcbiAgICAgICAgIGVsIHRvIHRoYXQgcGFyZW50J3MgbGlzdCBvZiBlbGVtZW50cyB0byB1cGRhdGUgb24gZHJhZyAoaWYgaXQgaXMgbm90IHRoZXJlIGFscmVhZHkpXHJcbiAgICAgICAgICovdGhpcy5lbmRwb2ludEFkZGVkPWZ1bmN0aW9uKGVsLGlkKXtpZD1pZHx8X2N1cnJlbnRJbnN0YW5jZS5nZXRJZChlbCk7dmFyIGI9ZG9jdW1lbnQuYm9keSxwPWVsLnBhcmVudE5vZGU7X2VsZW1lbnRzV2l0aEVuZHBvaW50c1tpZF09X2VsZW1lbnRzV2l0aEVuZHBvaW50c1tpZF0/X2VsZW1lbnRzV2l0aEVuZHBvaW50c1tpZF0rMToxO3doaWxlKHAhPW51bGwmJnAhPT1iKXt2YXIgcGlkPV9jdXJyZW50SW5zdGFuY2UuZ2V0SWQocCxudWxsLHRydWUpO2lmKHBpZCYmX2RyYWdnYWJsZXNbcGlkXSl7dmFyIHBMb2M9X2N1cnJlbnRJbnN0YW5jZS5nZXRPZmZzZXQocCk7aWYoX2RlbGVtZW50c1twaWRdW2lkXT09bnVsbCl7dmFyIGNMb2M9X2N1cnJlbnRJbnN0YW5jZS5nZXRPZmZzZXQoZWwpO19kZWxlbWVudHNbcGlkXVtpZF09e2lkOmlkLG9mZnNldDp7bGVmdDpjTG9jLmxlZnQtcExvYy5sZWZ0LHRvcDpjTG9jLnRvcC1wTG9jLnRvcH19O19kcmFnZ2FibGVzRm9yRWxlbWVudHNbaWRdPXBpZDt9YnJlYWs7fXA9cC5wYXJlbnROb2RlO319O3RoaXMuZW5kcG9pbnREZWxldGVkPWZ1bmN0aW9uKGVuZHBvaW50KXtpZihfZWxlbWVudHNXaXRoRW5kcG9pbnRzW2VuZHBvaW50LmVsZW1lbnRJZF0pe19lbGVtZW50c1dpdGhFbmRwb2ludHNbZW5kcG9pbnQuZWxlbWVudElkXS0tO2lmKF9lbGVtZW50c1dpdGhFbmRwb2ludHNbZW5kcG9pbnQuZWxlbWVudElkXTw9MCl7Zm9yKHZhciBpIGluIF9kZWxlbWVudHMpe2lmKF9kZWxlbWVudHMuaGFzT3duUHJvcGVydHkoaSkmJl9kZWxlbWVudHNbaV0pe2RlbGV0ZSBfZGVsZW1lbnRzW2ldW2VuZHBvaW50LmVsZW1lbnRJZF07ZGVsZXRlIF9kcmFnZ2FibGVzRm9yRWxlbWVudHNbZW5kcG9pbnQuZWxlbWVudElkXTt9fX19fTt0aGlzLmNoYW5nZUlkPWZ1bmN0aW9uKG9sZElkLG5ld0lkKXtfZGVsZW1lbnRzW25ld0lkXT1fZGVsZW1lbnRzW29sZElkXTtfZGVsZW1lbnRzW29sZElkXT17fTtfZHJhZ2dhYmxlc0ZvckVsZW1lbnRzW25ld0lkXT1fZHJhZ2dhYmxlc0ZvckVsZW1lbnRzW29sZElkXTtfZHJhZ2dhYmxlc0ZvckVsZW1lbnRzW29sZElkXT1udWxsO307dGhpcy5nZXRFbGVtZW50c0ZvckRyYWdnYWJsZT1mdW5jdGlvbihpZCl7cmV0dXJuIF9kZWxlbWVudHNbaWRdO307dGhpcy5lbGVtZW50UmVtb3ZlZD1mdW5jdGlvbihlbGVtZW50SWQpe3ZhciBlbElkPV9kcmFnZ2FibGVzRm9yRWxlbWVudHNbZWxlbWVudElkXTtpZihlbElkKXtkZWxldGUgX2RlbGVtZW50c1tlbElkXVtlbGVtZW50SWRdO2RlbGV0ZSBfZHJhZ2dhYmxlc0ZvckVsZW1lbnRzW2VsZW1lbnRJZF07fX07dGhpcy5yZXNldD1mdW5jdGlvbigpe19kcmFnZ2FibGVzPXt9O19kbGlzdD1bXTtfZGVsZW1lbnRzPXt9O19lbGVtZW50c1dpdGhFbmRwb2ludHM9e307fTsvL1xuLy8gbm90aWZpY2F0aW9uIGRyYWcgZW5kZWQuIFdlIGNoZWNrIGF1dG9tYXRpY2FsbHkgaWYgbmVlZCB0byB1cGRhdGUgc29tZVxuLy8gYW5jZXN0b3IncyBvZmZzZXRzLlxuLy9cbnRoaXMuZHJhZ0VuZGVkPWZ1bmN0aW9uKGVsKXtpZihlbC5vZmZzZXRQYXJlbnQhPW51bGwpe3ZhciBpZD1fY3VycmVudEluc3RhbmNlLmdldElkKGVsKSxhbmNlc3Rvcj1fZHJhZ2dhYmxlc0ZvckVsZW1lbnRzW2lkXTtpZihhbmNlc3Rvcil7dGhpcy51cGRhdGVPZmZzZXRzKGFuY2VzdG9yKTt9fX07dGhpcy5zZXRQYXJlbnQ9ZnVuY3Rpb24oZWwsZWxJZCxwLHBJZCxjdXJyZW50Q2hpbGRMb2NhdGlvbil7dmFyIGN1cnJlbnQ9X2RyYWdnYWJsZXNGb3JFbGVtZW50c1tlbElkXTtpZighX2RlbGVtZW50c1twSWRdKXtfZGVsZW1lbnRzW3BJZF09e307fXZhciBwTG9jPV9jdXJyZW50SW5zdGFuY2UuZ2V0T2Zmc2V0KHApLGNMb2M9Y3VycmVudENoaWxkTG9jYXRpb258fF9jdXJyZW50SW5zdGFuY2UuZ2V0T2Zmc2V0KGVsKTtpZihjdXJyZW50JiZfZGVsZW1lbnRzW2N1cnJlbnRdKXtkZWxldGUgX2RlbGVtZW50c1tjdXJyZW50XVtlbElkXTt9X2RlbGVtZW50c1twSWRdW2VsSWRdPXtpZDplbElkLG9mZnNldDp7bGVmdDpjTG9jLmxlZnQtcExvYy5sZWZ0LHRvcDpjTG9jLnRvcC1wTG9jLnRvcH19O19kcmFnZ2FibGVzRm9yRWxlbWVudHNbZWxJZF09cElkO307dGhpcy5jbGVhclBhcmVudD1mdW5jdGlvbihlbCxlbElkKXt2YXIgY3VycmVudD1fZHJhZ2dhYmxlc0ZvckVsZW1lbnRzW2VsSWRdO2lmKGN1cnJlbnQpe2RlbGV0ZSBfZGVsZW1lbnRzW2N1cnJlbnRdW2VsSWRdO2RlbGV0ZSBfZHJhZ2dhYmxlc0ZvckVsZW1lbnRzW2VsSWRdO319O3RoaXMucmV2YWxpZGF0ZVBhcmVudD1mdW5jdGlvbihlbCxlbElkLGNoaWxkT2Zmc2V0KXt2YXIgY3VycmVudD1fZHJhZ2dhYmxlc0ZvckVsZW1lbnRzW2VsSWRdO2lmKGN1cnJlbnQpe3ZhciBjbz17fTtjb1tlbElkXT1jaGlsZE9mZnNldDt0aGlzLnVwZGF0ZU9mZnNldHMoY3VycmVudCxjbyk7X2N1cnJlbnRJbnN0YW5jZS5yZXZhbGlkYXRlKGN1cnJlbnQpO319O3RoaXMuZ2V0RHJhZ0FuY2VzdG9yPWZ1bmN0aW9uKGVsKXt2YXIgZGU9anNQbHVtYi5nZXRFbGVtZW50KGVsKSxpZD1fY3VycmVudEluc3RhbmNlLmdldElkKGRlKSxhaWQ9X2RyYWdnYWJsZXNGb3JFbGVtZW50c1tpZF07aWYoYWlkKXtyZXR1cm4ganNQbHVtYi5nZXRFbGVtZW50KGFpZCk7fWVsc2V7cmV0dXJuIG51bGw7fX07fTt2YXIgdHJpbT1mdW5jdGlvbiB0cmltKHN0cil7cmV0dXJuIHN0cj09bnVsbD9udWxsOnN0ci5yZXBsYWNlKC9eXFxzXFxzKi8sJycpLnJlcGxhY2UoL1xcc1xccyokLywnJyk7fSxfc2V0Q2xhc3NOYW1lPWZ1bmN0aW9uIF9zZXRDbGFzc05hbWUoZWwsY24sY2xhc3NMaXN0KXtjbj10cmltKGNuKTtpZih0eXBlb2YgZWwuY2xhc3NOYW1lLmJhc2VWYWwhPT1cInVuZGVmaW5lZFwiKXtlbC5jbGFzc05hbWUuYmFzZVZhbD1jbjt9ZWxzZXtlbC5jbGFzc05hbWU9Y247fS8vIHJlY2VudCAoaSBjdXJyZW50bHkgaGF2ZSAgNjEuMC4zMTYzLjEwMCkgdmVyc2lvbiBvZiBjaHJvbWUgZG8gbm90IHVwZGF0ZSBjbGFzc0xpc3Qgd2hlbiB5b3Ugc2V0IHRoZSBiYXNlIHZhbFxuLy8gb2YgYW4gc3ZnIGVsZW1lbnQncyBjbGFzc05hbWUuIGluIHRoZSBsb25nIHJ1biB3ZSdkIGxpa2UgdG8gbW92ZSB0byBqdXN0IHVzaW5nIGNsYXNzTGlzdCBhbnl3YXlcbnRyeXt2YXIgY2w9ZWwuY2xhc3NMaXN0O3doaWxlKGNsLmxlbmd0aD4wKXtjbC5yZW1vdmUoY2wuaXRlbSgwKSk7fWZvcih2YXIgaT0wO2k8Y2xhc3NMaXN0Lmxlbmd0aDtpKyspe2lmKGNsYXNzTGlzdFtpXSl7Y2wuYWRkKGNsYXNzTGlzdFtpXSk7fX19Y2F0Y2goZSl7Ly8gbm90IGZhdGFsXG5jb25zb2xlLmxvZyhcIkpTUExVTUI6IGNhbm5vdCBzZXQgY2xhc3MgbGlzdFwiLGUpO319LF9nZXRDbGFzc05hbWU9ZnVuY3Rpb24gX2dldENsYXNzTmFtZShlbCl7cmV0dXJuIHR5cGVvZiBlbC5jbGFzc05hbWUuYmFzZVZhbD09PVwidW5kZWZpbmVkXCI/ZWwuY2xhc3NOYW1lOmVsLmNsYXNzTmFtZS5iYXNlVmFsO30sX2NsYXNzTWFuaXA9ZnVuY3Rpb24gX2NsYXNzTWFuaXAoZWwsY2xhc3Nlc1RvQWRkLGNsYXNzZXNUb1JlbW92ZSl7Y2xhc3Nlc1RvQWRkPWNsYXNzZXNUb0FkZD09bnVsbD9bXTpfanUuaXNBcnJheShjbGFzc2VzVG9BZGQpP2NsYXNzZXNUb0FkZDpjbGFzc2VzVG9BZGQuc3BsaXQoL1xccysvKTtjbGFzc2VzVG9SZW1vdmU9Y2xhc3Nlc1RvUmVtb3ZlPT1udWxsP1tdOl9qdS5pc0FycmF5KGNsYXNzZXNUb1JlbW92ZSk/Y2xhc3Nlc1RvUmVtb3ZlOmNsYXNzZXNUb1JlbW92ZS5zcGxpdCgvXFxzKy8pO3ZhciBjbGFzc05hbWU9X2dldENsYXNzTmFtZShlbCksY3VyQ2xhc3Nlcz1jbGFzc05hbWUuc3BsaXQoL1xccysvKTt2YXIgX29uZVNldD1mdW5jdGlvbiBfb25lU2V0KGFkZCxjbGFzc2VzKXtmb3IodmFyIGk9MDtpPGNsYXNzZXMubGVuZ3RoO2krKyl7aWYoYWRkKXtpZihjdXJDbGFzc2VzLmluZGV4T2YoY2xhc3Nlc1tpXSk9PT0tMSl7Y3VyQ2xhc3Nlcy5wdXNoKGNsYXNzZXNbaV0pO319ZWxzZXt2YXIgaWR4PWN1ckNsYXNzZXMuaW5kZXhPZihjbGFzc2VzW2ldKTtpZihpZHghPT0tMSl7Y3VyQ2xhc3Nlcy5zcGxpY2UoaWR4LDEpO319fX07X29uZVNldCh0cnVlLGNsYXNzZXNUb0FkZCk7X29uZVNldChmYWxzZSxjbGFzc2VzVG9SZW1vdmUpO19zZXRDbGFzc05hbWUoZWwsY3VyQ2xhc3Nlcy5qb2luKFwiIFwiKSxjdXJDbGFzc2VzKTt9O3Jvb3QuanNQbHVtYi5leHRlbmQocm9vdC5qc1BsdW1iSW5zdGFuY2UucHJvdG90eXBlLHtoZWFkbGVzczpmYWxzZSxwYWdlTG9jYXRpb246X3BhZ2VMb2NhdGlvbixzY3JlZW5Mb2NhdGlvbjpfc2NyZWVuTG9jYXRpb24sY2xpZW50TG9jYXRpb246X2NsaWVudExvY2F0aW9uLGdldERyYWdNYW5hZ2VyOmZ1bmN0aW9uIGdldERyYWdNYW5hZ2VyKCl7aWYodGhpcy5kcmFnTWFuYWdlcj09bnVsbCl7dGhpcy5kcmFnTWFuYWdlcj1uZXcgRHJhZ01hbmFnZXIodGhpcyk7fXJldHVybiB0aGlzLmRyYWdNYW5hZ2VyO30sLy8gTkVWRVIgQ0FMTEVEIElOIFRIRSBDVVJSRU5UIEpTXG5yZWNhbGN1bGF0ZU9mZnNldHM6ZnVuY3Rpb24gcmVjYWxjdWxhdGVPZmZzZXRzKGVsSWQpe3RoaXMuZ2V0RHJhZ01hbmFnZXIoKS51cGRhdGVPZmZzZXRzKGVsSWQpO30sLy8gQ09OVkVSVEVEXG5jcmVhdGVFbGVtZW50OmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnLHN0eWxlLGNsYXp6LGF0dHMpe3JldHVybiB0aGlzLmNyZWF0ZUVsZW1lbnROUyhudWxsLHRhZyxzdHlsZSxjbGF6eixhdHRzKTt9LC8vIENPTlZFUlRFRFxuY3JlYXRlRWxlbWVudE5TOmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyhucyx0YWcsc3R5bGUsY2xhenosYXR0cyl7dmFyIGU9bnM9PW51bGw/ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucyx0YWcpO3ZhciBpO3N0eWxlPXN0eWxlfHx7fTtmb3IoaSBpbiBzdHlsZSl7ZS5zdHlsZVtpXT1zdHlsZVtpXTt9aWYoY2xhenope2UuY2xhc3NOYW1lPWNsYXp6O31hdHRzPWF0dHN8fHt9O2ZvcihpIGluIGF0dHMpe2Uuc2V0QXR0cmlidXRlKGksXCJcIithdHRzW2ldKTt9cmV0dXJuIGU7fSwvLyBDT05WRVJURURcbmdldEF0dHJpYnV0ZTpmdW5jdGlvbiBnZXRBdHRyaWJ1dGUoZWwsYXR0TmFtZSl7cmV0dXJuIGVsLmdldEF0dHJpYnV0ZSE9bnVsbD9lbC5nZXRBdHRyaWJ1dGUoYXR0TmFtZSk6bnVsbDt9LC8vIENPTlZFUlRFRFxuc2V0QXR0cmlidXRlOmZ1bmN0aW9uIHNldEF0dHJpYnV0ZShlbCxhLHYpe2lmKGVsLnNldEF0dHJpYnV0ZSE9bnVsbCl7ZWwuc2V0QXR0cmlidXRlKGEsdik7fX0sLy8gQ09OVkVSVEVEXG5zZXRBdHRyaWJ1dGVzOmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoZWwsYXR0cyl7Zm9yKHZhciBpIGluIGF0dHMpe2lmKGF0dHMuaGFzT3duUHJvcGVydHkoaSkpe2VsLnNldEF0dHJpYnV0ZShpLGF0dHNbaV0pO319fSxhcHBlbmRUb1Jvb3Q6ZnVuY3Rpb24gYXBwZW5kVG9Sb290KG5vZGUpe2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobm9kZSk7fSwvLyBOT1QgQ09OVkVSVElOR1xuZ2V0UmVuZGVyTW9kZXM6ZnVuY3Rpb24gZ2V0UmVuZGVyTW9kZXMoKXtyZXR1cm5bXCJzdmdcIl07fSwvLyBDT05WRVJURURcbmdldENsYXNzOl9nZXRDbGFzc05hbWUsLy8gQ09OVkVSVEVEXG5hZGRDbGFzczpmdW5jdGlvbiBhZGRDbGFzcyhlbCxjbGF6eil7anNQbHVtYi5lYWNoKGVsLGZ1bmN0aW9uKGUpe19jbGFzc01hbmlwKGUsY2xhenopO30pO30sLy8gQ09OVkVSVEVEXG5oYXNDbGFzczpmdW5jdGlvbiBoYXNDbGFzcyhlbCxjbGF6eil7ZWw9anNQbHVtYi5nZXRFbGVtZW50KGVsKTtpZihlbC5jbGFzc0xpc3Qpe3JldHVybiBlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhenopO31lbHNle3JldHVybiBfZ2V0Q2xhc3NOYW1lKGVsKS5pbmRleE9mKGNsYXp6KSE9PS0xO319LC8vIENPTlZFUlRFRFxucmVtb3ZlQ2xhc3M6ZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsY2xhenope2pzUGx1bWIuZWFjaChlbCxmdW5jdGlvbihlKXtfY2xhc3NNYW5pcChlLG51bGwsY2xhenopO30pO30sLy8gQ09OVkVSVEVEXG51cGRhdGVDbGFzc2VzOmZ1bmN0aW9uIHVwZGF0ZUNsYXNzZXMoZWwsdG9BZGQsdG9SZW1vdmUpe2pzUGx1bWIuZWFjaChlbCxmdW5jdGlvbihlKXtfY2xhc3NNYW5pcChlLHRvQWRkLHRvUmVtb3ZlKTt9KTt9LC8vIENPTlZFUlRFRFxuc2V0Q2xhc3M6ZnVuY3Rpb24gc2V0Q2xhc3MoZWwsY2xhenope2lmKGNsYXp6IT1udWxsKXtqc1BsdW1iLmVhY2goZWwsZnVuY3Rpb24oZSl7X3NldENsYXNzTmFtZShlLGNsYXp6LGNsYXp6LnNwbGl0KC9cXHMrLykpO30pO319LC8vIENPTlZFUlRFRFxuc2V0UG9zaXRpb246ZnVuY3Rpb24gc2V0UG9zaXRpb24oZWwscCl7ZWwuc3R5bGUubGVmdD1wLmxlZnQrXCJweFwiO2VsLnN0eWxlLnRvcD1wLnRvcCtcInB4XCI7fSwvLyBDT05WRVJURURcbmdldFBvc2l0aW9uOmZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsKXt2YXIgX29uZT1mdW5jdGlvbiBfb25lKHByb3Ape3ZhciB2PWVsLnN0eWxlW3Byb3BdO3JldHVybiB2P3Yuc3Vic3RyaW5nKDAsdi5sZW5ndGgtMik6MDt9O3JldHVybntsZWZ0Ol9vbmUoXCJsZWZ0XCIpLHRvcDpfb25lKFwidG9wXCIpfTt9LC8vIENPTlZFUlRFRFxuZ2V0U3R5bGU6ZnVuY3Rpb24gZ2V0U3R5bGUoZWwscHJvcCl7aWYodHlwZW9mIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlIT09J3VuZGVmaW5lZCcpe3JldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsLG51bGwpLmdldFByb3BlcnR5VmFsdWUocHJvcCk7fWVsc2V7cmV0dXJuIGVsLmN1cnJlbnRTdHlsZVtwcm9wXTt9fSwvLyBDT05WRVJURURcbmdldFNlbGVjdG9yOmZ1bmN0aW9uIGdldFNlbGVjdG9yKGN0eCxzcGVjKXt2YXIgc2VsPW51bGw7aWYoYXJndW1lbnRzLmxlbmd0aD09PTEpe3NlbD1jdHgubm9kZVR5cGUhPW51bGw/Y3R4OmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoY3R4KTt9ZWxzZXtzZWw9Y3R4LnF1ZXJ5U2VsZWN0b3JBbGwoc3BlYyk7fXJldHVybiBzZWw7fSwvLyBDT05WRVJURURcbmdldE9mZnNldDpmdW5jdGlvbiBnZXRPZmZzZXQoZWwscmVsYXRpdmVUb1Jvb3QsY29udGFpbmVyKXtlbD1qc1BsdW1iLmdldEVsZW1lbnQoZWwpO2NvbnRhaW5lcj1jb250YWluZXJ8fHRoaXMuZ2V0Q29udGFpbmVyKCk7dmFyIG91dD17bGVmdDplbC5vZmZzZXRMZWZ0LHRvcDplbC5vZmZzZXRUb3B9LG9wPXJlbGF0aXZlVG9Sb290fHxjb250YWluZXIhPW51bGwmJmVsIT09Y29udGFpbmVyJiZlbC5vZmZzZXRQYXJlbnQhPT1jb250YWluZXI/ZWwub2Zmc2V0UGFyZW50Om51bGwsX21heWJlQWRqdXN0U2Nyb2xsPWZ1bmN0aW9uKG9mZnNldFBhcmVudCl7aWYob2Zmc2V0UGFyZW50IT1udWxsJiZvZmZzZXRQYXJlbnQhPT1kb2N1bWVudC5ib2R5JiYob2Zmc2V0UGFyZW50LnNjcm9sbFRvcD4wfHxvZmZzZXRQYXJlbnQuc2Nyb2xsTGVmdD4wKSl7b3V0LmxlZnQtPW9mZnNldFBhcmVudC5zY3JvbGxMZWZ0O291dC50b3AtPW9mZnNldFBhcmVudC5zY3JvbGxUb3A7fX0uYmluZCh0aGlzKTt3aGlsZShvcCE9bnVsbCl7b3V0LmxlZnQrPW9wLm9mZnNldExlZnQ7b3V0LnRvcCs9b3Aub2Zmc2V0VG9wO19tYXliZUFkanVzdFNjcm9sbChvcCk7b3A9cmVsYXRpdmVUb1Jvb3Q/b3Aub2Zmc2V0UGFyZW50Om9wLm9mZnNldFBhcmVudD09PWNvbnRhaW5lcj9udWxsOm9wLm9mZnNldFBhcmVudDt9Ly8gaWYgY29udGFpbmVyIGlzIHNjcm9sbGVkIGFuZCB0aGUgZWxlbWVudCAob3IgaXRzIG9mZnNldCBwYXJlbnQpIGlzIG5vdCBhYnNvbHV0ZSBvciBmaXhlZCwgYWRqdXN0IGFjY29yZGluZ2x5LlxuaWYoY29udGFpbmVyIT1udWxsJiYhcmVsYXRpdmVUb1Jvb3QmJihjb250YWluZXIuc2Nyb2xsVG9wPjB8fGNvbnRhaW5lci5zY3JvbGxMZWZ0PjApKXt2YXIgcHA9ZWwub2Zmc2V0UGFyZW50IT1udWxsP3RoaXMuZ2V0U3R5bGUoZWwub2Zmc2V0UGFyZW50LFwicG9zaXRpb25cIik6XCJzdGF0aWNcIixwPXRoaXMuZ2V0U3R5bGUoZWwsXCJwb3NpdGlvblwiKTtpZihwIT09XCJhYnNvbHV0ZVwiJiZwIT09XCJmaXhlZFwiJiZwcCE9PVwiYWJzb2x1dGVcIiYmcHAhPT1cImZpeGVkXCIpe291dC5sZWZ0LT1jb250YWluZXIuc2Nyb2xsTGVmdDtvdXQudG9wLT1jb250YWluZXIuc2Nyb2xsVG9wO319cmV0dXJuIG91dDt9LC8vXG4vLyByZXR1cm4geCt5IHByb3BvcnRpb24gb2YgdGhlIGdpdmVuIGVsZW1lbnQncyBzaXplIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGxvY2F0aW9uIG9mIHRoZSBnaXZlbiBldmVudC5cbi8vXG5nZXRQb3NpdGlvbk9uRWxlbWVudDpmdW5jdGlvbiBnZXRQb3NpdGlvbk9uRWxlbWVudChldnQsZWwsem9vbSl7dmFyIGJveD10eXBlb2YgZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0IT09XCJ1bmRlZmluZWRcIj9lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTp7bGVmdDowLHRvcDowLHdpZHRoOjAsaGVpZ2h0OjB9LGJvZHk9ZG9jdW1lbnQuYm9keSxkb2NFbGVtPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxzY3JvbGxUb3A9d2luZG93LnBhZ2VZT2Zmc2V0fHxkb2NFbGVtLnNjcm9sbFRvcHx8Ym9keS5zY3JvbGxUb3Asc2Nyb2xsTGVmdD13aW5kb3cucGFnZVhPZmZzZXR8fGRvY0VsZW0uc2Nyb2xsTGVmdHx8Ym9keS5zY3JvbGxMZWZ0LGNsaWVudFRvcD1kb2NFbGVtLmNsaWVudFRvcHx8Ym9keS5jbGllbnRUb3B8fDAsY2xpZW50TGVmdD1kb2NFbGVtLmNsaWVudExlZnR8fGJvZHkuY2xpZW50TGVmdHx8MCxwc3Q9MCxwc2w9MCx0b3A9Ym94LnRvcCtzY3JvbGxUb3AtY2xpZW50VG9wK3BzdCp6b29tLGxlZnQ9Ym94LmxlZnQrc2Nyb2xsTGVmdC1jbGllbnRMZWZ0K3BzbCp6b29tLGNsPWpzUGx1bWIucGFnZUxvY2F0aW9uKGV2dCksdz1ib3gud2lkdGh8fGVsLm9mZnNldFdpZHRoKnpvb20saD1ib3guaGVpZ2h0fHxlbC5vZmZzZXRIZWlnaHQqem9vbSx4PShjbFswXS1sZWZ0KS93LHk9KGNsWzFdLXRvcCkvaDtyZXR1cm5beCx5XTt9LC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHNvbWUgZWxlbWVudCBhcyByZWFkIGZyb20gdGhlIGxlZnQvdG9wIHByb3BlcnRpZXMgaW4gaXRzIHN0eWxlLlxyXG4gICAgICAgICAqIEBtZXRob2QgZ2V0QWJzb2x1dGVQb3NpdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWwgVGhlIGVsZW1lbnQgdG8gcmV0cmlldmUgdGhlIGFic29sdXRlIGNvb3JkaW5hdGVzIGZyb20uICoqTm90ZSoqIHRoaXMgaXMgYSBET00gZWxlbWVudCwgbm90IGEgc2VsZWN0b3IgZnJvbSB0aGUgdW5kZXJseWluZyBsaWJyYXJ5LlxyXG4gICAgICAgICAqIEByZXR1cm4ge051bWJlcltdfSBbbGVmdCwgdG9wXSBwaXhlbCB2YWx1ZXMuXHJcbiAgICAgICAgICovZ2V0QWJzb2x1dGVQb3NpdGlvbjpmdW5jdGlvbiBnZXRBYnNvbHV0ZVBvc2l0aW9uKGVsKXt2YXIgX29uZT1mdW5jdGlvbiBfb25lKHMpe3ZhciBzcz1lbC5zdHlsZVtzXTtpZihzcyl7cmV0dXJuIHBhcnNlRmxvYXQoc3Muc3Vic3RyaW5nKDAsc3MubGVuZ3RoLTIpKTt9fTtyZXR1cm5bX29uZShcImxlZnRcIiksX29uZShcInRvcFwiKV07fSwvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiBzb21lIGVsZW1lbnQgYnkgc2V0dGluZyB0aGUgbGVmdC90b3AgcHJvcGVydGllcyBpbiBpdHMgc3R5bGUuXHJcbiAgICAgICAgICogQG1ldGhvZCBzZXRBYnNvbHV0ZVBvc2l0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbCBUaGUgZWxlbWVudCB0byBzZXQgdGhlIGFic29sdXRlIGNvb3JkaW5hdGVzIG9uLiAqKk5vdGUqKiB0aGlzIGlzIGEgRE9NIGVsZW1lbnQsIG5vdCBhIHNlbGVjdG9yIGZyb20gdGhlIHVuZGVybHlpbmcgbGlicmFyeS5cclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcltdfSB4eSB4IGFuZCB5IGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJbXX0gW2FuaW1hdGVGcm9tXSBPcHRpb25hbCBwcmV2aW91cyB4eSB0byBhbmltYXRlIGZyb20uXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFthbmltYXRlT3B0aW9uc10gT3B0aW9ucyBmb3IgdGhlIGFuaW1hdGlvbi5cclxuICAgICAgICAgKi9zZXRBYnNvbHV0ZVBvc2l0aW9uOmZ1bmN0aW9uIHNldEFic29sdXRlUG9zaXRpb24oZWwseHksYW5pbWF0ZUZyb20sYW5pbWF0ZU9wdGlvbnMpe2lmKGFuaW1hdGVGcm9tKXt0aGlzLmFuaW1hdGUoZWwse2xlZnQ6XCIrPVwiKyh4eVswXS1hbmltYXRlRnJvbVswXSksdG9wOlwiKz1cIisoeHlbMV0tYW5pbWF0ZUZyb21bMV0pfSxhbmltYXRlT3B0aW9ucyk7fWVsc2V7ZWwuc3R5bGUubGVmdD14eVswXStcInB4XCI7ZWwuc3R5bGUudG9wPXh5WzFdK1wicHhcIjt9fSwvKipcclxuICAgICAgICAgKiBnZXRzIHRoZSBzaXplIGZvciB0aGUgZWxlbWVudCwgaW4gYW4gYXJyYXkgOiBbIHdpZHRoLCBoZWlnaHQgXS5cclxuICAgICAgICAgKi8vLyBDT05WRVJURURcbmdldFNpemU6ZnVuY3Rpb24gZ2V0U2l6ZShlbCl7cmV0dXJuW2VsLm9mZnNldFdpZHRoLGVsLm9mZnNldEhlaWdodF07fSwvLyBDT05WRVJURURcbmdldFdpZHRoOmZ1bmN0aW9uIGdldFdpZHRoKGVsKXtyZXR1cm4gZWwub2Zmc2V0V2lkdGg7fSwvLyBDT05WRVJURURcbmdldEhlaWdodDpmdW5jdGlvbiBnZXRIZWlnaHQoZWwpe3JldHVybiBlbC5vZmZzZXRIZWlnaHQ7fSxnZXRSZW5kZXJNb2RlOmZ1bmN0aW9uIGdldFJlbmRlck1vZGUoKXtyZXR1cm5cInN2Z1wiO319KTt9KS5jYWxsKHR5cGVvZiB3aW5kb3chPT0ndW5kZWZpbmVkJz93aW5kb3c6dGhpcyk7LypcclxuICogMjAxMCAtIDIwMTgganNQbHVtYiAoaGVsbG9AanNwbHVtYnRvb2xraXQuY29tKVxyXG4gKlxyXG4gKiBodHRwczovL2pzcGx1bWJ0b29sa2l0LmNvbVxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vanNwbHVtYi9qc3BsdW1iXHJcbiAqXHJcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMMiBsaWNlbnNlcy5cclxuICovOyhmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3ZhciByb290PXRoaXMsX2pwPXJvb3QuanNQbHVtYixfanU9cm9vdC5qc1BsdW1iVXRpbDsvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gQkVHSU4gT3ZlcmxheUNhcGFibGVqc1BsdW1iVUlDb21wb25lbnQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBfaW50ZXJuYWxMYWJlbE92ZXJsYXlJZD1cIl9fbGFiZWxcIiwvLyB0aGlzIGlzIGEgc2hvcnRjdXQgaGVscGVyIG1ldGhvZCB0byBsZXQgcGVvcGxlIGFkZCBhIGxhYmVsIGFzXG4vLyBvdmVybGF5LlxuX21ha2VMYWJlbE92ZXJsYXk9ZnVuY3Rpb24gX21ha2VMYWJlbE92ZXJsYXkoY29tcG9uZW50LHBhcmFtcyl7dmFyIF9wYXJhbXM9e2Nzc0NsYXNzOnBhcmFtcy5jc3NDbGFzcyxsYWJlbFN0eWxlOmNvbXBvbmVudC5sYWJlbFN0eWxlLGlkOl9pbnRlcm5hbExhYmVsT3ZlcmxheUlkLGNvbXBvbmVudDpjb21wb25lbnQsX2pzUGx1bWI6Y29tcG9uZW50Ll9qc1BsdW1iLmluc3RhbmNlLy8gVE9ETyBub3QgbmVjZXNzYXJ5LCBzaW5jZSB0aGUgaW5zdGFuY2UgY2FuIGJlIGFjY2Vzc2VkIHRocm91Z2ggdGhlIGNvbXBvbmVudC5cbn0sbWVyZ2VkUGFyYW1zPV9qcC5leHRlbmQoX3BhcmFtcyxwYXJhbXMpO3JldHVybiBuZXcgX2pwLk92ZXJsYXlzW2NvbXBvbmVudC5fanNQbHVtYi5pbnN0YW5jZS5nZXRSZW5kZXJNb2RlKCldLkxhYmVsKG1lcmdlZFBhcmFtcyk7fSxfcHJvY2Vzc092ZXJsYXk9ZnVuY3Rpb24gX3Byb2Nlc3NPdmVybGF5KGNvbXBvbmVudCxvKXt2YXIgX25ld092ZXJsYXk9bnVsbDtpZihfanUuaXNBcnJheShvKSl7Ly8gdGhpcyBpcyBmb3IgdGhlIHNob3J0aGFuZCBbXCJBcnJvd1wiLCB7IHdpZHRoOjUwIH1dIHN5bnRheFxuLy8gdGhlcmUncyBhbHNvIGEgdGhyZWUgYXJnIHZlcnNpb246XG4vLyBbXCJBcnJvd1wiLCB7IHdpZHRoOjUwIH0sIHtsb2NhdGlvbjowLjd9XVxuLy8gd2hpY2ggbWVyZ2VzIHRoZSAzcmQgYXJnIGludG8gdGhlIDJuZC5cbnZhciB0eXBlPW9bMF0sLy8gbWFrZSBhIGNvcHkgb2YgdGhlIG9iamVjdCBzbyBhcyBub3QgdG8gbWVzcyB1cCBhbnlvbmUgZWxzZSdzIHJlZmVyZW5jZS4uLlxucD1fanAuZXh0ZW5kKHtjb21wb25lbnQ6Y29tcG9uZW50LF9qc1BsdW1iOmNvbXBvbmVudC5fanNQbHVtYi5pbnN0YW5jZX0sb1sxXSk7aWYoby5sZW5ndGg9PT0zKXtfanAuZXh0ZW5kKHAsb1syXSk7fV9uZXdPdmVybGF5PW5ldyBfanAuT3ZlcmxheXNbY29tcG9uZW50Ll9qc1BsdW1iLmluc3RhbmNlLmdldFJlbmRlck1vZGUoKV1bdHlwZV0ocCk7fWVsc2UgaWYoby5jb25zdHJ1Y3Rvcj09PVN0cmluZyl7X25ld092ZXJsYXk9bmV3IF9qcC5PdmVybGF5c1tjb21wb25lbnQuX2pzUGx1bWIuaW5zdGFuY2UuZ2V0UmVuZGVyTW9kZSgpXVtvXSh7Y29tcG9uZW50OmNvbXBvbmVudCxfanNQbHVtYjpjb21wb25lbnQuX2pzUGx1bWIuaW5zdGFuY2V9KTt9ZWxzZXtfbmV3T3ZlcmxheT1vO31fbmV3T3ZlcmxheS5pZD1fbmV3T3ZlcmxheS5pZHx8X2p1LnV1aWQoKTtjb21wb25lbnQuY2FjaGVUeXBlSXRlbShcIm92ZXJsYXlcIixfbmV3T3ZlcmxheSxfbmV3T3ZlcmxheS5pZCk7Y29tcG9uZW50Ll9qc1BsdW1iLm92ZXJsYXlzW19uZXdPdmVybGF5LmlkXT1fbmV3T3ZlcmxheTtyZXR1cm4gX25ld092ZXJsYXk7fTtfanAuT3ZlcmxheUNhcGFibGVKc1BsdW1iVUlDb21wb25lbnQ9ZnVuY3Rpb24ocGFyYW1zKXtyb290LmpzUGx1bWJVSUNvbXBvbmVudC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dGhpcy5fanNQbHVtYi5vdmVybGF5cz17fTt0aGlzLl9qc1BsdW1iLm92ZXJsYXlQb3NpdGlvbnM9e307aWYocGFyYW1zLmxhYmVsKXt0aGlzLmdldERlZmF1bHRUeXBlKCkub3ZlcmxheXNbX2ludGVybmFsTGFiZWxPdmVybGF5SWRdPVtcIkxhYmVsXCIse2xhYmVsOnBhcmFtcy5sYWJlbCxsb2NhdGlvbjpwYXJhbXMubGFiZWxMb2NhdGlvbnx8dGhpcy5kZWZhdWx0TGFiZWxMb2NhdGlvbnx8MC41LGxhYmVsU3R5bGU6cGFyYW1zLmxhYmVsU3R5bGV8fHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuRGVmYXVsdHMuTGFiZWxTdHlsZSxpZDpfaW50ZXJuYWxMYWJlbE92ZXJsYXlJZH1dO310aGlzLnNldExpc3RlbmVyQ29tcG9uZW50PWZ1bmN0aW9uKGMpe2lmKHRoaXMuX2pzUGx1bWIpe2Zvcih2YXIgaSBpbiB0aGlzLl9qc1BsdW1iLm92ZXJsYXlzKXt0aGlzLl9qc1BsdW1iLm92ZXJsYXlzW2ldLnNldExpc3RlbmVyQ29tcG9uZW50KGMpO319fTt9O19qcC5PdmVybGF5Q2FwYWJsZUpzUGx1bWJVSUNvbXBvbmVudC5hcHBseVR5cGU9ZnVuY3Rpb24oY29tcG9uZW50LHQpe2lmKHQub3ZlcmxheXMpey8vIGxvb3AgdGhyb3VnaCB0aGUgb25lcyBpbiB0aGUgdHlwZS4gaWYgYWxyZWFkeSBwcmVzZW50IG9uIHRoZSBjb21wb25lbnQsXG4vLyBkb250IHJlbW92ZSBvciByZS1hZGQuXG52YXIga2VlcD17fSxpO2ZvcihpIGluIHQub3ZlcmxheXMpe3ZhciBleGlzdGluZz1jb21wb25lbnQuX2pzUGx1bWIub3ZlcmxheXNbdC5vdmVybGF5c1tpXVsxXS5pZF07aWYoZXhpc3Rpbmcpey8vIG1heWJlIHVwZGF0ZSBmcm9tIGRhdGEsIGlmIHRoZXJlIHdlcmUgcGFyYW1ldGVyaXNlZCB2YWx1ZXMgZm9yIGluc3RhbmNlLlxuZXhpc3RpbmcudXBkYXRlRnJvbSh0Lm92ZXJsYXlzW2ldWzFdKTtrZWVwW3Qub3ZlcmxheXNbaV1bMV0uaWRdPXRydWU7fWVsc2V7dmFyIGM9Y29tcG9uZW50LmdldENhY2hlZFR5cGVJdGVtKFwib3ZlcmxheVwiLHQub3ZlcmxheXNbaV1bMV0uaWQpO2lmKGMhPW51bGwpe2MucmVhdHRhY2goY29tcG9uZW50Ll9qc1BsdW1iLmluc3RhbmNlLGNvbXBvbmVudCk7Yy5zZXRWaXNpYmxlKHRydWUpOy8vIG1heWJlIHVwZGF0ZSBmcm9tIGRhdGEsIGlmIHRoZXJlIHdlcmUgcGFyYW1ldGVyaXNlZCB2YWx1ZXMgZm9yIGluc3RhbmNlLlxuYy51cGRhdGVGcm9tKHQub3ZlcmxheXNbaV1bMV0pO2NvbXBvbmVudC5fanNQbHVtYi5vdmVybGF5c1tjLmlkXT1jO31lbHNle2M9Y29tcG9uZW50LmFkZE92ZXJsYXkodC5vdmVybGF5c1tpXSx0cnVlKTt9a2VlcFtjLmlkXT10cnVlO319Ly8gbm93IGxvb3AgdGhyb3VnaCB0aGUgZnVsbCBvdmVybGF5cyBhbmQgcmVtb3ZlIHRob3NlIHRoYXQgd2UgZG9udCB3YW50IHRvIGtlZXBcbmZvcihpIGluIGNvbXBvbmVudC5fanNQbHVtYi5vdmVybGF5cyl7aWYoa2VlcFtjb21wb25lbnQuX2pzUGx1bWIub3ZlcmxheXNbaV0uaWRdPT1udWxsKXtjb21wb25lbnQucmVtb3ZlT3ZlcmxheShjb21wb25lbnQuX2pzUGx1bWIub3ZlcmxheXNbaV0uaWQsdHJ1ZSk7Ly8gcmVtb3ZlIG92ZXJsYXkgYnV0IGRvbnQgY2xlYW4gaXQgdXAuXG4vLyB0aGF0IHdvdWxkIHJlbW92ZSBldmVudCBsaXN0ZW5lcnMgZXRjOyBvdmVybGF5cyBhcmUgbmV2ZXIgZGlzY2FyZGVkIGJ5IHRoZSB0eXBlcyBzdHVmZiwgdGhleSBhcmVcbi8vIGp1c3QgZGV0YWNoZWQvcmVhdHRhY2hlZC5cbn19fX07X2p1LmV4dGVuZChfanAuT3ZlcmxheUNhcGFibGVKc1BsdW1iVUlDb21wb25lbnQscm9vdC5qc1BsdW1iVUlDb21wb25lbnQse3NldEhvdmVyOmZ1bmN0aW9uIHNldEhvdmVyKGhvdmVyLGlnbm9yZUF0dGFjaGVkRWxlbWVudHMpe2lmKHRoaXMuX2pzUGx1bWImJiF0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmlzQ29ubmVjdGlvbkJlaW5nRHJhZ2dlZCgpKXtmb3IodmFyIGkgaW4gdGhpcy5fanNQbHVtYi5vdmVybGF5cyl7dGhpcy5fanNQbHVtYi5vdmVybGF5c1tpXVtob3Zlcj9cImFkZENsYXNzXCI6XCJyZW1vdmVDbGFzc1wiXSh0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmhvdmVyQ2xhc3MpO319fSxhZGRPdmVybGF5OmZ1bmN0aW9uIGFkZE92ZXJsYXkob3ZlcmxheSxkb05vdFJlcGFpbnQpe3ZhciBvPV9wcm9jZXNzT3ZlcmxheSh0aGlzLG92ZXJsYXkpO2lmKCFkb05vdFJlcGFpbnQpe3RoaXMucmVwYWludCgpO31yZXR1cm4gbzt9LGdldE92ZXJsYXk6ZnVuY3Rpb24gZ2V0T3ZlcmxheShpZCl7cmV0dXJuIHRoaXMuX2pzUGx1bWIub3ZlcmxheXNbaWRdO30sZ2V0T3ZlcmxheXM6ZnVuY3Rpb24gZ2V0T3ZlcmxheXMoKXtyZXR1cm4gdGhpcy5fanNQbHVtYi5vdmVybGF5czt9LGhpZGVPdmVybGF5OmZ1bmN0aW9uIGhpZGVPdmVybGF5KGlkKXt2YXIgbz10aGlzLmdldE92ZXJsYXkoaWQpO2lmKG8pe28uaGlkZSgpO319LGhpZGVPdmVybGF5czpmdW5jdGlvbiBoaWRlT3ZlcmxheXMoKXtmb3IodmFyIGkgaW4gdGhpcy5fanNQbHVtYi5vdmVybGF5cyl7dGhpcy5fanNQbHVtYi5vdmVybGF5c1tpXS5oaWRlKCk7fX0sc2hvd092ZXJsYXk6ZnVuY3Rpb24gc2hvd092ZXJsYXkoaWQpe3ZhciBvPXRoaXMuZ2V0T3ZlcmxheShpZCk7aWYobyl7by5zaG93KCk7fX0sc2hvd092ZXJsYXlzOmZ1bmN0aW9uIHNob3dPdmVybGF5cygpe2Zvcih2YXIgaSBpbiB0aGlzLl9qc1BsdW1iLm92ZXJsYXlzKXt0aGlzLl9qc1BsdW1iLm92ZXJsYXlzW2ldLnNob3coKTt9fSxyZW1vdmVBbGxPdmVybGF5czpmdW5jdGlvbiByZW1vdmVBbGxPdmVybGF5cyhkb05vdFJlcGFpbnQpe2Zvcih2YXIgaSBpbiB0aGlzLl9qc1BsdW1iLm92ZXJsYXlzKXtpZih0aGlzLl9qc1BsdW1iLm92ZXJsYXlzW2ldLmNsZWFudXApe3RoaXMuX2pzUGx1bWIub3ZlcmxheXNbaV0uY2xlYW51cCgpO319dGhpcy5fanNQbHVtYi5vdmVybGF5cz17fTt0aGlzLl9qc1BsdW1iLm92ZXJsYXlQb3NpdGlvbnM9bnVsbDtpZighZG9Ob3RSZXBhaW50KXt0aGlzLnJlcGFpbnQoKTt9fSxyZW1vdmVPdmVybGF5OmZ1bmN0aW9uIHJlbW92ZU92ZXJsYXkob3ZlcmxheUlkLGRvbnRDbGVhbnVwKXt2YXIgbz10aGlzLl9qc1BsdW1iLm92ZXJsYXlzW292ZXJsYXlJZF07aWYobyl7by5zZXRWaXNpYmxlKGZhbHNlKTtpZighZG9udENsZWFudXAmJm8uY2xlYW51cCl7by5jbGVhbnVwKCk7fWRlbGV0ZSB0aGlzLl9qc1BsdW1iLm92ZXJsYXlzW292ZXJsYXlJZF07aWYodGhpcy5fanNQbHVtYi5vdmVybGF5UG9zaXRpb25zKXtkZWxldGUgdGhpcy5fanNQbHVtYi5vdmVybGF5UG9zaXRpb25zW292ZXJsYXlJZF07fX19LHJlbW92ZU92ZXJsYXlzOmZ1bmN0aW9uIHJlbW92ZU92ZXJsYXlzKCl7Zm9yKHZhciBpPTAsaj1hcmd1bWVudHMubGVuZ3RoO2k8ajtpKyspe3RoaXMucmVtb3ZlT3ZlcmxheShhcmd1bWVudHNbaV0pO319LG1vdmVQYXJlbnQ6ZnVuY3Rpb24gbW92ZVBhcmVudChuZXdQYXJlbnQpe2lmKHRoaXMuYmdDYW52YXMpe3RoaXMuYmdDYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmJnQ2FudmFzKTtuZXdQYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5iZ0NhbnZhcyk7fWlmKHRoaXMuY2FudmFzJiZ0aGlzLmNhbnZhcy5wYXJlbnROb2RlKXt0aGlzLmNhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY2FudmFzKTtuZXdQYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO2Zvcih2YXIgaSBpbiB0aGlzLl9qc1BsdW1iLm92ZXJsYXlzKXtpZih0aGlzLl9qc1BsdW1iLm92ZXJsYXlzW2ldLmlzQXBwZW5kZWRBdFRvcExldmVsKXt2YXIgZWw9dGhpcy5fanNQbHVtYi5vdmVybGF5c1tpXS5nZXRFbGVtZW50KCk7ZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7bmV3UGFyZW50LmFwcGVuZENoaWxkKGVsKTt9fX19LGdldExhYmVsOmZ1bmN0aW9uIGdldExhYmVsKCl7dmFyIGxvPXRoaXMuZ2V0T3ZlcmxheShfaW50ZXJuYWxMYWJlbE92ZXJsYXlJZCk7cmV0dXJuIGxvIT1udWxsP2xvLmdldExhYmVsKCk6bnVsbDt9LGdldExhYmVsT3ZlcmxheTpmdW5jdGlvbiBnZXRMYWJlbE92ZXJsYXkoKXtyZXR1cm4gdGhpcy5nZXRPdmVybGF5KF9pbnRlcm5hbExhYmVsT3ZlcmxheUlkKTt9LHNldExhYmVsOmZ1bmN0aW9uIHNldExhYmVsKGwpe3ZhciBsbz10aGlzLmdldE92ZXJsYXkoX2ludGVybmFsTGFiZWxPdmVybGF5SWQpO2lmKCFsbyl7dmFyIHBhcmFtcz1sLmNvbnN0cnVjdG9yPT09U3RyaW5nfHxsLmNvbnN0cnVjdG9yPT09RnVuY3Rpb24/e2xhYmVsOmx9Omw7bG89X21ha2VMYWJlbE92ZXJsYXkodGhpcyxwYXJhbXMpO3RoaXMuX2pzUGx1bWIub3ZlcmxheXNbX2ludGVybmFsTGFiZWxPdmVybGF5SWRdPWxvO31lbHNle2lmKGwuY29uc3RydWN0b3I9PT1TdHJpbmd8fGwuY29uc3RydWN0b3I9PT1GdW5jdGlvbil7bG8uc2V0TGFiZWwobCk7fWVsc2V7aWYobC5sYWJlbCl7bG8uc2V0TGFiZWwobC5sYWJlbCk7fWlmKGwubG9jYXRpb24pe2xvLnNldExvY2F0aW9uKGwubG9jYXRpb24pO319fWlmKCF0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmlzU3VzcGVuZERyYXdpbmcoKSl7dGhpcy5yZXBhaW50KCk7fX0sY2xlYW51cDpmdW5jdGlvbiBjbGVhbnVwKGZvcmNlKXtmb3IodmFyIGkgaW4gdGhpcy5fanNQbHVtYi5vdmVybGF5cyl7dGhpcy5fanNQbHVtYi5vdmVybGF5c1tpXS5jbGVhbnVwKGZvcmNlKTt0aGlzLl9qc1BsdW1iLm92ZXJsYXlzW2ldLmRlc3Ryb3koZm9yY2UpO31pZihmb3JjZSl7dGhpcy5fanNQbHVtYi5vdmVybGF5cz17fTt0aGlzLl9qc1BsdW1iLm92ZXJsYXlQb3NpdGlvbnM9bnVsbDt9fSxzZXRWaXNpYmxlOmZ1bmN0aW9uIHNldFZpc2libGUodil7dGhpc1t2P1wic2hvd092ZXJsYXlzXCI6XCJoaWRlT3ZlcmxheXNcIl0oKTt9LHNldEFic29sdXRlT3ZlcmxheVBvc2l0aW9uOmZ1bmN0aW9uIHNldEFic29sdXRlT3ZlcmxheVBvc2l0aW9uKG92ZXJsYXkseHkpe3RoaXMuX2pzUGx1bWIub3ZlcmxheVBvc2l0aW9uc1tvdmVybGF5LmlkXT14eTt9LGdldEFic29sdXRlT3ZlcmxheVBvc2l0aW9uOmZ1bmN0aW9uIGdldEFic29sdXRlT3ZlcmxheVBvc2l0aW9uKG92ZXJsYXkpe3JldHVybiB0aGlzLl9qc1BsdW1iLm92ZXJsYXlQb3NpdGlvbnM/dGhpcy5fanNQbHVtYi5vdmVybGF5UG9zaXRpb25zW292ZXJsYXkuaWRdOm51bGw7fSxfY2xhenpNYW5pcDpmdW5jdGlvbiBfY2xhenpNYW5pcChhY3Rpb24sY2xhenosZG9udFVwZGF0ZU92ZXJsYXlzKXtpZighZG9udFVwZGF0ZU92ZXJsYXlzKXtmb3IodmFyIGkgaW4gdGhpcy5fanNQbHVtYi5vdmVybGF5cyl7dGhpcy5fanNQbHVtYi5vdmVybGF5c1tpXVthY3Rpb24rXCJDbGFzc1wiXShjbGF6eik7fX19LGFkZENsYXNzOmZ1bmN0aW9uIGFkZENsYXNzKGNsYXp6LGRvbnRVcGRhdGVPdmVybGF5cyl7dGhpcy5fY2xhenpNYW5pcChcImFkZFwiLGNsYXp6LGRvbnRVcGRhdGVPdmVybGF5cyk7fSxyZW1vdmVDbGFzczpmdW5jdGlvbiByZW1vdmVDbGFzcyhjbGF6eixkb250VXBkYXRlT3ZlcmxheXMpe3RoaXMuX2NsYXp6TWFuaXAoXCJyZW1vdmVcIixjbGF6eixkb250VXBkYXRlT3ZlcmxheXMpO319KTsvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRU5EIE92ZXJsYXlDYXBhYmxlanNQbHVtYlVJQ29tcG9uZW50IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG59KS5jYWxsKHR5cGVvZiB3aW5kb3chPT0ndW5kZWZpbmVkJz93aW5kb3c6dGhpcyk7LypcclxuICogVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSBjb2RlIGZvciBFbmRwb2ludHMuXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMCAtIDIwMTgganNQbHVtYiAoaGVsbG9AanNwbHVtYnRvb2xraXQuY29tKVxyXG4gKiBcclxuICogaHR0cHM6Ly9qc3BsdW1idG9vbGtpdC5jb21cclxuICogaHR0cHM6Ly9naXRodWIuY29tL2pzcGx1bWIvanNwbHVtYlxyXG4gKiBcclxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwyIGxpY2Vuc2VzLlxyXG4gKi87KGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHJvb3Q9dGhpcyxfanA9cm9vdC5qc1BsdW1iLF9qdT1yb290LmpzUGx1bWJVdGlsOy8vIGNyZWF0ZSB0aGUgZHJhZyBoYW5kbGVyIGZvciBhIGNvbm5lY3Rpb25cbnZhciBfbWFrZUNvbm5lY3Rpb25EcmFnSGFuZGxlcj1mdW5jdGlvbiBfbWFrZUNvbm5lY3Rpb25EcmFnSGFuZGxlcihlbmRwb2ludCxwbGFjZWhvbGRlcixfanNQbHVtYil7dmFyIHN0b3BwZWQ9ZmFsc2U7cmV0dXJue2RyYWc6ZnVuY3Rpb24gZHJhZygpe2lmKHN0b3BwZWQpe3N0b3BwZWQ9ZmFsc2U7cmV0dXJuIHRydWU7fWlmKHBsYWNlaG9sZGVyLmVsZW1lbnQpe3ZhciBfdWk9X2pzUGx1bWIuZ2V0VUlQb3NpdGlvbihhcmd1bWVudHMsX2pzUGx1bWIuZ2V0Wm9vbSgpKTtpZihfdWkhPW51bGwpe19qc1BsdW1iLnNldFBvc2l0aW9uKHBsYWNlaG9sZGVyLmVsZW1lbnQsX3VpKTt9X2pzUGx1bWIucmVwYWludChwbGFjZWhvbGRlci5lbGVtZW50LF91aSk7Ly8gYWx3YXlzIHJlcGFpbnQgdGhlIHNvdXJjZSBlbmRwb2ludCwgYmVjYXVzZSBvbmx5IGNvbnRpbnVvdXMvZHluYW1pYyBhbmNob3JzIGNhdXNlIHRoZSBlbmRwb2ludFxuLy8gdG8gYmUgcmVwYWludGVkLCBzbyBzdGF0aWMgYW5jaG9ycyBuZWVkIHRvIGJlIHRvbGQgKG9yIHRoZSBlbmRwb2ludCBnZXRzIGRyYWdnZWQgYXJvdW5kKVxuZW5kcG9pbnQucGFpbnQoe2FuY2hvclBvaW50OmVuZHBvaW50LmFuY2hvci5nZXRDdXJyZW50TG9jYXRpb24oe2VsZW1lbnQ6ZW5kcG9pbnR9KX0pO319LHN0b3BEcmFnOmZ1bmN0aW9uIHN0b3BEcmFnKCl7c3RvcHBlZD10cnVlO319O307Ly8gY3JlYXRlcyBhIHBsYWNlaG9sZGVyIGRpdiBmb3IgZHJhZ2dpbmcgcHVycG9zZXMsIGFkZHMgaXQsIGFuZCBwcmUtY29tcHV0ZXMgaXRzIG9mZnNldC5cbnZhciBfbWFrZURyYWdnYWJsZVBsYWNlaG9sZGVyPWZ1bmN0aW9uIF9tYWtlRHJhZ2dhYmxlUGxhY2Vob2xkZXIocGxhY2Vob2xkZXIsX2pzUGx1bWIsaXBjbyxpcHMpe3ZhciBuPV9qc1BsdW1iLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7cG9zaXRpb246XCJhYnNvbHV0ZVwifSk7X2pzUGx1bWIuYXBwZW5kRWxlbWVudChuKTt2YXIgaWQ9X2pzUGx1bWIuZ2V0SWQobik7X2pzUGx1bWIuc2V0UG9zaXRpb24obixpcGNvKTtuLnN0eWxlLndpZHRoPWlwc1swXStcInB4XCI7bi5zdHlsZS5oZWlnaHQ9aXBzWzFdK1wicHhcIjtfanNQbHVtYi5tYW5hZ2UoaWQsbix0cnVlKTsvLyBUUkFOU0lFTlQgTUFOQUdFXG4vLyBjcmVhdGUgYW5kIGFzc2lnbiBhbiBpZCwgYW5kIGluaXRpYWxpemUgdGhlIG9mZnNldC5cbnBsYWNlaG9sZGVyLmlkPWlkO3BsYWNlaG9sZGVyLmVsZW1lbnQ9bjt9Oy8vIGNyZWF0ZSBhIGZsb2F0aW5nIGVuZHBvaW50IChmb3IgZHJhZyBjb25uZWN0aW9ucylcbnZhciBfbWFrZUZsb2F0aW5nRW5kcG9pbnQ9ZnVuY3Rpb24gX21ha2VGbG9hdGluZ0VuZHBvaW50KHBhaW50U3R5bGUscmVmZXJlbmNlQW5jaG9yLGVuZHBvaW50LHJlZmVyZW5jZUNhbnZhcyxzb3VyY2VFbGVtZW50LF9qc1BsdW1iLF9uZXdFbmRwb2ludCxzY29wZSl7dmFyIGZsb2F0aW5nQW5jaG9yPW5ldyBfanAuRmxvYXRpbmdBbmNob3Ioe3JlZmVyZW5jZTpyZWZlcmVuY2VBbmNob3IscmVmZXJlbmNlQ2FudmFzOnJlZmVyZW5jZUNhbnZhcyxqc1BsdW1iSW5zdGFuY2U6X2pzUGx1bWJ9KTsvL3NldHRpbmcgdGhlIHNjb3BlIGhlcmUgc2hvdWxkIG5vdCBiZSB0aGUgd2F5IHRvIGZpeCB0aGF0IG1vb3Rvb2xzIGlzc3VlLiAgaXQgc2hvdWxkIGJlIGZpeGVkIGJ5IG5vdFxuLy8gYWRkaW5nIHRoZSBmbG9hdGluZyBlbmRwb2ludCBhcyBhIGRyb3BwYWJsZS4gIHRoYXQgbWFrZXMgbW9yZSBzZW5zZSBhbnl3YXkhXG4vLyBUUkFOU0lFTlQgTUFOQUdFXG5yZXR1cm4gX25ld0VuZHBvaW50KHtwYWludFN0eWxlOnBhaW50U3R5bGUsZW5kcG9pbnQ6ZW5kcG9pbnQsYW5jaG9yOmZsb2F0aW5nQW5jaG9yLHNvdXJjZTpzb3VyY2VFbGVtZW50LHNjb3BlOnNjb3BlfSk7fTt2YXIgdHlwZVBhcmFtZXRlcnM9W1wiY29ubmVjdG9yU3R5bGVcIixcImNvbm5lY3RvckhvdmVyU3R5bGVcIixcImNvbm5lY3Rvck92ZXJsYXlzXCIsXCJjb25uZWN0b3JcIixcImNvbm5lY3Rpb25UeXBlXCIsXCJjb25uZWN0b3JDbGFzc1wiLFwiY29ubmVjdG9ySG92ZXJDbGFzc1wiXTsvLyBhIGhlbHBlciBmdW5jdGlvbiB0aGF0IHRyaWVzIHRvIGZpbmQgYSBjb25uZWN0aW9uIHRvIHRoZSBnaXZlbiBlbGVtZW50LCBhbmQgcmV0dXJucyBpdCBpZiBzby4gaWYgZWxlbWVudFdpdGhQcmVjZWRlbmNlIGlzIG51bGwsXG4vLyBvciBubyBjb25uZWN0aW9uIHRvIGl0IGlzIGZvdW5kLCB3ZSByZXR1cm4gdGhlIGZpcnN0IGNvbm5lY3Rpb24gaW4gb3VyIGxpc3QuXG52YXIgZmluZENvbm5lY3Rpb25Ub1VzZUZvckR5bmFtaWNBbmNob3I9ZnVuY3Rpb24gZmluZENvbm5lY3Rpb25Ub1VzZUZvckR5bmFtaWNBbmNob3IoZXAsZWxlbWVudFdpdGhQcmVjZWRlbmNlKXt2YXIgaWR4PTA7aWYoZWxlbWVudFdpdGhQcmVjZWRlbmNlIT1udWxsKXtmb3IodmFyIGk9MDtpPGVwLmNvbm5lY3Rpb25zLmxlbmd0aDtpKyspe2lmKGVwLmNvbm5lY3Rpb25zW2ldLnNvdXJjZUlkPT09ZWxlbWVudFdpdGhQcmVjZWRlbmNlfHxlcC5jb25uZWN0aW9uc1tpXS50YXJnZXRJZD09PWVsZW1lbnRXaXRoUHJlY2VkZW5jZSl7aWR4PWk7YnJlYWs7fX19cmV0dXJuIGVwLmNvbm5lY3Rpb25zW2lkeF07fTtfanAuRW5kcG9pbnQ9ZnVuY3Rpb24ocGFyYW1zKXt2YXIgX2pzUGx1bWI9cGFyYW1zLl9qc1BsdW1iLF9uZXdDb25uZWN0aW9uPXBhcmFtcy5uZXdDb25uZWN0aW9uLF9uZXdFbmRwb2ludD1wYXJhbXMubmV3RW5kcG9pbnQ7dGhpcy5pZFByZWZpeD1cIl9qc3BsdW1iX2VfXCI7dGhpcy5kZWZhdWx0TGFiZWxMb2NhdGlvbj1bMC41LDAuNV07dGhpcy5kZWZhdWx0T3ZlcmxheUtleXM9W1wiT3ZlcmxheXNcIixcIkVuZHBvaW50T3ZlcmxheXNcIl07X2pwLk92ZXJsYXlDYXBhYmxlSnNQbHVtYlVJQ29tcG9uZW50LmFwcGx5KHRoaXMsYXJndW1lbnRzKTsvLyBUWVBFXG50aGlzLmFwcGVuZFRvRGVmYXVsdFR5cGUoe2Nvbm5lY3Rpb25UeXBlOnBhcmFtcy5jb25uZWN0aW9uVHlwZSxtYXhDb25uZWN0aW9uczpwYXJhbXMubWF4Q29ubmVjdGlvbnM9PW51bGw/dGhpcy5fanNQbHVtYi5pbnN0YW5jZS5EZWZhdWx0cy5NYXhDb25uZWN0aW9uczpwYXJhbXMubWF4Q29ubmVjdGlvbnMsLy8gbWF4aW11bSBudW1iZXIgb2YgY29ubmVjdGlvbnMgdGhpcyBlbmRwb2ludCBjYW4gYmUgdGhlIHNvdXJjZSBvZi4sXG5wYWludFN0eWxlOnBhcmFtcy5lbmRwb2ludFN0eWxlfHxwYXJhbXMucGFpbnRTdHlsZXx8cGFyYW1zLnN0eWxlfHx0aGlzLl9qc1BsdW1iLmluc3RhbmNlLkRlZmF1bHRzLkVuZHBvaW50U3R5bGV8fF9qcC5EZWZhdWx0cy5FbmRwb2ludFN0eWxlLGhvdmVyUGFpbnRTdHlsZTpwYXJhbXMuZW5kcG9pbnRIb3ZlclN0eWxlfHxwYXJhbXMuaG92ZXJQYWludFN0eWxlfHx0aGlzLl9qc1BsdW1iLmluc3RhbmNlLkRlZmF1bHRzLkVuZHBvaW50SG92ZXJTdHlsZXx8X2pwLkRlZmF1bHRzLkVuZHBvaW50SG92ZXJTdHlsZSxjb25uZWN0b3JTdHlsZTpwYXJhbXMuY29ubmVjdG9yU3R5bGUsY29ubmVjdG9ySG92ZXJTdHlsZTpwYXJhbXMuY29ubmVjdG9ySG92ZXJTdHlsZSxjb25uZWN0b3JDbGFzczpwYXJhbXMuY29ubmVjdG9yQ2xhc3MsY29ubmVjdG9ySG92ZXJDbGFzczpwYXJhbXMuY29ubmVjdG9ySG92ZXJDbGFzcyxjb25uZWN0b3JPdmVybGF5czpwYXJhbXMuY29ubmVjdG9yT3ZlcmxheXMsY29ubmVjdG9yOnBhcmFtcy5jb25uZWN0b3IsY29ubmVjdG9yVG9vbHRpcDpwYXJhbXMuY29ubmVjdG9yVG9vbHRpcH0pOy8vIEVORCBUWVBFXG50aGlzLl9qc1BsdW1iLmVuYWJsZWQ9IShwYXJhbXMuZW5hYmxlZD09PWZhbHNlKTt0aGlzLl9qc1BsdW1iLnZpc2libGU9dHJ1ZTt0aGlzLmVsZW1lbnQ9X2pwLmdldEVsZW1lbnQocGFyYW1zLnNvdXJjZSk7dGhpcy5fanNQbHVtYi51dWlkPXBhcmFtcy51dWlkO3RoaXMuX2pzUGx1bWIuZmxvYXRpbmdFbmRwb2ludD1udWxsO3ZhciBpblBsYWNlQ29weT1udWxsO2lmKHRoaXMuX2pzUGx1bWIudXVpZCl7cGFyYW1zLmVuZHBvaW50c0J5VVVJRFt0aGlzLl9qc1BsdW1iLnV1aWRdPXRoaXM7fXRoaXMuZWxlbWVudElkPXBhcmFtcy5lbGVtZW50SWQ7dGhpcy5kcmFnUHJveHk9cGFyYW1zLmRyYWdQcm94eTt0aGlzLl9qc1BsdW1iLmNvbm5lY3Rpb25Db3N0PXBhcmFtcy5jb25uZWN0aW9uQ29zdDt0aGlzLl9qc1BsdW1iLmNvbm5lY3Rpb25zRGlyZWN0ZWQ9cGFyYW1zLmNvbm5lY3Rpb25zRGlyZWN0ZWQ7dGhpcy5fanNQbHVtYi5jdXJyZW50QW5jaG9yQ2xhc3M9XCJcIjt0aGlzLl9qc1BsdW1iLmV2ZW50cz17fTt2YXIgZGVsZXRlT25FbXB0eT1wYXJhbXMuZGVsZXRlT25FbXB0eT09PXRydWU7dGhpcy5zZXREZWxldGVPbkVtcHR5PWZ1bmN0aW9uKGQpe2RlbGV0ZU9uRW1wdHk9ZDt9O3ZhciBfdXBkYXRlQW5jaG9yQ2xhc3M9ZnVuY3Rpb24oKXsvLyBzdGFzaCBvbGQsIGdldCBuZXdcbnZhciBvbGRBbmNob3JDbGFzcz1fanNQbHVtYi5lbmRwb2ludEFuY2hvckNsYXNzUHJlZml4K1wiLVwiK3RoaXMuX2pzUGx1bWIuY3VycmVudEFuY2hvckNsYXNzO3RoaXMuX2pzUGx1bWIuY3VycmVudEFuY2hvckNsYXNzPXRoaXMuYW5jaG9yLmdldENzc0NsYXNzKCk7dmFyIGFuY2hvckNsYXNzPV9qc1BsdW1iLmVuZHBvaW50QW5jaG9yQ2xhc3NQcmVmaXgrKHRoaXMuX2pzUGx1bWIuY3VycmVudEFuY2hvckNsYXNzP1wiLVwiK3RoaXMuX2pzUGx1bWIuY3VycmVudEFuY2hvckNsYXNzOlwiXCIpO3RoaXMucmVtb3ZlQ2xhc3Mob2xkQW5jaG9yQ2xhc3MpO3RoaXMuYWRkQ2xhc3MoYW5jaG9yQ2xhc3MpOy8vIGFkZCBhbmQgcmVtb3ZlIGF0IHRoZSBzYW1lIHRpbWUgdG8gcmVkdWNlIHRoZSBudW1iZXIgb2YgcmVmbG93cy5cbl9qcC51cGRhdGVDbGFzc2VzKHRoaXMuZWxlbWVudCxhbmNob3JDbGFzcyxvbGRBbmNob3JDbGFzcyk7fS5iaW5kKHRoaXMpO3RoaXMucHJlcGFyZUFuY2hvcj1mdW5jdGlvbihhbmNob3JQYXJhbXMpe3ZhciBhPXRoaXMuX2pzUGx1bWIuaW5zdGFuY2UubWFrZUFuY2hvcihhbmNob3JQYXJhbXMsdGhpcy5lbGVtZW50SWQsX2pzUGx1bWIpO2EuYmluZChcImFuY2hvckNoYW5nZWRcIixmdW5jdGlvbihjdXJyZW50QW5jaG9yKXt0aGlzLmZpcmUoXCJhbmNob3JDaGFuZ2VkXCIse2VuZHBvaW50OnRoaXMsYW5jaG9yOmN1cnJlbnRBbmNob3J9KTtfdXBkYXRlQW5jaG9yQ2xhc3MoKTt9LmJpbmQodGhpcykpO3JldHVybiBhO307dGhpcy5zZXRQcmVwYXJlZEFuY2hvcj1mdW5jdGlvbihhbmNob3IsZG9Ob3RSZXBhaW50KXt0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmNvbnRpbnVvdXNBbmNob3JGYWN0b3J5LmNsZWFyKHRoaXMuZWxlbWVudElkKTt0aGlzLmFuY2hvcj1hbmNob3I7X3VwZGF0ZUFuY2hvckNsYXNzKCk7aWYoIWRvTm90UmVwYWludCl7dGhpcy5fanNQbHVtYi5pbnN0YW5jZS5yZXBhaW50KHRoaXMuZWxlbWVudElkKTt9cmV0dXJuIHRoaXM7fTt0aGlzLnNldEFuY2hvcj1mdW5jdGlvbihhbmNob3JQYXJhbXMsZG9Ob3RSZXBhaW50KXt2YXIgYT10aGlzLnByZXBhcmVBbmNob3IoYW5jaG9yUGFyYW1zKTt0aGlzLnNldFByZXBhcmVkQW5jaG9yKGEsZG9Ob3RSZXBhaW50KTtyZXR1cm4gdGhpczt9O3ZhciBpbnRlcm5hbEhvdmVyPWZ1bmN0aW9uKHN0YXRlKXtpZih0aGlzLmNvbm5lY3Rpb25zLmxlbmd0aD4wKXtmb3IodmFyIGk9MDtpPHRoaXMuY29ubmVjdGlvbnMubGVuZ3RoO2krKyl7dGhpcy5jb25uZWN0aW9uc1tpXS5zZXRIb3ZlcihzdGF0ZSxmYWxzZSk7fX1lbHNle3RoaXMuc2V0SG92ZXIoc3RhdGUpO319LmJpbmQodGhpcyk7dGhpcy5iaW5kKFwibW91c2VvdmVyXCIsZnVuY3Rpb24oKXtpbnRlcm5hbEhvdmVyKHRydWUpO30pO3RoaXMuYmluZChcIm1vdXNlb3V0XCIsZnVuY3Rpb24oKXtpbnRlcm5hbEhvdmVyKGZhbHNlKTt9KTsvLyBBTkNIT1IgTUFOQUdFUlxuaWYoIXBhcmFtcy5fdHJhbnNpZW50KXsvLyBpbiBwbGFjZSBjb3BpZXMsIGZvciBleGFtcGxlLCBhcmUgdHJhbnNpZW50LiAgdGhleSB3aWxsIG5ldmVyIG5lZWQgdG8gYmUgcmV0cmlldmVkIGR1cmluZyBhIHBhaW50IGN5Y2xlLCBiZWNhdXNlIHRoZXkgZG9udCBtb3ZlLCBhbmQgdGhlbiB0aGV5IGFyZSBkZWxldGVkLlxudGhpcy5fanNQbHVtYi5pbnN0YW5jZS5hbmNob3JNYW5hZ2VyLmFkZCh0aGlzLHRoaXMuZWxlbWVudElkKTt9dGhpcy5wcmVwYXJlRW5kcG9pbnQ9ZnVuY3Rpb24oZXAsdHlwZUlkKXt2YXIgX2U9ZnVuY3Rpb24gX2UodCxwKXt2YXIgcm09X2pzUGx1bWIuZ2V0UmVuZGVyTW9kZSgpO2lmKF9qcC5FbmRwb2ludHNbcm1dW3RdKXtyZXR1cm4gbmV3IF9qcC5FbmRwb2ludHNbcm1dW3RdKHApO31pZighX2pzUGx1bWIuRGVmYXVsdHMuRG9Ob3RUaHJvd0Vycm9ycyl7dGhyb3d7bXNnOlwianNQbHVtYjogdW5rbm93biBlbmRwb2ludCB0eXBlICdcIit0K1wiJ1wifTt9fTt2YXIgZW5kcG9pbnRBcmdzPXtfanNQbHVtYjp0aGlzLl9qc1BsdW1iLmluc3RhbmNlLGNzc0NsYXNzOnBhcmFtcy5jc3NDbGFzcyxjb250YWluZXI6cGFyYW1zLmNvbnRhaW5lcix0b29sdGlwOnBhcmFtcy50b29sdGlwLGNvbm5lY3RvclRvb2x0aXA6cGFyYW1zLmNvbm5lY3RvclRvb2x0aXAsZW5kcG9pbnQ6dGhpc307dmFyIGVuZHBvaW50O2lmKF9qdS5pc1N0cmluZyhlcCkpe2VuZHBvaW50PV9lKGVwLGVuZHBvaW50QXJncyk7fWVsc2UgaWYoX2p1LmlzQXJyYXkoZXApKXtlbmRwb2ludEFyZ3M9X2p1Lm1lcmdlKGVwWzFdLGVuZHBvaW50QXJncyk7ZW5kcG9pbnQ9X2UoZXBbMF0sZW5kcG9pbnRBcmdzKTt9ZWxzZXtlbmRwb2ludD1lcC5jbG9uZSgpO30vLyBhc3NpZ24gYSBjbG9uZSBmdW5jdGlvbiB1c2luZyBhIGNvcHkgb2YgZW5kcG9pbnRBcmdzLiB0aGlzIGlzIHVzZWQgd2hlbiBhIGRyYWcgc3RhcnRzOiB0aGUgZW5kcG9pbnQgdGhhdCB3YXMgZHJhZ2dlZCBpcyBjbG9uZWQsXG4vLyBhbmQgdGhlIGNsb25lIGlzIGxlZnQgaW4gaXRzIHBsYWNlIHdoaWxlIHRoZSBvcmlnaW5hbCBvbmUgZ29lcyBvZmYgb24gYSBtYWdpY2FsIGpvdXJuZXkuXG4vLyB0aGUgY29weSBpcyB0byBnZXQgYXJvdW5kIGEgY2xvc3VyZSBwcm9ibGVtLCBpbiB3aGljaCBlbmRwb2ludEFyZ3MgZW5kcyB1cCBnZXR0aW5nIHNoYXJlZCBieVxuLy8gdGhlIHdob2xlIHdvcmxkLlxuLy92YXIgYXJnc0ZvckNsb25lID0ganNQbHVtYi5leHRlbmQoe30sIGVuZHBvaW50QXJncyk7XG5lbmRwb2ludC5jbG9uZT1mdW5jdGlvbigpey8vIFRPRE8gdGhpcywgYW5kIHRoZSBjb2RlIGFib3ZlLCBjYW4gYmUgcmVmYWN0b3JlZCB0byBiZSBtb3JlIGRyeS5cbmlmKF9qdS5pc1N0cmluZyhlcCkpe3JldHVybiBfZShlcCxlbmRwb2ludEFyZ3MpO31lbHNlIGlmKF9qdS5pc0FycmF5KGVwKSl7ZW5kcG9pbnRBcmdzPV9qdS5tZXJnZShlcFsxXSxlbmRwb2ludEFyZ3MpO3JldHVybiBfZShlcFswXSxlbmRwb2ludEFyZ3MpO319LmJpbmQodGhpcyk7ZW5kcG9pbnQudHlwZUlkPXR5cGVJZDtyZXR1cm4gZW5kcG9pbnQ7fTt0aGlzLnNldEVuZHBvaW50PWZ1bmN0aW9uKGVwLGRvTm90UmVwYWludCl7dmFyIF9lcD10aGlzLnByZXBhcmVFbmRwb2ludChlcCk7dGhpcy5zZXRQcmVwYXJlZEVuZHBvaW50KF9lcCx0cnVlKTt9O3RoaXMuc2V0UHJlcGFyZWRFbmRwb2ludD1mdW5jdGlvbihlcCxkb05vdFJlcGFpbnQpe2lmKHRoaXMuZW5kcG9pbnQhPW51bGwpe3RoaXMuZW5kcG9pbnQuY2xlYW51cCgpO3RoaXMuZW5kcG9pbnQuZGVzdHJveSgpO310aGlzLmVuZHBvaW50PWVwO3RoaXMudHlwZT10aGlzLmVuZHBvaW50LnR5cGU7dGhpcy5jYW52YXM9dGhpcy5lbmRwb2ludC5jYW52YXM7fTtfanAuZXh0ZW5kKHRoaXMscGFyYW1zLHR5cGVQYXJhbWV0ZXJzKTt0aGlzLmlzU291cmNlPXBhcmFtcy5pc1NvdXJjZXx8ZmFsc2U7dGhpcy5pc1RlbXBvcmFyeVNvdXJjZT1wYXJhbXMuaXNUZW1wb3JhcnlTb3VyY2V8fGZhbHNlO3RoaXMuaXNUYXJnZXQ9cGFyYW1zLmlzVGFyZ2V0fHxmYWxzZTt0aGlzLmNvbm5lY3Rpb25zPXBhcmFtcy5jb25uZWN0aW9uc3x8W107dGhpcy5jb25uZWN0b3JQb2ludGVyRXZlbnRzPXBhcmFtc1tcImNvbm5lY3Rvci1wb2ludGVyLWV2ZW50c1wiXTt0aGlzLnNjb3BlPXBhcmFtcy5zY29wZXx8X2pzUGx1bWIuZ2V0RGVmYXVsdFNjb3BlKCk7dGhpcy50aW1lc3RhbXA9bnVsbDt0aGlzLnJlYXR0YWNoQ29ubmVjdGlvbnM9cGFyYW1zLnJlYXR0YWNofHxfanNQbHVtYi5EZWZhdWx0cy5SZWF0dGFjaENvbm5lY3Rpb25zO3RoaXMuY29ubmVjdGlvbnNEZXRhY2hhYmxlPV9qc1BsdW1iLkRlZmF1bHRzLkNvbm5lY3Rpb25zRGV0YWNoYWJsZTtpZihwYXJhbXMuY29ubmVjdGlvbnNEZXRhY2hhYmxlPT09ZmFsc2V8fHBhcmFtcy5kZXRhY2hhYmxlPT09ZmFsc2Upe3RoaXMuY29ubmVjdGlvbnNEZXRhY2hhYmxlPWZhbHNlO310aGlzLmRyYWdBbGxvd2VkV2hlbkZ1bGw9cGFyYW1zLmRyYWdBbGxvd2VkV2hlbkZ1bGwhPT1mYWxzZTtpZihwYXJhbXMub25NYXhDb25uZWN0aW9ucyl7dGhpcy5iaW5kKFwibWF4Q29ubmVjdGlvbnNcIixwYXJhbXMub25NYXhDb25uZWN0aW9ucyk7fS8vXG4vLyBhZGQgYSBjb25uZWN0aW9uLiBub3QgcGFydCBvZiBwdWJsaWMgQVBJLlxuLy9cbnRoaXMuYWRkQ29ubmVjdGlvbj1mdW5jdGlvbihjb25uZWN0aW9uKXt0aGlzLmNvbm5lY3Rpb25zLnB1c2goY29ubmVjdGlvbik7dGhpc1sodGhpcy5jb25uZWN0aW9ucy5sZW5ndGg+MD9cImFkZFwiOlwicmVtb3ZlXCIpK1wiQ2xhc3NcIl0oX2pzUGx1bWIuZW5kcG9pbnRDb25uZWN0ZWRDbGFzcyk7dGhpc1sodGhpcy5pc0Z1bGwoKT9cImFkZFwiOlwicmVtb3ZlXCIpK1wiQ2xhc3NcIl0oX2pzUGx1bWIuZW5kcG9pbnRGdWxsQ2xhc3MpO307dGhpcy5kZXRhY2hGcm9tQ29ubmVjdGlvbj1mdW5jdGlvbihjb25uZWN0aW9uLGlkeCxkb05vdENsZWFudXApe2lkeD1pZHg9PW51bGw/dGhpcy5jb25uZWN0aW9ucy5pbmRleE9mKGNvbm5lY3Rpb24pOmlkeDtpZihpZHg+PTApe3RoaXMuY29ubmVjdGlvbnMuc3BsaWNlKGlkeCwxKTt0aGlzWyh0aGlzLmNvbm5lY3Rpb25zLmxlbmd0aD4wP1wiYWRkXCI6XCJyZW1vdmVcIikrXCJDbGFzc1wiXShfanNQbHVtYi5lbmRwb2ludENvbm5lY3RlZENsYXNzKTt0aGlzWyh0aGlzLmlzRnVsbCgpP1wiYWRkXCI6XCJyZW1vdmVcIikrXCJDbGFzc1wiXShfanNQbHVtYi5lbmRwb2ludEZ1bGxDbGFzcyk7fWlmKCFkb05vdENsZWFudXAmJmRlbGV0ZU9uRW1wdHkmJnRoaXMuY29ubmVjdGlvbnMubGVuZ3RoPT09MCl7X2pzUGx1bWIuZGVsZXRlT2JqZWN0KHtlbmRwb2ludDp0aGlzLGZpcmVFdmVudDpmYWxzZSxkZWxldGVBdHRhY2hlZE9iamVjdHM6ZG9Ob3RDbGVhbnVwIT09dHJ1ZX0pO319O3RoaXMuZGVsZXRlRXZlcnlDb25uZWN0aW9uPWZ1bmN0aW9uKHBhcmFtcyl7dmFyIGM9dGhpcy5jb25uZWN0aW9ucy5sZW5ndGg7Zm9yKHZhciBpPTA7aTxjO2krKyl7X2pzUGx1bWIuZGVsZXRlQ29ubmVjdGlvbih0aGlzLmNvbm5lY3Rpb25zWzBdLHBhcmFtcyk7fX07dGhpcy5kZXRhY2hGcm9tPWZ1bmN0aW9uKHRhcmdldEVuZHBvaW50LGZpcmVFdmVudCxvcmlnaW5hbEV2ZW50KXt2YXIgYz1bXTtmb3IodmFyIGk9MDtpPHRoaXMuY29ubmVjdGlvbnMubGVuZ3RoO2krKyl7aWYodGhpcy5jb25uZWN0aW9uc1tpXS5lbmRwb2ludHNbMV09PT10YXJnZXRFbmRwb2ludHx8dGhpcy5jb25uZWN0aW9uc1tpXS5lbmRwb2ludHNbMF09PT10YXJnZXRFbmRwb2ludCl7Yy5wdXNoKHRoaXMuY29ubmVjdGlvbnNbaV0pO319Zm9yKHZhciBqPTAsY291bnQ9Yy5sZW5ndGg7ajxjb3VudDtqKyspe19qc1BsdW1iLmRlbGV0ZUNvbm5lY3Rpb24oY1swXSk7fXJldHVybiB0aGlzO307dGhpcy5nZXRFbGVtZW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWxlbWVudDt9O3RoaXMuc2V0RWxlbWVudD1mdW5jdGlvbihlbCl7dmFyIHBhcmVudElkPXRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuZ2V0SWQoZWwpLGN1cklkPXRoaXMuZWxlbWVudElkOy8vIHJlbW92ZSB0aGUgZW5kcG9pbnQgZnJvbSB0aGUgbGlzdCBmb3IgdGhlIGN1cnJlbnQgZW5kcG9pbnQncyBlbGVtZW50XG5fanUucmVtb3ZlV2l0aEZ1bmN0aW9uKHBhcmFtcy5lbmRwb2ludHNCeUVsZW1lbnRbdGhpcy5lbGVtZW50SWRdLGZ1bmN0aW9uKGUpe3JldHVybiBlLmlkPT09dGhpcy5pZDt9LmJpbmQodGhpcykpO3RoaXMuZWxlbWVudD1fanAuZ2V0RWxlbWVudChlbCk7dGhpcy5lbGVtZW50SWQ9X2pzUGx1bWIuZ2V0SWQodGhpcy5lbGVtZW50KTtfanNQbHVtYi5hbmNob3JNYW5hZ2VyLnJlaG9tZUVuZHBvaW50KHRoaXMsY3VySWQsdGhpcy5lbGVtZW50KTtfanNQbHVtYi5kcmFnTWFuYWdlci5lbmRwb2ludEFkZGVkKHRoaXMuZWxlbWVudCk7X2p1LmFkZFRvTGlzdChwYXJhbXMuZW5kcG9pbnRzQnlFbGVtZW50LHBhcmVudElkLHRoaXMpO3JldHVybiB0aGlzO307LyoqXHJcbiAgICAgICAgICogcHJpdmF0ZSBidXQgbXVzdCBiZSBleHBvc2VkLlxyXG4gICAgICAgICAqL3RoaXMubWFrZUluUGxhY2VDb3B5PWZ1bmN0aW9uKCl7dmFyIGxvYz10aGlzLmFuY2hvci5nZXRDdXJyZW50TG9jYXRpb24oe2VsZW1lbnQ6dGhpc30pLG89dGhpcy5hbmNob3IuZ2V0T3JpZW50YXRpb24odGhpcyksYWNjPXRoaXMuYW5jaG9yLmdldENzc0NsYXNzKCksaW5QbGFjZUFuY2hvcj17YmluZDpmdW5jdGlvbiBiaW5kKCl7fSxjb21wdXRlOmZ1bmN0aW9uIGNvbXB1dGUoKXtyZXR1cm5bbG9jWzBdLGxvY1sxXV07fSxnZXRDdXJyZW50TG9jYXRpb246ZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKCl7cmV0dXJuW2xvY1swXSxsb2NbMV1dO30sZ2V0T3JpZW50YXRpb246ZnVuY3Rpb24gZ2V0T3JpZW50YXRpb24oKXtyZXR1cm4gbzt9LGdldENzc0NsYXNzOmZ1bmN0aW9uIGdldENzc0NsYXNzKCl7cmV0dXJuIGFjYzt9fTtyZXR1cm4gX25ld0VuZHBvaW50KHtkcm9wT3B0aW9uczpwYXJhbXMuZHJvcE9wdGlvbnMsYW5jaG9yOmluUGxhY2VBbmNob3Isc291cmNlOnRoaXMuZWxlbWVudCxwYWludFN0eWxlOnRoaXMuZ2V0UGFpbnRTdHlsZSgpLGVuZHBvaW50OnBhcmFtcy5oaWRlT25EcmFnP1wiQmxhbmtcIjp0aGlzLmVuZHBvaW50LF90cmFuc2llbnQ6dHJ1ZSxzY29wZTp0aGlzLnNjb3BlLHJlZmVyZW5jZTp0aGlzfSk7fTsvKipcclxuICAgICAgICAgKiByZXR1cm5zIGEgY29ubmVjdGlvbiBmcm9tIHRoZSBwb29sOyB1c2VkIHdoZW4gZHJhZ2dpbmcgc3RhcnRzLiAganVzdCBnZXRzIHRoZSBoZWFkIG9mIHRoZSBhcnJheSBpZiBpdCBjYW4uXHJcbiAgICAgICAgICovdGhpcy5jb25uZWN0b3JTZWxlY3Rvcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbm5lY3Rpb25zWzBdO307dGhpcy5zZXRTdHlsZT10aGlzLnNldFBhaW50U3R5bGU7dGhpcy5wYWludD1mdW5jdGlvbihwYXJhbXMpe3BhcmFtcz1wYXJhbXN8fHt9O3ZhciB0aW1lc3RhbXA9cGFyYW1zLnRpbWVzdGFtcCxyZWNhbGM9IShwYXJhbXMucmVjYWxjPT09ZmFsc2UpO2lmKCF0aW1lc3RhbXB8fHRoaXMudGltZXN0YW1wIT09dGltZXN0YW1wKXt2YXIgaW5mbz1fanNQbHVtYi51cGRhdGVPZmZzZXQoe2VsSWQ6dGhpcy5lbGVtZW50SWQsdGltZXN0YW1wOnRpbWVzdGFtcH0pO3ZhciB4eT1wYXJhbXMub2Zmc2V0P3BhcmFtcy5vZmZzZXQubzppbmZvLm87aWYoeHkhPW51bGwpe3ZhciBhcD1wYXJhbXMuYW5jaG9yUG9pbnQsY29ubmVjdG9yUGFpbnRTdHlsZT1wYXJhbXMuY29ubmVjdG9yUGFpbnRTdHlsZTtpZihhcD09bnVsbCl7dmFyIHdoPXBhcmFtcy5kaW1lbnNpb25zfHxpbmZvLnMsYW5jaG9yUGFyYW1zPXt4eTpbeHkubGVmdCx4eS50b3BdLHdoOndoLGVsZW1lbnQ6dGhpcyx0aW1lc3RhbXA6dGltZXN0YW1wfTtpZihyZWNhbGMmJnRoaXMuYW5jaG9yLmlzRHluYW1pYyYmdGhpcy5jb25uZWN0aW9ucy5sZW5ndGg+MCl7dmFyIGM9ZmluZENvbm5lY3Rpb25Ub1VzZUZvckR5bmFtaWNBbmNob3IodGhpcyxwYXJhbXMuZWxlbWVudFdpdGhQcmVjZWRlbmNlKSxvSWR4PWMuZW5kcG9pbnRzWzBdPT09dGhpcz8xOjAsb0lkPW9JZHg9PT0wP2Muc291cmNlSWQ6Yy50YXJnZXRJZCxvSW5mbz1fanNQbHVtYi5nZXRDYWNoZWREYXRhKG9JZCksb09mZnNldD1vSW5mby5vLG9XSD1vSW5mby5zO2FuY2hvclBhcmFtcy5pbmRleD1vSWR4PT09MD8xOjA7YW5jaG9yUGFyYW1zLmNvbm5lY3Rpb249YzthbmNob3JQYXJhbXMudHh5PVtvT2Zmc2V0LmxlZnQsb09mZnNldC50b3BdO2FuY2hvclBhcmFtcy50d2g9b1dIO2FuY2hvclBhcmFtcy50RWxlbWVudD1jLmVuZHBvaW50c1tvSWR4XTt9ZWxzZSBpZih0aGlzLmNvbm5lY3Rpb25zLmxlbmd0aD4wKXthbmNob3JQYXJhbXMuY29ubmVjdGlvbj10aGlzLmNvbm5lY3Rpb25zWzBdO31hcD10aGlzLmFuY2hvci5jb21wdXRlKGFuY2hvclBhcmFtcyk7fXRoaXMuZW5kcG9pbnQuY29tcHV0ZShhcCx0aGlzLmFuY2hvci5nZXRPcmllbnRhdGlvbih0aGlzKSx0aGlzLl9qc1BsdW1iLnBhaW50U3R5bGVJblVzZSxjb25uZWN0b3JQYWludFN0eWxlfHx0aGlzLnBhaW50U3R5bGVJblVzZSk7dGhpcy5lbmRwb2ludC5wYWludCh0aGlzLl9qc1BsdW1iLnBhaW50U3R5bGVJblVzZSx0aGlzLmFuY2hvcik7dGhpcy50aW1lc3RhbXA9dGltZXN0YW1wOy8vIHBhaW50IG92ZXJsYXlzXG5mb3IodmFyIGkgaW4gdGhpcy5fanNQbHVtYi5vdmVybGF5cyl7aWYodGhpcy5fanNQbHVtYi5vdmVybGF5cy5oYXNPd25Qcm9wZXJ0eShpKSl7dmFyIG89dGhpcy5fanNQbHVtYi5vdmVybGF5c1tpXTtpZihvLmlzVmlzaWJsZSgpKXt0aGlzLl9qc1BsdW1iLm92ZXJsYXlQbGFjZW1lbnRzW2ldPW8uZHJhdyh0aGlzLmVuZHBvaW50LHRoaXMuX2pzUGx1bWIucGFpbnRTdHlsZUluVXNlKTtvLnBhaW50KHRoaXMuX2pzUGx1bWIub3ZlcmxheVBsYWNlbWVudHNbaV0pO319fX19fTt0aGlzLmdldFR5cGVEZXNjcmlwdG9yPWZ1bmN0aW9uKCl7cmV0dXJuXCJlbmRwb2ludFwiO307dGhpcy5pc1Zpc2libGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fanNQbHVtYi52aXNpYmxlO307dGhpcy5yZXBhaW50PXRoaXMucGFpbnQ7dmFyIGRyYWdnaW5nSW5pdGlhbGlzZWQ9ZmFsc2U7dGhpcy5pbml0RHJhZ2dhYmxlPWZ1bmN0aW9uKCl7Ly8gaXMgdGhpcyBhIGNvbm5lY3Rpb24gc291cmNlPyB3ZSBtYWtlIGl0IGRyYWdnYWJsZSBhbmQgaGF2ZSB0aGVcbi8vIGRyYWcgbGlzdGVuZXIgbWFpbnRhaW4gYSBjb25uZWN0aW9uIHdpdGggYSBmbG9hdGluZyBlbmRwb2ludC5cbmlmKCFkcmFnZ2luZ0luaXRpYWxpc2VkJiZfanAuaXNEcmFnU3VwcG9ydGVkKHRoaXMuZWxlbWVudCkpe3ZhciBwbGFjZWhvbGRlckluZm89e2lkOm51bGwsZWxlbWVudDpudWxsfSxqcGM9bnVsbCxleGlzdGluZ0pwYz1mYWxzZSxleGlzdGluZ0pwY1BhcmFtcz1udWxsLF9kcmFnSGFuZGxlcj1fbWFrZUNvbm5lY3Rpb25EcmFnSGFuZGxlcih0aGlzLHBsYWNlaG9sZGVySW5mbyxfanNQbHVtYiksZHJhZ09wdGlvbnM9cGFyYW1zLmRyYWdPcHRpb25zfHx7fSxkZWZhdWx0T3B0cz17fSxzdGFydEV2ZW50PV9qcC5kcmFnRXZlbnRzLnN0YXJ0LHN0b3BFdmVudD1fanAuZHJhZ0V2ZW50cy5zdG9wLGRyYWdFdmVudD1fanAuZHJhZ0V2ZW50cy5kcmFnLGJlZm9yZVN0YXJ0RXZlbnQ9X2pwLmRyYWdFdmVudHMuYmVmb3JlU3RhcnQscGF5bG9hZDsvLyByZXNwb25kIHRvIGJlZm9yZVN0YXJ0IGZyb20ga2F0YXZvcmlvOyB0aGlzIHdpbGwgaGF2ZSwgb3B0aW9uYWxseSwgYSBwYXlsb2FkIG9mIGF0dHJpYnV0ZSB2YWx1ZXNcbi8vIHRoYXQgd2VyZSBwbGFjZWQgdGhlcmUgYnkgdGhlIG1ha2VTb3VyY2UgbW91c2Vkb3duIGxpc3RlbmVyLlxudmFyIGJlZm9yZVN0YXJ0PWZ1bmN0aW9uIGJlZm9yZVN0YXJ0KGJlZm9yZVN0YXJ0UGFyYW1zKXtwYXlsb2FkPWJlZm9yZVN0YXJ0UGFyYW1zLmUucGF5bG9hZHx8e307fTt2YXIgc3RhcnQ9ZnVuY3Rpb24oc3RhcnRQYXJhbXMpey8vIC0tLS0tLS0tLS0tLS0gICBmaXJzdCwgZ2V0IGEgY29ubmVjdGlvbiB0byBkcmFnLiB0aGlzIG1heSBiZSBudWxsLCBpbiB3aGljaCBjYXNlIHdlIGFyZSBkcmFnZ2luZyBhIG5ldyBvbmUuXG5qcGM9dGhpcy5jb25uZWN0b3JTZWxlY3RvcigpOy8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIG5vdyBhIGJ1bmNoIG9mIHRlc3RzIGFib3V0IHdoZXRoZXIgb3Igbm90IHRvIHByb2NlZWQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIF9jb250aW51ZT10cnVlOy8vIGlmIG5vdCBlbmFibGVkLCByZXR1cm5cbmlmKCF0aGlzLmlzRW5hYmxlZCgpKXtfY29udGludWU9ZmFsc2U7fS8vIGlmIG5vIGNvbm5lY3Rpb24gYW5kIHdlJ3JlIG5vdCBhIHNvdXJjZSAtIG9yIHRlbXBvcmFyaWx5IGEgc291cmNlLCBhcyBpcyB0aGUgY2FzZSB3aXRoIG1ha2VTb3VyY2UgLSByZXR1cm4uXG5pZihqcGM9PW51bGwmJiF0aGlzLmlzU291cmNlJiYhdGhpcy5pc1RlbXBvcmFyeVNvdXJjZSl7X2NvbnRpbnVlPWZhbHNlO30vLyBvdGhlcndpc2UgaWYgd2UncmUgZnVsbCBhbmQgbm90IGFsbG93ZWQgdG8gZHJhZywgYWxzbyByZXR1cm4gZmFsc2UuXG5pZih0aGlzLmlzU291cmNlJiZ0aGlzLmlzRnVsbCgpJiYhKGpwYyE9bnVsbCYmdGhpcy5kcmFnQWxsb3dlZFdoZW5GdWxsKSl7X2NvbnRpbnVlPWZhbHNlO30vLyBpZiB0aGUgY29ubmVjdGlvbiB3YXMgc2V0dXAgYXMgbm90IGRldGFjaGFibGUgb3Igb25lIG9mIGl0cyBlbmRwb2ludHNcbi8vIHdhcyBzZXR1cCBhcyBjb25uZWN0aW9uc0RldGFjaGFibGUgPSBmYWxzZSwgb3IgRGVmYXVsdHMuQ29ubmVjdGlvbnNEZXRhY2hhYmxlXG4vLyBpcyBzZXQgdG8gZmFsc2UuLi5cbmlmKGpwYyE9bnVsbCYmIWpwYy5pc0RldGFjaGFibGUodGhpcykpe19jb250aW51ZT1mYWxzZTt9dmFyIGJlZm9yZURyYWc9X2pzUGx1bWIuY2hlY2tDb25kaXRpb24oanBjPT1udWxsP1wiYmVmb3JlRHJhZ1wiOlwiYmVmb3JlU3RhcnREZXRhY2hcIix7ZW5kcG9pbnQ6dGhpcyxzb3VyY2U6dGhpcy5lbGVtZW50LHNvdXJjZUlkOnRoaXMuZWxlbWVudElkLGNvbm5lY3Rpb246anBjfSk7aWYoYmVmb3JlRHJhZz09PWZhbHNlKXtfY29udGludWU9ZmFsc2U7fS8vIGVsc2Ugd2UgbWlnaHQgaGF2ZSBiZWVuIGdpdmVuIHNvbWUgZGF0YS4gd2UnbGwgcGFzcyBpdCBpbiB0byBhIG5ldyBjb25uZWN0aW9uIGFzICdkYXRhJy5cbi8vIGhlcmUgd2UgYWxzbyBtZXJnZSBpbiB0aGUgb3B0aW9uYWwgcGF5bG9hZCB3ZSB3ZXJlIGdpdmVuIG9uIG1vdXNlZG93bi5cbmVsc2UgaWYoKHR5cGVvZiBiZWZvcmVEcmFnPT09XCJ1bmRlZmluZWRcIj9cInVuZGVmaW5lZFwiOl90eXBlb2YoYmVmb3JlRHJhZykpPT09XCJvYmplY3RcIil7X2pwLmV4dGVuZChiZWZvcmVEcmFnLHBheWxvYWR8fHt9KTt9ZWxzZXsvLyBvciBpZiBubyBiZWZvcmVEcmFnIGRhdGEsIG1heWJlIHVzZSB0aGUgcGF5bG9hZCBvbiBpdHMgb3duLlxuYmVmb3JlRHJhZz1wYXlsb2FkfHx7fTt9aWYoX2NvbnRpbnVlPT09ZmFsc2Upey8vIHRoaXMgaXMgZm9yIG1vb3Rvb2xzIGFuZCB5dWkuIHJldHVybmluZyBmYWxzZSBmcm9tIHRoaXMgY2F1c2VzIGpxdWVyeSB0byBzdG9wIGRyYWcuXG4vLyB0aGUgZXZlbnRzIGFyZSB3cmFwcGVkIGluIGJvdGggbW9vdG9vbHMgYW5kIHl1aSBhbnl3YXksIGJ1dCBpIGRvbid0IHRoaW5rIHJldHVybmluZ1xuLy8gZmFsc2UgZnJvbSB0aGUgc3RhcnQgY2FsbGJhY2sgd291bGQgc3RvcCBhIGRyYWcuXG5pZihfanNQbHVtYi5zdG9wRHJhZyl7X2pzUGx1bWIuc3RvcERyYWcodGhpcy5jYW52YXMpO31fZHJhZ0hhbmRsZXIuc3RvcERyYWcoKTtyZXR1cm4gZmFsc2U7fS8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gb2sgdG8gcHJvY2VlZC5cbi8vIGNsZWFyIGhvdmVyIGZvciBhbGwgY29ubmVjdGlvbnMgZm9yIHRoaXMgZW5kcG9pbnQgYmVmb3JlIGNvbnRpbnVpbmcuXG5mb3IodmFyIGk9MDtpPHRoaXMuY29ubmVjdGlvbnMubGVuZ3RoO2krKyl7dGhpcy5jb25uZWN0aW9uc1tpXS5zZXRIb3ZlcihmYWxzZSk7fXRoaXMuYWRkQ2xhc3MoXCJlbmRwb2ludERyYWdcIik7X2pzUGx1bWIuc2V0Q29ubmVjdGlvbkJlaW5nRHJhZ2dlZCh0cnVlKTsvLyBpZiB3ZSdyZSBub3QgZnVsbCBidXQgdGhlcmUgd2FzIGEgY29ubmVjdGlvbiwgbWFrZSBpdCBudWxsLiB3ZSdsbCBjcmVhdGUgYSBuZXcgb25lLlxuaWYoanBjJiYhdGhpcy5pc0Z1bGwoKSYmdGhpcy5pc1NvdXJjZSl7anBjPW51bGw7fV9qc1BsdW1iLnVwZGF0ZU9mZnNldCh7ZWxJZDp0aGlzLmVsZW1lbnRJZH0pOy8vIC0tLS0tLS0tLS0tLS0tLS0gICAgbWFrZSB0aGUgZWxlbWVudCB3ZSB3aWxsIGRyYWcgYXJvdW5kLCBhbmQgcG9zaXRpb24gaXQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBpcGNvPXRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuZ2V0T2Zmc2V0KHRoaXMuY2FudmFzKSxjYW52YXNFbGVtZW50PXRoaXMuY2FudmFzLGlwcz10aGlzLl9qc1BsdW1iLmluc3RhbmNlLmdldFNpemUodGhpcy5jYW52YXMpO19tYWtlRHJhZ2dhYmxlUGxhY2Vob2xkZXIocGxhY2Vob2xkZXJJbmZvLF9qc1BsdW1iLGlwY28saXBzKTsvLyBzdG9yZSB0aGUgaWQgb2YgdGhlIGRyYWdnaW5nIGRpdiBhbmQgdGhlIHNvdXJjZSBlbGVtZW50LiB0aGUgZHJvcCBmdW5jdGlvbiB3aWxsIHBpY2sgdGhlc2UgdXAuICAgICAgICAgICAgICAgICAgIFxuX2pzUGx1bWIuc2V0QXR0cmlidXRlcyh0aGlzLmNhbnZhcyx7XCJkcmFnSWRcIjpwbGFjZWhvbGRlckluZm8uaWQsXCJlbElkXCI6dGhpcy5lbGVtZW50SWR9KTsvLyAtLS0tLS0tLS0tLS0tLS0tLS0tIGNyZWF0ZSBhbiBlbmRwb2ludCB0aGF0IHdpbGwgYmUgb3VyIGZsb2F0aW5nIGVuZHBvaW50IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIGVuZHBvaW50VG9GbG9hdD10aGlzLmRyYWdQcm94eXx8dGhpcy5lbmRwb2ludDtpZih0aGlzLmRyYWdQcm94eT09bnVsbCYmdGhpcy5jb25uZWN0aW9uVHlwZSE9bnVsbCl7dmFyIGFhZT10aGlzLl9qc1BsdW1iLmluc3RhbmNlLmRlcml2ZUVuZHBvaW50QW5kQW5jaG9yU3BlYyh0aGlzLmNvbm5lY3Rpb25UeXBlKTtpZihhYWUuZW5kcG9pbnRzWzFdKXtlbmRwb2ludFRvRmxvYXQ9YWFlLmVuZHBvaW50c1sxXTt9fXZhciBjZW50ZXJBbmNob3I9dGhpcy5fanNQbHVtYi5pbnN0YW5jZS5tYWtlQW5jaG9yKFwiQ2VudGVyXCIpO2NlbnRlckFuY2hvci5pc0Zsb2F0aW5nPXRydWU7dGhpcy5fanNQbHVtYi5mbG9hdGluZ0VuZHBvaW50PV9tYWtlRmxvYXRpbmdFbmRwb2ludCh0aGlzLmdldFBhaW50U3R5bGUoKSxjZW50ZXJBbmNob3IsZW5kcG9pbnRUb0Zsb2F0LHRoaXMuY2FudmFzLHBsYWNlaG9sZGVySW5mby5lbGVtZW50LF9qc1BsdW1iLF9uZXdFbmRwb2ludCx0aGlzLnNjb3BlKTt2YXIgX3NhdmVkQW5jaG9yPXRoaXMuX2pzUGx1bWIuZmxvYXRpbmdFbmRwb2ludC5hbmNob3I7aWYoanBjPT1udWxsKXt0aGlzLnNldEhvdmVyKGZhbHNlLGZhbHNlKTsvLyBjcmVhdGUgYSBjb25uZWN0aW9uLiBvbmUgZW5kIGlzIHRoaXMgZW5kcG9pbnQsIHRoZSBvdGhlciBpcyBhIGZsb2F0aW5nIGVuZHBvaW50LiAgICAgICAgICAgICAgICAgICAgXG5qcGM9X25ld0Nvbm5lY3Rpb24oe3NvdXJjZUVuZHBvaW50OnRoaXMsdGFyZ2V0RW5kcG9pbnQ6dGhpcy5fanNQbHVtYi5mbG9hdGluZ0VuZHBvaW50LHNvdXJjZTp0aGlzLmVsZW1lbnQsLy8gZm9yIG1ha2VTb3VyY2Ugd2l0aCBwYXJlbnQgb3B0aW9uLiAgZW5zdXJlIHNvdXJjZSBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGNvcnJlY3RseS5cbnRhcmdldDpwbGFjZWhvbGRlckluZm8uZWxlbWVudCxhbmNob3JzOlt0aGlzLmFuY2hvcix0aGlzLl9qc1BsdW1iLmZsb2F0aW5nRW5kcG9pbnQuYW5jaG9yXSxwYWludFN0eWxlOnBhcmFtcy5jb25uZWN0b3JTdHlsZSwvLyB0aGlzIGNhbiBiZSBudWxsLiBDb25uZWN0aW9uIHdpbGwgdXNlIHRoZSBkZWZhdWx0LlxuaG92ZXJQYWludFN0eWxlOnBhcmFtcy5jb25uZWN0b3JIb3ZlclN0eWxlLGNvbm5lY3RvcjpwYXJhbXMuY29ubmVjdG9yLC8vIHRoaXMgY2FuIGFsc28gYmUgbnVsbC4gQ29ubmVjdGlvbiB3aWxsIHVzZSB0aGUgZGVmYXVsdC5cbm92ZXJsYXlzOnBhcmFtcy5jb25uZWN0b3JPdmVybGF5cyx0eXBlOnRoaXMuY29ubmVjdGlvblR5cGUsY3NzQ2xhc3M6dGhpcy5jb25uZWN0b3JDbGFzcyxob3ZlckNsYXNzOnRoaXMuY29ubmVjdG9ySG92ZXJDbGFzcyxzY29wZTpwYXJhbXMuc2NvcGUsZGF0YTpiZWZvcmVEcmFnfSk7anBjLnBlbmRpbmc9dHJ1ZTtqcGMuYWRkQ2xhc3MoX2pzUGx1bWIuZHJhZ2dpbmdDbGFzcyk7dGhpcy5fanNQbHVtYi5mbG9hdGluZ0VuZHBvaW50LmFkZENsYXNzKF9qc1BsdW1iLmRyYWdnaW5nQ2xhc3MpO3RoaXMuX2pzUGx1bWIuZmxvYXRpbmdFbmRwb2ludC5hbmNob3I9X3NhdmVkQW5jaG9yOy8vIGZpcmUgYW4gZXZlbnQgdGhhdCBpbmZvcm1zIHRoYXQgYSBjb25uZWN0aW9uIGlzIGJlaW5nIGRyYWdnZWRcbl9qc1BsdW1iLmZpcmUoXCJjb25uZWN0aW9uRHJhZ1wiLGpwYyk7Ly8gcmVnaXN0ZXIgdGhlIG5ldyBjb25uZWN0aW9uIG9uIHRoZSBkcmFnIG1hbmFnZXIuIFRoaXMgY29ubmVjdGlvbiwgYXQgdGhpcyBwb2ludCwgaXMgJ3BlbmRpbmcnLFxuLy8gYW5kIGhhcyBhcyBpdHMgdGFyZ2V0IGEgdGVtcG9yYXJ5IGVsZW1lbnQgKHRoZSAncGxhY2Vob2xkZXInKS4gSWYgdGhlIGNvbm5lY3Rpb24gc3Vic2VxdWVudGx5XG4vLyBiZWNvbWVzIGVzdGFibGlzaGVkLCB0aGUgYW5jaG9yIG1hbmFnZXIgaXMgaW5mb3JtZWQgdGhhdCB0aGUgdGFyZ2V0IG9mIHRoZSBjb25uZWN0aW9uIGhhc1xuLy8gY2hhbmdlZC5cbl9qc1BsdW1iLmFuY2hvck1hbmFnZXIubmV3Q29ubmVjdGlvbihqcGMpO31lbHNle2V4aXN0aW5nSnBjPXRydWU7anBjLnNldEhvdmVyKGZhbHNlKTsvLyBuZXcgYW5jaG9yIGlkeFxudmFyIGFuY2hvcklkeD1qcGMuZW5kcG9pbnRzWzBdLmlkPT09dGhpcy5pZD8wOjE7dGhpcy5kZXRhY2hGcm9tQ29ubmVjdGlvbihqcGMsbnVsbCx0cnVlKTsvLyBkZXRhY2ggZnJvbSB0aGUgY29ubmVjdGlvbiB3aGlsZSBkcmFnZ2luZyBpcyBvY2N1cnJpbmcuIGJ1dCBkb250IGNsZWFudXAgYXV0b21hdGljYWxseS5cbi8vIHN0b3JlIHRoZSBvcmlnaW5hbCBzY29wZSAoaXNzdWUgNTcpXG52YXIgZHJhZ1Njb3BlPV9qc1BsdW1iLmdldERyYWdTY29wZShjYW52YXNFbGVtZW50KTtfanNQbHVtYi5zZXRBdHRyaWJ1dGUodGhpcy5jYW52YXMsXCJvcmlnaW5hbFNjb3BlXCIsZHJhZ1Njb3BlKTsvLyBmaXJlIGFuIGV2ZW50IHRoYXQgaW5mb3JtcyB0aGF0IGEgY29ubmVjdGlvbiBpcyBiZWluZyBkcmFnZ2VkLiB3ZSBkbyB0aGlzIGJlZm9yZVxuLy8gcmVwbGFjaW5nIHRoZSBvcmlnaW5hbCB0YXJnZXQgd2l0aCB0aGUgZmxvYXRpbmcgZWxlbWVudCBpbmZvLlxuX2pzUGx1bWIuZmlyZShcImNvbm5lY3Rpb25EcmFnXCIsanBjKTsvLyBub3cgd2UgcmVwbGFjZSBvdXJzZWx2ZXMgd2l0aCB0aGUgdGVtcG9yYXJ5IGRpdiB3ZSBjcmVhdGVkIGFib3ZlOlxuaWYoYW5jaG9ySWR4PT09MCl7ZXhpc3RpbmdKcGNQYXJhbXM9W2pwYy5zb3VyY2UsanBjLnNvdXJjZUlkLGNhbnZhc0VsZW1lbnQsZHJhZ1Njb3BlXTtfanNQbHVtYi5hbmNob3JNYW5hZ2VyLnNvdXJjZUNoYW5nZWQoanBjLmVuZHBvaW50c1thbmNob3JJZHhdLmVsZW1lbnRJZCxwbGFjZWhvbGRlckluZm8uaWQsanBjLHBsYWNlaG9sZGVySW5mby5lbGVtZW50KTt9ZWxzZXtleGlzdGluZ0pwY1BhcmFtcz1banBjLnRhcmdldCxqcGMudGFyZ2V0SWQsY2FudmFzRWxlbWVudCxkcmFnU2NvcGVdO2pwYy50YXJnZXQ9cGxhY2Vob2xkZXJJbmZvLmVsZW1lbnQ7anBjLnRhcmdldElkPXBsYWNlaG9sZGVySW5mby5pZDtfanNQbHVtYi5hbmNob3JNYW5hZ2VyLnVwZGF0ZU90aGVyRW5kcG9pbnQoanBjLnNvdXJjZUlkLGpwYy5lbmRwb2ludHNbYW5jaG9ySWR4XS5lbGVtZW50SWQsanBjLnRhcmdldElkLGpwYyk7fS8vIHN0b3JlIHRoZSBvcmlnaW5hbCBlbmRwb2ludCBhbmQgYXNzaWduIHRoZSBuZXcgZmxvYXRpbmcgZW5kcG9pbnQgZm9yIHRoZSBkcmFnLlxuanBjLnN1c3BlbmRlZEVuZHBvaW50PWpwYy5lbmRwb2ludHNbYW5jaG9ySWR4XTsvLyBQUk9WSURFIFRIRSBTVVNQRU5ERUQgRUxFTUVOVCwgQkUgSVQgQSBTT1VSQ0UgT1IgVEFSR0VUIChJU1NVRSAzOSlcbmpwYy5zdXNwZW5kZWRFbGVtZW50PWpwYy5lbmRwb2ludHNbYW5jaG9ySWR4XS5nZXRFbGVtZW50KCk7anBjLnN1c3BlbmRlZEVsZW1lbnRJZD1qcGMuZW5kcG9pbnRzW2FuY2hvcklkeF0uZWxlbWVudElkO2pwYy5zdXNwZW5kZWRFbGVtZW50VHlwZT1hbmNob3JJZHg9PT0wP1wic291cmNlXCI6XCJ0YXJnZXRcIjtqcGMuc3VzcGVuZGVkRW5kcG9pbnQuc2V0SG92ZXIoZmFsc2UpO3RoaXMuX2pzUGx1bWIuZmxvYXRpbmdFbmRwb2ludC5yZWZlcmVuY2VFbmRwb2ludD1qcGMuc3VzcGVuZGVkRW5kcG9pbnQ7anBjLmVuZHBvaW50c1thbmNob3JJZHhdPXRoaXMuX2pzUGx1bWIuZmxvYXRpbmdFbmRwb2ludDtqcGMuYWRkQ2xhc3MoX2pzUGx1bWIuZHJhZ2dpbmdDbGFzcyk7dGhpcy5fanNQbHVtYi5mbG9hdGluZ0VuZHBvaW50LmFkZENsYXNzKF9qc1BsdW1iLmRyYWdnaW5nQ2xhc3MpO31fanNQbHVtYi5yZWdpc3RlckZsb2F0aW5nQ29ubmVjdGlvbihwbGFjZWhvbGRlckluZm8sanBjLHRoaXMuX2pzUGx1bWIuZmxvYXRpbmdFbmRwb2ludCk7Ly8gLy8gcmVnaXN0ZXIgaXQgYW5kIHJlZ2lzdGVyIGNvbm5lY3Rpb24gb24gaXQuXG4vLyBfanNQbHVtYi5mbG9hdGluZ0Nvbm5lY3Rpb25zW3BsYWNlaG9sZGVySW5mby5pZF0gPSBqcGM7XG4vL1xuLy8gLy8gb25seSByZWdpc3RlciBmb3IgdGhlIHRhcmdldCBlbmRwb2ludDsgd2Ugd2lsbCBub3QgYmUgZHJhZ2dpbmcgdGhlIHNvdXJjZSBhdCBhbnkgdGltZVxuLy8gLy8gYmVmb3JlIHRoaXMgY29ubmVjdGlvbiBpcyBlaXRoZXIgZGlzY2FyZGVkIG9yIG1hZGUgaW50byBhIHBlcm1hbmVudCBjb25uZWN0aW9uLlxuLy8gX2p1LmFkZFRvTGlzdChwYXJhbXMuZW5kcG9pbnRzQnlFbGVtZW50LCBwbGFjZWhvbGRlckluZm8uaWQsIHRoaXMuX2pzUGx1bWIuZmxvYXRpbmdFbmRwb2ludCk7XG4vLyB0ZWxsIGpzcGx1bWIgYWJvdXQgaXRcbl9qc1BsdW1iLmN1cnJlbnRseURyYWdnaW5nPXRydWU7fS5iaW5kKHRoaXMpO3ZhciBzdG9wPWZ1bmN0aW9uKCl7X2pzUGx1bWIuc2V0Q29ubmVjdGlvbkJlaW5nRHJhZ2dlZChmYWxzZSk7aWYoanBjJiZqcGMuZW5kcG9pbnRzIT1udWxsKXsvLyBnZXQgdGhlIGFjdHVhbCBkcm9wIGV2ZW50IChkZWNvZGUgZnJvbSBsaWJyYXJ5IGFyZ3MgdG8gc3RvcCBmdW5jdGlvbilcbnZhciBvcmlnaW5hbEV2ZW50PV9qc1BsdW1iLmdldERyb3BFdmVudChhcmd1bWVudHMpOy8vIHVubG9jayB0aGUgb3RoZXIgZW5kcG9pbnQgKGlmIGl0IGlzIGR5bmFtaWMsIGl0IHdvdWxkIGhhdmUgYmVlbiBsb2NrZWQgYXQgZHJhZyBzdGFydClcbnZhciBpZHg9X2pzUGx1bWIuZ2V0RmxvYXRpbmdBbmNob3JJbmRleChqcGMpO2pwYy5lbmRwb2ludHNbaWR4PT09MD8xOjBdLmFuY2hvci5sb2NrZWQ9ZmFsc2U7Ly8gVE9ETzogRG9udCB3YW50IHRvIGtub3cgYWJvdXQgY3NzIGNsYXNzZXMgaW5zaWRlIGpzcGx1bWIsIGlkZWFsbHkuXG5qcGMucmVtb3ZlQ2xhc3MoX2pzUGx1bWIuZHJhZ2dpbmdDbGFzcyk7Ly8gaWYgd2UgaGF2ZSB0aGUgZmxvYXRpbmcgZW5kcG9pbnQgdGhlbiB0aGUgY29ubmVjdGlvbiBoYXMgbm90IGJlZW4gZHJvcHBlZFxuLy8gb24gYW5vdGhlciBlbmRwb2ludC4gIElmIGl0IGlzIGEgbmV3IGNvbm5lY3Rpb24gd2UgdGhyb3cgaXQgYXdheS4gSWYgaXQgaXMgYW5cbi8vIGV4aXN0aW5nIGNvbm5lY3Rpb24gd2UgY2hlY2sgdG8gc2VlIGlmIHdlIHNob3VsZCByZWF0dGFjaCBpdCwgdGhyb3dpbmcgaXQgYXdheVxuLy8gaWYgbm90LlxuaWYodGhpcy5fanNQbHVtYiYmKGpwYy5kZWxldGVDb25uZWN0aW9uTm93fHxqcGMuZW5kcG9pbnRzW2lkeF09PT10aGlzLl9qc1BsdW1iLmZsb2F0aW5nRW5kcG9pbnQpKXsvLyA2YS4gaWYgdGhlIGNvbm5lY3Rpb24gd2FzIGFuIGV4aXN0aW5nIG9uZS4uLlxuaWYoZXhpc3RpbmdKcGMmJmpwYy5zdXNwZW5kZWRFbmRwb2ludCl7Ly8gZml4IGZvciBpc3N1ZTM1LCB0aGFua3MgU3lsdmFpbiBHaXphcmQ6IHdoZW4gZmlyaW5nIHRoZSBkZXRhY2ggZXZlbnQgbWFrZSBzdXJlIHRoZVxuLy8gZmxvYXRpbmcgZW5kcG9pbnQgaGFzIGJlZW4gcmVwbGFjZWQuXG5pZihpZHg9PT0wKXtqcGMuZmxvYXRpbmdFbGVtZW50PWpwYy5zb3VyY2U7anBjLmZsb2F0aW5nSWQ9anBjLnNvdXJjZUlkO2pwYy5mbG9hdGluZ0VuZHBvaW50PWpwYy5lbmRwb2ludHNbMF07anBjLmZsb2F0aW5nSW5kZXg9MDtqcGMuc291cmNlPWV4aXN0aW5nSnBjUGFyYW1zWzBdO2pwYy5zb3VyY2VJZD1leGlzdGluZ0pwY1BhcmFtc1sxXTt9ZWxzZXsvLyBrZWVwIGEgY29weSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudDsgdGhlIGFuY2hvciBtYW5hZ2VyIHdpbGwgd2FudCB0byBjbGVhbiB1cC5cbmpwYy5mbG9hdGluZ0VsZW1lbnQ9anBjLnRhcmdldDtqcGMuZmxvYXRpbmdJZD1qcGMudGFyZ2V0SWQ7anBjLmZsb2F0aW5nRW5kcG9pbnQ9anBjLmVuZHBvaW50c1sxXTtqcGMuZmxvYXRpbmdJbmRleD0xO2pwYy50YXJnZXQ9ZXhpc3RpbmdKcGNQYXJhbXNbMF07anBjLnRhcmdldElkPWV4aXN0aW5nSnBjUGFyYW1zWzFdO312YXIgZmU9dGhpcy5fanNQbHVtYi5mbG9hdGluZ0VuZHBvaW50Oy8vIHN0b3JlIGZvciBsYXRlciByZW1vdmFsLlxuLy8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgc2NvcGUgKGlzc3VlIDU3KVxuX2pzUGx1bWIuc2V0RHJhZ1Njb3BlKGV4aXN0aW5nSnBjUGFyYW1zWzJdLGV4aXN0aW5nSnBjUGFyYW1zWzNdKTtqcGMuZW5kcG9pbnRzW2lkeF09anBjLnN1c3BlbmRlZEVuZHBvaW50Oy8vIGlmIHRoZSBjb25uZWN0aW9uIHNob3VsZCBiZSByZWF0dGFjaGVkLCBvciB0aGUgb3RoZXIgZW5kcG9pbnQgcmVmdXNlcyBkZXRhY2gsIHRoZW5cbi8vIHJlc2V0IHRoZSBjb25uZWN0aW9uIHRvIGl0cyBvcmlnaW5hbCBzdGF0ZVxuaWYoanBjLmlzUmVhdHRhY2goKXx8anBjLl9mb3JjZVJlYXR0YWNofHxqcGMuX2ZvcmNlRGV0YWNofHwhX2pzUGx1bWIuZGVsZXRlQ29ubmVjdGlvbihqcGMse29yaWdpbmFsRXZlbnQ6b3JpZ2luYWxFdmVudH0pKXtqcGMuc2V0SG92ZXIoZmFsc2UpO2pwYy5fZm9yY2VEZXRhY2g9bnVsbDtqcGMuX2ZvcmNlUmVhdHRhY2g9bnVsbDt0aGlzLl9qc1BsdW1iLmZsb2F0aW5nRW5kcG9pbnQuZGV0YWNoRnJvbUNvbm5lY3Rpb24oanBjKTtqcGMuc3VzcGVuZGVkRW5kcG9pbnQuYWRkQ29ubmVjdGlvbihqcGMpOy8vIFRPRE8gdGhpcyBjb2RlIGlzIGR1cGxpY2F0ZWQgaW4gbG90cyBvZiBwbGFjZXMuLi5hbmQgdGhlcmUgaXMgbm90aGluZyBleHRlcm5hbFxuLy8gaW4gdGhlIGNvZGU7IGl0IGFsbCByZWZlcnMgdG8gdGhlIGNvbm5lY3Rpb24gaXRzZWxmLiB3ZSBjb3VsZCBhZGQgYVxuLy8gYGNoZWNrU2FuaXR5KGNvbm5lY3Rpb24pYCBtZXRob2QgdG8gYW5jaG9yTWFuYWdlciB0aGF0IGRpZCB0aGlzLlxuaWYoaWR4PT09MSl7X2pzUGx1bWIuYW5jaG9yTWFuYWdlci51cGRhdGVPdGhlckVuZHBvaW50KGpwYy5zb3VyY2VJZCxqcGMuZmxvYXRpbmdJZCxqcGMudGFyZ2V0SWQsanBjKTt9ZWxzZXtfanNQbHVtYi5hbmNob3JNYW5hZ2VyLnNvdXJjZUNoYW5nZWQoanBjLmZsb2F0aW5nSWQsanBjLnNvdXJjZUlkLGpwYyxqcGMuc291cmNlKTt9X2pzUGx1bWIucmVwYWludChleGlzdGluZ0pwY1BhcmFtc1sxXSk7fWVsc2V7X2pzUGx1bWIuZGVsZXRlT2JqZWN0KHtlbmRwb2ludDpmZX0pO319fS8vIG1ha2VUYXJnZXRzIHNldHMgdGhpcyBmbGFnLCB0byB0ZWxsIHVzIHdlIGhhdmUgYmVlbiByZXBsYWNlZCBhbmQgc2hvdWxkIGRlbGV0ZSB0aGlzIG9iamVjdC5cbmlmKHRoaXMuZGVsZXRlQWZ0ZXJEcmFnU3RvcCl7X2pzUGx1bWIuZGVsZXRlT2JqZWN0KHtlbmRwb2ludDp0aGlzfSk7fWVsc2V7aWYodGhpcy5fanNQbHVtYil7dGhpcy5wYWludCh7cmVjYWxjOmZhbHNlfSk7fX0vLyBhbHRob3VnaCB0aGUgY29ubmVjdGlvbiBpcyBubyBsb25nZXIgdmFsaWQsIHRoZXJlIGFyZSB1c2UgY2FzZXMgd2hlcmUgdGhpcyBpcyB1c2VmdWwuXG5fanNQbHVtYi5maXJlKFwiY29ubmVjdGlvbkRyYWdTdG9wXCIsanBjLG9yaWdpbmFsRXZlbnQpOy8vIGZpcmUgdGhpcyBldmVudCB0byBnaXZlIHBlb3BsZSBtb3JlIGZpbmUtZ3JhaW5lZCBjb250cm9sIChjb25uZWN0aW9uRHJhZ1N0b3AgZmlyZXMgYSBsb3QpXG5pZihqcGMucGVuZGluZyl7X2pzUGx1bWIuZmlyZShcImNvbm5lY3Rpb25BYm9ydGVkXCIsanBjLG9yaWdpbmFsRXZlbnQpO30vLyB0ZWxsIGpzcGx1bWIgdGhhdCBkcmFnZ2luZyBpcyBmaW5pc2hlZC5cbl9qc1BsdW1iLmN1cnJlbnRseURyYWdnaW5nPWZhbHNlO2pwYy5zdXNwZW5kZWRFbGVtZW50PW51bGw7anBjLnN1c3BlbmRlZEVuZHBvaW50PW51bGw7anBjPW51bGw7fS8vIGlmIG5vIGVuZHBvaW50cywganBjIGFscmVhZHkgY2xlYW5lZCB1cC4gYnV0IHN0aWxsIHdlIHdhbnQgdG8gZW5zdXJlIHdlJ3JlIHJlc2V0IHByb3Blcmx5LlxuLy8gcmVtb3ZlIHRoZSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgZmxvYXRpbmcgZW5kcG9pbnRcbi8vIChhbmQgaXRzIGFzc29jaWF0ZWQgZmxvYXRpbmcgZW5kcG9pbnQgYW5kIHZpc3VhbCBhcnRlZmFjdHMpXG5pZihwbGFjZWhvbGRlckluZm8mJnBsYWNlaG9sZGVySW5mby5lbGVtZW50KXtfanNQbHVtYi5yZW1vdmUocGxhY2Vob2xkZXJJbmZvLmVsZW1lbnQsZmFsc2UsZmFsc2UpO30vLyByZW1vdmUgdGhlIGlucGxhY2UgY29weVxuaWYoaW5QbGFjZUNvcHkpe19qc1BsdW1iLmRlbGV0ZU9iamVjdCh7ZW5kcG9pbnQ6aW5QbGFjZUNvcHl9KTt9aWYodGhpcy5fanNQbHVtYil7Ly8gbWFrZSBvdXIgY2FudmFzIHZpc2libGUgKFRPRE86IGhhbmQgb2ZmIHRvIGxpYnJhcnk7IHdlIHNob3VsZCBub3Qga25vdyBhYm91dCBET00pXG50aGlzLmNhbnZhcy5zdHlsZS52aXNpYmlsaXR5PVwidmlzaWJsZVwiOy8vIHVubG9jayBvdXIgYW5jaG9yXG50aGlzLmFuY2hvci5sb2NrZWQ9ZmFsc2U7Ly8gY2xlYXIgZmxvYXRpbmcgYW5jaG9yLlxudGhpcy5fanNQbHVtYi5mbG9hdGluZ0VuZHBvaW50PW51bGw7fX0uYmluZCh0aGlzKTtkcmFnT3B0aW9ucz1fanAuZXh0ZW5kKGRlZmF1bHRPcHRzLGRyYWdPcHRpb25zKTtkcmFnT3B0aW9ucy5zY29wZT10aGlzLnNjb3BlfHxkcmFnT3B0aW9ucy5zY29wZTtkcmFnT3B0aW9uc1tiZWZvcmVTdGFydEV2ZW50XT1fanUud3JhcChkcmFnT3B0aW9uc1tiZWZvcmVTdGFydEV2ZW50XSxiZWZvcmVTdGFydCxmYWxzZSk7ZHJhZ09wdGlvbnNbc3RhcnRFdmVudF09X2p1LndyYXAoZHJhZ09wdGlvbnNbc3RhcnRFdmVudF0sc3RhcnQsZmFsc2UpOy8vIGV4dHJhY3RlZCBkcmFnIGhhbmRsZXIgZnVuY3Rpb24gc28gY2FuIGJlIHVzZWQgYnkgbWFrZVNvdXJjZVxuZHJhZ09wdGlvbnNbZHJhZ0V2ZW50XT1fanUud3JhcChkcmFnT3B0aW9uc1tkcmFnRXZlbnRdLF9kcmFnSGFuZGxlci5kcmFnKTtkcmFnT3B0aW9uc1tzdG9wRXZlbnRdPV9qdS53cmFwKGRyYWdPcHRpb25zW3N0b3BFdmVudF0sc3RvcCk7ZHJhZ09wdGlvbnMubXVsdGlwbGVEcm9wPWZhbHNlO2RyYWdPcHRpb25zLmNhbkRyYWc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc1NvdXJjZXx8dGhpcy5pc1RlbXBvcmFyeVNvdXJjZXx8LyoodGhpcy5pc1RhcmdldCAmJiAqL3RoaXMuY29ubmVjdGlvbnMubGVuZ3RoPjAvKikqLzt9LmJpbmQodGhpcyk7X2pzUGx1bWIuaW5pdERyYWdnYWJsZSh0aGlzLmNhbnZhcyxkcmFnT3B0aW9ucyxcImludGVybmFsXCIpO3RoaXMuY2FudmFzLl9qc1BsdW1iUmVsYXRlZEVsZW1lbnQ9dGhpcy5lbGVtZW50O2RyYWdnaW5nSW5pdGlhbGlzZWQ9dHJ1ZTt9fTt2YXIgZXA9cGFyYW1zLmVuZHBvaW50fHx0aGlzLl9qc1BsdW1iLmluc3RhbmNlLkRlZmF1bHRzLkVuZHBvaW50fHxfanAuRGVmYXVsdHMuRW5kcG9pbnQ7dGhpcy5zZXRFbmRwb2ludChlcCx0cnVlKTt2YXIgYW5jaG9yUGFyYW1zVG9Vc2U9cGFyYW1zLmFuY2hvcj9wYXJhbXMuYW5jaG9yOnBhcmFtcy5hbmNob3JzP3BhcmFtcy5hbmNob3JzOl9qc1BsdW1iLkRlZmF1bHRzLkFuY2hvcnx8XCJUb3BcIjt0aGlzLnNldEFuY2hvcihhbmNob3JQYXJhbXNUb1VzZSx0cnVlKTsvLyBmaW5hbGx5LCBzZXQgdHlwZSBpZiBpdCB3YXMgcHJvdmlkZWRcbnZhciB0eXBlPVtcImRlZmF1bHRcIixwYXJhbXMudHlwZXx8XCJcIl0uam9pbihcIiBcIik7dGhpcy5hZGRUeXBlKHR5cGUscGFyYW1zLmRhdGEsdHJ1ZSk7dGhpcy5jYW52YXM9dGhpcy5lbmRwb2ludC5jYW52YXM7dGhpcy5jYW52YXMuX2pzUGx1bWI9dGhpczt0aGlzLmluaXREcmFnZ2FibGUoKTsvLyBwdWxsZWQgdGhpcyBvdXQgaW50byBhIGZ1bmN0aW9uIHNvIHdlIGNhbiByZXVzZSBpdCBmb3IgdGhlIGluUGxhY2VDb3B5IGNhbnZhczsgeW91IGNhbiBub3cgZHJvcCBkZXRhY2hlZCBjb25uZWN0aW9uc1xuLy8gYmFjayBvbnRvIHRoZSBlbmRwb2ludCB5b3UgZGV0YWNoZWQgaXQgZnJvbS5cbnZhciBfaW5pdERyb3BUYXJnZXQ9ZnVuY3Rpb24oY2FudmFzLGlzVHJhbnNpZW50LGVuZHBvaW50LHJlZmVyZW5jZUVuZHBvaW50KXtpZihfanAuaXNEcm9wU3VwcG9ydGVkKHRoaXMuZWxlbWVudCkpe3ZhciBkcm9wT3B0aW9ucz1wYXJhbXMuZHJvcE9wdGlvbnN8fF9qc1BsdW1iLkRlZmF1bHRzLkRyb3BPcHRpb25zfHxfanAuRGVmYXVsdHMuRHJvcE9wdGlvbnM7ZHJvcE9wdGlvbnM9X2pwLmV4dGVuZCh7fSxkcm9wT3B0aW9ucyk7ZHJvcE9wdGlvbnMuc2NvcGU9ZHJvcE9wdGlvbnMuc2NvcGV8fHRoaXMuc2NvcGU7dmFyIGRyb3BFdmVudD1fanAuZHJhZ0V2ZW50cy5kcm9wLG92ZXJFdmVudD1fanAuZHJhZ0V2ZW50cy5vdmVyLG91dEV2ZW50PV9qcC5kcmFnRXZlbnRzLm91dCxfZXA9dGhpcyxkcm9wPV9qc1BsdW1iLkVuZHBvaW50RHJvcEhhbmRsZXIoe2dldEVuZHBvaW50OmZ1bmN0aW9uIGdldEVuZHBvaW50KCl7cmV0dXJuIF9lcDt9LGpzUGx1bWI6X2pzUGx1bWIsZW5hYmxlZDpmdW5jdGlvbiBlbmFibGVkKCl7cmV0dXJuIGVuZHBvaW50IT1udWxsP2VuZHBvaW50LmlzRW5hYmxlZCgpOnRydWU7fSxpc0Z1bGw6ZnVuY3Rpb24gaXNGdWxsKCl7cmV0dXJuIGVuZHBvaW50LmlzRnVsbCgpO30sZWxlbWVudDp0aGlzLmVsZW1lbnQsZWxlbWVudElkOnRoaXMuZWxlbWVudElkLGlzU291cmNlOnRoaXMuaXNTb3VyY2UsaXNUYXJnZXQ6dGhpcy5pc1RhcmdldCxhZGRDbGFzczpmdW5jdGlvbiBhZGRDbGFzcyhjbGF6eil7X2VwLmFkZENsYXNzKGNsYXp6KTt9LHJlbW92ZUNsYXNzOmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGNsYXp6KXtfZXAucmVtb3ZlQ2xhc3MoY2xhenopO30saXNEcm9wQWxsb3dlZDpmdW5jdGlvbiBpc0Ryb3BBbGxvd2VkKCl7cmV0dXJuIF9lcC5pc0Ryb3BBbGxvd2VkLmFwcGx5KF9lcCxhcmd1bWVudHMpO30scmVmZXJlbmNlOnJlZmVyZW5jZUVuZHBvaW50LGlzUmVkcm9wOmZ1bmN0aW9uIGlzUmVkcm9wKGpwYyxkaFBhcmFtcyl7cmV0dXJuIGpwYy5zdXNwZW5kZWRFbmRwb2ludCYmZGhQYXJhbXMucmVmZXJlbmNlJiZqcGMuc3VzcGVuZGVkRW5kcG9pbnQuaWQ9PT1kaFBhcmFtcy5yZWZlcmVuY2UuaWQ7fX0pO2Ryb3BPcHRpb25zW2Ryb3BFdmVudF09X2p1LndyYXAoZHJvcE9wdGlvbnNbZHJvcEV2ZW50XSxkcm9wLHRydWUpO2Ryb3BPcHRpb25zW292ZXJFdmVudF09X2p1LndyYXAoZHJvcE9wdGlvbnNbb3ZlckV2ZW50XSxmdW5jdGlvbigpe3ZhciBkcmFnZ2FibGU9X2pwLmdldERyYWdPYmplY3QoYXJndW1lbnRzKSxpZD1fanNQbHVtYi5nZXRBdHRyaWJ1dGUoX2pwLmdldEVsZW1lbnQoZHJhZ2dhYmxlKSxcImRyYWdJZFwiKSxfanBjPV9qc1BsdW1iLmdldEZsb2F0aW5nQ29ubmVjdGlvbkZvcihpZCk7Ly9fanNQbHVtYi5mbG9hdGluZ0Nvbm5lY3Rpb25zW2lkXTtcbmlmKF9qcGMhPW51bGwpe3ZhciBpZHg9X2pzUGx1bWIuZ2V0RmxvYXRpbmdBbmNob3JJbmRleChfanBjKTsvLyBoZXJlIHdlIHNob3VsZCBmaXJlIHRoZSAnb3ZlcicgZXZlbnQgaWYgd2UgYXJlIGEgdGFyZ2V0IGFuZCB0aGlzIGlzIGEgbmV3IGNvbm5lY3Rpb24sXG4vLyBvciB3ZSBhcmUgdGhlIHNhbWUgYXMgdGhlIGZsb2F0aW5nIGVuZHBvaW50LlxudmFyIF9jb250PXRoaXMuaXNUYXJnZXQmJmlkeCE9PTB8fF9qcGMuc3VzcGVuZGVkRW5kcG9pbnQmJnRoaXMucmVmZXJlbmNlRW5kcG9pbnQmJnRoaXMucmVmZXJlbmNlRW5kcG9pbnQuaWQ9PT1fanBjLnN1c3BlbmRlZEVuZHBvaW50LmlkO2lmKF9jb250KXt2YXIgYmI9X2pzUGx1bWIuY2hlY2tDb25kaXRpb24oXCJjaGVja0Ryb3BBbGxvd2VkXCIse3NvdXJjZUVuZHBvaW50Ol9qcGMuZW5kcG9pbnRzW2lkeF0sdGFyZ2V0RW5kcG9pbnQ6dGhpcyxjb25uZWN0aW9uOl9qcGN9KTt0aGlzWyhiYj9cImFkZFwiOlwicmVtb3ZlXCIpK1wiQ2xhc3NcIl0oX2pzUGx1bWIuZW5kcG9pbnREcm9wQWxsb3dlZENsYXNzKTt0aGlzWyhiYj9cInJlbW92ZVwiOlwiYWRkXCIpK1wiQ2xhc3NcIl0oX2pzUGx1bWIuZW5kcG9pbnREcm9wRm9yYmlkZGVuQ2xhc3MpO19qcGMuZW5kcG9pbnRzW2lkeF0uYW5jaG9yLm92ZXIodGhpcy5hbmNob3IsdGhpcyk7fX19LmJpbmQodGhpcykpO2Ryb3BPcHRpb25zW291dEV2ZW50XT1fanUud3JhcChkcm9wT3B0aW9uc1tvdXRFdmVudF0sZnVuY3Rpb24oKXt2YXIgZHJhZ2dhYmxlPV9qcC5nZXREcmFnT2JqZWN0KGFyZ3VtZW50cyksaWQ9ZHJhZ2dhYmxlPT1udWxsP251bGw6X2pzUGx1bWIuZ2V0QXR0cmlidXRlKF9qcC5nZXRFbGVtZW50KGRyYWdnYWJsZSksXCJkcmFnSWRcIiksX2pwYz1pZD9fanNQbHVtYi5nZXRGbG9hdGluZ0Nvbm5lY3Rpb25Gb3IoaWQpOm51bGw7aWYoX2pwYyE9bnVsbCl7dmFyIGlkeD1fanNQbHVtYi5nZXRGbG9hdGluZ0FuY2hvckluZGV4KF9qcGMpO3ZhciBfY29udD10aGlzLmlzVGFyZ2V0JiZpZHghPT0wfHxfanBjLnN1c3BlbmRlZEVuZHBvaW50JiZ0aGlzLnJlZmVyZW5jZUVuZHBvaW50JiZ0aGlzLnJlZmVyZW5jZUVuZHBvaW50LmlkPT09X2pwYy5zdXNwZW5kZWRFbmRwb2ludC5pZDtpZihfY29udCl7dGhpcy5yZW1vdmVDbGFzcyhfanNQbHVtYi5lbmRwb2ludERyb3BBbGxvd2VkQ2xhc3MpO3RoaXMucmVtb3ZlQ2xhc3MoX2pzUGx1bWIuZW5kcG9pbnREcm9wRm9yYmlkZGVuQ2xhc3MpO19qcGMuZW5kcG9pbnRzW2lkeF0uYW5jaG9yLm91dCgpO319fS5iaW5kKHRoaXMpKTtfanNQbHVtYi5pbml0RHJvcHBhYmxlKGNhbnZhcyxkcm9wT3B0aW9ucyxcImludGVybmFsXCIsaXNUcmFuc2llbnQpO319LmJpbmQodGhpcyk7Ly8gSW5pdGlhbGlzZSB0aGUgZW5kcG9pbnQncyBjYW52YXMgYXMgYSBkcm9wIHRhcmdldC4gVGhlIGRyb3AgaGFuZGxlciB3aWxsIHRha2UgY2FyZSBvZiB0aGUgbG9naWMgb2Ygd2hldGhlclxuLy8gc29tZXRoaW5nIGNhbiBhY3R1YWxseSBiZSBkcm9wcGVkLlxuaWYoIXRoaXMuYW5jaG9yLmlzRmxvYXRpbmcpe19pbml0RHJvcFRhcmdldCh0aGlzLmNhbnZhcywhKHBhcmFtcy5fdHJhbnNpZW50fHx0aGlzLmFuY2hvci5pc0Zsb2F0aW5nKSx0aGlzLHBhcmFtcy5yZWZlcmVuY2UpO31yZXR1cm4gdGhpczt9O19qdS5leHRlbmQoX2pwLkVuZHBvaW50LF9qcC5PdmVybGF5Q2FwYWJsZUpzUGx1bWJVSUNvbXBvbmVudCx7c2V0VmlzaWJsZTpmdW5jdGlvbiBzZXRWaXNpYmxlKHYsZG9Ob3RDaGFuZ2VDb25uZWN0aW9ucyxkb05vdE5vdGlmeU90aGVyRW5kcG9pbnQpe3RoaXMuX2pzUGx1bWIudmlzaWJsZT12O2lmKHRoaXMuY2FudmFzKXt0aGlzLmNhbnZhcy5zdHlsZS5kaXNwbGF5PXY/XCJibG9ja1wiOlwibm9uZVwiO310aGlzW3Y/XCJzaG93T3ZlcmxheXNcIjpcImhpZGVPdmVybGF5c1wiXSgpO2lmKCFkb05vdENoYW5nZUNvbm5lY3Rpb25zKXtmb3IodmFyIGk9MDtpPHRoaXMuY29ubmVjdGlvbnMubGVuZ3RoO2krKyl7dGhpcy5jb25uZWN0aW9uc1tpXS5zZXRWaXNpYmxlKHYpO2lmKCFkb05vdE5vdGlmeU90aGVyRW5kcG9pbnQpe3ZhciBvSWR4PXRoaXM9PT10aGlzLmNvbm5lY3Rpb25zW2ldLmVuZHBvaW50c1swXT8xOjA7Ly8gb25seSBjaGFuZ2UgdGhlIG90aGVyIGVuZHBvaW50IGlmIHRoaXMgaXMgaXRzIG9ubHkgY29ubmVjdGlvbi5cbmlmKHRoaXMuY29ubmVjdGlvbnNbaV0uZW5kcG9pbnRzW29JZHhdLmNvbm5lY3Rpb25zLmxlbmd0aD09PTEpe3RoaXMuY29ubmVjdGlvbnNbaV0uZW5kcG9pbnRzW29JZHhdLnNldFZpc2libGUodix0cnVlLHRydWUpO319fX19LGdldEF0dGFjaGVkRWxlbWVudHM6ZnVuY3Rpb24gZ2V0QXR0YWNoZWRFbGVtZW50cygpe3JldHVybiB0aGlzLmNvbm5lY3Rpb25zO30sYXBwbHlUeXBlOmZ1bmN0aW9uIGFwcGx5VHlwZSh0LGRvTm90UmVwYWludCl7dGhpcy5zZXRQYWludFN0eWxlKHQuZW5kcG9pbnRTdHlsZXx8dC5wYWludFN0eWxlLGRvTm90UmVwYWludCk7dGhpcy5zZXRIb3ZlclBhaW50U3R5bGUodC5lbmRwb2ludEhvdmVyU3R5bGV8fHQuaG92ZXJQYWludFN0eWxlLGRvTm90UmVwYWludCk7aWYodC5tYXhDb25uZWN0aW9ucyE9bnVsbCl7dGhpcy5fanNQbHVtYi5tYXhDb25uZWN0aW9ucz10Lm1heENvbm5lY3Rpb25zO31pZih0LnNjb3BlKXt0aGlzLnNjb3BlPXQuc2NvcGU7fV9qcC5leHRlbmQodGhpcyx0LHR5cGVQYXJhbWV0ZXJzKTtpZih0LmNzc0NsYXNzIT1udWxsJiZ0aGlzLmNhbnZhcyl7dGhpcy5fanNQbHVtYi5pbnN0YW5jZS5hZGRDbGFzcyh0aGlzLmNhbnZhcyx0LmNzc0NsYXNzKTt9X2pwLk92ZXJsYXlDYXBhYmxlSnNQbHVtYlVJQ29tcG9uZW50LmFwcGx5VHlwZSh0aGlzLHQpO30saXNFbmFibGVkOmZ1bmN0aW9uIGlzRW5hYmxlZCgpe3JldHVybiB0aGlzLl9qc1BsdW1iLmVuYWJsZWQ7fSxzZXRFbmFibGVkOmZ1bmN0aW9uIHNldEVuYWJsZWQoZSl7dGhpcy5fanNQbHVtYi5lbmFibGVkPWU7fSxjbGVhbnVwOmZ1bmN0aW9uIGNsZWFudXAoKXt2YXIgYW5jaG9yQ2xhc3M9dGhpcy5fanNQbHVtYi5pbnN0YW5jZS5lbmRwb2ludEFuY2hvckNsYXNzUHJlZml4Kyh0aGlzLl9qc1BsdW1iLmN1cnJlbnRBbmNob3JDbGFzcz9cIi1cIit0aGlzLl9qc1BsdW1iLmN1cnJlbnRBbmNob3JDbGFzczpcIlwiKTtfanAucmVtb3ZlQ2xhc3ModGhpcy5lbGVtZW50LGFuY2hvckNsYXNzKTt0aGlzLmFuY2hvcj1udWxsO3RoaXMuZW5kcG9pbnQuY2xlYW51cCh0cnVlKTt0aGlzLmVuZHBvaW50LmRlc3Ryb3koKTt0aGlzLmVuZHBvaW50PW51bGw7Ly8gZHJhZy9kcm9wXG50aGlzLl9qc1BsdW1iLmluc3RhbmNlLmRlc3Ryb3lEcmFnZ2FibGUodGhpcy5jYW52YXMsXCJpbnRlcm5hbFwiKTt0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmRlc3Ryb3lEcm9wcGFibGUodGhpcy5jYW52YXMsXCJpbnRlcm5hbFwiKTt9LHNldEhvdmVyOmZ1bmN0aW9uIHNldEhvdmVyKGgpe2lmKHRoaXMuZW5kcG9pbnQmJnRoaXMuX2pzUGx1bWImJiF0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmlzQ29ubmVjdGlvbkJlaW5nRHJhZ2dlZCgpKXt0aGlzLmVuZHBvaW50LnNldEhvdmVyKGgpO319LGlzRnVsbDpmdW5jdGlvbiBpc0Z1bGwoKXtyZXR1cm4gdGhpcy5fanNQbHVtYi5tYXhDb25uZWN0aW9ucz09PTA/dHJ1ZTohKHRoaXMuaXNGbG9hdGluZygpfHx0aGlzLl9qc1BsdW1iLm1heENvbm5lY3Rpb25zPDB8fHRoaXMuY29ubmVjdGlvbnMubGVuZ3RoPHRoaXMuX2pzUGx1bWIubWF4Q29ubmVjdGlvbnMpO30sLyoqXHJcbiAgICAgICAgICogcHJpdmF0ZSBidXQgbmVlZHMgdG8gYmUgZXhwb3NlZC5cclxuICAgICAgICAgKi9pc0Zsb2F0aW5nOmZ1bmN0aW9uIGlzRmxvYXRpbmcoKXtyZXR1cm4gdGhpcy5hbmNob3IhPW51bGwmJnRoaXMuYW5jaG9yLmlzRmxvYXRpbmc7fSxpc0Nvbm5lY3RlZFRvOmZ1bmN0aW9uIGlzQ29ubmVjdGVkVG8oZW5kcG9pbnQpe3ZhciBmb3VuZD1mYWxzZTtpZihlbmRwb2ludCl7Zm9yKHZhciBpPTA7aTx0aGlzLmNvbm5lY3Rpb25zLmxlbmd0aDtpKyspe2lmKHRoaXMuY29ubmVjdGlvbnNbaV0uZW5kcG9pbnRzWzFdPT09ZW5kcG9pbnR8fHRoaXMuY29ubmVjdGlvbnNbaV0uZW5kcG9pbnRzWzBdPT09ZW5kcG9pbnQpe2ZvdW5kPXRydWU7YnJlYWs7fX19cmV0dXJuIGZvdW5kO30sZ2V0Q29ubmVjdGlvbkNvc3Q6ZnVuY3Rpb24gZ2V0Q29ubmVjdGlvbkNvc3QoKXtyZXR1cm4gdGhpcy5fanNQbHVtYi5jb25uZWN0aW9uQ29zdDt9LHNldENvbm5lY3Rpb25Db3N0OmZ1bmN0aW9uIHNldENvbm5lY3Rpb25Db3N0KGMpe3RoaXMuX2pzUGx1bWIuY29ubmVjdGlvbkNvc3Q9Yzt9LGFyZUNvbm5lY3Rpb25zRGlyZWN0ZWQ6ZnVuY3Rpb24gYXJlQ29ubmVjdGlvbnNEaXJlY3RlZCgpe3JldHVybiB0aGlzLl9qc1BsdW1iLmNvbm5lY3Rpb25zRGlyZWN0ZWQ7fSxzZXRDb25uZWN0aW9uc0RpcmVjdGVkOmZ1bmN0aW9uIHNldENvbm5lY3Rpb25zRGlyZWN0ZWQoYil7dGhpcy5fanNQbHVtYi5jb25uZWN0aW9uc0RpcmVjdGVkPWI7fSxzZXRFbGVtZW50SWQ6ZnVuY3Rpb24gc2V0RWxlbWVudElkKF9lbElkKXt0aGlzLmVsZW1lbnRJZD1fZWxJZDt0aGlzLmFuY2hvci5lbGVtZW50SWQ9X2VsSWQ7fSxzZXRSZWZlcmVuY2VFbGVtZW50OmZ1bmN0aW9uIHNldFJlZmVyZW5jZUVsZW1lbnQoX2VsKXt0aGlzLmVsZW1lbnQ9X2pwLmdldEVsZW1lbnQoX2VsKTt9LHNldERyYWdBbGxvd2VkV2hlbkZ1bGw6ZnVuY3Rpb24gc2V0RHJhZ0FsbG93ZWRXaGVuRnVsbChhbGxvd2VkKXt0aGlzLmRyYWdBbGxvd2VkV2hlbkZ1bGw9YWxsb3dlZDt9LGVxdWFsczpmdW5jdGlvbiBlcXVhbHMoZW5kcG9pbnQpe3JldHVybiB0aGlzLmFuY2hvci5lcXVhbHMoZW5kcG9pbnQuYW5jaG9yKTt9LGdldFV1aWQ6ZnVuY3Rpb24gZ2V0VXVpZCgpe3JldHVybiB0aGlzLl9qc1BsdW1iLnV1aWQ7fSxjb21wdXRlQW5jaG9yOmZ1bmN0aW9uIGNvbXB1dGVBbmNob3IocGFyYW1zKXtyZXR1cm4gdGhpcy5hbmNob3IuY29tcHV0ZShwYXJhbXMpO319KTtyb290LmpzUGx1bWJJbnN0YW5jZS5wcm90b3R5cGUuRW5kcG9pbnREcm9wSGFuZGxlcj1mdW5jdGlvbihkaFBhcmFtcyl7cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciBfanNQbHVtYj1kaFBhcmFtcy5qc1BsdW1iOy8vIHJlbW92ZSB0aGUgY2xhc3NlcyB0aGF0IGFyZSBhZGRlZCBkeW5hbWljYWxseS4gZHJvcCBpcyBuZWl0aGVyIGZvcmJpZGRlbiBub3IgYWxsb3dlZCBub3cgdGhhdFxuLy8gdGhlIGRyb3AgaXMgZmluaXNoaW5nLlxuZGhQYXJhbXMucmVtb3ZlQ2xhc3MoX2pzUGx1bWIuZW5kcG9pbnREcm9wQWxsb3dlZENsYXNzKTtkaFBhcmFtcy5yZW1vdmVDbGFzcyhfanNQbHVtYi5lbmRwb2ludERyb3BGb3JiaWRkZW5DbGFzcyk7dmFyIG9yaWdpbmFsRXZlbnQ9X2pzUGx1bWIuZ2V0RHJvcEV2ZW50KGFyZ3VtZW50cyksZHJhZ2dhYmxlPV9qc1BsdW1iLmdldERyYWdPYmplY3QoYXJndW1lbnRzKSxpZD1fanNQbHVtYi5nZXRBdHRyaWJ1dGUoZHJhZ2dhYmxlLFwiZHJhZ0lkXCIpLGVsSWQ9X2pzUGx1bWIuZ2V0QXR0cmlidXRlKGRyYWdnYWJsZSxcImVsSWRcIiksc2NvcGU9X2pzUGx1bWIuZ2V0QXR0cmlidXRlKGRyYWdnYWJsZSxcIm9yaWdpbmFsU2NvcGVcIiksanBjPV9qc1BsdW1iLmdldEZsb2F0aW5nQ29ubmVjdGlvbkZvcihpZCk7Ly8gaWYgbm8gYWN0aXZlIGNvbm5lY3Rpb24sIGJhaWwuXG5pZihqcGM9PW51bGwpe3JldHVybjt9Ly8gY2FsY3VsYXRlIGlmIHRoaXMgaXMgYW4gZXhpc3RpbmcgY29ubmVjdGlvbi5cbnZhciBleGlzdGluZ0Nvbm5lY3Rpb249anBjLnN1c3BlbmRlZEVuZHBvaW50IT1udWxsOy8vIGlmIHN1c3BlbmRlZCBlbmRwb2ludCBleGlzdHMgYnV0IGhhcyBiZWVuIGNsZWFuZWQgdXAsIGJhaWwuIFRoaXMgbWVhbnMgaXQncyBhbiBleGlzdGluZyBjb25uZWN0aW9uXG4vLyB0aGF0IGhhcyBiZWVuIGRldGFjaGVkIGFuZCB3aWxsIHNob3J0bHkgYmUgZGlzY2FyZGVkLlxuaWYoZXhpc3RpbmdDb25uZWN0aW9uJiZqcGMuc3VzcGVuZGVkRW5kcG9pbnQuX2pzUGx1bWI9PW51bGwpe3JldHVybjt9Ly8gZ2V0IHRoZSBkcm9wIGVuZHBvaW50LiBmb3IgYSBub3JtYWwgY29ubmVjdGlvbiB0aGlzIGlzIGp1c3QgdGhlIG9uZSB0aGF0IHdvdWxkIHJlcGxhY2UgdGhlIGN1cnJlbnRseVxuLy8gZmxvYXRpbmcgZW5kcG9pbnQuIGZvciBhIG1ha2VUYXJnZXQgdGhpcyBpcyBhIG5ldyBlbmRwb2ludCB0aGF0IGlzIGNyZWF0ZWQgb24gZHJvcC4gQnV0IHdlIGxlYXZlIHRoYXQgdG9cbi8vIHRoZSBoYW5kbGVyIHRvIGZpZ3VyZSBvdXQuXG52YXIgX2VwPWRoUGFyYW1zLmdldEVuZHBvaW50KGpwYyk7Ly8gSWYgd2UncmUgbm90IGdpdmVuIGFuIGVuZHBvaW50IHRvIHVzZSwgYmFpbC5cbmlmKF9lcD09bnVsbCl7cmV0dXJuO30vLyBpZiB0aGlzIGlzIGEgZHJvcCBiYWNrIHdoZXJlIHRoZSBjb25uZWN0aW9uIGNhbWUgZnJvbSwgbWFyayBpdCBmb3JjZSByZWF0dGFjaCBhbmRcbi8vIHJldHVybjsgdGhlIHN0b3AgaGFuZGxlciB3aWxsIHJlYXR0YWNoLiB3aXRob3V0IGZpcmluZyBhbiBldmVudC5cbmlmKGRoUGFyYW1zLmlzUmVkcm9wKGpwYyxkaFBhcmFtcykpe2pwYy5fZm9yY2VSZWF0dGFjaD10cnVlO2pwYy5zZXRIb3ZlcihmYWxzZSk7aWYoZGhQYXJhbXMubWF5YmVDbGVhbnVwKXtkaFBhcmFtcy5tYXliZUNsZWFudXAoX2VwKTt9cmV0dXJuO30vLyBlbnN1cmUgd2UgZG9udCBib3RoZXIgdHJ5aW5nIHRvIGRyb3Agc291cmNlcyBvbiBub24tc291cmNlIGVwcywgYW5kIHNhbWUgZm9yIHRhcmdldC5cbnZhciBpZHg9X2pzUGx1bWIuZ2V0RmxvYXRpbmdBbmNob3JJbmRleChqcGMpO2lmKGlkeD09PTAmJiFkaFBhcmFtcy5pc1NvdXJjZXx8aWR4PT09MSYmIWRoUGFyYW1zLmlzVGFyZ2V0KXtpZihkaFBhcmFtcy5tYXliZUNsZWFudXApe2RoUGFyYW1zLm1heWJlQ2xlYW51cChfZXApO31yZXR1cm47fWlmKGRoUGFyYW1zLm9uRHJvcCl7ZGhQYXJhbXMub25Ecm9wKGpwYyk7fS8vIHJlc3RvcmUgdGhlIG9yaWdpbmFsIHNjb3BlIGlmIG5lY2Vzc2FyeSAoaXNzdWUgNTcpXG5pZihzY29wZSl7X2pzUGx1bWIuc2V0RHJhZ1Njb3BlKGRyYWdnYWJsZSxzY29wZSk7fS8vIGlmIHRoZSB0YXJnZXQgb2YgdGhlIGRyb3AgaXMgZnVsbCwgZmlyZSBhbiBldmVudCAod2UgYWJvcnQgYmVsb3cpXG4vLyBtYWtlVGFyZ2V0OiBrZWVwLlxudmFyIGlzRnVsbD1kaFBhcmFtcy5pc0Z1bGwoZSk7aWYoaXNGdWxsKXtfZXAuZmlyZShcIm1heENvbm5lY3Rpb25zXCIse2VuZHBvaW50OnRoaXMsY29ubmVjdGlvbjpqcGMsbWF4Q29ubmVjdGlvbnM6X2VwLl9qc1BsdW1iLm1heENvbm5lY3Rpb25zfSxvcmlnaW5hbEV2ZW50KTt9Ly9cbi8vIGlmIGVuZHBvaW50IGVuYWJsZWQsIG5vdCBmdWxsLCBhbmQgbWF0Y2hlcyB0aGUgaW5kZXggb2YgdGhlIGZsb2F0aW5nIGVuZHBvaW50Li4uXG5pZighaXNGdWxsJiZkaFBhcmFtcy5lbmFibGVkKCkpe3ZhciBfZG9Db250aW51ZT10cnVlOy8vIGJlZm9yZSB0ZXN0aW5nIGZvciBiZWZvcmVEcm9wLCByZXNldCB0aGUgY29ubmVjdGlvbidzIHNvdXJjZS90YXJnZXQgdG8gYmUgdGhlIGFjdHVhbCBET00gZWxlbWVudHNcbi8vIGludm9sdmVkICh0aGF0IGlzLCBzdGFzaCBhbnkgdGVtcG9yYXJ5IHN0dWZmIHVzZWQgZm9yIGRyYWdnaW5nLiBidXQgd2UgbmVlZCB0byBrZWVwIGl0IGFyb3VuZCBpblxuLy8gb3JkZXIgdGhhdCB0aGUgYW5jaG9yIG1hbmFnZXIgY2FuIGNsZWFuIHRoaW5ncyB1cCBwcm9wZXJseSkuXG5pZihpZHg9PT0wKXtqcGMuZmxvYXRpbmdFbGVtZW50PWpwYy5zb3VyY2U7anBjLmZsb2F0aW5nSWQ9anBjLnNvdXJjZUlkO2pwYy5mbG9hdGluZ0VuZHBvaW50PWpwYy5lbmRwb2ludHNbMF07anBjLmZsb2F0aW5nSW5kZXg9MDtqcGMuc291cmNlPWRoUGFyYW1zLmVsZW1lbnQ7anBjLnNvdXJjZUlkPWRoUGFyYW1zLmVsZW1lbnRJZDt9ZWxzZXtqcGMuZmxvYXRpbmdFbGVtZW50PWpwYy50YXJnZXQ7anBjLmZsb2F0aW5nSWQ9anBjLnRhcmdldElkO2pwYy5mbG9hdGluZ0VuZHBvaW50PWpwYy5lbmRwb2ludHNbMV07anBjLmZsb2F0aW5nSW5kZXg9MTtqcGMudGFyZ2V0PWRoUGFyYW1zLmVsZW1lbnQ7anBjLnRhcmdldElkPWRoUGFyYW1zLmVsZW1lbnRJZDt9Ly8gaWYgdGhpcyBpcyBhbiBleGlzdGluZyBjb25uZWN0aW9uIGFuZCBkZXRhY2ggaXMgbm90IGFsbG93ZWQgd2Ugd29uJ3QgY29udGludWUuIFRoZSBjb25uZWN0aW9uJ3Ncbi8vIGVuZHBvaW50cyBoYXZlIGJlZW4gcmVpbnN0YXRlZDsgZXZlcnl0aGluZyBpcyBiYWNrIHRvIGhvdyBpdCB3YXMuXG5pZihleGlzdGluZ0Nvbm5lY3Rpb24mJmpwYy5zdXNwZW5kZWRFbmRwb2ludC5pZCE9PV9lcC5pZCl7aWYoIWpwYy5pc0RldGFjaEFsbG93ZWQoanBjKXx8IWpwYy5lbmRwb2ludHNbaWR4XS5pc0RldGFjaEFsbG93ZWQoanBjKXx8IWpwYy5zdXNwZW5kZWRFbmRwb2ludC5pc0RldGFjaEFsbG93ZWQoanBjKXx8IV9qc1BsdW1iLmNoZWNrQ29uZGl0aW9uKFwiYmVmb3JlRGV0YWNoXCIsanBjKSl7X2RvQ29udGludWU9ZmFsc2U7fX0vLyAtLS0tLS0tLS0tLS0gd3JhcCB0aGUgZXhlY3V0aW9uIHBhdGggaW4gYSBmdW5jdGlvbiBzbyB3ZSBjYW4gc3VwcG9ydCBhc3luY2hyb25vdXMgYmVmb3JlRHJvcFxudmFyIGNvbnRpbnVlRnVuY3Rpb249ZnVuY3Rpb24ob3B0aW9uYWxEYXRhKXsvLyByZW1vdmUgdGhpcyBqcGMgZnJvbSB0aGUgY3VycmVudCBlbmRwb2ludCwgd2hpY2ggaXMgYSBmbG9hdGluZyBlbmRwb2ludCB0aGF0IHdlIHdpbGxcbi8vIHN1YnNlcXVlbnRseSBkaXNjYXJkLlxuanBjLmVuZHBvaW50c1tpZHhdLmRldGFjaEZyb21Db25uZWN0aW9uKGpwYyk7Ly8gaWYgdGhlcmUncyBhIHN1c3BlbmRlZCBlbmRwb2ludCwgZGV0YWNoIGl0IGZyb20gdGhlIGNvbm5lY3Rpb24uXG5pZihqcGMuc3VzcGVuZGVkRW5kcG9pbnQpe2pwYy5zdXNwZW5kZWRFbmRwb2ludC5kZXRhY2hGcm9tQ29ubmVjdGlvbihqcGMpO31qcGMuZW5kcG9pbnRzW2lkeF09X2VwO19lcC5hZGRDb25uZWN0aW9uKGpwYyk7Ly8gY29weSBvdXIgcGFyYW1ldGVycyBpbiB0byB0aGUgY29ubmVjdGlvbjpcbnZhciBwYXJhbXM9X2VwLmdldFBhcmFtZXRlcnMoKTtmb3IodmFyIGFQYXJhbSBpbiBwYXJhbXMpe2pwYy5zZXRQYXJhbWV0ZXIoYVBhcmFtLHBhcmFtc1thUGFyYW1dKTt9aWYoIWV4aXN0aW5nQ29ubmVjdGlvbil7Ly8gaWYgbm90IGFuIGV4aXN0aW5nIGNvbm5lY3Rpb24gYW5kXG5pZihwYXJhbXMuZHJhZ2dhYmxlKXtfanNQbHVtYi5pbml0RHJhZ2dhYmxlKHRoaXMuZWxlbWVudCxkaFBhcmFtcy5kcmFnT3B0aW9ucyxcImludGVybmFsXCIsX2pzUGx1bWIpO319ZWxzZXt2YXIgc3VzcGVuZGVkRWxlbWVudElkPWpwYy5zdXNwZW5kZWRFbmRwb2ludC5lbGVtZW50SWQ7X2pzUGx1bWIuZmlyZU1vdmVFdmVudCh7aW5kZXg6aWR4LG9yaWdpbmFsU291cmNlSWQ6aWR4PT09MD9zdXNwZW5kZWRFbGVtZW50SWQ6anBjLnNvdXJjZUlkLG5ld1NvdXJjZUlkOmlkeD09PTA/X2VwLmVsZW1lbnRJZDpqcGMuc291cmNlSWQsb3JpZ2luYWxUYXJnZXRJZDppZHg9PT0xP3N1c3BlbmRlZEVsZW1lbnRJZDpqcGMudGFyZ2V0SWQsbmV3VGFyZ2V0SWQ6aWR4PT09MT9fZXAuZWxlbWVudElkOmpwYy50YXJnZXRJZCxvcmlnaW5hbFNvdXJjZUVuZHBvaW50OmlkeD09PTA/anBjLnN1c3BlbmRlZEVuZHBvaW50OmpwYy5lbmRwb2ludHNbMF0sbmV3U291cmNlRW5kcG9pbnQ6aWR4PT09MD9fZXA6anBjLmVuZHBvaW50c1swXSxvcmlnaW5hbFRhcmdldEVuZHBvaW50OmlkeD09PTE/anBjLnN1c3BlbmRlZEVuZHBvaW50OmpwYy5lbmRwb2ludHNbMV0sbmV3VGFyZ2V0RW5kcG9pbnQ6aWR4PT09MT9fZXA6anBjLmVuZHBvaW50c1sxXSxjb25uZWN0aW9uOmpwY30sb3JpZ2luYWxFdmVudCk7fWlmKGlkeD09PTEpe19qc1BsdW1iLmFuY2hvck1hbmFnZXIudXBkYXRlT3RoZXJFbmRwb2ludChqcGMuc291cmNlSWQsanBjLmZsb2F0aW5nSWQsanBjLnRhcmdldElkLGpwYyk7fWVsc2V7X2pzUGx1bWIuYW5jaG9yTWFuYWdlci5zb3VyY2VDaGFuZ2VkKGpwYy5mbG9hdGluZ0lkLGpwYy5zb3VyY2VJZCxqcGMsanBjLnNvdXJjZSk7fS8vIHdoZW4gbWFrZVNvdXJjZSBoYXMgdW5pcXVlRW5kcG9pbnQ6dHJ1ZSwgd2Ugd2FudCB0byBjcmVhdGUgY29ubmVjdGlvbnMgd2l0aCBuZXcgZW5kcG9pbnRzXG4vLyB0aGF0IGFyZSBzdWJzZXF1ZW50bHkgZGVsZXRlZC4gU28gbWFrZVNvdXJjZSBzZXRzIGBmaW5hbEVuZHBvaW50YCwgd2hpY2ggaXMgdGhlIEVuZHBvaW50IHRvXG4vLyB3aGljaCB0aGUgY29ubmVjdGlvbiBzaG91bGQgYmUgYXR0YWNoZWQuIFRoZSBgZGV0YWNoRnJvbUNvbm5lY3Rpb25gIGNhbGwgYmVsb3cgcmVzdWx0cyBpbiB0aGVcbi8vIHRlbXBvcmFyeSBlbmRwb2ludCBiZWluZyBjbGVhbmVkIHVwLlxuaWYoanBjLmVuZHBvaW50c1swXS5maW5hbEVuZHBvaW50KXt2YXIgX3RvRGVsZXRlPWpwYy5lbmRwb2ludHNbMF07X3RvRGVsZXRlLmRldGFjaEZyb21Db25uZWN0aW9uKGpwYyk7anBjLmVuZHBvaW50c1swXT1qcGMuZW5kcG9pbnRzWzBdLmZpbmFsRW5kcG9pbnQ7anBjLmVuZHBvaW50c1swXS5hZGRDb25uZWN0aW9uKGpwYyk7fS8vIGlmIG9wdGlvbmFsRGF0YSB3YXMgZ2l2ZW4sIG1lcmdlIGl0IG9udG8gdGhlIGNvbm5lY3Rpb24ncyBkYXRhLlxuaWYoX2p1LmlzT2JqZWN0KG9wdGlvbmFsRGF0YSkpe2pwYy5tZXJnZURhdGEob3B0aW9uYWxEYXRhKTt9Ly8gZmluYWxpc2Ugd2lsbCBpbmZvcm0gdGhlIGFuY2hvciBtYW5hZ2VyIGFuZCBhbHNvIGFkZCB0b1xuLy8gY29ubmVjdGlvbnNCeVNjb3BlIGlmIG5lY2Vzc2FyeS5cbl9qc1BsdW1iLmZpbmFsaXNlQ29ubmVjdGlvbihqcGMsbnVsbCxvcmlnaW5hbEV2ZW50LGZhbHNlKTtqcGMuc2V0SG92ZXIoZmFsc2UpO30uYmluZCh0aGlzKTt2YXIgZG9udENvbnRpbnVlRnVuY3Rpb249ZnVuY3Rpb24gZG9udENvbnRpbnVlRnVuY3Rpb24oKXsvLyBvdGhlcndpc2UganVzdCBwdXQgaXQgYmFjayBvbiB0aGUgZW5kcG9pbnQgaXQgd2FzIG9uIGJlZm9yZSB0aGUgZHJhZy5cbmlmKGpwYy5zdXNwZW5kZWRFbmRwb2ludCl7anBjLmVuZHBvaW50c1tpZHhdPWpwYy5zdXNwZW5kZWRFbmRwb2ludDtqcGMuc2V0SG92ZXIoZmFsc2UpO2pwYy5fZm9yY2VEZXRhY2g9dHJ1ZTtpZihpZHg9PT0wKXtqcGMuc291cmNlPWpwYy5zdXNwZW5kZWRFbmRwb2ludC5lbGVtZW50O2pwYy5zb3VyY2VJZD1qcGMuc3VzcGVuZGVkRW5kcG9pbnQuZWxlbWVudElkO31lbHNle2pwYy50YXJnZXQ9anBjLnN1c3BlbmRlZEVuZHBvaW50LmVsZW1lbnQ7anBjLnRhcmdldElkPWpwYy5zdXNwZW5kZWRFbmRwb2ludC5lbGVtZW50SWQ7fWpwYy5zdXNwZW5kZWRFbmRwb2ludC5hZGRDb25uZWN0aW9uKGpwYyk7Ly8gVE9ETyBjaGVja1Nhbml0eVxuaWYoaWR4PT09MSl7X2pzUGx1bWIuYW5jaG9yTWFuYWdlci51cGRhdGVPdGhlckVuZHBvaW50KGpwYy5zb3VyY2VJZCxqcGMuZmxvYXRpbmdJZCxqcGMudGFyZ2V0SWQsanBjKTt9ZWxzZXtfanNQbHVtYi5hbmNob3JNYW5hZ2VyLnNvdXJjZUNoYW5nZWQoanBjLmZsb2F0aW5nSWQsanBjLnNvdXJjZUlkLGpwYyxqcGMuc291cmNlKTt9X2pzUGx1bWIucmVwYWludChqcGMuc291cmNlSWQpO2pwYy5fZm9yY2VEZXRhY2g9ZmFsc2U7fX07Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIG5vdyBjaGVjayBiZWZvcmVEcm9wLiAgdGhpcyB3aWxsIGJlIGF2YWlsYWJsZSBvbmx5IG9uIEVuZHBvaW50cyB0aGF0IGFyZSBzZXR1cCB0b1xuLy8gaGF2ZSBhIGJlZm9yZURyb3AgY29uZGl0aW9uIChhbHRob3VnaCwgc2VjcmV0bHksIHVuZGVyIHRoZSBob29kIGFsbCBFbmRwb2ludHMgYW5kXG4vLyB0aGUgQ29ubmVjdGlvbiBoYXZlIHRoZW0sIGJlY2F1c2UgdGhleSBhcmUgb24ganNQbHVtYlVJQ29tcG9uZW50LiAgc2hoaCEpLCBiZWNhdXNlXG4vLyBpdCBvbmx5IG1ha2VzIHNlbnNlIHRvIGhhdmUgaXQgb24gYSB0YXJnZXQgZW5kcG9pbnQuXG5fZG9Db250aW51ZT1fZG9Db250aW51ZSYmZGhQYXJhbXMuaXNEcm9wQWxsb3dlZChqcGMuc291cmNlSWQsanBjLnRhcmdldElkLGpwYy5zY29wZSxqcGMsX2VwKTsvLyAmJiBqcGMucGVuZGluZztcbmlmKF9kb0NvbnRpbnVlKXtjb250aW51ZUZ1bmN0aW9uKF9kb0NvbnRpbnVlKTtyZXR1cm4gdHJ1ZTt9ZWxzZXtkb250Q29udGludWVGdW5jdGlvbigpO319aWYoZGhQYXJhbXMubWF5YmVDbGVhbnVwKXtkaFBhcmFtcy5tYXliZUNsZWFudXAoX2VwKTt9X2pzUGx1bWIuY3VycmVudGx5RHJhZ2dpbmc9ZmFsc2U7fTt9O30pLmNhbGwodHlwZW9mIHdpbmRvdyE9PSd1bmRlZmluZWQnP3dpbmRvdzp0aGlzKTsvKlxyXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdGhlIGNvZGUgZm9yIENvbm5lY3Rpb25zLlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgLSAyMDE4IGpzUGx1bWIgKGhlbGxvQGpzcGx1bWJ0b29sa2l0LmNvbSlcclxuICpcclxuICogaHR0cHM6Ly9qc3BsdW1idG9vbGtpdC5jb21cclxuICogaHR0cHM6Ly9naXRodWIuY29tL2pzcGx1bWIvanNwbHVtYlxyXG4gKlxyXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgYW5kIEdQTDIgbGljZW5zZXMuXHJcbiAqLzsoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgcm9vdD10aGlzLF9qcD1yb290LmpzUGx1bWIsX2p1PXJvb3QuanNQbHVtYlV0aWw7dmFyIG1ha2VDb25uZWN0b3I9ZnVuY3Rpb24gbWFrZUNvbm5lY3RvcihfanNQbHVtYixyZW5kZXJNb2RlLGNvbm5lY3Rvck5hbWUsY29ubmVjdG9yQXJncyxmb3JDb21wb25lbnQpe2lmKCFfanNQbHVtYi5EZWZhdWx0cy5Eb05vdFRocm93RXJyb3JzJiZfanAuQ29ubmVjdG9yc1tyZW5kZXJNb2RlXVtjb25uZWN0b3JOYW1lXT09bnVsbCl7dGhyb3d7bXNnOlwianNQbHVtYjogdW5rbm93biBjb25uZWN0b3IgdHlwZSAnXCIrY29ubmVjdG9yTmFtZStcIidcIn07fXJldHVybiBuZXcgX2pwLkNvbm5lY3RvcnNbcmVuZGVyTW9kZV1bY29ubmVjdG9yTmFtZV0oY29ubmVjdG9yQXJncyxmb3JDb21wb25lbnQpO30sX21ha2VBbmNob3I9ZnVuY3Rpb24gX21ha2VBbmNob3IoYW5jaG9yUGFyYW1zLGVsZW1lbnRJZCxfanNQbHVtYil7cmV0dXJuIGFuY2hvclBhcmFtcz9fanNQbHVtYi5tYWtlQW5jaG9yKGFuY2hvclBhcmFtcyxlbGVtZW50SWQsX2pzUGx1bWIpOm51bGw7fSxfdXBkYXRlQ29ubmVjdGVkQ2xhc3M9ZnVuY3Rpb24gX3VwZGF0ZUNvbm5lY3RlZENsYXNzKGNvbm4sZWxlbWVudCxfanNQbHVtYixyZW1vdmUpe2lmKGVsZW1lbnQhPW51bGwpe2VsZW1lbnQuX2pzUGx1bWJDb25uZWN0aW9ucz1lbGVtZW50Ll9qc1BsdW1iQ29ubmVjdGlvbnN8fHt9O2lmKHJlbW92ZSl7ZGVsZXRlIGVsZW1lbnQuX2pzUGx1bWJDb25uZWN0aW9uc1tjb25uLmlkXTt9ZWxzZXtlbGVtZW50Ll9qc1BsdW1iQ29ubmVjdGlvbnNbY29ubi5pZF09dHJ1ZTt9aWYoX2p1LmlzRW1wdHkoZWxlbWVudC5fanNQbHVtYkNvbm5lY3Rpb25zKSl7X2pzUGx1bWIucmVtb3ZlQ2xhc3MoZWxlbWVudCxfanNQbHVtYi5jb25uZWN0ZWRDbGFzcyk7fWVsc2V7X2pzUGx1bWIuYWRkQ2xhc3MoZWxlbWVudCxfanNQbHVtYi5jb25uZWN0ZWRDbGFzcyk7fX19O19qcC5Db25uZWN0aW9uPWZ1bmN0aW9uKHBhcmFtcyl7dmFyIF9uZXdFbmRwb2ludD1wYXJhbXMubmV3RW5kcG9pbnQ7dGhpcy5pZD1wYXJhbXMuaWQ7dGhpcy5jb25uZWN0b3I9bnVsbDt0aGlzLmlkUHJlZml4PVwiX2pzcGx1bWJfY19cIjt0aGlzLmRlZmF1bHRMYWJlbExvY2F0aW9uPTAuNTt0aGlzLmRlZmF1bHRPdmVybGF5S2V5cz1bXCJPdmVybGF5c1wiLFwiQ29ubmVjdGlvbk92ZXJsYXlzXCJdOy8vIGlmIGEgbmV3IGNvbm5lY3Rpb24gaXMgdGhlIHJlc3VsdCBvZiBtb3Zpbmcgc29tZSBleGlzdGluZyBjb25uZWN0aW9uLCBwYXJhbXMucHJldmlvdXNDb25uZWN0aW9uXG4vLyB3aWxsIGhhdmUgdGhhdCBDb25uZWN0aW9uIGluIGl0LiBsaXN0ZW5lcnMgZm9yIHRoZSBqc1BsdW1iQ29ubmVjdGlvbiBldmVudCBjYW4gbG9vayBmb3IgdGhhdFxuLy8gbWVtYmVyIGFuZCB0YWtlIGFjdGlvbiBpZiB0aGV5IG5lZWQgdG8uXG50aGlzLnByZXZpb3VzQ29ubmVjdGlvbj1wYXJhbXMucHJldmlvdXNDb25uZWN0aW9uO3RoaXMuc291cmNlPV9qcC5nZXRFbGVtZW50KHBhcmFtcy5zb3VyY2UpO3RoaXMudGFyZ2V0PV9qcC5nZXRFbGVtZW50KHBhcmFtcy50YXJnZXQpO19qcC5PdmVybGF5Q2FwYWJsZUpzUGx1bWJVSUNvbXBvbmVudC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7Ly8gc291cmNlRW5kcG9pbnQgYW5kIHRhcmdldEVuZHBvaW50IG92ZXJyaWRlIHNvdXJjZS90YXJnZXQsIGlmIHRoZXkgYXJlIHByZXNlbnQuIGJ1dCBcbi8vIHNvdXJjZSBpcyBub3Qgb3ZlcnJpZGRlbiBpZiB0aGUgRW5kcG9pbnQgaGFzIGRlY2xhcmVkIGl0IGlzIG5vdCB0aGUgZmluYWwgdGFyZ2V0IG9mIGEgY29ubmVjdGlvbjtcbi8vIGluc3RlYWQgd2UgdXNlIHRoZSBzb3VyY2UgdGhhdCB0aGUgRW5kcG9pbnQgZGVjbGFyZXMgd2lsbCBiZSB0aGUgZmluYWwgc291cmNlIGVsZW1lbnQuXG5pZihwYXJhbXMuc291cmNlRW5kcG9pbnQpe3RoaXMuc291cmNlPXBhcmFtcy5zb3VyY2VFbmRwb2ludC5nZXRFbGVtZW50KCk7dGhpcy5zb3VyY2VJZD1wYXJhbXMuc291cmNlRW5kcG9pbnQuZWxlbWVudElkO31lbHNle3RoaXMuc291cmNlSWQ9dGhpcy5fanNQbHVtYi5pbnN0YW5jZS5nZXRJZCh0aGlzLnNvdXJjZSk7fWlmKHBhcmFtcy50YXJnZXRFbmRwb2ludCl7dGhpcy50YXJnZXQ9cGFyYW1zLnRhcmdldEVuZHBvaW50LmdldEVsZW1lbnQoKTt0aGlzLnRhcmdldElkPXBhcmFtcy50YXJnZXRFbmRwb2ludC5lbGVtZW50SWQ7fWVsc2V7dGhpcy50YXJnZXRJZD10aGlzLl9qc1BsdW1iLmluc3RhbmNlLmdldElkKHRoaXMudGFyZ2V0KTt9dGhpcy5zY29wZT1wYXJhbXMuc2NvcGU7Ly8gc2NvcGUgbWF5IGhhdmUgYmVlbiBwYXNzZWQgaW4gdG8gdGhlIGNvbm5lY3QgY2FsbC4gaWYgaXQgd2Fzbid0LCB3ZSB3aWxsIHB1bGwgaXQgZnJvbSB0aGUgc291cmNlIGVuZHBvaW50LCBhZnRlciBoYXZpbmcgaW5pdGlhbGlzZWQgdGhlIGVuZHBvaW50cy4gICAgICAgICAgICBcbnRoaXMuZW5kcG9pbnRzPVtdO3RoaXMuZW5kcG9pbnRTdHlsZXM9W107dmFyIF9qc1BsdW1iPXRoaXMuX2pzUGx1bWIuaW5zdGFuY2U7X2pzUGx1bWIubWFuYWdlKHRoaXMuc291cmNlSWQsdGhpcy5zb3VyY2UpO19qc1BsdW1iLm1hbmFnZSh0aGlzLnRhcmdldElkLHRoaXMudGFyZ2V0KTt0aGlzLl9qc1BsdW1iLnZpc2libGU9dHJ1ZTt0aGlzLl9qc1BsdW1iLnBhcmFtcz17Y3NzQ2xhc3M6cGFyYW1zLmNzc0NsYXNzLGNvbnRhaW5lcjpwYXJhbXMuY29udGFpbmVyLFwicG9pbnRlci1ldmVudHNcIjpwYXJhbXNbXCJwb2ludGVyLWV2ZW50c1wiXSxlZGl0b3JQYXJhbXM6cGFyYW1zLmVkaXRvclBhcmFtcyxvdmVybGF5czpwYXJhbXMub3ZlcmxheXN9O3RoaXMuX2pzUGx1bWIubGFzdFBhaW50ZWRBdD1udWxsOy8vIGxpc3RlbiB0byBtb3VzZW92ZXIgYW5kIG1vdXNlb3V0IGV2ZW50cyBwYXNzZWQgZnJvbSB0aGUgY29udGFpbmVyIGRlbGVnYXRlLlxudGhpcy5iaW5kKFwibW91c2VvdmVyXCIsZnVuY3Rpb24oKXt0aGlzLnNldEhvdmVyKHRydWUpO30uYmluZCh0aGlzKSk7dGhpcy5iaW5kKFwibW91c2VvdXRcIixmdW5jdGlvbigpe3RoaXMuc2V0SG92ZXIoZmFsc2UpO30uYmluZCh0aGlzKSk7Ly8gSU5JVElBTElTQVRJT04gQ09ERVxudGhpcy5tYWtlRW5kcG9pbnQ9ZnVuY3Rpb24oaXNTb3VyY2UsZWwsZWxJZCxlcCl7ZWxJZD1lbElkfHx0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmdldElkKGVsKTtyZXR1cm4gdGhpcy5wcmVwYXJlRW5kcG9pbnQoX2pzUGx1bWIsX25ld0VuZHBvaW50LHRoaXMsZXAsaXNTb3VyY2U/MDoxLHBhcmFtcyxlbCxlbElkKTt9Oy8vIGlmIHR5cGUgZ2l2ZW4sIGdldCB0aGUgZW5kcG9pbnQgZGVmaW5pdGlvbnMgbWFwcGluZyB0byB0aGF0IHR5cGUgZnJvbSB0aGUganNwbHVtYiBpbnN0YW5jZSwgYW5kIHVzZSB0aG9zZS5cbi8vIHdlIGFwcGx5IHR5cGVzIGF0IHRoZSBlbmQgb2YgdGhpcyBjb25zdHJ1Y3RvciBidXQgZW5kcG9pbnRzIGFyZSBvbmx5IGhvbm91cmVkIGluIGEgdHlwZSBkZWZpbml0aW9uIGF0XG4vLyBjcmVhdGUgdGltZS5cbmlmKHBhcmFtcy50eXBlKXtwYXJhbXMuZW5kcG9pbnRzPXBhcmFtcy5lbmRwb2ludHN8fHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuZGVyaXZlRW5kcG9pbnRBbmRBbmNob3JTcGVjKHBhcmFtcy50eXBlKS5lbmRwb2ludHM7fXZhciBlUz10aGlzLm1ha2VFbmRwb2ludCh0cnVlLHRoaXMuc291cmNlLHRoaXMuc291cmNlSWQscGFyYW1zLnNvdXJjZUVuZHBvaW50KSxlVD10aGlzLm1ha2VFbmRwb2ludChmYWxzZSx0aGlzLnRhcmdldCx0aGlzLnRhcmdldElkLHBhcmFtcy50YXJnZXRFbmRwb2ludCk7aWYoZVMpe19qdS5hZGRUb0xpc3QocGFyYW1zLmVuZHBvaW50c0J5RWxlbWVudCx0aGlzLnNvdXJjZUlkLGVTKTt9aWYoZVQpe19qdS5hZGRUb0xpc3QocGFyYW1zLmVuZHBvaW50c0J5RWxlbWVudCx0aGlzLnRhcmdldElkLGVUKTt9Ly8gaWYgc2NvcGUgbm90IHNldCwgc2V0IGl0IHRvIGJlIHRoZSBzY29wZSBmb3IgdGhlIHNvdXJjZSBlbmRwb2ludC5cbmlmKCF0aGlzLnNjb3BlKXt0aGlzLnNjb3BlPXRoaXMuZW5kcG9pbnRzWzBdLnNjb3BlO30vLyBpZiBleHBsaWNpdGx5IHRvbGQgdG8gKG9yIG5vdCB0bykgZGVsZXRlIGVuZHBvaW50cyB3aGVuIGVtcHR5LCBvdmVycmlkZSBlbmRwb2ludCdzIHByZWZlcmVuY2VzXG5pZihwYXJhbXMuZGVsZXRlRW5kcG9pbnRzT25FbXB0eSE9bnVsbCl7dGhpcy5lbmRwb2ludHNbMF0uc2V0RGVsZXRlT25FbXB0eShwYXJhbXMuZGVsZXRlRW5kcG9pbnRzT25FbXB0eSk7dGhpcy5lbmRwb2ludHNbMV0uc2V0RGVsZXRlT25FbXB0eShwYXJhbXMuZGVsZXRlRW5kcG9pbnRzT25FbXB0eSk7fS8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIERFRkFVTFQgVFlQRSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERFVEFDSEFCTEVcbnZhciBfZGV0YWNoYWJsZT1fanNQbHVtYi5EZWZhdWx0cy5Db25uZWN0aW9uc0RldGFjaGFibGU7aWYocGFyYW1zLmRldGFjaGFibGU9PT1mYWxzZSl7X2RldGFjaGFibGU9ZmFsc2U7fWlmKHRoaXMuZW5kcG9pbnRzWzBdLmNvbm5lY3Rpb25zRGV0YWNoYWJsZT09PWZhbHNlKXtfZGV0YWNoYWJsZT1mYWxzZTt9aWYodGhpcy5lbmRwb2ludHNbMV0uY29ubmVjdGlvbnNEZXRhY2hhYmxlPT09ZmFsc2Upe19kZXRhY2hhYmxlPWZhbHNlO30vLyBSRUFUVEFDSFxudmFyIF9yZWF0dGFjaD1wYXJhbXMucmVhdHRhY2h8fHRoaXMuZW5kcG9pbnRzWzBdLnJlYXR0YWNoQ29ubmVjdGlvbnN8fHRoaXMuZW5kcG9pbnRzWzFdLnJlYXR0YWNoQ29ubmVjdGlvbnN8fF9qc1BsdW1iLkRlZmF1bHRzLlJlYXR0YWNoQ29ubmVjdGlvbnM7dGhpcy5hcHBlbmRUb0RlZmF1bHRUeXBlKHtkZXRhY2hhYmxlOl9kZXRhY2hhYmxlLHJlYXR0YWNoOl9yZWF0dGFjaCxwYWludFN0eWxlOnRoaXMuZW5kcG9pbnRzWzBdLmNvbm5lY3RvclN0eWxlfHx0aGlzLmVuZHBvaW50c1sxXS5jb25uZWN0b3JTdHlsZXx8cGFyYW1zLnBhaW50U3R5bGV8fF9qc1BsdW1iLkRlZmF1bHRzLlBhaW50U3R5bGV8fF9qcC5EZWZhdWx0cy5QYWludFN0eWxlLGhvdmVyUGFpbnRTdHlsZTp0aGlzLmVuZHBvaW50c1swXS5jb25uZWN0b3JIb3ZlclN0eWxlfHx0aGlzLmVuZHBvaW50c1sxXS5jb25uZWN0b3JIb3ZlclN0eWxlfHxwYXJhbXMuaG92ZXJQYWludFN0eWxlfHxfanNQbHVtYi5EZWZhdWx0cy5Ib3ZlclBhaW50U3R5bGV8fF9qcC5EZWZhdWx0cy5Ib3ZlclBhaW50U3R5bGV9KTt2YXIgX3N1c3BlbmRlZEF0PV9qc1BsdW1iLmdldFN1c3BlbmRlZEF0KCk7aWYoIV9qc1BsdW1iLmlzU3VzcGVuZERyYXdpbmcoKSl7Ly8gcGFpbnQgdGhlIGVuZHBvaW50c1xudmFyIG15SW5mbz1fanNQbHVtYi5nZXRDYWNoZWREYXRhKHRoaXMuc291cmNlSWQpLG15T2Zmc2V0PW15SW5mby5vLG15V0g9bXlJbmZvLnMsb3RoZXJJbmZvPV9qc1BsdW1iLmdldENhY2hlZERhdGEodGhpcy50YXJnZXRJZCksb3RoZXJPZmZzZXQ9b3RoZXJJbmZvLm8sb3RoZXJXSD1vdGhlckluZm8ucyxpbml0aWFsVGltZXN0YW1wPV9zdXNwZW5kZWRBdHx8X2pzUGx1bWIudGltZXN0YW1wKCksYW5jaG9yTG9jPXRoaXMuZW5kcG9pbnRzWzBdLmFuY2hvci5jb21wdXRlKHt4eTpbbXlPZmZzZXQubGVmdCxteU9mZnNldC50b3BdLHdoOm15V0gsZWxlbWVudDp0aGlzLmVuZHBvaW50c1swXSxlbGVtZW50SWQ6dGhpcy5lbmRwb2ludHNbMF0uZWxlbWVudElkLHR4eTpbb3RoZXJPZmZzZXQubGVmdCxvdGhlck9mZnNldC50b3BdLHR3aDpvdGhlcldILHRFbGVtZW50OnRoaXMuZW5kcG9pbnRzWzFdLHRpbWVzdGFtcDppbml0aWFsVGltZXN0YW1wfSk7dGhpcy5lbmRwb2ludHNbMF0ucGFpbnQoe2FuY2hvckxvYzphbmNob3JMb2MsdGltZXN0YW1wOmluaXRpYWxUaW1lc3RhbXB9KTthbmNob3JMb2M9dGhpcy5lbmRwb2ludHNbMV0uYW5jaG9yLmNvbXB1dGUoe3h5OltvdGhlck9mZnNldC5sZWZ0LG90aGVyT2Zmc2V0LnRvcF0sd2g6b3RoZXJXSCxlbGVtZW50OnRoaXMuZW5kcG9pbnRzWzFdLGVsZW1lbnRJZDp0aGlzLmVuZHBvaW50c1sxXS5lbGVtZW50SWQsdHh5OltteU9mZnNldC5sZWZ0LG15T2Zmc2V0LnRvcF0sdHdoOm15V0gsdEVsZW1lbnQ6dGhpcy5lbmRwb2ludHNbMF0sdGltZXN0YW1wOmluaXRpYWxUaW1lc3RhbXB9KTt0aGlzLmVuZHBvaW50c1sxXS5wYWludCh7YW5jaG9yTG9jOmFuY2hvckxvYyx0aW1lc3RhbXA6aW5pdGlhbFRpbWVzdGFtcH0pO310aGlzLmdldFR5cGVEZXNjcmlwdG9yPWZ1bmN0aW9uKCl7cmV0dXJuXCJjb25uZWN0aW9uXCI7fTt0aGlzLmdldEF0dGFjaGVkRWxlbWVudHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbmRwb2ludHM7fTt0aGlzLmlzRGV0YWNoYWJsZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9qc1BsdW1iLmRldGFjaGFibGU9PT10cnVlO307dGhpcy5zZXREZXRhY2hhYmxlPWZ1bmN0aW9uKGRldGFjaGFibGUpe3RoaXMuX2pzUGx1bWIuZGV0YWNoYWJsZT1kZXRhY2hhYmxlPT09dHJ1ZTt9O3RoaXMuaXNSZWF0dGFjaD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9qc1BsdW1iLnJlYXR0YWNoPT09dHJ1ZXx8dGhpcy5lbmRwb2ludHNbMF0ucmVhdHRhY2hDb25uZWN0aW9ucz09PXRydWV8fHRoaXMuZW5kcG9pbnRzWzFdLnJlYXR0YWNoQ29ubmVjdGlvbnM9PT10cnVlO307dGhpcy5zZXRSZWF0dGFjaD1mdW5jdGlvbihyZWF0dGFjaCl7dGhpcy5fanNQbHVtYi5yZWF0dGFjaD1yZWF0dGFjaD09PXRydWU7fTsvLyBFTkQgSU5JVElBTElTQVRJT04gQ09ERVxuLy8gQ09TVCArIERJUkVDVElPTkFMSVRZXG4vLyBpZiBjb3N0IG5vdCBzdXBwbGllZCwgdHJ5IHRvIGluaGVyaXQgZnJvbSBzb3VyY2UgZW5kcG9pbnRcbnRoaXMuX2pzUGx1bWIuY29zdD1wYXJhbXMuY29zdHx8dGhpcy5lbmRwb2ludHNbMF0uZ2V0Q29ubmVjdGlvbkNvc3QoKTt0aGlzLl9qc1BsdW1iLmRpcmVjdGVkPXBhcmFtcy5kaXJlY3RlZDsvLyBpbmhlcml0IGRpcmVjdGVkIGZsYWcgaWYgc2V0IG5vIHNvdXJjZSBlbmRwb2ludFxuaWYocGFyYW1zLmRpcmVjdGVkPT1udWxsKXt0aGlzLl9qc1BsdW1iLmRpcmVjdGVkPXRoaXMuZW5kcG9pbnRzWzBdLmFyZUNvbm5lY3Rpb25zRGlyZWN0ZWQoKTt9Ly8gRU5EIENPU1QgKyBESVJFQ1RJT05BTElUWVxuLy8gUEFSQU1FVEVSU1xuLy8gbWVyZ2UgYWxsIHRoZSBwYXJhbWV0ZXJzIG9iamVjdHMgaW50byB0aGUgY29ubmVjdGlvbi4gIHBhcmFtZXRlcnMgc2V0XG4vLyBvbiB0aGUgY29ubmVjdGlvbiB0YWtlIHByZWNlZGVuY2U7IHRoZW4gc291cmNlIGVuZHBvaW50IHBhcmFtcywgdGhlblxuLy8gZmluYWxseSB0YXJnZXQgZW5kcG9pbnQgcGFyYW1zLlxudmFyIF9wPV9qcC5leHRlbmQoe30sdGhpcy5lbmRwb2ludHNbMV0uZ2V0UGFyYW1ldGVycygpKTtfanAuZXh0ZW5kKF9wLHRoaXMuZW5kcG9pbnRzWzBdLmdldFBhcmFtZXRlcnMoKSk7X2pwLmV4dGVuZChfcCx0aGlzLmdldFBhcmFtZXRlcnMoKSk7dGhpcy5zZXRQYXJhbWV0ZXJzKF9wKTsvLyBFTkQgUEFSQU1FVEVSU1xuLy8gUEFJTlRJTkdcbnRoaXMuc2V0Q29ubmVjdG9yKHRoaXMuZW5kcG9pbnRzWzBdLmNvbm5lY3Rvcnx8dGhpcy5lbmRwb2ludHNbMV0uY29ubmVjdG9yfHxwYXJhbXMuY29ubmVjdG9yfHxfanNQbHVtYi5EZWZhdWx0cy5Db25uZWN0b3J8fF9qcC5EZWZhdWx0cy5Db25uZWN0b3IsdHJ1ZSk7dmFyIGRhdGE9cGFyYW1zLmRhdGE9PW51bGx8fCFfanUuaXNPYmplY3QocGFyYW1zLmRhdGEpP3t9OnBhcmFtcy5kYXRhO3RoaXMuZ2V0RGF0YT1mdW5jdGlvbigpe3JldHVybiBkYXRhO307dGhpcy5zZXREYXRhPWZ1bmN0aW9uKGQpe2RhdGE9ZHx8e307fTt0aGlzLm1lcmdlRGF0YT1mdW5jdGlvbihkKXtkYXRhPV9qcC5leHRlbmQoZGF0YSxkKTt9Oy8vIHRoZSB2ZXJ5IGxhc3QgdGhpbmcgd2UgZG8gaXMgYXBwbHkgdHlwZXMsIGlmIHRoZXJlIGFyZSBhbnkuXG52YXIgX3R5cGVzPVtcImRlZmF1bHRcIix0aGlzLmVuZHBvaW50c1swXS5jb25uZWN0aW9uVHlwZSx0aGlzLmVuZHBvaW50c1sxXS5jb25uZWN0aW9uVHlwZSxwYXJhbXMudHlwZV0uam9pbihcIiBcIik7aWYoL1teXFxzXS8udGVzdChfdHlwZXMpKXt0aGlzLmFkZFR5cGUoX3R5cGVzLHBhcmFtcy5kYXRhLHRydWUpO310aGlzLnVwZGF0ZUNvbm5lY3RlZENsYXNzKCk7Ly8gRU5EIFBBSU5USU5HICAgIFxufTtfanUuZXh0ZW5kKF9qcC5Db25uZWN0aW9uLF9qcC5PdmVybGF5Q2FwYWJsZUpzUGx1bWJVSUNvbXBvbmVudCx7YXBwbHlUeXBlOmZ1bmN0aW9uIGFwcGx5VHlwZSh0LGRvTm90UmVwYWludCx0eXBlTWFwKXt2YXIgX2Nvbm5lY3Rvcj1udWxsO2lmKHQuY29ubmVjdG9yIT1udWxsKXtfY29ubmVjdG9yPXRoaXMuZ2V0Q2FjaGVkVHlwZUl0ZW0oXCJjb25uZWN0b3JcIix0eXBlTWFwLmNvbm5lY3Rvcik7aWYoX2Nvbm5lY3Rvcj09bnVsbCl7X2Nvbm5lY3Rvcj10aGlzLnByZXBhcmVDb25uZWN0b3IodC5jb25uZWN0b3IsdHlwZU1hcC5jb25uZWN0b3IpO3RoaXMuY2FjaGVUeXBlSXRlbShcImNvbm5lY3RvclwiLF9jb25uZWN0b3IsdHlwZU1hcC5jb25uZWN0b3IpO310aGlzLnNldFByZXBhcmVkQ29ubmVjdG9yKF9jb25uZWN0b3IpO30vLyBub25lIG9mIHRoZXNlIHRoaW5ncyByZXN1bHQgaW4gdGhlIGNyZWF0aW9uIG9mIG9iamVjdHMgc28gY2FuIGJlIGlnbm9yZWQuXG5pZih0LmRldGFjaGFibGUhPW51bGwpe3RoaXMuc2V0RGV0YWNoYWJsZSh0LmRldGFjaGFibGUpO31pZih0LnJlYXR0YWNoIT1udWxsKXt0aGlzLnNldFJlYXR0YWNoKHQucmVhdHRhY2gpO31pZih0LnNjb3BlKXt0aGlzLnNjb3BlPXQuc2NvcGU7fWlmKHQuY3NzQ2xhc3MhPW51bGwmJnRoaXMuY2FudmFzKXt0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmFkZENsYXNzKHRoaXMuY2FudmFzLHQuY3NzQ2xhc3MpO312YXIgX2FuY2hvcnM9bnVsbDsvLyB0aGlzIGFsc28gcmVzdWx0cyBpbiB0aGUgY3JlYXRpb24gb2Ygb2JqZWN0cy5cbmlmKHQuYW5jaG9yKXsvLyBub3RlIHRoYXQgZXZlbiBpZiB0aGUgcGFyYW0gd2FzIGFuY2hvciwgd2Ugc3RvcmUgYGFuY2hvcnNgLlxuX2FuY2hvcnM9dGhpcy5nZXRDYWNoZWRUeXBlSXRlbShcImFuY2hvcnNcIix0eXBlTWFwLmFuY2hvcik7aWYoX2FuY2hvcnM9PW51bGwpe19hbmNob3JzPVt0aGlzLl9qc1BsdW1iLmluc3RhbmNlLm1ha2VBbmNob3IodC5hbmNob3IpLHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UubWFrZUFuY2hvcih0LmFuY2hvcildO3RoaXMuY2FjaGVUeXBlSXRlbShcImFuY2hvcnNcIixfYW5jaG9ycyx0eXBlTWFwLmFuY2hvcik7fX1lbHNlIGlmKHQuYW5jaG9ycyl7X2FuY2hvcnM9dGhpcy5nZXRDYWNoZWRUeXBlSXRlbShcImFuY2hvcnNcIix0eXBlTWFwLmFuY2hvcnMpO2lmKF9hbmNob3JzPT1udWxsKXtfYW5jaG9ycz1bdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5tYWtlQW5jaG9yKHQuYW5jaG9yc1swXSksdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5tYWtlQW5jaG9yKHQuYW5jaG9yc1sxXSldO3RoaXMuY2FjaGVUeXBlSXRlbShcImFuY2hvcnNcIixfYW5jaG9ycyx0eXBlTWFwLmFuY2hvcnMpO319aWYoX2FuY2hvcnMhPW51bGwpe3RoaXMuZW5kcG9pbnRzWzBdLmFuY2hvcj1fYW5jaG9yc1swXTt0aGlzLmVuZHBvaW50c1sxXS5hbmNob3I9X2FuY2hvcnNbMV07aWYodGhpcy5lbmRwb2ludHNbMV0uYW5jaG9yLmlzRHluYW1pYyl7dGhpcy5fanNQbHVtYi5pbnN0YW5jZS5yZXBhaW50KHRoaXMuZW5kcG9pbnRzWzFdLmVsZW1lbnRJZCk7fX1fanAuT3ZlcmxheUNhcGFibGVKc1BsdW1iVUlDb21wb25lbnQuYXBwbHlUeXBlKHRoaXMsdCk7fSxhZGRDbGFzczpmdW5jdGlvbiBhZGRDbGFzcyhjLGluZm9ybUVuZHBvaW50cyl7aWYoaW5mb3JtRW5kcG9pbnRzKXt0aGlzLmVuZHBvaW50c1swXS5hZGRDbGFzcyhjKTt0aGlzLmVuZHBvaW50c1sxXS5hZGRDbGFzcyhjKTtpZih0aGlzLnN1c3BlbmRlZEVuZHBvaW50KXt0aGlzLnN1c3BlbmRlZEVuZHBvaW50LmFkZENsYXNzKGMpO319aWYodGhpcy5jb25uZWN0b3Ipe3RoaXMuY29ubmVjdG9yLmFkZENsYXNzKGMpO319LHJlbW92ZUNsYXNzOmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGMsaW5mb3JtRW5kcG9pbnRzKXtpZihpbmZvcm1FbmRwb2ludHMpe3RoaXMuZW5kcG9pbnRzWzBdLnJlbW92ZUNsYXNzKGMpO3RoaXMuZW5kcG9pbnRzWzFdLnJlbW92ZUNsYXNzKGMpO2lmKHRoaXMuc3VzcGVuZGVkRW5kcG9pbnQpe3RoaXMuc3VzcGVuZGVkRW5kcG9pbnQucmVtb3ZlQ2xhc3MoYyk7fX1pZih0aGlzLmNvbm5lY3Rvcil7dGhpcy5jb25uZWN0b3IucmVtb3ZlQ2xhc3MoYyk7fX0saXNWaXNpYmxlOmZ1bmN0aW9uIGlzVmlzaWJsZSgpe3JldHVybiB0aGlzLl9qc1BsdW1iLnZpc2libGU7fSxzZXRWaXNpYmxlOmZ1bmN0aW9uIHNldFZpc2libGUodil7dGhpcy5fanNQbHVtYi52aXNpYmxlPXY7aWYodGhpcy5jb25uZWN0b3Ipe3RoaXMuY29ubmVjdG9yLnNldFZpc2libGUodik7fXRoaXMucmVwYWludCgpO30sY2xlYW51cDpmdW5jdGlvbiBjbGVhbnVwKCl7dGhpcy51cGRhdGVDb25uZWN0ZWRDbGFzcyh0cnVlKTt0aGlzLmVuZHBvaW50cz1udWxsO3RoaXMuc291cmNlPW51bGw7dGhpcy50YXJnZXQ9bnVsbDtpZih0aGlzLmNvbm5lY3RvciE9bnVsbCl7dGhpcy5jb25uZWN0b3IuY2xlYW51cCh0cnVlKTt0aGlzLmNvbm5lY3Rvci5kZXN0cm95KHRydWUpO310aGlzLmNvbm5lY3Rvcj1udWxsO30sdXBkYXRlQ29ubmVjdGVkQ2xhc3M6ZnVuY3Rpb24gdXBkYXRlQ29ubmVjdGVkQ2xhc3MocmVtb3ZlKXtpZih0aGlzLl9qc1BsdW1iKXtfdXBkYXRlQ29ubmVjdGVkQ2xhc3ModGhpcyx0aGlzLnNvdXJjZSx0aGlzLl9qc1BsdW1iLmluc3RhbmNlLHJlbW92ZSk7X3VwZGF0ZUNvbm5lY3RlZENsYXNzKHRoaXMsdGhpcy50YXJnZXQsdGhpcy5fanNQbHVtYi5pbnN0YW5jZSxyZW1vdmUpO319LHNldEhvdmVyOmZ1bmN0aW9uIHNldEhvdmVyKHN0YXRlKXtpZih0aGlzLmNvbm5lY3RvciYmdGhpcy5fanNQbHVtYiYmIXRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuaXNDb25uZWN0aW9uQmVpbmdEcmFnZ2VkKCkpe3RoaXMuY29ubmVjdG9yLnNldEhvdmVyKHN0YXRlKTtyb290LmpzUGx1bWJbc3RhdGU/XCJhZGRDbGFzc1wiOlwicmVtb3ZlQ2xhc3NcIl0odGhpcy5zb3VyY2UsdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5ob3ZlclNvdXJjZUNsYXNzKTtyb290LmpzUGx1bWJbc3RhdGU/XCJhZGRDbGFzc1wiOlwicmVtb3ZlQ2xhc3NcIl0odGhpcy50YXJnZXQsdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5ob3ZlclRhcmdldENsYXNzKTt9fSxnZXRVdWlkczpmdW5jdGlvbiBnZXRVdWlkcygpe3JldHVyblt0aGlzLmVuZHBvaW50c1swXS5nZXRVdWlkKCksdGhpcy5lbmRwb2ludHNbMV0uZ2V0VXVpZCgpXTt9LGdldENvc3Q6ZnVuY3Rpb24gZ2V0Q29zdCgpe3JldHVybiB0aGlzLl9qc1BsdW1iP3RoaXMuX2pzUGx1bWIuY29zdDotSW5maW5pdHk7fSxzZXRDb3N0OmZ1bmN0aW9uIHNldENvc3QoYyl7dGhpcy5fanNQbHVtYi5jb3N0PWM7fSxpc0RpcmVjdGVkOmZ1bmN0aW9uIGlzRGlyZWN0ZWQoKXtyZXR1cm4gdGhpcy5fanNQbHVtYi5kaXJlY3RlZDt9LGdldENvbm5lY3RvcjpmdW5jdGlvbiBnZXRDb25uZWN0b3IoKXtyZXR1cm4gdGhpcy5jb25uZWN0b3I7fSxwcmVwYXJlQ29ubmVjdG9yOmZ1bmN0aW9uIHByZXBhcmVDb25uZWN0b3IoY29ubmVjdG9yU3BlYyx0eXBlSWQpe3ZhciBjb25uZWN0b3JBcmdzPXtfanNQbHVtYjp0aGlzLl9qc1BsdW1iLmluc3RhbmNlLGNzc0NsYXNzOnRoaXMuX2pzUGx1bWIucGFyYW1zLmNzc0NsYXNzfHxcIlwiLGNvbnRhaW5lcjp0aGlzLl9qc1BsdW1iLnBhcmFtcy5jb250YWluZXIsXCJwb2ludGVyLWV2ZW50c1wiOnRoaXMuX2pzUGx1bWIucGFyYW1zW1wicG9pbnRlci1ldmVudHNcIl19LHJlbmRlck1vZGU9dGhpcy5fanNQbHVtYi5pbnN0YW5jZS5nZXRSZW5kZXJNb2RlKCksY29ubmVjdG9yO2lmKF9qdS5pc1N0cmluZyhjb25uZWN0b3JTcGVjKSl7Y29ubmVjdG9yPW1ha2VDb25uZWN0b3IodGhpcy5fanNQbHVtYi5pbnN0YW5jZSxyZW5kZXJNb2RlLGNvbm5lY3RvclNwZWMsY29ubmVjdG9yQXJncyx0aGlzKTt9Ly8gbGV0cyB5b3UgdXNlIGEgc3RyaW5nIGFzIHNob3J0aGFuZC5cbmVsc2UgaWYoX2p1LmlzQXJyYXkoY29ubmVjdG9yU3BlYykpe2lmKGNvbm5lY3RvclNwZWMubGVuZ3RoPT09MSl7Y29ubmVjdG9yPW1ha2VDb25uZWN0b3IodGhpcy5fanNQbHVtYi5pbnN0YW5jZSxyZW5kZXJNb2RlLGNvbm5lY3RvclNwZWNbMF0sY29ubmVjdG9yQXJncyx0aGlzKTt9ZWxzZXtjb25uZWN0b3I9bWFrZUNvbm5lY3Rvcih0aGlzLl9qc1BsdW1iLmluc3RhbmNlLHJlbmRlck1vZGUsY29ubmVjdG9yU3BlY1swXSxfanUubWVyZ2UoY29ubmVjdG9yU3BlY1sxXSxjb25uZWN0b3JBcmdzKSx0aGlzKTt9fWlmKHR5cGVJZCE9bnVsbCl7Y29ubmVjdG9yLnR5cGVJZD10eXBlSWQ7fXJldHVybiBjb25uZWN0b3I7fSxzZXRQcmVwYXJlZENvbm5lY3RvcjpmdW5jdGlvbiBzZXRQcmVwYXJlZENvbm5lY3Rvcihjb25uZWN0b3IsZG9Ob3RSZXBhaW50LGRvTm90Q2hhbmdlTGlzdGVuZXJDb21wb25lbnQsdHlwZUlkKXtpZih0aGlzLmNvbm5lY3RvciE9PWNvbm5lY3Rvcil7dmFyIHByZXZpb3VzLHByZXZpb3VzQ2xhc3Nlcz1cIlwiOy8vIHRoZSBjb25uZWN0b3Igd2lsbCBub3QgYmUgY2xlYW5lZCB1cCBpZiBpdCB3YXMgc2V0IGFzIHBhcnQgb2YgYSB0eXBlLCBiZWNhdXNlIGB0eXBlSWRgIHdpbGwgYmUgc2V0IG9uIGl0XG4vLyBhbmQgd2UgaGF2ZW50IHBhc3NlZCBpbiBgdHJ1ZWAgZm9yIFwiZm9yY2VcIiBoZXJlLlxuaWYodGhpcy5jb25uZWN0b3IhPW51bGwpe3ByZXZpb3VzPXRoaXMuY29ubmVjdG9yO3ByZXZpb3VzQ2xhc3Nlcz1wcmV2aW91cy5nZXRDbGFzcygpO3RoaXMuY29ubmVjdG9yLmNsZWFudXAoKTt0aGlzLmNvbm5lY3Rvci5kZXN0cm95KCk7fXRoaXMuY29ubmVjdG9yPWNvbm5lY3RvcjtpZih0eXBlSWQpe3RoaXMuY2FjaGVUeXBlSXRlbShcImNvbm5lY3RvclwiLGNvbm5lY3Rvcix0eXBlSWQpO310aGlzLmNhbnZhcz10aGlzLmNvbm5lY3Rvci5jYW52YXM7dGhpcy5iZ0NhbnZhcz10aGlzLmNvbm5lY3Rvci5iZ0NhbnZhczsvLyBwdXQgY2xhc3NlcyBmcm9tIHByaW9yIGNvbm5lY3RvciBvbnRvIHRoZSBjYW52YXNcbnRoaXMuYWRkQ2xhc3MocHJldmlvdXNDbGFzc2VzKTsvLyBuZXc6IGluc3RlYWQgb2YgYmluZGluZyBsaXN0ZW5lcnMgcGVyIGNvbm5lY3Rvciwgd2Ugbm93IGp1c3QgaGF2ZSBvbmUgZGVsZWdhdGUgb24gdGhlIGNvbnRhaW5lci5cbi8vIHNvIGZvciB0aGF0IGhhbmRsZXIgd2Ugc2V0IHRoZSBjb25uZWN0aW9uIGFzIHRoZSAnX2pzUGx1bWInIG1lbWJlciBvZiB0aGUgY2FudmFzIGVsZW1lbnQsIGFuZFxuLy8gYmdDYW52YXMsIGlmIGl0IGV4aXN0cywgd2hpY2ggaXQgZG9lcyByaWdodCBub3cgaW4gdGhlIFZNTCByZW5kZXJlciwgc28gaXQgd29uJ3QgZnJvbSB2IDIuMC4wIG9ud2FyZHMuXG5pZih0aGlzLmNhbnZhcyl7dGhpcy5jYW52YXMuX2pzUGx1bWI9dGhpczt9aWYodGhpcy5iZ0NhbnZhcyl7dGhpcy5iZ0NhbnZhcy5fanNQbHVtYj10aGlzO31pZihwcmV2aW91cyE9bnVsbCl7dmFyIG89dGhpcy5nZXRPdmVybGF5cygpO2Zvcih2YXIgaT0wO2k8by5sZW5ndGg7aSsrKXtpZihvW2ldLnRyYW5zZmVyKXtvW2ldLnRyYW5zZmVyKHRoaXMuY29ubmVjdG9yKTt9fX1pZighZG9Ob3RDaGFuZ2VMaXN0ZW5lckNvbXBvbmVudCl7dGhpcy5zZXRMaXN0ZW5lckNvbXBvbmVudCh0aGlzLmNvbm5lY3Rvcik7fWlmKCFkb05vdFJlcGFpbnQpe3RoaXMucmVwYWludCgpO319fSxzZXRDb25uZWN0b3I6ZnVuY3Rpb24gc2V0Q29ubmVjdG9yKGNvbm5lY3RvclNwZWMsZG9Ob3RSZXBhaW50LGRvTm90Q2hhbmdlTGlzdGVuZXJDb21wb25lbnQsdHlwZUlkKXt2YXIgY29ubmVjdG9yPXRoaXMucHJlcGFyZUNvbm5lY3Rvcihjb25uZWN0b3JTcGVjLHR5cGVJZCk7dGhpcy5zZXRQcmVwYXJlZENvbm5lY3Rvcihjb25uZWN0b3IsZG9Ob3RSZXBhaW50LGRvTm90Q2hhbmdlTGlzdGVuZXJDb21wb25lbnQsdHlwZUlkKTt9LHBhaW50OmZ1bmN0aW9uIHBhaW50KHBhcmFtcyl7aWYoIXRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuaXNTdXNwZW5kRHJhd2luZygpJiZ0aGlzLl9qc1BsdW1iLnZpc2libGUpe3BhcmFtcz1wYXJhbXN8fHt9O3ZhciB0aW1lc3RhbXA9cGFyYW1zLnRpbWVzdGFtcCwvLyBpZiB0aGUgbW92aW5nIG9iamVjdCBpcyBub3QgdGhlIHNvdXJjZSB3ZSBtdXN0IHRyYW5zcG9zZSB0aGUgdHdvIHJlZmVyZW5jZXMuXG5zd2FwPWZhbHNlLHRJZD1zd2FwP3RoaXMuc291cmNlSWQ6dGhpcy50YXJnZXRJZCxzSWQ9c3dhcD90aGlzLnRhcmdldElkOnRoaXMuc291cmNlSWQsdElkeD1zd2FwPzA6MSxzSWR4PXN3YXA/MTowO2lmKHRpbWVzdGFtcD09bnVsbHx8dGltZXN0YW1wIT09dGhpcy5fanNQbHVtYi5sYXN0UGFpbnRlZEF0KXt2YXIgc291cmNlSW5mbz10aGlzLl9qc1BsdW1iLmluc3RhbmNlLnVwZGF0ZU9mZnNldCh7ZWxJZDpzSWR9KS5vLHRhcmdldEluZm89dGhpcy5fanNQbHVtYi5pbnN0YW5jZS51cGRhdGVPZmZzZXQoe2VsSWQ6dElkfSkubyxzRT10aGlzLmVuZHBvaW50c1tzSWR4XSx0RT10aGlzLmVuZHBvaW50c1t0SWR4XTt2YXIgc0FuY2hvclA9c0UuYW5jaG9yLmdldEN1cnJlbnRMb2NhdGlvbih7eHk6W3NvdXJjZUluZm8ubGVmdCxzb3VyY2VJbmZvLnRvcF0sd2g6W3NvdXJjZUluZm8ud2lkdGgsc291cmNlSW5mby5oZWlnaHRdLGVsZW1lbnQ6c0UsdGltZXN0YW1wOnRpbWVzdGFtcH0pLHRBbmNob3JQPXRFLmFuY2hvci5nZXRDdXJyZW50TG9jYXRpb24oe3h5Olt0YXJnZXRJbmZvLmxlZnQsdGFyZ2V0SW5mby50b3BdLHdoOlt0YXJnZXRJbmZvLndpZHRoLHRhcmdldEluZm8uaGVpZ2h0XSxlbGVtZW50OnRFLHRpbWVzdGFtcDp0aW1lc3RhbXB9KTt0aGlzLmNvbm5lY3Rvci5yZXNldEJvdW5kcygpO3RoaXMuY29ubmVjdG9yLmNvbXB1dGUoe3NvdXJjZVBvczpzQW5jaG9yUCx0YXJnZXRQb3M6dEFuY2hvclAsc291cmNlRW5kcG9pbnQ6dGhpcy5lbmRwb2ludHNbc0lkeF0sdGFyZ2V0RW5kcG9pbnQ6dGhpcy5lbmRwb2ludHNbdElkeF0sXCJzdHJva2Utd2lkdGhcIjp0aGlzLl9qc1BsdW1iLnBhaW50U3R5bGVJblVzZS5zdHJva2VXaWR0aCxzb3VyY2VJbmZvOnNvdXJjZUluZm8sdGFyZ2V0SW5mbzp0YXJnZXRJbmZvfSk7dmFyIG92ZXJsYXlFeHRlbnRzPXttaW5YOkluZmluaXR5LG1pblk6SW5maW5pdHksbWF4WDotSW5maW5pdHksbWF4WTotSW5maW5pdHl9Oy8vIGNvbXB1dGUgb3ZlcmxheXMuIHdlIGRvIHRoaXMgZmlyc3Qgc28gd2UgY2FuIGdldCB0aGVpciBwbGFjZW1lbnRzLCBhbmQgYWRqdXN0IHRoZVxuLy8gY29udGFpbmVyIGlmIG5lZWRzIGJlIChpZiBhbiBvdmVybGF5IHdvdWxkIGJlIGNsaXBwZWQpXG5mb3IodmFyIGkgaW4gdGhpcy5fanNQbHVtYi5vdmVybGF5cyl7aWYodGhpcy5fanNQbHVtYi5vdmVybGF5cy5oYXNPd25Qcm9wZXJ0eShpKSl7dmFyIG89dGhpcy5fanNQbHVtYi5vdmVybGF5c1tpXTtpZihvLmlzVmlzaWJsZSgpKXt0aGlzLl9qc1BsdW1iLm92ZXJsYXlQbGFjZW1lbnRzW2ldPW8uZHJhdyh0aGlzLmNvbm5lY3Rvcix0aGlzLl9qc1BsdW1iLnBhaW50U3R5bGVJblVzZSx0aGlzLmdldEFic29sdXRlT3ZlcmxheVBvc2l0aW9uKG8pKTtvdmVybGF5RXh0ZW50cy5taW5YPU1hdGgubWluKG92ZXJsYXlFeHRlbnRzLm1pblgsdGhpcy5fanNQbHVtYi5vdmVybGF5UGxhY2VtZW50c1tpXS5taW5YKTtvdmVybGF5RXh0ZW50cy5tYXhYPU1hdGgubWF4KG92ZXJsYXlFeHRlbnRzLm1heFgsdGhpcy5fanNQbHVtYi5vdmVybGF5UGxhY2VtZW50c1tpXS5tYXhYKTtvdmVybGF5RXh0ZW50cy5taW5ZPU1hdGgubWluKG92ZXJsYXlFeHRlbnRzLm1pblksdGhpcy5fanNQbHVtYi5vdmVybGF5UGxhY2VtZW50c1tpXS5taW5ZKTtvdmVybGF5RXh0ZW50cy5tYXhZPU1hdGgubWF4KG92ZXJsYXlFeHRlbnRzLm1heFksdGhpcy5fanNQbHVtYi5vdmVybGF5UGxhY2VtZW50c1tpXS5tYXhZKTt9fX12YXIgbGluZVdpZHRoPXBhcnNlRmxvYXQodGhpcy5fanNQbHVtYi5wYWludFN0eWxlSW5Vc2Uuc3Ryb2tlV2lkdGh8fDEpLzIsb3V0bGluZVdpZHRoPXBhcnNlRmxvYXQodGhpcy5fanNQbHVtYi5wYWludFN0eWxlSW5Vc2Uuc3Ryb2tlV2lkdGh8fDApLGV4dGVudHM9e3htaW46TWF0aC5taW4odGhpcy5jb25uZWN0b3IuYm91bmRzLm1pblgtKGxpbmVXaWR0aCtvdXRsaW5lV2lkdGgpLG92ZXJsYXlFeHRlbnRzLm1pblgpLHltaW46TWF0aC5taW4odGhpcy5jb25uZWN0b3IuYm91bmRzLm1pblktKGxpbmVXaWR0aCtvdXRsaW5lV2lkdGgpLG92ZXJsYXlFeHRlbnRzLm1pblkpLHhtYXg6TWF0aC5tYXgodGhpcy5jb25uZWN0b3IuYm91bmRzLm1heFgrKGxpbmVXaWR0aCtvdXRsaW5lV2lkdGgpLG92ZXJsYXlFeHRlbnRzLm1heFgpLHltYXg6TWF0aC5tYXgodGhpcy5jb25uZWN0b3IuYm91bmRzLm1heFkrKGxpbmVXaWR0aCtvdXRsaW5lV2lkdGgpLG92ZXJsYXlFeHRlbnRzLm1heFkpfTsvLyBwYWludCB0aGUgY29ubmVjdG9yLlxudGhpcy5jb25uZWN0b3IucGFpbnQodGhpcy5fanNQbHVtYi5wYWludFN0eWxlSW5Vc2UsbnVsbCxleHRlbnRzKTsvLyBhbmQgdGhlbiB0aGUgb3ZlcmxheXNcbmZvcih2YXIgaiBpbiB0aGlzLl9qc1BsdW1iLm92ZXJsYXlzKXtpZih0aGlzLl9qc1BsdW1iLm92ZXJsYXlzLmhhc093blByb3BlcnR5KGopKXt2YXIgcD10aGlzLl9qc1BsdW1iLm92ZXJsYXlzW2pdO2lmKHAuaXNWaXNpYmxlKCkpe3AucGFpbnQodGhpcy5fanNQbHVtYi5vdmVybGF5UGxhY2VtZW50c1tqXSxleHRlbnRzKTt9fX19dGhpcy5fanNQbHVtYi5sYXN0UGFpbnRlZEF0PXRpbWVzdGFtcDt9fSxyZXBhaW50OmZ1bmN0aW9uIHJlcGFpbnQocGFyYW1zKXtwYXJhbXM9cGFyYW1zfHx7fTt0aGlzLnBhaW50KHtlbElkOnRoaXMuc291cmNlSWQscmVjYWxjOiEocGFyYW1zLnJlY2FsYz09PWZhbHNlKSx0aW1lc3RhbXA6cGFyYW1zLnRpbWVzdGFtcH0pO30scHJlcGFyZUVuZHBvaW50OmZ1bmN0aW9uIHByZXBhcmVFbmRwb2ludChfanNQbHVtYixfbmV3RW5kcG9pbnQsY29ubixleGlzdGluZyxpbmRleCxwYXJhbXMsZWxlbWVudCxlbGVtZW50SWQpe3ZhciBlO2lmKGV4aXN0aW5nKXtjb25uLmVuZHBvaW50c1tpbmRleF09ZXhpc3Rpbmc7ZXhpc3RpbmcuYWRkQ29ubmVjdGlvbihjb25uKTt9ZWxzZXtpZighcGFyYW1zLmVuZHBvaW50cyl7cGFyYW1zLmVuZHBvaW50cz1bbnVsbCxudWxsXTt9dmFyIGVwPXBhcmFtcy5lbmRwb2ludHNbaW5kZXhdfHxwYXJhbXMuZW5kcG9pbnR8fF9qc1BsdW1iLkRlZmF1bHRzLkVuZHBvaW50c1tpbmRleF18fF9qcC5EZWZhdWx0cy5FbmRwb2ludHNbaW5kZXhdfHxfanNQbHVtYi5EZWZhdWx0cy5FbmRwb2ludHx8X2pwLkRlZmF1bHRzLkVuZHBvaW50O2lmKCFwYXJhbXMuZW5kcG9pbnRTdHlsZXMpe3BhcmFtcy5lbmRwb2ludFN0eWxlcz1bbnVsbCxudWxsXTt9aWYoIXBhcmFtcy5lbmRwb2ludEhvdmVyU3R5bGVzKXtwYXJhbXMuZW5kcG9pbnRIb3ZlclN0eWxlcz1bbnVsbCxudWxsXTt9dmFyIGVzPXBhcmFtcy5lbmRwb2ludFN0eWxlc1tpbmRleF18fHBhcmFtcy5lbmRwb2ludFN0eWxlfHxfanNQbHVtYi5EZWZhdWx0cy5FbmRwb2ludFN0eWxlc1tpbmRleF18fF9qcC5EZWZhdWx0cy5FbmRwb2ludFN0eWxlc1tpbmRleF18fF9qc1BsdW1iLkRlZmF1bHRzLkVuZHBvaW50U3R5bGV8fF9qcC5EZWZhdWx0cy5FbmRwb2ludFN0eWxlOy8vIEVuZHBvaW50cyBkZXJpdmUgdGhlaXIgZmlsbCBmcm9tIHRoZSBjb25uZWN0b3IncyBzdHJva2UsIGlmIG5vIGZpbGwgd2FzIHNwZWNpZmllZC5cbmlmKGVzLmZpbGw9PW51bGwmJnBhcmFtcy5wYWludFN0eWxlIT1udWxsKXtlcy5maWxsPXBhcmFtcy5wYWludFN0eWxlLnN0cm9rZTt9aWYoZXMub3V0bGluZVN0cm9rZT09bnVsbCYmcGFyYW1zLnBhaW50U3R5bGUhPW51bGwpe2VzLm91dGxpbmVTdHJva2U9cGFyYW1zLnBhaW50U3R5bGUub3V0bGluZVN0cm9rZTt9aWYoZXMub3V0bGluZVdpZHRoPT1udWxsJiZwYXJhbXMucGFpbnRTdHlsZSE9bnVsbCl7ZXMub3V0bGluZVdpZHRoPXBhcmFtcy5wYWludFN0eWxlLm91dGxpbmVXaWR0aDt9dmFyIGVocz1wYXJhbXMuZW5kcG9pbnRIb3ZlclN0eWxlc1tpbmRleF18fHBhcmFtcy5lbmRwb2ludEhvdmVyU3R5bGV8fF9qc1BsdW1iLkRlZmF1bHRzLkVuZHBvaW50SG92ZXJTdHlsZXNbaW5kZXhdfHxfanAuRGVmYXVsdHMuRW5kcG9pbnRIb3ZlclN0eWxlc1tpbmRleF18fF9qc1BsdW1iLkRlZmF1bHRzLkVuZHBvaW50SG92ZXJTdHlsZXx8X2pwLkRlZmF1bHRzLkVuZHBvaW50SG92ZXJTdHlsZTsvLyBlbmRwb2ludCBob3ZlciBmaWxsIHN0eWxlIGlzIGRlcml2ZWQgZnJvbSBjb25uZWN0b3IncyBob3ZlciBzdHJva2Ugc3R5bGVcbmlmKHBhcmFtcy5ob3ZlclBhaW50U3R5bGUhPW51bGwpe2lmKGVocz09bnVsbCl7ZWhzPXt9O31pZihlaHMuZmlsbD09bnVsbCl7ZWhzLmZpbGw9cGFyYW1zLmhvdmVyUGFpbnRTdHlsZS5zdHJva2U7fX12YXIgYT1wYXJhbXMuYW5jaG9ycz9wYXJhbXMuYW5jaG9yc1tpbmRleF06cGFyYW1zLmFuY2hvcj9wYXJhbXMuYW5jaG9yOl9tYWtlQW5jaG9yKF9qc1BsdW1iLkRlZmF1bHRzLkFuY2hvcnNbaW5kZXhdLGVsZW1lbnRJZCxfanNQbHVtYil8fF9tYWtlQW5jaG9yKF9qcC5EZWZhdWx0cy5BbmNob3JzW2luZGV4XSxlbGVtZW50SWQsX2pzUGx1bWIpfHxfbWFrZUFuY2hvcihfanNQbHVtYi5EZWZhdWx0cy5BbmNob3IsZWxlbWVudElkLF9qc1BsdW1iKXx8X21ha2VBbmNob3IoX2pwLkRlZmF1bHRzLkFuY2hvcixlbGVtZW50SWQsX2pzUGx1bWIpLHU9cGFyYW1zLnV1aWRzP3BhcmFtcy51dWlkc1tpbmRleF06bnVsbDtlPV9uZXdFbmRwb2ludCh7cGFpbnRTdHlsZTplcyxob3ZlclBhaW50U3R5bGU6ZWhzLGVuZHBvaW50OmVwLGNvbm5lY3Rpb25zOltjb25uXSx1dWlkOnUsYW5jaG9yOmEsc291cmNlOmVsZW1lbnQsc2NvcGU6cGFyYW1zLnNjb3BlLHJlYXR0YWNoOnBhcmFtcy5yZWF0dGFjaHx8X2pzUGx1bWIuRGVmYXVsdHMuUmVhdHRhY2hDb25uZWN0aW9ucyxkZXRhY2hhYmxlOnBhcmFtcy5kZXRhY2hhYmxlfHxfanNQbHVtYi5EZWZhdWx0cy5Db25uZWN0aW9uc0RldGFjaGFibGV9KTtpZihleGlzdGluZz09bnVsbCl7ZS5zZXREZWxldGVPbkVtcHR5KHRydWUpO31jb25uLmVuZHBvaW50c1tpbmRleF09ZTtpZihwYXJhbXMuZHJhd0VuZHBvaW50cz09PWZhbHNlKXtlLnNldFZpc2libGUoZmFsc2UsdHJ1ZSx0cnVlKTt9fXJldHVybiBlO319KTsvLyBFTkQgQ29ubmVjdGlvbiBjbGFzcyAgICAgICAgICAgIFxufSkuY2FsbCh0eXBlb2Ygd2luZG93IT09J3VuZGVmaW5lZCc/d2luZG93OnRoaXMpOy8qXHJcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUgY29kZSBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBhbmNob3JzLlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgLSAyMDE4IGpzUGx1bWIgKGhlbGxvQGpzcGx1bWJ0b29sa2l0LmNvbSlcclxuICpcclxuICogaHR0cHM6Ly9qc3BsdW1idG9vbGtpdC5jb21cclxuICogaHR0cHM6Ly9naXRodWIuY29tL2pzcGx1bWIvanNwbHVtYlxyXG4gKlxyXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgYW5kIEdQTDIgbGljZW5zZXMuXHJcbiAqLzsoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgcm9vdD10aGlzLF9qdT1yb290LmpzUGx1bWJVdGlsLF9qcD1yb290LmpzUGx1bWI7Ly9cbi8vIG1hbmFnZXMgYW5jaG9ycyBmb3IgYWxsIGVsZW1lbnRzLlxuLy9cbl9qcC5BbmNob3JNYW5hZ2VyPWZ1bmN0aW9uKHBhcmFtcyl7dmFyIF9hbUVuZHBvaW50cz17fSxjb250aW51b3VzQW5jaG9yTG9jYXRpb25zPXt9LHVzZXJEZWZpbmVkQ29udGludW91c0FuY2hvckxvY2F0aW9ucz17fSxjb250aW51b3VzQW5jaG9yT3JpZW50YXRpb25zPXt9LE9yaWVudGF0aW9uPXtIT1JJWk9OVEFMOlwiaG9yaXpvbnRhbFwiLFZFUlRJQ0FMOlwidmVydGljYWxcIixESUFHT05BTDpcImRpYWdvbmFsXCIsSURFTlRJVFk6XCJpZGVudGl0eVwifSxheGVzPVtcImxlZnRcIixcInRvcFwiLFwicmlnaHRcIixcImJvdHRvbVwiXSxjb25uZWN0aW9uc0J5RWxlbWVudElkPXt9LHNlbGY9dGhpcyxhbmNob3JMaXN0cz17fSxqc1BsdW1iSW5zdGFuY2U9cGFyYW1zLmpzUGx1bWJJbnN0YW5jZSxmbG9hdGluZ0Nvbm5lY3Rpb25zPXt9LGNhbGN1bGF0ZU9yaWVudGF0aW9uPWZ1bmN0aW9uIGNhbGN1bGF0ZU9yaWVudGF0aW9uKHNvdXJjZUlkLHRhcmdldElkLHNkLHRkLHNvdXJjZUFuY2hvcix0YXJnZXRBbmNob3Ipe2lmKHNvdXJjZUlkPT09dGFyZ2V0SWQpe3JldHVybntvcmllbnRhdGlvbjpPcmllbnRhdGlvbi5JREVOVElUWSxhOltcInRvcFwiLFwidG9wXCJdfTt9dmFyIHRoZXRhPU1hdGguYXRhbjIodGQuY2VudGVyeS1zZC5jZW50ZXJ5LHRkLmNlbnRlcngtc2QuY2VudGVyeCksdGhldGEyPU1hdGguYXRhbjIoc2QuY2VudGVyeS10ZC5jZW50ZXJ5LHNkLmNlbnRlcngtdGQuY2VudGVyeCk7Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGltcHJvdmVkIGZhY2UgY2FsY3VsYXRpb24uIGdldCBtaWRwb2ludHMgb2YgZWFjaCBmYWNlIGZvciBzb3VyY2UgYW5kIHRhcmdldCwgdGhlbiBwdXQgaW4gYW4gYXJyYXkgd2l0aCBhbGwgY29tYmluYXRpb25zIG9mXG4vLyBzb3VyY2UvdGFyZ2V0IGZhY2VzLiBzb3J0IHRoaXMgYXJyYXkgYnkgZGlzdGFuY2UgYmV0d2VlbiBtaWRwb2ludHMuIHRoZSBlbnRyeSBhdCBpbmRleCAwIGlzIG91ciBwcmVmZXJyZWQgb3B0aW9uLiB3ZSBjYW5cbi8vIGdvIHRocm91Z2ggdGhlIGFycmF5IG9uZSBieSBvbmUgdW50aWwgd2UgZmluZCBhbiBlbnRyeSBpbiB3aGljaCBlYWNoIHJlcXVlc3RlZCBmYWNlIGlzIHN1cHBvcnRlZC5cbnZhciBjYW5kaWRhdGVzPVtdLG1pZHBvaW50cz17fTsoZnVuY3Rpb24odHlwZXMsZGltKXtmb3IodmFyIGk9MDtpPHR5cGVzLmxlbmd0aDtpKyspe21pZHBvaW50c1t0eXBlc1tpXV09e1wibGVmdFwiOltkaW1baV0ubGVmdCxkaW1baV0uY2VudGVyeV0sXCJyaWdodFwiOltkaW1baV0ucmlnaHQsZGltW2ldLmNlbnRlcnldLFwidG9wXCI6W2RpbVtpXS5jZW50ZXJ4LGRpbVtpXS50b3BdLFwiYm90dG9tXCI6W2RpbVtpXS5jZW50ZXJ4LGRpbVtpXS5ib3R0b21dfTt9fSkoW1wic291cmNlXCIsXCJ0YXJnZXRcIl0sW3NkLHRkXSk7Zm9yKHZhciBzZj0wO3NmPGF4ZXMubGVuZ3RoO3NmKyspe2Zvcih2YXIgdGY9MDt0ZjxheGVzLmxlbmd0aDt0ZisrKXtjYW5kaWRhdGVzLnB1c2goe3NvdXJjZTpheGVzW3NmXSx0YXJnZXQ6YXhlc1t0Zl0sZGlzdDpCaWx0b25nLmxpbmVMZW5ndGgobWlkcG9pbnRzLnNvdXJjZVtheGVzW3NmXV0sbWlkcG9pbnRzLnRhcmdldFtheGVzW3RmXV0pfSk7fX1jYW5kaWRhdGVzLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5kaXN0PGIuZGlzdD8tMTphLmRpc3Q+Yi5kaXN0PzE6MDt9KTsvLyBub3cgZ28gdGhyb3VnaCB0aGlzIGxpc3QgYW5kIHRyeSB0byBnZXQgYW4gZW50cnkgdGhhdCBzYXRpc2ZpZXMgYm90aCAodGhlcmUgd2lsbCBiZSBvbmUsIHVubGVzcyBvbmUgb2YgdGhlIGFuY2hvcnNcbi8vIGRlY2xhcmVzIG5vIGF2YWlsYWJsZSBmYWNlcylcbnZhciBzb3VyY2VFZGdlPWNhbmRpZGF0ZXNbMF0uc291cmNlLHRhcmdldEVkZ2U9Y2FuZGlkYXRlc1swXS50YXJnZXQ7Zm9yKHZhciBpPTA7aTxjYW5kaWRhdGVzLmxlbmd0aDtpKyspe2lmKCFzb3VyY2VBbmNob3IuaXNDb250aW51b3VzfHxzb3VyY2VBbmNob3IuaXNFZGdlU3VwcG9ydGVkKGNhbmRpZGF0ZXNbaV0uc291cmNlKSl7c291cmNlRWRnZT1jYW5kaWRhdGVzW2ldLnNvdXJjZTt9ZWxzZXtzb3VyY2VFZGdlPW51bGw7fWlmKCF0YXJnZXRBbmNob3IuaXNDb250aW51b3VzfHx0YXJnZXRBbmNob3IuaXNFZGdlU3VwcG9ydGVkKGNhbmRpZGF0ZXNbaV0udGFyZ2V0KSl7dGFyZ2V0RWRnZT1jYW5kaWRhdGVzW2ldLnRhcmdldDt9ZWxzZXt0YXJnZXRFZGdlPW51bGw7fWlmKHNvdXJjZUVkZ2UhPW51bGwmJnRhcmdldEVkZ2UhPW51bGwpe2JyZWFrO319aWYoc291cmNlQW5jaG9yLmlzQ29udGludW91cyl7c291cmNlQW5jaG9yLnNldEN1cnJlbnRGYWNlKHNvdXJjZUVkZ2UpO31pZih0YXJnZXRBbmNob3IuaXNDb250aW51b3VzKXt0YXJnZXRBbmNob3Iuc2V0Q3VycmVudEZhY2UodGFyZ2V0RWRnZSk7fS8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5yZXR1cm57YTpbc291cmNlRWRnZSx0YXJnZXRFZGdlXSx0aGV0YTp0aGV0YSx0aGV0YTI6dGhldGEyfTt9LC8vIHVzZWQgYnkgcGxhY2VBbmNob3JzIGZ1bmN0aW9uXG5wbGFjZUFuY2hvcnNPbkxpbmU9ZnVuY3Rpb24gcGxhY2VBbmNob3JzT25MaW5lKGRlc2MsZWxlbWVudERpbWVuc2lvbnMsZWxlbWVudFBvc2l0aW9uLGNvbm5lY3Rpb25zLGhvcml6b250YWwsb3RoZXJNdWx0aXBsaWVyLHJldmVyc2Upe3ZhciBhPVtdLHN0ZXA9ZWxlbWVudERpbWVuc2lvbnNbaG9yaXpvbnRhbD8wOjFdLyhjb25uZWN0aW9ucy5sZW5ndGgrMSk7Zm9yKHZhciBpPTA7aTxjb25uZWN0aW9ucy5sZW5ndGg7aSsrKXt2YXIgdmFsPShpKzEpKnN0ZXAsb3RoZXI9b3RoZXJNdWx0aXBsaWVyKmVsZW1lbnREaW1lbnNpb25zW2hvcml6b250YWw/MTowXTtpZihyZXZlcnNlKXt2YWw9ZWxlbWVudERpbWVuc2lvbnNbaG9yaXpvbnRhbD8wOjFdLXZhbDt9dmFyIGR4PWhvcml6b250YWw/dmFsOm90aGVyLHg9ZWxlbWVudFBvc2l0aW9uWzBdK2R4LHhwPWR4L2VsZW1lbnREaW1lbnNpb25zWzBdLGR5PWhvcml6b250YWw/b3RoZXI6dmFsLHk9ZWxlbWVudFBvc2l0aW9uWzFdK2R5LHlwPWR5L2VsZW1lbnREaW1lbnNpb25zWzFdO2EucHVzaChbeCx5LHhwLHlwLGNvbm5lY3Rpb25zW2ldWzFdLGNvbm5lY3Rpb25zW2ldWzJdXSk7fXJldHVybiBhO30sLy8gdXNlZCBieSBlZGdlU29ydEZ1bmN0aW9uc1xuY3VycnlTb3J0PWZ1bmN0aW9uIGN1cnJ5U29ydChyZXZlcnNlQW5nbGVzKXtyZXR1cm4gZnVuY3Rpb24oYSxiKXt2YXIgcj10cnVlO2lmKHJldmVyc2VBbmdsZXMpe3I9YVswXVswXTxiWzBdWzBdO31lbHNle3I9YVswXVswXT5iWzBdWzBdO31yZXR1cm4gcj09PWZhbHNlPy0xOjE7fTt9LC8vIHVzZWQgYnkgZWRnZVNvcnRGdW5jdGlvbnNcbmxlZnRTb3J0PWZ1bmN0aW9uIGxlZnRTb3J0KGEsYil7Ly8gZmlyc3QgZ2V0IGFkanVzdGVkIHZhbHVlc1xudmFyIHAxPWFbMF1bMF08MD8tTWF0aC5QSS1hWzBdWzBdOk1hdGguUEktYVswXVswXSxwMj1iWzBdWzBdPDA/LU1hdGguUEktYlswXVswXTpNYXRoLlBJLWJbMF1bMF07aWYocDE+cDIpe3JldHVybiAxO31lbHNle3JldHVybi0xO319LC8vIHVzZWQgYnkgcGxhY2VBbmNob3JzXG5lZGdlU29ydEZ1bmN0aW9ucz17XCJ0b3BcIjpmdW5jdGlvbiB0b3AoYSxiKXtyZXR1cm4gYVswXT5iWzBdPzE6LTE7fSxcInJpZ2h0XCI6Y3VycnlTb3J0KHRydWUpLFwiYm90dG9tXCI6Y3VycnlTb3J0KHRydWUpLFwibGVmdFwiOmxlZnRTb3J0fSwvLyB1c2VkIGJ5IHBsYWNlQW5jaG9yc1xuX3NvcnRIZWxwZXI9ZnVuY3Rpb24gX3NvcnRIZWxwZXIoX2FycmF5LF9mbil7cmV0dXJuIF9hcnJheS5zb3J0KF9mbik7fSwvLyB1c2VkIGJ5IEFuY2hvck1hbmFnZXIucmVkcmF3XG5wbGFjZUFuY2hvcnM9ZnVuY3Rpb24gcGxhY2VBbmNob3JzKGVsZW1lbnRJZCxfYW5jaG9yTGlzdHMpe3ZhciBjZD1qc1BsdW1iSW5zdGFuY2UuZ2V0Q2FjaGVkRGF0YShlbGVtZW50SWQpLHNTPWNkLnMsc089Y2QubyxwbGFjZVNvbWVBbmNob3JzPWZ1bmN0aW9uIHBsYWNlU29tZUFuY2hvcnMoZGVzYyxlbGVtZW50RGltZW5zaW9ucyxlbGVtZW50UG9zaXRpb24sdW5zb3J0ZWRDb25uZWN0aW9ucyxpc0hvcml6b250YWwsb3RoZXJNdWx0aXBsaWVyLG9yaWVudGF0aW9uKXtpZih1bnNvcnRlZENvbm5lY3Rpb25zLmxlbmd0aD4wKXt2YXIgc2M9X3NvcnRIZWxwZXIodW5zb3J0ZWRDb25uZWN0aW9ucyxlZGdlU29ydEZ1bmN0aW9uc1tkZXNjXSksLy8gcHV0cyB0aGVtIGluIG9yZGVyIGJhc2VkIG9uIHRoZSB0YXJnZXQgZWxlbWVudCdzIHBvcyBvbiBzY3JlZW5cbnJldmVyc2U9ZGVzYz09PVwicmlnaHRcInx8ZGVzYz09PVwidG9wXCIsYW5jaG9ycz1wbGFjZUFuY2hvcnNPbkxpbmUoZGVzYyxlbGVtZW50RGltZW5zaW9ucyxlbGVtZW50UG9zaXRpb24sc2MsaXNIb3Jpem9udGFsLG90aGVyTXVsdGlwbGllcixyZXZlcnNlKTsvLyB0YWtlcyBhIGNvbXB1dGVkIGFuY2hvciBwb3NpdGlvbiBhbmQgYWRqdXN0cyBpdCBmb3IgcGFyZW50IG9mZnNldCBhbmQgc2Nyb2xsLCB0aGVuIHN0b3JlcyBpdC5cbnZhciBfc2V0QW5jaG9yTG9jYXRpb249ZnVuY3Rpb24gX3NldEFuY2hvckxvY2F0aW9uKGVuZHBvaW50LGFuY2hvclBvcyl7Y29udGludW91c0FuY2hvckxvY2F0aW9uc1tlbmRwb2ludC5pZF09W2FuY2hvclBvc1swXSxhbmNob3JQb3NbMV0sYW5jaG9yUG9zWzJdLGFuY2hvclBvc1szXV07Y29udGludW91c0FuY2hvck9yaWVudGF0aW9uc1tlbmRwb2ludC5pZF09b3JpZW50YXRpb247fTtmb3IodmFyIGk9MDtpPGFuY2hvcnMubGVuZ3RoO2krKyl7dmFyIGM9YW5jaG9yc1tpXVs0XSx3ZUFyZVNvdXJjZT1jLmVuZHBvaW50c1swXS5lbGVtZW50SWQ9PT1lbGVtZW50SWQsd2VBcmVUYXJnZXQ9Yy5lbmRwb2ludHNbMV0uZWxlbWVudElkPT09ZWxlbWVudElkO2lmKHdlQXJlU291cmNlKXtfc2V0QW5jaG9yTG9jYXRpb24oYy5lbmRwb2ludHNbMF0sYW5jaG9yc1tpXSk7fWlmKHdlQXJlVGFyZ2V0KXtfc2V0QW5jaG9yTG9jYXRpb24oYy5lbmRwb2ludHNbMV0sYW5jaG9yc1tpXSk7fX19fTtwbGFjZVNvbWVBbmNob3JzKFwiYm90dG9tXCIsc1MsW3NPLmxlZnQsc08udG9wXSxfYW5jaG9yTGlzdHMuYm90dG9tLHRydWUsMSxbMCwxXSk7cGxhY2VTb21lQW5jaG9ycyhcInRvcFwiLHNTLFtzTy5sZWZ0LHNPLnRvcF0sX2FuY2hvckxpc3RzLnRvcCx0cnVlLDAsWzAsLTFdKTtwbGFjZVNvbWVBbmNob3JzKFwibGVmdFwiLHNTLFtzTy5sZWZ0LHNPLnRvcF0sX2FuY2hvckxpc3RzLmxlZnQsZmFsc2UsMCxbLTEsMF0pO3BsYWNlU29tZUFuY2hvcnMoXCJyaWdodFwiLHNTLFtzTy5sZWZ0LHNPLnRvcF0sX2FuY2hvckxpc3RzLnJpZ2h0LGZhbHNlLDEsWzEsMF0pO307dGhpcy5yZXNldD1mdW5jdGlvbigpe19hbUVuZHBvaW50cz17fTtjb25uZWN0aW9uc0J5RWxlbWVudElkPXt9O2FuY2hvckxpc3RzPXt9O307dGhpcy5hZGRGbG9hdGluZ0Nvbm5lY3Rpb249ZnVuY3Rpb24oa2V5LGNvbm4pe2Zsb2F0aW5nQ29ubmVjdGlvbnNba2V5XT1jb25uO307dGhpcy5yZW1vdmVGbG9hdGluZ0Nvbm5lY3Rpb249ZnVuY3Rpb24oa2V5KXtkZWxldGUgZmxvYXRpbmdDb25uZWN0aW9uc1trZXldO307dGhpcy5uZXdDb25uZWN0aW9uPWZ1bmN0aW9uKGNvbm4pe3ZhciBzb3VyY2VJZD1jb25uLnNvdXJjZUlkLHRhcmdldElkPWNvbm4udGFyZ2V0SWQsZXA9Y29ubi5lbmRwb2ludHMsZG9SZWdpc3RlclRhcmdldD10cnVlLHJlZ2lzdGVyQ29ubmVjdGlvbj1mdW5jdGlvbiByZWdpc3RlckNvbm5lY3Rpb24ob3RoZXJJbmRleCxvdGhlckVuZHBvaW50LG90aGVyQW5jaG9yLGVsSWQsYyl7aWYoc291cmNlSWQ9PT10YXJnZXRJZCYmb3RoZXJBbmNob3IuaXNDb250aW51b3VzKXsvLyByZW1vdmUgdGhlIHRhcmdldCBlbmRwb2ludCdzIGNhbnZhcy4gIHdlIGRvbnQgbmVlZCBpdC5cbmNvbm4uX2pzUGx1bWIuaW5zdGFuY2UucmVtb3ZlRWxlbWVudChlcFsxXS5jYW52YXMpO2RvUmVnaXN0ZXJUYXJnZXQ9ZmFsc2U7fV9qdS5hZGRUb0xpc3QoY29ubmVjdGlvbnNCeUVsZW1lbnRJZCxlbElkLFtjLG90aGVyRW5kcG9pbnQsb3RoZXJBbmNob3IuY29uc3RydWN0b3I9PT1fanAuRHluYW1pY0FuY2hvcl0pO307cmVnaXN0ZXJDb25uZWN0aW9uKDAsZXBbMF0sZXBbMF0uYW5jaG9yLHRhcmdldElkLGNvbm4pO2lmKGRvUmVnaXN0ZXJUYXJnZXQpe3JlZ2lzdGVyQ29ubmVjdGlvbigxLGVwWzFdLGVwWzFdLmFuY2hvcixzb3VyY2VJZCxjb25uKTt9fTt2YXIgcmVtb3ZlRW5kcG9pbnRGcm9tQW5jaG9yTGlzdHM9ZnVuY3Rpb24gcmVtb3ZlRW5kcG9pbnRGcm9tQW5jaG9yTGlzdHMoZW5kcG9pbnQpeyhmdW5jdGlvbihsaXN0LGVJZCl7aWYobGlzdCl7Ly8gdHJhbnNpZW50IGFuY2hvcnMgZG9udCBnZXQgZW50cmllcyBpbiB0aGlzIGxpc3QuXG52YXIgZj1mdW5jdGlvbiBmKGUpe3JldHVybiBlWzRdPT09ZUlkO307X2p1LnJlbW92ZVdpdGhGdW5jdGlvbihsaXN0LnRvcCxmKTtfanUucmVtb3ZlV2l0aEZ1bmN0aW9uKGxpc3QubGVmdCxmKTtfanUucmVtb3ZlV2l0aEZ1bmN0aW9uKGxpc3QuYm90dG9tLGYpO19qdS5yZW1vdmVXaXRoRnVuY3Rpb24obGlzdC5yaWdodCxmKTt9fSkoYW5jaG9yTGlzdHNbZW5kcG9pbnQuZWxlbWVudElkXSxlbmRwb2ludC5pZCk7fTt0aGlzLmNvbm5lY3Rpb25EZXRhY2hlZD1mdW5jdGlvbihjb25uSW5mbyxkb05vdFJlZHJhdyl7dmFyIGNvbm5lY3Rpb249Y29ubkluZm8uY29ubmVjdGlvbnx8Y29ubkluZm8sc291cmNlSWQ9Y29ubkluZm8uc291cmNlSWQsdGFyZ2V0SWQ9Y29ubkluZm8udGFyZ2V0SWQsZXA9Y29ubmVjdGlvbi5lbmRwb2ludHMscmVtb3ZlQ29ubmVjdGlvbj1mdW5jdGlvbiByZW1vdmVDb25uZWN0aW9uKG90aGVySW5kZXgsb3RoZXJFbmRwb2ludCxvdGhlckFuY2hvcixlbElkLGMpe19qdS5yZW1vdmVXaXRoRnVuY3Rpb24oY29ubmVjdGlvbnNCeUVsZW1lbnRJZFtlbElkXSxmdW5jdGlvbihfYyl7cmV0dXJuIF9jWzBdLmlkPT09Yy5pZDt9KTt9O3JlbW92ZUNvbm5lY3Rpb24oMSxlcFsxXSxlcFsxXS5hbmNob3Isc291cmNlSWQsY29ubmVjdGlvbik7cmVtb3ZlQ29ubmVjdGlvbigwLGVwWzBdLGVwWzBdLmFuY2hvcix0YXJnZXRJZCxjb25uZWN0aW9uKTtpZihjb25uZWN0aW9uLmZsb2F0aW5nSWQpe3JlbW92ZUNvbm5lY3Rpb24oY29ubmVjdGlvbi5mbG9hdGluZ0luZGV4LGNvbm5lY3Rpb24uZmxvYXRpbmdFbmRwb2ludCxjb25uZWN0aW9uLmZsb2F0aW5nRW5kcG9pbnQuYW5jaG9yLGNvbm5lY3Rpb24uZmxvYXRpbmdJZCxjb25uZWN0aW9uKTtyZW1vdmVFbmRwb2ludEZyb21BbmNob3JMaXN0cyhjb25uZWN0aW9uLmZsb2F0aW5nRW5kcG9pbnQpO30vLyByZW1vdmUgZnJvbSBhbmNob3JMaXN0cyAgICAgICAgICAgIFxucmVtb3ZlRW5kcG9pbnRGcm9tQW5jaG9yTGlzdHMoY29ubmVjdGlvbi5lbmRwb2ludHNbMF0pO3JlbW92ZUVuZHBvaW50RnJvbUFuY2hvckxpc3RzKGNvbm5lY3Rpb24uZW5kcG9pbnRzWzFdKTtpZighZG9Ob3RSZWRyYXcpe3NlbGYucmVkcmF3KGNvbm5lY3Rpb24uc291cmNlSWQpO2lmKGNvbm5lY3Rpb24udGFyZ2V0SWQhPT1jb25uZWN0aW9uLnNvdXJjZUlkKXtzZWxmLnJlZHJhdyhjb25uZWN0aW9uLnRhcmdldElkKTt9fX07dGhpcy5hZGQ9ZnVuY3Rpb24oZW5kcG9pbnQsZWxlbWVudElkKXtfanUuYWRkVG9MaXN0KF9hbUVuZHBvaW50cyxlbGVtZW50SWQsZW5kcG9pbnQpO307dGhpcy5jaGFuZ2VJZD1mdW5jdGlvbihvbGRJZCxuZXdJZCl7Y29ubmVjdGlvbnNCeUVsZW1lbnRJZFtuZXdJZF09Y29ubmVjdGlvbnNCeUVsZW1lbnRJZFtvbGRJZF07X2FtRW5kcG9pbnRzW25ld0lkXT1fYW1FbmRwb2ludHNbb2xkSWRdO2RlbGV0ZSBjb25uZWN0aW9uc0J5RWxlbWVudElkW29sZElkXTtkZWxldGUgX2FtRW5kcG9pbnRzW29sZElkXTt9O3RoaXMuZ2V0Q29ubmVjdGlvbnNGb3I9ZnVuY3Rpb24oZWxlbWVudElkKXtyZXR1cm4gY29ubmVjdGlvbnNCeUVsZW1lbnRJZFtlbGVtZW50SWRdfHxbXTt9O3RoaXMuZ2V0RW5kcG9pbnRzRm9yPWZ1bmN0aW9uKGVsZW1lbnRJZCl7cmV0dXJuIF9hbUVuZHBvaW50c1tlbGVtZW50SWRdfHxbXTt9O3RoaXMuZGVsZXRlRW5kcG9pbnQ9ZnVuY3Rpb24oZW5kcG9pbnQpe19qdS5yZW1vdmVXaXRoRnVuY3Rpb24oX2FtRW5kcG9pbnRzW2VuZHBvaW50LmVsZW1lbnRJZF0sZnVuY3Rpb24oZSl7cmV0dXJuIGUuaWQ9PT1lbmRwb2ludC5pZDt9KTtyZW1vdmVFbmRwb2ludEZyb21BbmNob3JMaXN0cyhlbmRwb2ludCk7fTt0aGlzLmNsZWFyRm9yPWZ1bmN0aW9uKGVsZW1lbnRJZCl7ZGVsZXRlIF9hbUVuZHBvaW50c1tlbGVtZW50SWRdO19hbUVuZHBvaW50c1tlbGVtZW50SWRdPVtdO307Ly8gdXBkYXRlcyB0aGUgZ2l2ZW4gYW5jaG9yIGxpc3QgYnkgZWl0aGVyIHVwZGF0aW5nIGFuIGV4aXN0aW5nIGFuY2hvcidzIGluZm8sIG9yIGFkZGluZyBpdC4gdGhpcyBmdW5jdGlvblxuLy8gYWxzbyByZW1vdmVzIHRoZSBhbmNob3IgZnJvbSBpdHMgcHJldmlvdXMgbGlzdCwgaWYgdGhlIGVkZ2UgaXQgaXMgb24gaGFzIGNoYW5nZWQuXG4vLyBhbGwgY29ubmVjdGlvbnMgZm91bmQgYWxvbmcgdGhlIHdheSAodGhvc2UgdGhhdCBhcmUgY29ubmVjdGVkIHRvIG9uZSBvZiB0aGUgZmFjZXMgdGhpcyBmdW5jdGlvblxuLy8gb3BlcmF0ZXMgb24pIGFyZSBhZGRlZCB0byB0aGUgY29ubnNUb1BhaW50IGxpc3QsIGFzIGFyZSB0aGVpciBlbmRwb2ludHMuIGluIHRoaXMgd2F5IHdlIGtub3cgdG8gcmVwYWludFxuLy8gdGhlbSB3dGhvdXQgaGF2aW5nIHRvIGNhbGN1bGF0ZSBhbnl0aGluZyBlbHNlIGFib3V0IHRoZW0uXG52YXIgX3VwZGF0ZUFuY2hvckxpc3Q9ZnVuY3Rpb24gX3VwZGF0ZUFuY2hvckxpc3QobGlzdHMsdGhldGEsb3JkZXIsY29ubixhQm9vbGVhbixvdGhlckVsSWQsaWR4LHJldmVyc2UsZWRnZUlkLGVsSWQsY29ubnNUb1BhaW50LGVuZHBvaW50c1RvUGFpbnQpey8vIGZpcnN0IHRyeSB0byBmaW5kIHRoZSBleGFjdCBtYXRjaCwgYnV0IGtlZXAgdHJhY2sgb2YgdGhlIGZpcnN0IGluZGV4IG9mIGEgbWF0Y2hpbmcgZWxlbWVudCBpZCBhbG9uZyB0aGUgd2F5LnNcbnZhciBleGFjdElkeD0tMSxmaXJzdE1hdGNoaW5nRWxJZHg9LTEsZW5kcG9pbnQ9Y29ubi5lbmRwb2ludHNbaWR4XSxlbmRwb2ludElkPWVuZHBvaW50LmlkLG9JZHg9WzEsMF1baWR4XSx2YWx1ZXM9W1t0aGV0YSxvcmRlcl0sY29ubixhQm9vbGVhbixvdGhlckVsSWQsZW5kcG9pbnRJZF0sbGlzdFRvQWRkVG89bGlzdHNbZWRnZUlkXSxsaXN0VG9SZW1vdmVGcm9tPWVuZHBvaW50Ll9jb250aW51b3VzQW5jaG9yRWRnZT9saXN0c1tlbmRwb2ludC5fY29udGludW91c0FuY2hvckVkZ2VdOm51bGwsaSxjYW5kaWRhdGU7aWYobGlzdFRvUmVtb3ZlRnJvbSl7dmFyIHJJZHg9X2p1LmZpbmRXaXRoRnVuY3Rpb24obGlzdFRvUmVtb3ZlRnJvbSxmdW5jdGlvbihlKXtyZXR1cm4gZVs0XT09PWVuZHBvaW50SWQ7fSk7aWYocklkeCE9PS0xKXtsaXN0VG9SZW1vdmVGcm9tLnNwbGljZShySWR4LDEpOy8vIGdldCBhbGwgY29ubmVjdGlvbnMgZnJvbSB0aGlzIGxpc3RcbmZvcihpPTA7aTxsaXN0VG9SZW1vdmVGcm9tLmxlbmd0aDtpKyspe2NhbmRpZGF0ZT1saXN0VG9SZW1vdmVGcm9tW2ldWzFdO19qdS5hZGRXaXRoRnVuY3Rpb24oY29ubnNUb1BhaW50LGNhbmRpZGF0ZSxmdW5jdGlvbihjKXtyZXR1cm4gYy5pZD09PWNhbmRpZGF0ZS5pZDt9KTtfanUuYWRkV2l0aEZ1bmN0aW9uKGVuZHBvaW50c1RvUGFpbnQsbGlzdFRvUmVtb3ZlRnJvbVtpXVsxXS5lbmRwb2ludHNbaWR4XSxmdW5jdGlvbihlKXtyZXR1cm4gZS5pZD09PWNhbmRpZGF0ZS5lbmRwb2ludHNbaWR4XS5pZDt9KTtfanUuYWRkV2l0aEZ1bmN0aW9uKGVuZHBvaW50c1RvUGFpbnQsbGlzdFRvUmVtb3ZlRnJvbVtpXVsxXS5lbmRwb2ludHNbb0lkeF0sZnVuY3Rpb24oZSl7cmV0dXJuIGUuaWQ9PT1jYW5kaWRhdGUuZW5kcG9pbnRzW29JZHhdLmlkO30pO319fWZvcihpPTA7aTxsaXN0VG9BZGRUby5sZW5ndGg7aSsrKXtjYW5kaWRhdGU9bGlzdFRvQWRkVG9baV1bMV07aWYocGFyYW1zLmlkeD09PTEmJmxpc3RUb0FkZFRvW2ldWzNdPT09b3RoZXJFbElkJiZmaXJzdE1hdGNoaW5nRWxJZHg9PT0tMSl7Zmlyc3RNYXRjaGluZ0VsSWR4PWk7fV9qdS5hZGRXaXRoRnVuY3Rpb24oY29ubnNUb1BhaW50LGNhbmRpZGF0ZSxmdW5jdGlvbihjKXtyZXR1cm4gYy5pZD09PWNhbmRpZGF0ZS5pZDt9KTtfanUuYWRkV2l0aEZ1bmN0aW9uKGVuZHBvaW50c1RvUGFpbnQsbGlzdFRvQWRkVG9baV1bMV0uZW5kcG9pbnRzW2lkeF0sZnVuY3Rpb24oZSl7cmV0dXJuIGUuaWQ9PT1jYW5kaWRhdGUuZW5kcG9pbnRzW2lkeF0uaWQ7fSk7X2p1LmFkZFdpdGhGdW5jdGlvbihlbmRwb2ludHNUb1BhaW50LGxpc3RUb0FkZFRvW2ldWzFdLmVuZHBvaW50c1tvSWR4XSxmdW5jdGlvbihlKXtyZXR1cm4gZS5pZD09PWNhbmRpZGF0ZS5lbmRwb2ludHNbb0lkeF0uaWQ7fSk7fWlmKGV4YWN0SWR4IT09LTEpe2xpc3RUb0FkZFRvW2V4YWN0SWR4XT12YWx1ZXM7fWVsc2V7dmFyIGluc2VydElkeD1yZXZlcnNlP2ZpcnN0TWF0Y2hpbmdFbElkeCE9PS0xP2ZpcnN0TWF0Y2hpbmdFbElkeDowOmxpc3RUb0FkZFRvLmxlbmd0aDsvLyBvZiBjb3Vyc2Ugd2Ugd2lsbCBnZXQgdGhpcyBmcm9tIGhhdmluZyBsb29rZWQgdGhyb3VnaCB0aGUgYXJyYXkgc2hvcnRseS5cbmxpc3RUb0FkZFRvLnNwbGljZShpbnNlcnRJZHgsMCx2YWx1ZXMpO30vLyBzdG9yZSB0aGlzIGZvciBuZXh0IHRpbWUuXG5lbmRwb2ludC5fY29udGludW91c0FuY2hvckVkZ2U9ZWRnZUlkO307Ly9cbi8vIGZpbmQgdGhlIGVudHJ5IGluIGFuIGVuZHBvaW50J3MgbGlzdCBmb3IgdGhpcyBjb25uZWN0aW9uIGFuZCB1cGRhdGUgaXRzIHRhcmdldCBlbmRwb2ludFxuLy8gd2l0aCB0aGUgY3VycmVudCB0YXJnZXQgaW4gdGhlIGNvbm5lY3Rpb24uXG4vLyBUaGlzIG1ldGhvZCBhbmQgc291cmNlQ2hhbmdlZCBuZWVkIHRvIGJlIGZvbGRlciBpbnRvIG9uZS5cbi8vXG50aGlzLnVwZGF0ZU90aGVyRW5kcG9pbnQ9ZnVuY3Rpb24oc291cmNlRWxJZCxvbGRUYXJnZXRJZCxuZXdUYXJnZXRJZCxjb25uZWN0aW9uKXt2YXIgc0luZGV4PV9qdS5maW5kV2l0aEZ1bmN0aW9uKGNvbm5lY3Rpb25zQnlFbGVtZW50SWRbc291cmNlRWxJZF0sZnVuY3Rpb24oaSl7cmV0dXJuIGlbMF0uaWQ9PT1jb25uZWN0aW9uLmlkO30pLHRJbmRleD1fanUuZmluZFdpdGhGdW5jdGlvbihjb25uZWN0aW9uc0J5RWxlbWVudElkW29sZFRhcmdldElkXSxmdW5jdGlvbihpKXtyZXR1cm4gaVswXS5pZD09PWNvbm5lY3Rpb24uaWQ7fSk7Ly8gdXBkYXRlIG9yIGFkZCBkYXRhIGZvciBzb3VyY2VcbmlmKHNJbmRleCE9PS0xKXtjb25uZWN0aW9uc0J5RWxlbWVudElkW3NvdXJjZUVsSWRdW3NJbmRleF1bMF09Y29ubmVjdGlvbjtjb25uZWN0aW9uc0J5RWxlbWVudElkW3NvdXJjZUVsSWRdW3NJbmRleF1bMV09Y29ubmVjdGlvbi5lbmRwb2ludHNbMV07Y29ubmVjdGlvbnNCeUVsZW1lbnRJZFtzb3VyY2VFbElkXVtzSW5kZXhdWzJdPWNvbm5lY3Rpb24uZW5kcG9pbnRzWzFdLmFuY2hvci5jb25zdHJ1Y3Rvcj09PV9qcC5EeW5hbWljQW5jaG9yO30vLyByZW1vdmUgZW50cnkgZm9yIHByZXZpb3VzIHRhcmdldCAoaWYgdGhlcmUpXG5pZih0SW5kZXg+LTEpe2Nvbm5lY3Rpb25zQnlFbGVtZW50SWRbb2xkVGFyZ2V0SWRdLnNwbGljZSh0SW5kZXgsMSk7Ly8gYWRkIGVudHJ5IGZvciBuZXcgdGFyZ2V0XG5fanUuYWRkVG9MaXN0KGNvbm5lY3Rpb25zQnlFbGVtZW50SWQsbmV3VGFyZ2V0SWQsW2Nvbm5lY3Rpb24sY29ubmVjdGlvbi5lbmRwb2ludHNbMF0sY29ubmVjdGlvbi5lbmRwb2ludHNbMF0uYW5jaG9yLmNvbnN0cnVjdG9yPT09X2pwLkR5bmFtaWNBbmNob3JdKTt9Y29ubmVjdGlvbi51cGRhdGVDb25uZWN0ZWRDbGFzcygpO307Ly9cbi8vIG5vdGlmaWNhdGlvbiB0aGF0IHRoZSBjb25uZWN0aW9uIGdpdmVuIGhhcyBjaGFuZ2VkIHNvdXJjZSBmcm9tIHRoZSBvcmlnaW5hbElkIHRvIHRoZSBuZXdJZC5cbi8vIFRoaXMgaW52b2x2ZXM6XG4vLyAxLiByZW1vdmluZyB0aGUgY29ubmVjdGlvbiBmcm9tIHRoZSBsaXN0IG9mIGNvbm5lY3Rpb25zIHN0b3JlZCBmb3IgdGhlIG9yaWdpbmFsSWRcbi8vIDIuIHVwZGF0aW5nIHRoZSBzb3VyY2UgaW5mb3JtYXRpb24gZm9yIHRoZSB0YXJnZXQgb2YgdGhlIGNvbm5lY3Rpb25cbi8vIDMuIHJlLXJlZ2lzdGVyaW5nIHRoZSBjb25uZWN0aW9uIGluIGNvbm5lY3Rpb25zQnlFbGVtZW50SWQgd2l0aCB0aGUgbmV3SWRcbi8vXG50aGlzLnNvdXJjZUNoYW5nZWQ9ZnVuY3Rpb24ob3JpZ2luYWxJZCxuZXdJZCxjb25uZWN0aW9uLG5ld0VsZW1lbnQpe2lmKG9yaWdpbmFsSWQhPT1uZXdJZCl7Y29ubmVjdGlvbi5zb3VyY2VJZD1uZXdJZDtjb25uZWN0aW9uLnNvdXJjZT1uZXdFbGVtZW50Oy8vIHJlbW92ZSB0aGUgZW50cnkgdGhhdCBwb2ludHMgZnJvbSB0aGUgb2xkIHNvdXJjZSB0byB0aGUgdGFyZ2V0XG5fanUucmVtb3ZlV2l0aEZ1bmN0aW9uKGNvbm5lY3Rpb25zQnlFbGVtZW50SWRbb3JpZ2luYWxJZF0sZnVuY3Rpb24oaW5mbyl7cmV0dXJuIGluZm9bMF0uaWQ9PT1jb25uZWN0aW9uLmlkO30pOy8vIGZpbmQgZW50cnkgZm9yIHRhcmdldCBhbmQgdXBkYXRlIGl0XG52YXIgdElkeD1fanUuZmluZFdpdGhGdW5jdGlvbihjb25uZWN0aW9uc0J5RWxlbWVudElkW2Nvbm5lY3Rpb24udGFyZ2V0SWRdLGZ1bmN0aW9uKGkpe3JldHVybiBpWzBdLmlkPT09Y29ubmVjdGlvbi5pZDt9KTtpZih0SWR4Pi0xKXtjb25uZWN0aW9uc0J5RWxlbWVudElkW2Nvbm5lY3Rpb24udGFyZ2V0SWRdW3RJZHhdWzBdPWNvbm5lY3Rpb247Y29ubmVjdGlvbnNCeUVsZW1lbnRJZFtjb25uZWN0aW9uLnRhcmdldElkXVt0SWR4XVsxXT1jb25uZWN0aW9uLmVuZHBvaW50c1swXTtjb25uZWN0aW9uc0J5RWxlbWVudElkW2Nvbm5lY3Rpb24udGFyZ2V0SWRdW3RJZHhdWzJdPWNvbm5lY3Rpb24uZW5kcG9pbnRzWzBdLmFuY2hvci5jb25zdHJ1Y3Rvcj09PV9qcC5EeW5hbWljQW5jaG9yO30vLyBhZGQgZW50cnkgZm9yIG5ldyBzb3VyY2Vcbl9qdS5hZGRUb0xpc3QoY29ubmVjdGlvbnNCeUVsZW1lbnRJZCxuZXdJZCxbY29ubmVjdGlvbixjb25uZWN0aW9uLmVuZHBvaW50c1sxXSxjb25uZWN0aW9uLmVuZHBvaW50c1sxXS5hbmNob3IuY29uc3RydWN0b3I9PT1fanAuRHluYW1pY0FuY2hvcl0pOy8vIFRPRE8gU1Agbm90IGZpbmFsIG9uIHRoaXMgeWV0LiB3aGVuIGEgdXNlciBkcmFncyBhbiBleGlzdGluZyBjb25uZWN0aW9uIGFuZCBpdCB0dXJucyBpbnRvIGEgc2VsZlxuLy8gbG9vcCwgdGhlbiB0aGlzIGNvZGUgaGlkZXMgdGhlIHRhcmdldCBlbmRwb2ludCAoYnkgcmVtb3ZpbmcgaXQgZnJvbSB0aGUgRE9NKSBCdXQgSSB0aGluayB0aGlzIHNob3VsZFxuLy8gb2NjdXIgb25seSBpZiB0aGUgYW5jaG9yIGlzIENvbnRpbnVvdXNcbmlmKGNvbm5lY3Rpb24uZW5kcG9pbnRzWzFdLmFuY2hvci5pc0NvbnRpbnVvdXMpe2lmKGNvbm5lY3Rpb24uc291cmNlPT09Y29ubmVjdGlvbi50YXJnZXQpe2Nvbm5lY3Rpb24uX2pzUGx1bWIuaW5zdGFuY2UucmVtb3ZlRWxlbWVudChjb25uZWN0aW9uLmVuZHBvaW50c1sxXS5jYW52YXMpO31lbHNle2lmKGNvbm5lY3Rpb24uZW5kcG9pbnRzWzFdLmNhbnZhcy5wYXJlbnROb2RlPT1udWxsKXtjb25uZWN0aW9uLl9qc1BsdW1iLmluc3RhbmNlLmFwcGVuZEVsZW1lbnQoY29ubmVjdGlvbi5lbmRwb2ludHNbMV0uY2FudmFzKTt9fX1jb25uZWN0aW9uLnVwZGF0ZUNvbm5lY3RlZENsYXNzKCk7fX07Ly9cbi8vIG1vdmVzIHRoZSBnaXZlbiBlbmRwb2ludCBmcm9tIGBjdXJyZW50SWRgIHRvIGBlbGVtZW50YC5cbi8vIFRoaXMgaW52b2x2ZXM6XG4vL1xuLy8gMS4gY2hhbmdpbmcgdGhlIGtleSBpbiBfYW1FbmRwb2ludHMgdW5kZXIgd2hpY2ggdGhlIGVuZHBvaW50IGlzIHN0b3JlZFxuLy8gMi4gY2hhbmdpbmcgdGhlIHNvdXJjZSBvciB0YXJnZXQgdmFsdWVzIGluIGFsbCBvZiB0aGUgZW5kcG9pbnQncyBjb25uZWN0aW9uc1xuLy8gMy4gY2hhbmdpbmcgdGhlIGFycmF5IGluIGNvbm5lY3Rpb25zQnlFbGVtZW50SWQgaW4gd2hpY2ggdGhlIGVuZHBvaW50J3MgY29ubmVjdGlvbnNcbi8vICAgIGFyZSBzdG9yZWQgKGRvbmUgYnkgZWl0aGVyIHNvdXJjZUNoYW5nZWQgb3IgdXBkYXRlT3RoZXJFbmRwb2ludClcbi8vXG50aGlzLnJlaG9tZUVuZHBvaW50PWZ1bmN0aW9uKGVwLGN1cnJlbnRJZCxlbGVtZW50KXt2YXIgZXBzPV9hbUVuZHBvaW50c1tjdXJyZW50SWRdfHxbXSxlbGVtZW50SWQ9anNQbHVtYkluc3RhbmNlLmdldElkKGVsZW1lbnQpO2lmKGVsZW1lbnRJZCE9PWN1cnJlbnRJZCl7dmFyIGlkeD1lcHMuaW5kZXhPZihlcCk7aWYoaWR4Pi0xKXt2YXIgX2VwPWVwcy5zcGxpY2UoaWR4LDEpWzBdO3NlbGYuYWRkKF9lcCxlbGVtZW50SWQpO319Zm9yKHZhciBpPTA7aTxlcC5jb25uZWN0aW9ucy5sZW5ndGg7aSsrKXtpZihlcC5jb25uZWN0aW9uc1tpXS5zb3VyY2VJZD09PWN1cnJlbnRJZCl7c2VsZi5zb3VyY2VDaGFuZ2VkKGN1cnJlbnRJZCxlcC5lbGVtZW50SWQsZXAuY29ubmVjdGlvbnNbaV0sZXAuZWxlbWVudCk7fWVsc2UgaWYoZXAuY29ubmVjdGlvbnNbaV0udGFyZ2V0SWQ9PT1jdXJyZW50SWQpe2VwLmNvbm5lY3Rpb25zW2ldLnRhcmdldElkPWVwLmVsZW1lbnRJZDtlcC5jb25uZWN0aW9uc1tpXS50YXJnZXQ9ZXAuZWxlbWVudDtzZWxmLnVwZGF0ZU90aGVyRW5kcG9pbnQoZXAuY29ubmVjdGlvbnNbaV0uc291cmNlSWQsY3VycmVudElkLGVwLmVsZW1lbnRJZCxlcC5jb25uZWN0aW9uc1tpXSk7fX19O3RoaXMucmVkcmF3PWZ1bmN0aW9uKGVsZW1lbnRJZCx1aSx0aW1lc3RhbXAsb2Zmc2V0VG9VSSxjbGVhckVkaXRzLGRvTm90UmVjYWxjRW5kcG9pbnQpe2lmKCFqc1BsdW1iSW5zdGFuY2UuaXNTdXNwZW5kRHJhd2luZygpKXsvLyBnZXQgYWxsIHRoZSBlbmRwb2ludHMgZm9yIHRoaXMgZWxlbWVudFxudmFyIGVwPV9hbUVuZHBvaW50c1tlbGVtZW50SWRdfHxbXSxlbmRwb2ludENvbm5lY3Rpb25zPWNvbm5lY3Rpb25zQnlFbGVtZW50SWRbZWxlbWVudElkXXx8W10sY29ubmVjdGlvbnNUb1BhaW50PVtdLGVuZHBvaW50c1RvUGFpbnQ9W10sYW5jaG9yc1RvVXBkYXRlPVtdO3RpbWVzdGFtcD10aW1lc3RhbXB8fGpzUGx1bWJJbnN0YW5jZS50aW1lc3RhbXAoKTsvLyBvZmZzZXRUb1VJIGFyZSB2YWx1ZXMgdGhhdCB3b3VsZCBoYXZlIGJlZW4gY2FsY3VsYXRlZCBpbiB0aGUgZHJhZ01hbmFnZXIgd2hlbiByZWdpc3RlcmluZ1xuLy8gYW4gZW5kcG9pbnQgZm9yIGFuIGVsZW1lbnQgdGhhdCBoYWQgYSBwYXJlbnQgKHNvbWV3aGVyZSBpbiB0aGUgaGllcmFyY2h5KSB0aGF0IGhhZCBiZWVuXG4vLyByZWdpc3RlcmVkIGFzIGRyYWdnYWJsZS5cbm9mZnNldFRvVUk9b2Zmc2V0VG9VSXx8e2xlZnQ6MCx0b3A6MH07aWYodWkpe3VpPXtsZWZ0OnVpLmxlZnQrb2Zmc2V0VG9VSS5sZWZ0LHRvcDp1aS50b3Arb2Zmc2V0VG9VSS50b3B9O30vLyB2YWxpZCBmb3Igb25lIHBhaW50IGN5Y2xlLlxudmFyIG15T2Zmc2V0PWpzUGx1bWJJbnN0YW5jZS51cGRhdGVPZmZzZXQoe2VsSWQ6ZWxlbWVudElkLG9mZnNldDp1aSxyZWNhbGM6ZmFsc2UsdGltZXN0YW1wOnRpbWVzdGFtcH0pLG9yaWVudGF0aW9uQ2FjaGU9e307Ly8gYWN0dWFsbHksIGZpcnN0IHdlIHNob3VsZCBjb21wdXRlIHRoZSBvcmllbnRhdGlvbiBvZiB0aGlzIGVsZW1lbnQgdG8gYWxsIG90aGVyIGVsZW1lbnRzIHRvIHdoaWNoXG4vLyB0aGlzIGVsZW1lbnQgaXMgY29ubmVjdGVkIHdpdGggYSBjb250aW51b3VzIGFuY2hvciAod2hldGhlciBib3RoIGVuZHMgb2YgdGhlIGNvbm5lY3Rpb24gaGF2ZVxuLy8gYSBjb250aW51b3VzIGFuY2hvciBvciBqdXN0IG9uZSlcbmZvcih2YXIgaT0wO2k8ZW5kcG9pbnRDb25uZWN0aW9ucy5sZW5ndGg7aSsrKXt2YXIgY29ubj1lbmRwb2ludENvbm5lY3Rpb25zW2ldWzBdLHNvdXJjZUlkPWNvbm4uc291cmNlSWQsdGFyZ2V0SWQ9Y29ubi50YXJnZXRJZCxzb3VyY2VDb250aW51b3VzPWNvbm4uZW5kcG9pbnRzWzBdLmFuY2hvci5pc0NvbnRpbnVvdXMsdGFyZ2V0Q29udGludW91cz1jb25uLmVuZHBvaW50c1sxXS5hbmNob3IuaXNDb250aW51b3VzO2lmKHNvdXJjZUNvbnRpbnVvdXN8fHRhcmdldENvbnRpbnVvdXMpe3ZhciBvS2V5PXNvdXJjZUlkK1wiX1wiK3RhcmdldElkLG89b3JpZW50YXRpb25DYWNoZVtvS2V5XSxvSWR4PWNvbm4uc291cmNlSWQ9PT1lbGVtZW50SWQ/MTowO2lmKHNvdXJjZUNvbnRpbnVvdXMmJiFhbmNob3JMaXN0c1tzb3VyY2VJZF0pe2FuY2hvckxpc3RzW3NvdXJjZUlkXT17dG9wOltdLHJpZ2h0OltdLGJvdHRvbTpbXSxsZWZ0OltdfTt9aWYodGFyZ2V0Q29udGludW91cyYmIWFuY2hvckxpc3RzW3RhcmdldElkXSl7YW5jaG9yTGlzdHNbdGFyZ2V0SWRdPXt0b3A6W10scmlnaHQ6W10sYm90dG9tOltdLGxlZnQ6W119O31pZihlbGVtZW50SWQhPT10YXJnZXRJZCl7anNQbHVtYkluc3RhbmNlLnVwZGF0ZU9mZnNldCh7ZWxJZDp0YXJnZXRJZCx0aW1lc3RhbXA6dGltZXN0YW1wfSk7fWlmKGVsZW1lbnRJZCE9PXNvdXJjZUlkKXtqc1BsdW1iSW5zdGFuY2UudXBkYXRlT2Zmc2V0KHtlbElkOnNvdXJjZUlkLHRpbWVzdGFtcDp0aW1lc3RhbXB9KTt9dmFyIHRkPWpzUGx1bWJJbnN0YW5jZS5nZXRDYWNoZWREYXRhKHRhcmdldElkKSxzZD1qc1BsdW1iSW5zdGFuY2UuZ2V0Q2FjaGVkRGF0YShzb3VyY2VJZCk7aWYodGFyZ2V0SWQ9PT1zb3VyY2VJZCYmKHNvdXJjZUNvbnRpbnVvdXN8fHRhcmdldENvbnRpbnVvdXMpKXsvLyBoZXJlIHdlIG1heSB3YW50IHRvIGltcHJvdmUgdGhpcyBieSBzb21laG93IGRldGVybWluaW5nIHRoZSBmYWNlIHdlJ2QgbGlrZVxuLy8gdG8gcHV0IHRoZSBjb25uZWN0b3Igb24uICBpZGVhbGx5LCB3aGVuIGRyYXdpbmcsIHRoZSBmYWNlIHNob3VsZCBiZSBjYWxjdWxhdGVkXG4vLyBieSBkZXRlcm1pbmluZyB3aGljaCBmYWNlIGlzIGNsb3Nlc3QgdG8gdGhlIHBvaW50IGF0IHdoaWNoIHRoZSBtb3VzZSBidXR0b25cbi8vIHdhcyByZWxlYXNlZC4gIGZvciBub3csIHdlJ3JlIHB1dHRpbmcgaXQgb24gdGhlIHRvcCBmYWNlLlxuX3VwZGF0ZUFuY2hvckxpc3QoYW5jaG9yTGlzdHNbc291cmNlSWRdLC1NYXRoLlBJLzIsMCxjb25uLGZhbHNlLHRhcmdldElkLDAsZmFsc2UsXCJ0b3BcIixzb3VyY2VJZCxjb25uZWN0aW9uc1RvUGFpbnQsZW5kcG9pbnRzVG9QYWludCk7X3VwZGF0ZUFuY2hvckxpc3QoYW5jaG9yTGlzdHNbdGFyZ2V0SWRdLC1NYXRoLlBJLzIsMCxjb25uLGZhbHNlLHNvdXJjZUlkLDEsZmFsc2UsXCJ0b3BcIix0YXJnZXRJZCxjb25uZWN0aW9uc1RvUGFpbnQsZW5kcG9pbnRzVG9QYWludCk7fWVsc2V7aWYoIW8pe289Y2FsY3VsYXRlT3JpZW50YXRpb24oc291cmNlSWQsdGFyZ2V0SWQsc2Qubyx0ZC5vLGNvbm4uZW5kcG9pbnRzWzBdLmFuY2hvcixjb25uLmVuZHBvaW50c1sxXS5hbmNob3IpO29yaWVudGF0aW9uQ2FjaGVbb0tleV09bzsvLyB0aGlzIHdvdWxkIGJlIGEgcGVyZm9ybWFuY2UgZW5oYW5jZW1lbnQsIGJ1dCB0aGUgY29tcHV0ZWQgYW5nbGVzIG5lZWQgdG8gYmUgY2xhbXBlZCB0b1xuLy90aGUgKC1QSS8yIC0+IFBJLzIpIHJhbmdlIGluIG9yZGVyIGZvciB0aGUgc29ydGluZyB0byB3b3JrIHByb3Blcmx5LlxuLyogIG9yaWVudGF0aW9uQ2FjaGVbb0tleTJdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmllbnRhdGlvbjpvLm9yaWVudGF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhOltvLmFbMV0sIG8uYVswXV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZXRhOm8udGhldGEgKyBNYXRoLlBJLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGV0YTI6by50aGV0YTIgKyBNYXRoLlBJXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07Ki99aWYoc291cmNlQ29udGludW91cyl7X3VwZGF0ZUFuY2hvckxpc3QoYW5jaG9yTGlzdHNbc291cmNlSWRdLG8udGhldGEsMCxjb25uLGZhbHNlLHRhcmdldElkLDAsZmFsc2Usby5hWzBdLHNvdXJjZUlkLGNvbm5lY3Rpb25zVG9QYWludCxlbmRwb2ludHNUb1BhaW50KTt9aWYodGFyZ2V0Q29udGludW91cyl7X3VwZGF0ZUFuY2hvckxpc3QoYW5jaG9yTGlzdHNbdGFyZ2V0SWRdLG8udGhldGEyLC0xLGNvbm4sdHJ1ZSxzb3VyY2VJZCwxLHRydWUsby5hWzFdLHRhcmdldElkLGNvbm5lY3Rpb25zVG9QYWludCxlbmRwb2ludHNUb1BhaW50KTt9fWlmKHNvdXJjZUNvbnRpbnVvdXMpe19qdS5hZGRXaXRoRnVuY3Rpb24oYW5jaG9yc1RvVXBkYXRlLHNvdXJjZUlkLGZ1bmN0aW9uKGEpe3JldHVybiBhPT09c291cmNlSWQ7fSk7fWlmKHRhcmdldENvbnRpbnVvdXMpe19qdS5hZGRXaXRoRnVuY3Rpb24oYW5jaG9yc1RvVXBkYXRlLHRhcmdldElkLGZ1bmN0aW9uKGEpe3JldHVybiBhPT09dGFyZ2V0SWQ7fSk7fV9qdS5hZGRXaXRoRnVuY3Rpb24oY29ubmVjdGlvbnNUb1BhaW50LGNvbm4sZnVuY3Rpb24oYyl7cmV0dXJuIGMuaWQ9PT1jb25uLmlkO30pO2lmKHNvdXJjZUNvbnRpbnVvdXMmJm9JZHg9PT0wfHx0YXJnZXRDb250aW51b3VzJiZvSWR4PT09MSl7X2p1LmFkZFdpdGhGdW5jdGlvbihlbmRwb2ludHNUb1BhaW50LGNvbm4uZW5kcG9pbnRzW29JZHhdLGZ1bmN0aW9uKGUpe3JldHVybiBlLmlkPT09Y29ubi5lbmRwb2ludHNbb0lkeF0uaWQ7fSk7fX19Ly8gcGxhY2UgRW5kcG9pbnRzIHdob3NlIGFuY2hvcnMgYXJlIGNvbnRpbnVvdXMgYnV0IGhhdmUgbm8gQ29ubmVjdGlvbnNcbmZvcihpPTA7aTxlcC5sZW5ndGg7aSsrKXtpZihlcFtpXS5jb25uZWN0aW9ucy5sZW5ndGg9PT0wJiZlcFtpXS5hbmNob3IuaXNDb250aW51b3VzKXtpZighYW5jaG9yTGlzdHNbZWxlbWVudElkXSl7YW5jaG9yTGlzdHNbZWxlbWVudElkXT17dG9wOltdLHJpZ2h0OltdLGJvdHRvbTpbXSxsZWZ0OltdfTt9X3VwZGF0ZUFuY2hvckxpc3QoYW5jaG9yTGlzdHNbZWxlbWVudElkXSwtTWF0aC5QSS8yLDAse2VuZHBvaW50czpbZXBbaV0sZXBbaV1dLHBhaW50OmZ1bmN0aW9uIHBhaW50KCl7fX0sZmFsc2UsZWxlbWVudElkLDAsZmFsc2UsZXBbaV0uYW5jaG9yLmdldERlZmF1bHRGYWNlKCksZWxlbWVudElkLGNvbm5lY3Rpb25zVG9QYWludCxlbmRwb2ludHNUb1BhaW50KTtfanUuYWRkV2l0aEZ1bmN0aW9uKGFuY2hvcnNUb1VwZGF0ZSxlbGVtZW50SWQsZnVuY3Rpb24oYSl7cmV0dXJuIGE9PT1lbGVtZW50SWQ7fSk7fX0vLyBub3cgcGxhY2UgYWxsIHRoZSBjb250aW51b3VzIGFuY2hvcnMgd2UgbmVlZCB0bztcbmZvcihpPTA7aTxhbmNob3JzVG9VcGRhdGUubGVuZ3RoO2krKyl7cGxhY2VBbmNob3JzKGFuY2hvcnNUb1VwZGF0ZVtpXSxhbmNob3JMaXN0c1thbmNob3JzVG9VcGRhdGVbaV1dKTt9Ly8gbm93IHRoYXQgY29udGludW91cyBhbmNob3JzIGhhdmUgYmVlbiBwbGFjZWQsIHBhaW50IGFsbCB0aGUgZW5kcG9pbnRzIGZvciB0aGlzIGVsZW1lbnRcbi8vIFRPRE8gcGVyZm9ybWFuY2U6IGFkZCB0aGUgZW5kcG9pbnQgaWRzIHRvIGEgdGVtcCBhcnJheSwgYW5kIHRoZW4gd2hlbiBpdGVyYXRpbmcgaW4gdGhlIG5leHRcbi8vIGxvb3AsIGNoZWNrIHRoYXQgd2UgZGlkbid0IGp1c3QgcGFpbnQgdGhhdCBlbmRwb2ludC4gd2UgY2FuIHByb2JhYmx5IHNoYXZlIG9mZiBhIGZldyBtb3JlIG1pbGxpc2Vjb25kcyB0aGlzIHdheS5cbmZvcihpPTA7aTxlcC5sZW5ndGg7aSsrKXtlcFtpXS5wYWludCh7dGltZXN0YW1wOnRpbWVzdGFtcCxvZmZzZXQ6bXlPZmZzZXQsZGltZW5zaW9uczpteU9mZnNldC5zLHJlY2FsYzpkb05vdFJlY2FsY0VuZHBvaW50IT09dHJ1ZX0pO30vLyAuLi4gYW5kIGFueSBvdGhlciBlbmRwb2ludHMgd2UgY2FtZSBhY3Jvc3MgYXMgYSByZXN1bHQgb2YgdGhlIGNvbnRpbnVvdXMgYW5jaG9ycy5cbmZvcihpPTA7aTxlbmRwb2ludHNUb1BhaW50Lmxlbmd0aDtpKyspe3ZhciBjZD1qc1BsdW1iSW5zdGFuY2UuZ2V0Q2FjaGVkRGF0YShlbmRwb2ludHNUb1BhaW50W2ldLmVsZW1lbnRJZCk7ZW5kcG9pbnRzVG9QYWludFtpXS5wYWludCh7dGltZXN0YW1wOnRpbWVzdGFtcCxvZmZzZXQ6Y2QsZGltZW5zaW9uczpjZC5zfSk7fS8vIHBhaW50IGFsbCB0aGUgc3RhbmRhcmQgYW5kIFwiZHluYW1pYyBjb25uZWN0aW9uc1wiLCB3aGljaCBhcmUgY29ubmVjdGlvbnMgd2hvc2Ugb3RoZXIgYW5jaG9yIGlzXG4vLyBzdGF0aWMgYW5kIHRoZXJlZm9yZSBkb2VzIG5lZWQgdG8gYmUgcmVjb21wdXRlZDsgd2UgbWFrZSBzdXJlIHRoYXQgaGFwcGVucyBvbmx5IG9uZSB0aW1lLlxuLy8gVE9ETyB3ZSBjb3VsZCBoYXZlIGNvbXBpbGVkIGEgbGlzdCBvZiB0aGVzZSBpbiB0aGUgZmlyc3QgcGFzcyB0aHJvdWdoIGNvbm5lY3Rpb25zOyBtaWdodCBzYXZlIHNvbWUgdGltZS5cbmZvcihpPTA7aTxlbmRwb2ludENvbm5lY3Rpb25zLmxlbmd0aDtpKyspe3ZhciBvdGhlckVuZHBvaW50PWVuZHBvaW50Q29ubmVjdGlvbnNbaV1bMV07aWYob3RoZXJFbmRwb2ludC5hbmNob3IuY29uc3RydWN0b3I9PT1fanAuRHluYW1pY0FuY2hvcil7b3RoZXJFbmRwb2ludC5wYWludCh7ZWxlbWVudFdpdGhQcmVjZWRlbmNlOmVsZW1lbnRJZCx0aW1lc3RhbXA6dGltZXN0YW1wfSk7X2p1LmFkZFdpdGhGdW5jdGlvbihjb25uZWN0aW9uc1RvUGFpbnQsZW5kcG9pbnRDb25uZWN0aW9uc1tpXVswXSxmdW5jdGlvbihjKXtyZXR1cm4gYy5pZD09PWVuZHBvaW50Q29ubmVjdGlvbnNbaV1bMF0uaWQ7fSk7Ly8gYWxsIHRoZSBjb25uZWN0aW9ucyBmb3IgdGhlIG90aGVyIGVuZHBvaW50IG5vdyBuZWVkIHRvIGJlIHJlcGFpbnRlZFxuZm9yKHZhciBrPTA7azxvdGhlckVuZHBvaW50LmNvbm5lY3Rpb25zLmxlbmd0aDtrKyspe2lmKG90aGVyRW5kcG9pbnQuY29ubmVjdGlvbnNba10hPT1lbmRwb2ludENvbm5lY3Rpb25zW2ldWzBdKXtfanUuYWRkV2l0aEZ1bmN0aW9uKGNvbm5lY3Rpb25zVG9QYWludCxvdGhlckVuZHBvaW50LmNvbm5lY3Rpb25zW2tdLGZ1bmN0aW9uKGMpe3JldHVybiBjLmlkPT09b3RoZXJFbmRwb2ludC5jb25uZWN0aW9uc1trXS5pZDt9KTt9fX1lbHNle19qdS5hZGRXaXRoRnVuY3Rpb24oY29ubmVjdGlvbnNUb1BhaW50LGVuZHBvaW50Q29ubmVjdGlvbnNbaV1bMF0sZnVuY3Rpb24oYyl7cmV0dXJuIGMuaWQ9PT1lbmRwb2ludENvbm5lY3Rpb25zW2ldWzBdLmlkO30pO319Ly8gcGFpbnQgY3VycmVudCBmbG9hdGluZyBjb25uZWN0aW9uIGZvciB0aGlzIGVsZW1lbnQsIGlmIHRoZXJlIGlzIG9uZS5cbnZhciBmYz1mbG9hdGluZ0Nvbm5lY3Rpb25zW2VsZW1lbnRJZF07aWYoZmMpe2ZjLnBhaW50KHt0aW1lc3RhbXA6dGltZXN0YW1wLHJlY2FsYzpmYWxzZSxlbElkOmVsZW1lbnRJZH0pO30vLyBwYWludCBhbGwgdGhlIGNvbm5lY3Rpb25zXG5mb3IoaT0wO2k8Y29ubmVjdGlvbnNUb1BhaW50Lmxlbmd0aDtpKyspe2Nvbm5lY3Rpb25zVG9QYWludFtpXS5wYWludCh7ZWxJZDplbGVtZW50SWQsdGltZXN0YW1wOnRpbWVzdGFtcCxyZWNhbGM6ZmFsc2UsY2xlYXJFZGl0czpjbGVhckVkaXRzfSk7fX19O3ZhciBDb250aW51b3VzQW5jaG9yPWZ1bmN0aW9uIENvbnRpbnVvdXNBbmNob3IoYW5jaG9yUGFyYW1zKXtfanUuRXZlbnRHZW5lcmF0b3IuYXBwbHkodGhpcyk7dGhpcy50eXBlPVwiQ29udGludW91c1wiO3RoaXMuaXNEeW5hbWljPXRydWU7dGhpcy5pc0NvbnRpbnVvdXM9dHJ1ZTt2YXIgZmFjZXM9YW5jaG9yUGFyYW1zLmZhY2VzfHxbXCJ0b3BcIixcInJpZ2h0XCIsXCJib3R0b21cIixcImxlZnRcIl0sY2xvY2t3aXNlPSEoYW5jaG9yUGFyYW1zLmNsb2Nrd2lzZT09PWZhbHNlKSxhdmFpbGFibGVGYWNlcz17fSxvcHBvc2l0ZXM9e1widG9wXCI6XCJib3R0b21cIixcInJpZ2h0XCI6XCJsZWZ0XCIsXCJsZWZ0XCI6XCJyaWdodFwiLFwiYm90dG9tXCI6XCJ0b3BcIn0sY2xvY2t3aXNlT3B0aW9ucz17XCJ0b3BcIjpcInJpZ2h0XCIsXCJyaWdodFwiOlwiYm90dG9tXCIsXCJsZWZ0XCI6XCJ0b3BcIixcImJvdHRvbVwiOlwibGVmdFwifSxhbnRpQ2xvY2t3aXNlT3B0aW9ucz17XCJ0b3BcIjpcImxlZnRcIixcInJpZ2h0XCI6XCJ0b3BcIixcImxlZnRcIjpcImJvdHRvbVwiLFwiYm90dG9tXCI6XCJyaWdodFwifSxzZWNvbmRCZXN0PWNsb2Nrd2lzZT9jbG9ja3dpc2VPcHRpb25zOmFudGlDbG9ja3dpc2VPcHRpb25zLGxhc3RDaG9pY2U9Y2xvY2t3aXNlP2FudGlDbG9ja3dpc2VPcHRpb25zOmNsb2Nrd2lzZU9wdGlvbnMsY3NzQ2xhc3M9YW5jaG9yUGFyYW1zLmNzc0NsYXNzfHxcIlwiLF9jdXJyZW50RmFjZT1udWxsLF9sb2NrZWRGYWNlPW51bGwsWF9BWElTX0ZBQ0VTPVtcImxlZnRcIixcInJpZ2h0XCJdLFlfQVhJU19GQUNFUz1bXCJ0b3BcIixcImJvdHRvbVwiXSxfbG9ja2VkQXhpcz1udWxsO2Zvcih2YXIgaT0wO2k8ZmFjZXMubGVuZ3RoO2krKyl7YXZhaWxhYmxlRmFjZXNbZmFjZXNbaV1dPXRydWU7fXRoaXMuZ2V0RGVmYXVsdEZhY2U9ZnVuY3Rpb24oKXtyZXR1cm4gZmFjZXMubGVuZ3RoPT09MD9cInRvcFwiOmZhY2VzWzBdO307Ly8gaWYgdGhlIGdpdmVuIGVkZ2UgaXMgc3VwcG9ydGVkLCByZXR1cm5zIGl0LiBvdGhlcndpc2UgbG9va3MgZm9yIGEgc3Vic3RpdHV0ZSB0aGF0IF9pc19cbi8vIHN1cHBvcnRlZC4gaWYgbm9uZSBzdXBwb3J0ZWQgd2UgYWxzbyByZXR1cm4gdGhlIHJlcXVlc3QgZWRnZS5cbnRoaXMudmVyaWZ5RWRnZT1mdW5jdGlvbihlZGdlKXtpZihhdmFpbGFibGVGYWNlc1tlZGdlXSl7cmV0dXJuIGVkZ2U7fWVsc2UgaWYoYXZhaWxhYmxlRmFjZXNbb3Bwb3NpdGVzW2VkZ2VdXSl7cmV0dXJuIG9wcG9zaXRlc1tlZGdlXTt9ZWxzZSBpZihhdmFpbGFibGVGYWNlc1tzZWNvbmRCZXN0W2VkZ2VdXSl7cmV0dXJuIHNlY29uZEJlc3RbZWRnZV07fWVsc2UgaWYoYXZhaWxhYmxlRmFjZXNbbGFzdENob2ljZVtlZGdlXV0pe3JldHVybiBsYXN0Q2hvaWNlW2VkZ2VdO31yZXR1cm4gZWRnZTsvLyB3ZSBoYXZlIHRvIGdpdmUgdGhlbSBzb21ldGhpbmcuXG59O3RoaXMuaXNFZGdlU3VwcG9ydGVkPWZ1bmN0aW9uKGVkZ2Upe3JldHVybiBfbG9ja2VkQXhpcz09bnVsbD9fbG9ja2VkRmFjZT09bnVsbD9hdmFpbGFibGVGYWNlc1tlZGdlXT09PXRydWU6X2xvY2tlZEZhY2U9PT1lZGdlOl9sb2NrZWRBeGlzLmluZGV4T2YoZWRnZSkhPT0tMTt9O3RoaXMuc2V0Q3VycmVudEZhY2U9ZnVuY3Rpb24oZmFjZSl7X2N1cnJlbnRGYWNlPWZhY2U7fTt0aGlzLmdldEN1cnJlbnRGYWNlPWZ1bmN0aW9uKCl7cmV0dXJuIF9jdXJyZW50RmFjZTt9O3RoaXMubG9ja0N1cnJlbnRGYWNlPWZ1bmN0aW9uKCl7X2xvY2tlZEZhY2U9X2N1cnJlbnRGYWNlO307dGhpcy51bmxvY2tDdXJyZW50RmFjZT1mdW5jdGlvbigpe19sb2NrZWRGYWNlPW51bGw7fTt0aGlzLmxvY2tDdXJyZW50QXhpcz1mdW5jdGlvbigpe2lmKF9jdXJyZW50RmFjZSE9bnVsbCl7X2xvY2tlZEF4aXM9X2N1cnJlbnRGYWNlPT09XCJsZWZ0XCJ8fF9jdXJyZW50RmFjZT09PVwicmlnaHRcIj9YX0FYSVNfRkFDRVM6WV9BWElTX0ZBQ0VTO319O3RoaXMudW5sb2NrQ3VycmVudEF4aXM9ZnVuY3Rpb24oKXtfbG9ja2VkQXhpcz1udWxsO307dGhpcy5jb21wdXRlPWZ1bmN0aW9uKHBhcmFtcyl7cmV0dXJuIHVzZXJEZWZpbmVkQ29udGludW91c0FuY2hvckxvY2F0aW9uc1twYXJhbXMuZWxlbWVudC5pZF18fGNvbnRpbnVvdXNBbmNob3JMb2NhdGlvbnNbcGFyYW1zLmVsZW1lbnQuaWRdfHxbMCwwXTt9O3RoaXMuZ2V0Q3VycmVudExvY2F0aW9uPWZ1bmN0aW9uKHBhcmFtcyl7cmV0dXJuIHVzZXJEZWZpbmVkQ29udGludW91c0FuY2hvckxvY2F0aW9uc1twYXJhbXMuZWxlbWVudC5pZF18fGNvbnRpbnVvdXNBbmNob3JMb2NhdGlvbnNbcGFyYW1zLmVsZW1lbnQuaWRdfHxbMCwwXTt9O3RoaXMuZ2V0T3JpZW50YXRpb249ZnVuY3Rpb24oZW5kcG9pbnQpe3JldHVybiBjb250aW51b3VzQW5jaG9yT3JpZW50YXRpb25zW2VuZHBvaW50LmlkXXx8WzAsMF07fTt0aGlzLmNsZWFyVXNlckRlZmluZWRMb2NhdGlvbj1mdW5jdGlvbigpe2RlbGV0ZSB1c2VyRGVmaW5lZENvbnRpbnVvdXNBbmNob3JMb2NhdGlvbnNbYW5jaG9yUGFyYW1zLmVsZW1lbnRJZF07fTt0aGlzLnNldFVzZXJEZWZpbmVkTG9jYXRpb249ZnVuY3Rpb24obG9jKXt1c2VyRGVmaW5lZENvbnRpbnVvdXNBbmNob3JMb2NhdGlvbnNbYW5jaG9yUGFyYW1zLmVsZW1lbnRJZF09bG9jO307dGhpcy5nZXRDc3NDbGFzcz1mdW5jdGlvbigpe3JldHVybiBjc3NDbGFzczt9O307Ly8gY29udGludW91cyBhbmNob3JzXG5qc1BsdW1iSW5zdGFuY2UuY29udGludW91c0FuY2hvckZhY3Rvcnk9e2dldDpmdW5jdGlvbiBnZXQocGFyYW1zKXtyZXR1cm4gbmV3IENvbnRpbnVvdXNBbmNob3IocGFyYW1zKTt9LGNsZWFyOmZ1bmN0aW9uIGNsZWFyKGVsZW1lbnRJZCl7ZGVsZXRlIHVzZXJEZWZpbmVkQ29udGludW91c0FuY2hvckxvY2F0aW9uc1tlbGVtZW50SWRdO2RlbGV0ZSBjb250aW51b3VzQW5jaG9yTG9jYXRpb25zW2VsZW1lbnRJZF07fX07fTsvKipcclxuICAgICAqIEFuY2hvcnMgbW9kZWwgYSBwb3NpdGlvbiBvbiBzb21lIGVsZW1lbnQgYXQgd2hpY2ggYW4gRW5kcG9pbnQgbWF5IGJlIGxvY2F0ZWQuICBUaGV5IGJlZ2FuIGFzIGEgZmlyc3QgY2xhc3MgY2l0aXplbiBvZiBqc1BsdW1iLCBpZS4gYSB1c2VyXHJcbiAgICAgKiB3YXMgcmVxdWlyZWQgdG8gY3JlYXRlIHRoZXNlIHRoZW1zZWx2ZXMsIGJ1dCBvdmVyIHRpbWUgdGhpcyBoYXMgYmVlbiByZXBsYWNlZCBieSB0aGUgY29uY2VwdCBvZiByZWZlcnJpbmcgdG8gdGhlbSBlaXRoZXIgYnkgbmFtZSAoZWcuIFwiVG9wTWlkZGxlXCIpLFxyXG4gICAgICogb3IgYnkgYW4gYXJyYXkgZGVzY3JpYmluZyB0aGVpciBjb29yZGluYXRlcyAoZWcuIFsgMCwgMC41LCAwLCAtMSBdLCB3aGljaCBpcyB0aGUgc2FtZSBhcyBcIlRvcE1pZGRsZVwiKS4gIGpzUGx1bWIgbm93IGhhbmRsZXMgYWxsIG9mIHRoZVxyXG4gICAgICogY3JlYXRpb24gb2YgQW5jaG9ycyB3aXRob3V0IHVzZXIgaW50ZXJ2ZW50aW9uLlxyXG4gICAgICovX2pwLkFuY2hvcj1mdW5jdGlvbihwYXJhbXMpe3RoaXMueD1wYXJhbXMueHx8MDt0aGlzLnk9cGFyYW1zLnl8fDA7dGhpcy5lbGVtZW50SWQ9cGFyYW1zLmVsZW1lbnRJZDt0aGlzLmNzc0NsYXNzPXBhcmFtcy5jc3NDbGFzc3x8XCJcIjt0aGlzLnVzZXJEZWZpbmVkTG9jYXRpb249bnVsbDt0aGlzLm9yaWVudGF0aW9uPXBhcmFtcy5vcmllbnRhdGlvbnx8WzAsMF07dGhpcy5sYXN0UmV0dXJuVmFsdWU9bnVsbDt0aGlzLm9mZnNldHM9cGFyYW1zLm9mZnNldHN8fFswLDBdO3RoaXMudGltZXN0YW1wPW51bGw7X2p1LkV2ZW50R2VuZXJhdG9yLmFwcGx5KHRoaXMpO3RoaXMuY29tcHV0ZT1mdW5jdGlvbihwYXJhbXMpe3ZhciB4eT1wYXJhbXMueHksd2g9cGFyYW1zLndoLHRpbWVzdGFtcD1wYXJhbXMudGltZXN0YW1wO2lmKHBhcmFtcy5jbGVhclVzZXJEZWZpbmVkTG9jYXRpb24pe3RoaXMudXNlckRlZmluZWRMb2NhdGlvbj1udWxsO31pZih0aW1lc3RhbXAmJnRpbWVzdGFtcD09PXRoaXMudGltZXN0YW1wKXtyZXR1cm4gdGhpcy5sYXN0UmV0dXJuVmFsdWU7fWlmKHRoaXMudXNlckRlZmluZWRMb2NhdGlvbiE9bnVsbCl7dGhpcy5sYXN0UmV0dXJuVmFsdWU9dGhpcy51c2VyRGVmaW5lZExvY2F0aW9uO31lbHNle3RoaXMubGFzdFJldHVyblZhbHVlPVt4eVswXSt0aGlzLngqd2hbMF0rdGhpcy5vZmZzZXRzWzBdLHh5WzFdK3RoaXMueSp3aFsxXSt0aGlzLm9mZnNldHNbMV1dO310aGlzLnRpbWVzdGFtcD10aW1lc3RhbXA7cmV0dXJuIHRoaXMubGFzdFJldHVyblZhbHVlO307dGhpcy5nZXRDdXJyZW50TG9jYXRpb249ZnVuY3Rpb24ocGFyYW1zKXtwYXJhbXM9cGFyYW1zfHx7fTtyZXR1cm4gdGhpcy5sYXN0UmV0dXJuVmFsdWU9PW51bGx8fHBhcmFtcy50aW1lc3RhbXAhPW51bGwmJnRoaXMudGltZXN0YW1wIT09cGFyYW1zLnRpbWVzdGFtcD90aGlzLmNvbXB1dGUocGFyYW1zKTp0aGlzLmxhc3RSZXR1cm5WYWx1ZTt9O307X2p1LmV4dGVuZChfanAuQW5jaG9yLF9qdS5FdmVudEdlbmVyYXRvcix7ZXF1YWxzOmZ1bmN0aW9uIGVxdWFscyhhbmNob3Ipe2lmKCFhbmNob3Ipe3JldHVybiBmYWxzZTt9dmFyIGFvPWFuY2hvci5nZXRPcmllbnRhdGlvbigpLG89dGhpcy5nZXRPcmllbnRhdGlvbigpO3JldHVybiB0aGlzLng9PT1hbmNob3IueCYmdGhpcy55PT09YW5jaG9yLnkmJnRoaXMub2Zmc2V0c1swXT09PWFuY2hvci5vZmZzZXRzWzBdJiZ0aGlzLm9mZnNldHNbMV09PT1hbmNob3Iub2Zmc2V0c1sxXSYmb1swXT09PWFvWzBdJiZvWzFdPT09YW9bMV07fSxnZXRVc2VyRGVmaW5lZExvY2F0aW9uOmZ1bmN0aW9uIGdldFVzZXJEZWZpbmVkTG9jYXRpb24oKXtyZXR1cm4gdGhpcy51c2VyRGVmaW5lZExvY2F0aW9uO30sc2V0VXNlckRlZmluZWRMb2NhdGlvbjpmdW5jdGlvbiBzZXRVc2VyRGVmaW5lZExvY2F0aW9uKGwpe3RoaXMudXNlckRlZmluZWRMb2NhdGlvbj1sO30sY2xlYXJVc2VyRGVmaW5lZExvY2F0aW9uOmZ1bmN0aW9uIGNsZWFyVXNlckRlZmluZWRMb2NhdGlvbigpe3RoaXMudXNlckRlZmluZWRMb2NhdGlvbj1udWxsO30sZ2V0T3JpZW50YXRpb246ZnVuY3Rpb24gZ2V0T3JpZW50YXRpb24oKXtyZXR1cm4gdGhpcy5vcmllbnRhdGlvbjt9LGdldENzc0NsYXNzOmZ1bmN0aW9uIGdldENzc0NsYXNzKCl7cmV0dXJuIHRoaXMuY3NzQ2xhc3M7fX0pOy8qKlxyXG4gICAgICogQW4gQW5jaG9yIHRoYXQgZmxvYXRzLiBpdHMgb3JpZW50YXRpb24gaXMgY29tcHV0ZWQgZHluYW1pY2FsbHkgZnJvbVxyXG4gICAgICogaXRzIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBhbmNob3IgaXQgaXMgZmxvYXRpbmcgcmVsYXRpdmUgdG8uICBJdCBpcyB1c2VkIHdoZW4gY3JlYXRpbmdcclxuICAgICAqIGEgY29ubmVjdGlvbiB0aHJvdWdoIGRyYWcgYW5kIGRyb3AuXHJcbiAgICAgKlxyXG4gICAgICogVE9ETyBGbG9hdGluZ0FuY2hvciBjb3VsZCB0b3RhbGx5IGJlIHJlZmFjdG9yZWQgdG8gZXh0ZW5kIEFuY2hvciBqdXN0IHNsaWdodGx5LlxyXG4gICAgICovX2pwLkZsb2F0aW5nQW5jaG9yPWZ1bmN0aW9uKHBhcmFtcyl7X2pwLkFuY2hvci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7Ly8gdGhpcyBpcyB0aGUgYW5jaG9yIHRoYXQgdGhpcyBmbG9hdGluZyBhbmNob3IgaXMgcmVmZXJlbmNlZCB0byBmb3Jcbi8vIHB1cnBvc2VzIG9mIGNhbGN1bGF0aW5nIHRoZSBvcmllbnRhdGlvbi5cbnZhciByZWY9cGFyYW1zLnJlZmVyZW5jZSwvLyB0aGUgY2FudmFzIHRoaXMgcmVmZXJzIHRvLlxucmVmQ2FudmFzPXBhcmFtcy5yZWZlcmVuY2VDYW52YXMsc2l6ZT1fanAuZ2V0U2l6ZShyZWZDYW52YXMpLC8vIHRoZXNlIGFyZSB1c2VkIHRvIHN0b3JlIHRoZSBjdXJyZW50IHJlbGF0aXZlIHBvc2l0aW9uIG9mIG91clxuLy8gYW5jaG9yIHdydCB0aGUgcmVmZXJlbmNlIGFuY2hvci4gdGhleSBvbmx5IGluZGljYXRlXG4vLyBkaXJlY3Rpb24sIHNvIGhhdmUgYSB2YWx1ZSBvZiAxIG9yIC0xIChvciwgdmVyeSByYXJlbHksIDApLiB0aGVzZVxuLy8gdmFsdWVzIGFyZSB3cml0dGVuIGJ5IHRoZSBjb21wdXRlIG1ldGhvZCwgYW5kIHJlYWRcbi8vIGJ5IHRoZSBnZXRPcmllbnRhdGlvbiBtZXRob2QuXG54RGlyPTAseURpcj0wLC8vIHRlbXBvcmFyeSBtZW1iZXIgdXNlZCB0byBzdG9yZSBhbiBvcmllbnRhdGlvbiB3aGVuIHRoZSBmbG9hdGluZ1xuLy8gYW5jaG9yIGlzIGhvdmVyaW5nIG92ZXIgYW5vdGhlciBhbmNob3IuXG5vcmllbnRhdGlvbj1udWxsLF9sYXN0UmVzdWx0PW51bGw7Ly8gY2xlYXIgZnJvbSBwYXJlbnQuIHdlIHdhbnQgZmxvYXRpbmcgYW5jaG9yIG9yaWVudGF0aW9uIHRvIGFsd2F5cyBiZSBjb21wdXRlZC5cbnRoaXMub3JpZW50YXRpb249bnVsbDsvLyBzZXQgdGhlc2UgdG8gMCBlYWNoOyB0aGV5IGFyZSB1c2VkIGJ5IGNlcnRhaW4gdHlwZXMgb2YgY29ubmVjdG9ycyBpbiB0aGUgbG9vcGJhY2sgY2FzZSxcbi8vIHdoZW4gdGhlIGNvbm5lY3RvciBpcyB0cnlpbmcgdG8gY2xlYXIgdGhlIGVsZW1lbnQgaXQgaXMgb24uIGJ1dCBmb3IgZmxvYXRpbmcgYW5jaG9yIGl0J3Mgbm90XG4vLyB2ZXJ5IGltcG9ydGFudC5cbnRoaXMueD0wO3RoaXMueT0wO3RoaXMuaXNGbG9hdGluZz10cnVlO3RoaXMuY29tcHV0ZT1mdW5jdGlvbihwYXJhbXMpe3ZhciB4eT1wYXJhbXMueHkscmVzdWx0PVt4eVswXStzaXplWzBdLzIseHlbMV0rc2l6ZVsxXS8yXTsvLyByZXR1cm4gb3JpZ2luIG9mIHRoZSBlbGVtZW50LiB3ZSBtYXkgd2lzaCB0byBpbXByb3ZlIHRoaXMgc28gdGhhdCBhbnkgb2JqZWN0IGNhbiBiZSB0aGUgZHJhZyBwcm94eS5cbl9sYXN0UmVzdWx0PXJlc3VsdDtyZXR1cm4gcmVzdWx0O307dGhpcy5nZXRPcmllbnRhdGlvbj1mdW5jdGlvbihfZW5kcG9pbnQpe2lmKG9yaWVudGF0aW9uKXtyZXR1cm4gb3JpZW50YXRpb247fWVsc2V7dmFyIG89cmVmLmdldE9yaWVudGF0aW9uKF9lbmRwb2ludCk7Ly8gaGVyZSB3ZSB0YWtlIGludG8gYWNjb3VudCB0aGUgb3JpZW50YXRpb24gb2YgdGhlIG90aGVyXG4vLyBhbmNob3I6IGlmIGl0IGRlY2xhcmVzIHplcm8gZm9yIHNvbWUgZGlyZWN0aW9uLCB3ZSBkZWNsYXJlIHplcm8gdG9vLiB0aGlzIG1pZ2h0IG5vdCBiZSB0aGUgbW9zdCBhd2Vzb21lLiBwZXJoYXBzIHdlIGNhbiBjb21lXG4vLyB1cCB3aXRoIGEgYmV0dGVyIHdheS4gaXQncyBqdXN0IHNvIHRoYXQgdGhlIGxpbmUgd2UgZHJhdyBsb29rcyBsaWtlIGl0IG1ha2VzIHNlbnNlLiBtYXliZSB0aGlzIHdvbnQgbWFrZSBzZW5zZS5cbnJldHVybltNYXRoLmFicyhvWzBdKSp4RGlyKi0xLE1hdGguYWJzKG9bMV0pKnlEaXIqLTFdO319Oy8qKlxyXG4gICAgICAgICAqIG5vdGlmaWNhdGlvbiB0aGUgZW5kcG9pbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgYW5jaG9yIGlzIGhvdmVyaW5nXHJcbiAgICAgICAgICogb3ZlciBhbm90aGVyIGFuY2hvcjsgd2Ugd2FudCB0byBhc3N1bWUgdGhhdCBhbmNob3IncyBvcmllbnRhdGlvblxyXG4gICAgICAgICAqIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGhvdmVyLlxyXG4gICAgICAgICAqL3RoaXMub3Zlcj1mdW5jdGlvbihhbmNob3IsZW5kcG9pbnQpe29yaWVudGF0aW9uPWFuY2hvci5nZXRPcmllbnRhdGlvbihlbmRwb2ludCk7fTsvKipcclxuICAgICAgICAgKiBub3RpZmljYXRpb24gdGhlIGVuZHBvaW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGFuY2hvciBpcyBub1xyXG4gICAgICAgICAqIGxvbmdlciBob3ZlcmluZyBvdmVyIGFub3RoZXIgYW5jaG9yOyB3ZSBzaG91bGQgcmVzdW1lIGNhbGN1bGF0aW5nXHJcbiAgICAgICAgICogb3JpZW50YXRpb24gYXMgd2Ugbm9ybWFsbHkgZG8uXHJcbiAgICAgICAgICovdGhpcy5vdXQ9ZnVuY3Rpb24oKXtvcmllbnRhdGlvbj1udWxsO307dGhpcy5nZXRDdXJyZW50TG9jYXRpb249ZnVuY3Rpb24ocGFyYW1zKXtyZXR1cm4gX2xhc3RSZXN1bHQ9PW51bGw/dGhpcy5jb21wdXRlKHBhcmFtcyk6X2xhc3RSZXN1bHQ7fTt9O19qdS5leHRlbmQoX2pwLkZsb2F0aW5nQW5jaG9yLF9qcC5BbmNob3IpO3ZhciBfY29udmVydEFuY2hvcj1mdW5jdGlvbiBfY29udmVydEFuY2hvcihhbmNob3IsanNQbHVtYkluc3RhbmNlLGVsZW1lbnRJZCl7cmV0dXJuIGFuY2hvci5jb25zdHJ1Y3Rvcj09PV9qcC5BbmNob3I/YW5jaG9yOmpzUGx1bWJJbnN0YW5jZS5tYWtlQW5jaG9yKGFuY2hvcixlbGVtZW50SWQsanNQbHVtYkluc3RhbmNlKTt9Oy8qIFxyXG4gICAgICogQSBEeW5hbWljQW5jaG9yIGlzIGFuIEFuY2hvciB0aGF0IGNvbnRhaW5zIGEgbGlzdCBvZiBvdGhlciBBbmNob3JzLCB3aGljaCBpdCBjeWNsZXNcclxuICAgICAqIHRocm91Z2ggYXQgY29tcHV0ZSB0aW1lIHRvIGZpbmQgdGhlIG9uZSB0aGF0IGlzIGxvY2F0ZWQgY2xvc2VzdCB0b1xyXG4gICAgICogdGhlIGNlbnRlciBvZiB0aGUgdGFyZ2V0IGVsZW1lbnQsIGFuZCByZXR1cm5zIHRoYXQgQW5jaG9yJ3MgY29tcHV0ZVxyXG4gICAgICogbWV0aG9kIHJlc3VsdC4gdGhpcyBjYXVzZXMgZW5kcG9pbnRzIHRvIGZvbGxvdyBlYWNoIG90aGVyIHdpdGhcclxuICAgICAqIHJlc3BlY3QgdG8gdGhlIG9yaWVudGF0aW9uIG9mIHRoZWlyIHRhcmdldCBlbGVtZW50cywgd2hpY2ggaXMgYSB1c2VmdWxcclxuICAgICAqIGZlYXR1cmUgZm9yIHNvbWUgYXBwbGljYXRpb25zLlxyXG4gICAgICogXHJcbiAgICAgKi9fanAuRHluYW1pY0FuY2hvcj1mdW5jdGlvbihwYXJhbXMpe19qcC5BbmNob3IuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMuaXNEeW5hbWljPXRydWU7dGhpcy5hbmNob3JzPVtdO3RoaXMuZWxlbWVudElkPXBhcmFtcy5lbGVtZW50SWQ7dGhpcy5qc1BsdW1iSW5zdGFuY2U9cGFyYW1zLmpzUGx1bWJJbnN0YW5jZTtmb3IodmFyIGk9MDtpPHBhcmFtcy5hbmNob3JzLmxlbmd0aDtpKyspe3RoaXMuYW5jaG9yc1tpXT1fY29udmVydEFuY2hvcihwYXJhbXMuYW5jaG9yc1tpXSx0aGlzLmpzUGx1bWJJbnN0YW5jZSx0aGlzLmVsZW1lbnRJZCk7fXRoaXMuZ2V0QW5jaG9ycz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFuY2hvcnM7fTt0aGlzLmxvY2tlZD1mYWxzZTt2YXIgX2N1ckFuY2hvcj10aGlzLmFuY2hvcnMubGVuZ3RoPjA/dGhpcy5hbmNob3JzWzBdOm51bGwsX2xhc3RBbmNob3I9X2N1ckFuY2hvcixzZWxmPXRoaXMsLy8gaGVscGVyIG1ldGhvZCB0byBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGNlbnRlcnMgb2YgdGhlIHR3byBlbGVtZW50cy5cbl9kaXN0YW5jZT1mdW5jdGlvbiBfZGlzdGFuY2UoYW5jaG9yLGN4LGN5LHh5LHdoKXt2YXIgYXg9eHlbMF0rYW5jaG9yLngqd2hbMF0sYXk9eHlbMV0rYW5jaG9yLnkqd2hbMV0sYWN4PXh5WzBdK3doWzBdLzIsYWN5PXh5WzFdK3doWzFdLzI7cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhjeC1heCwyKStNYXRoLnBvdyhjeS1heSwyKSkrTWF0aC5zcXJ0KE1hdGgucG93KGFjeC1heCwyKStNYXRoLnBvdyhhY3ktYXksMikpO30sLy8gZGVmYXVsdCBtZXRob2QgdXNlcyBkaXN0YW5jZSBiZXR3ZWVuIGVsZW1lbnQgY2VudGVycy4gIHlvdSBjYW4gcHJvdmlkZSB5b3VyIG93biBtZXRob2QgaW4gdGhlIGR5bmFtaWMgYW5jaG9yXG4vLyBjb25zdHJ1Y3RvciAoYW5kIGFsc28gdG8ganNQbHVtYi5tYWtlRHluYW1pY0FuY2hvcikuIHRoZSBhcmd1bWVudHMgdG8gaXQgYXJlIGZvdXIgYXJyYXlzOlxuLy8geHkgLSB4eSBsb2Mgb2YgdGhlIGFuY2hvcidzIGVsZW1lbnRcbi8vIHdoIC0gYW5jaG9yJ3MgZWxlbWVudCdzIGRpbWVuc2lvbnNcbi8vIHR4eSAtIHh5IGxvYyBvZiB0aGUgZWxlbWVudCBvZiB0aGUgb3RoZXIgYW5jaG9yIGluIHRoZSBjb25uZWN0aW9uXG4vLyB0d2ggLSBkaW1lbnNpb25zIG9mIHRoZSBlbGVtZW50IG9mIHRoZSBvdGhlciBhbmNob3IgaW4gdGhlIGNvbm5lY3Rpb24uXG4vLyBhbmNob3JzIC0gdGhlIGxpc3Qgb2Ygc2VsZWN0YWJsZSBhbmNob3JzXG5fYW5jaG9yU2VsZWN0b3I9cGFyYW1zLnNlbGVjdG9yfHxmdW5jdGlvbih4eSx3aCx0eHksdHdoLGFuY2hvcnMpe3ZhciBjeD10eHlbMF0rdHdoWzBdLzIsY3k9dHh5WzFdK3R3aFsxXS8yO3ZhciBtaW5JZHg9LTEsbWluRGlzdD1JbmZpbml0eTtmb3IodmFyIGk9MDtpPGFuY2hvcnMubGVuZ3RoO2krKyl7dmFyIGQ9X2Rpc3RhbmNlKGFuY2hvcnNbaV0sY3gsY3kseHksd2gpO2lmKGQ8bWluRGlzdCl7bWluSWR4PWkrMDttaW5EaXN0PWQ7fX1yZXR1cm4gYW5jaG9yc1ttaW5JZHhdO307dGhpcy5jb21wdXRlPWZ1bmN0aW9uKHBhcmFtcyl7dmFyIHh5PXBhcmFtcy54eSx3aD1wYXJhbXMud2gsdHh5PXBhcmFtcy50eHksdHdoPXBhcmFtcy50d2g7dGhpcy50aW1lc3RhbXA9cGFyYW1zLnRpbWVzdGFtcDt2YXIgdWRsPXNlbGYuZ2V0VXNlckRlZmluZWRMb2NhdGlvbigpO2lmKHVkbCE9bnVsbCl7cmV0dXJuIHVkbDt9Ly8gaWYgYW5jaG9yIGlzIGxvY2tlZCBvciBhbiBvcHBvc2l0ZSBlbGVtZW50IHdhcyBub3QgZ2l2ZW4sIHdlXG4vLyBtYWludGFpbiBvdXIgc3RhdGUuIGFuY2hvciB3aWxsIGJlIGxvY2tlZFxuLy8gaWYgaXQgaXMgdGhlIHNvdXJjZSBvZiBhIGRyYWcgYW5kIGRyb3AuXG5pZih0aGlzLmxvY2tlZHx8dHh5PT1udWxsfHx0d2g9PW51bGwpe3JldHVybiBfY3VyQW5jaG9yLmNvbXB1dGUocGFyYW1zKTt9ZWxzZXtwYXJhbXMudGltZXN0YW1wPW51bGw7Ly8gb3RoZXJ3aXNlIGNsZWFyIHRoaXMsIGkgdGhpbmsuIHdlIHdhbnQgdGhlIGFuY2hvciB0byBjb21wdXRlLlxufV9jdXJBbmNob3I9X2FuY2hvclNlbGVjdG9yKHh5LHdoLHR4eSx0d2gsdGhpcy5hbmNob3JzKTt0aGlzLng9X2N1ckFuY2hvci54O3RoaXMueT1fY3VyQW5jaG9yLnk7aWYoX2N1ckFuY2hvciE9PV9sYXN0QW5jaG9yKXt0aGlzLmZpcmUoXCJhbmNob3JDaGFuZ2VkXCIsX2N1ckFuY2hvcik7fV9sYXN0QW5jaG9yPV9jdXJBbmNob3I7cmV0dXJuIF9jdXJBbmNob3IuY29tcHV0ZShwYXJhbXMpO307dGhpcy5nZXRDdXJyZW50TG9jYXRpb249ZnVuY3Rpb24ocGFyYW1zKXtyZXR1cm4gdGhpcy5nZXRVc2VyRGVmaW5lZExvY2F0aW9uKCl8fChfY3VyQW5jaG9yIT1udWxsP19jdXJBbmNob3IuZ2V0Q3VycmVudExvY2F0aW9uKHBhcmFtcyk6bnVsbCk7fTt0aGlzLmdldE9yaWVudGF0aW9uPWZ1bmN0aW9uKF9lbmRwb2ludCl7cmV0dXJuIF9jdXJBbmNob3IhPW51bGw/X2N1ckFuY2hvci5nZXRPcmllbnRhdGlvbihfZW5kcG9pbnQpOlswLDBdO307dGhpcy5vdmVyPWZ1bmN0aW9uKGFuY2hvcixlbmRwb2ludCl7aWYoX2N1ckFuY2hvciE9bnVsbCl7X2N1ckFuY2hvci5vdmVyKGFuY2hvcixlbmRwb2ludCk7fX07dGhpcy5vdXQ9ZnVuY3Rpb24oKXtpZihfY3VyQW5jaG9yIT1udWxsKXtfY3VyQW5jaG9yLm91dCgpO319O3RoaXMuZ2V0Q3NzQ2xhc3M9ZnVuY3Rpb24oKXtyZXR1cm4gX2N1ckFuY2hvciYmX2N1ckFuY2hvci5nZXRDc3NDbGFzcygpfHxcIlwiO307fTtfanUuZXh0ZW5kKF9qcC5EeW5hbWljQW5jaG9yLF9qcC5BbmNob3IpOy8vIC0tLS0tLS0tIGJhc2ljIGFuY2hvcnMgLS0tLS0tLS0tLS0tLS0tLS0tICAgIFxudmFyIF9jdXJyeUFuY2hvcj1mdW5jdGlvbiBfY3VycnlBbmNob3IoeCx5LG94LG95LHR5cGUsZm5Jbml0KXtfanAuQW5jaG9yc1t0eXBlXT1mdW5jdGlvbihwYXJhbXMpe3ZhciBhPXBhcmFtcy5qc1BsdW1iSW5zdGFuY2UubWFrZUFuY2hvcihbeCx5LG94LG95LDAsMF0scGFyYW1zLmVsZW1lbnRJZCxwYXJhbXMuanNQbHVtYkluc3RhbmNlKTthLnR5cGU9dHlwZTtpZihmbkluaXQpe2ZuSW5pdChhLHBhcmFtcyk7fXJldHVybiBhO307fTtfY3VycnlBbmNob3IoMC41LDAsMCwtMSxcIlRvcENlbnRlclwiKTtfY3VycnlBbmNob3IoMC41LDEsMCwxLFwiQm90dG9tQ2VudGVyXCIpO19jdXJyeUFuY2hvcigwLDAuNSwtMSwwLFwiTGVmdE1pZGRsZVwiKTtfY3VycnlBbmNob3IoMSwwLjUsMSwwLFwiUmlnaHRNaWRkbGVcIik7X2N1cnJ5QW5jaG9yKDAuNSwwLDAsLTEsXCJUb3BcIik7X2N1cnJ5QW5jaG9yKDAuNSwxLDAsMSxcIkJvdHRvbVwiKTtfY3VycnlBbmNob3IoMCwwLjUsLTEsMCxcIkxlZnRcIik7X2N1cnJ5QW5jaG9yKDEsMC41LDEsMCxcIlJpZ2h0XCIpO19jdXJyeUFuY2hvcigwLjUsMC41LDAsMCxcIkNlbnRlclwiKTtfY3VycnlBbmNob3IoMSwwLDAsLTEsXCJUb3BSaWdodFwiKTtfY3VycnlBbmNob3IoMSwxLDAsMSxcIkJvdHRvbVJpZ2h0XCIpO19jdXJyeUFuY2hvcigwLDAsMCwtMSxcIlRvcExlZnRcIik7X2N1cnJ5QW5jaG9yKDAsMSwwLDEsXCJCb3R0b21MZWZ0XCIpOy8vIC0tLS0tLS0gZHluYW1pYyBhbmNob3JzIC0tLS0tLS0tLS0tLS0tLS0tLS0gICAgXG4vLyBkZWZhdWx0IGR5bmFtaWMgYW5jaG9ycyBjaG9vc2VzIGZyb20gVG9wLCBSaWdodCwgQm90dG9tLCBMZWZ0XG5fanAuRGVmYXVsdHMuRHluYW1pY0FuY2hvcnM9ZnVuY3Rpb24ocGFyYW1zKXtyZXR1cm4gcGFyYW1zLmpzUGx1bWJJbnN0YW5jZS5tYWtlQW5jaG9ycyhbXCJUb3BDZW50ZXJcIixcIlJpZ2h0TWlkZGxlXCIsXCJCb3R0b21DZW50ZXJcIixcIkxlZnRNaWRkbGVcIl0scGFyYW1zLmVsZW1lbnRJZCxwYXJhbXMuanNQbHVtYkluc3RhbmNlKTt9Oy8vIGRlZmF1bHQgZHluYW1pYyBhbmNob3JzIGJvdW5kIHRvIG5hbWUgJ0F1dG9EZWZhdWx0J1xuX2pwLkFuY2hvcnMuQXV0b0RlZmF1bHQ9ZnVuY3Rpb24ocGFyYW1zKXt2YXIgYT1wYXJhbXMuanNQbHVtYkluc3RhbmNlLm1ha2VEeW5hbWljQW5jaG9yKF9qcC5EZWZhdWx0cy5EeW5hbWljQW5jaG9ycyhwYXJhbXMpKTthLnR5cGU9XCJBdXRvRGVmYXVsdFwiO3JldHVybiBhO307Ly8gLS0tLS0tLSBjb250aW51b3VzIGFuY2hvcnMgLS0tLS0tLS0tLS0tLS0tLS0tLSAgICBcbnZhciBfY3VycnlDb250aW51b3VzQW5jaG9yPWZ1bmN0aW9uIF9jdXJyeUNvbnRpbnVvdXNBbmNob3IodHlwZSxmYWNlcyl7X2pwLkFuY2hvcnNbdHlwZV09ZnVuY3Rpb24ocGFyYW1zKXt2YXIgYT1wYXJhbXMuanNQbHVtYkluc3RhbmNlLm1ha2VBbmNob3IoW1wiQ29udGludW91c1wiLHtmYWNlczpmYWNlc31dLHBhcmFtcy5lbGVtZW50SWQscGFyYW1zLmpzUGx1bWJJbnN0YW5jZSk7YS50eXBlPXR5cGU7cmV0dXJuIGE7fTt9O19qcC5BbmNob3JzLkNvbnRpbnVvdXM9ZnVuY3Rpb24ocGFyYW1zKXtyZXR1cm4gcGFyYW1zLmpzUGx1bWJJbnN0YW5jZS5jb250aW51b3VzQW5jaG9yRmFjdG9yeS5nZXQocGFyYW1zKTt9O19jdXJyeUNvbnRpbnVvdXNBbmNob3IoXCJDb250aW51b3VzTGVmdFwiLFtcImxlZnRcIl0pO19jdXJyeUNvbnRpbnVvdXNBbmNob3IoXCJDb250aW51b3VzVG9wXCIsW1widG9wXCJdKTtfY3VycnlDb250aW51b3VzQW5jaG9yKFwiQ29udGludW91c0JvdHRvbVwiLFtcImJvdHRvbVwiXSk7X2N1cnJ5Q29udGludW91c0FuY2hvcihcIkNvbnRpbnVvdXNSaWdodFwiLFtcInJpZ2h0XCJdKTsvLyAtLS0tLS0tIHBvc2l0aW9uIGFzc2lnbiBhbmNob3JzIC0tLS0tLS0tLS0tLS0tLS0tLS0gICAgXG4vLyB0aGlzIGFuY2hvciB0eXBlIGxldHMgeW91IGFzc2lnbiB0aGUgcG9zaXRpb24gYXQgY29ubmVjdGlvbiB0aW1lLlxuX2N1cnJ5QW5jaG9yKDAsMCwwLDAsXCJBc3NpZ25cIixmdW5jdGlvbihhbmNob3IscGFyYW1zKXsvLyBmaW5kIHdoYXQgdG8gdXNlIGFzIHRoZSBcInBvc2l0aW9uIGZpbmRlclwiLiB0aGUgdXNlciBtYXkgaGF2ZSBzdXBwbGllZCBhIFN0cmluZyB3aGljaCByZXByZXNlbnRzXG4vLyB0aGUgaWQgb2YgYSBwb3NpdGlvbiBmaW5kZXIgaW4ganNQbHVtYi5BbmNob3JQb3NpdGlvbkZpbmRlcnMsIG9yIHRoZSB1c2VyIG1heSBoYXZlIHN1cHBsaWVkIHRoZVxuLy8gcG9zaXRpb24gZmluZGVyIGFzIGEgZnVuY3Rpb24uICB3ZSBmaW5kIG91dCB3aGF0IHRvIHVzZSBhbmQgdGhlbiBzZXQgaXQgb24gdGhlIGFuY2hvci5cbnZhciBwZj1wYXJhbXMucG9zaXRpb258fFwiRml4ZWRcIjthbmNob3IucG9zaXRpb25GaW5kZXI9cGYuY29uc3RydWN0b3I9PT1TdHJpbmc/cGFyYW1zLmpzUGx1bWJJbnN0YW5jZS5BbmNob3JQb3NpdGlvbkZpbmRlcnNbcGZdOnBmOy8vIGFsd2F5cyBzZXQgdGhlIGNvbnN0cnVjdG9yIHBhcmFtczsgdGhlIHBvc2l0aW9uIGZpbmRlciBtaWdodCBuZWVkIHRoZW0gbGF0ZXIgKHRoZSBHcmlkIG9uZSBkb2VzLFxuLy8gZm9yIGV4YW1wbGUpXG5hbmNob3IuY29uc3RydWN0b3JQYXJhbXM9cGFyYW1zO30pOy8vIHRoZXNlIGFyZSB0aGUgZGVmYXVsdCBhbmNob3IgcG9zaXRpb25zIGZpbmRlcnMsIHdoaWNoIGFyZSB1c2VkIGJ5IHRoZSBtYWtlVGFyZ2V0IGZ1bmN0aW9uLiAgc3VwcGx5aW5nXG4vLyBhIHBvc2l0aW9uIGZpbmRlciBhcmd1bWVudCB0byB0aGF0IGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc3BlY2lmeSB3aGVyZSB0aGUgcmVzdWx0aW5nIGFuY2hvciB3aWxsXG4vLyBiZSBsb2NhdGVkXG5yb290LmpzUGx1bWJJbnN0YW5jZS5wcm90b3R5cGUuQW5jaG9yUG9zaXRpb25GaW5kZXJzPXtcIkZpeGVkXCI6ZnVuY3Rpb24gRml4ZWQoZHAsZXAsZXMpe3JldHVyblsoZHAubGVmdC1lcC5sZWZ0KS9lc1swXSwoZHAudG9wLWVwLnRvcCkvZXNbMV1dO30sXCJHcmlkXCI6ZnVuY3Rpb24gR3JpZChkcCxlcCxlcyxwYXJhbXMpe3ZhciBkeD1kcC5sZWZ0LWVwLmxlZnQsZHk9ZHAudG9wLWVwLnRvcCxneD1lc1swXS9wYXJhbXMuZ3JpZFswXSxneT1lc1sxXS9wYXJhbXMuZ3JpZFsxXSxteD1NYXRoLmZsb29yKGR4L2d4KSxteT1NYXRoLmZsb29yKGR5L2d5KTtyZXR1cm5bKG14Kmd4K2d4LzIpL2VzWzBdLChteSpneStneS8yKS9lc1sxXV07fX07Ly8gLS0tLS0tLSBwZXJpbWV0ZXIgYW5jaG9ycyAtLS0tLS0tLS0tLS0tLS0tLS0tICAgIFxuX2pwLkFuY2hvcnMuUGVyaW1ldGVyPWZ1bmN0aW9uKHBhcmFtcyl7cGFyYW1zPXBhcmFtc3x8e307dmFyIGFuY2hvckNvdW50PXBhcmFtcy5hbmNob3JDb3VudHx8NjAsc2hhcGU9cGFyYW1zLnNoYXBlO2lmKCFzaGFwZSl7dGhyb3cgbmV3IEVycm9yKFwibm8gc2hhcGUgc3VwcGxpZWQgdG8gUGVyaW1ldGVyIEFuY2hvciB0eXBlXCIpO312YXIgX2NpcmNsZT1mdW5jdGlvbiBfY2lyY2xlKCl7dmFyIHI9MC41LHN0ZXA9TWF0aC5QSSoyL2FuY2hvckNvdW50LGN1cnJlbnQ9MCxhPVtdO2Zvcih2YXIgaT0wO2k8YW5jaG9yQ291bnQ7aSsrKXt2YXIgeD1yK3IqTWF0aC5zaW4oY3VycmVudCkseT1yK3IqTWF0aC5jb3MoY3VycmVudCk7YS5wdXNoKFt4LHksMCwwXSk7Y3VycmVudCs9c3RlcDt9cmV0dXJuIGE7fSxfcGF0aD1mdW5jdGlvbiBfcGF0aChzZWdtZW50cyl7dmFyIGFuY2hvcnNQZXJGYWNlPWFuY2hvckNvdW50L3NlZ21lbnRzLmxlbmd0aCxhPVtdLF9jb21wdXRlRmFjZT1mdW5jdGlvbiBfY29tcHV0ZUZhY2UoeDEseTEseDIseTIsZnJhY3Rpb25hbExlbmd0aCl7YW5jaG9yc1BlckZhY2U9YW5jaG9yQ291bnQqZnJhY3Rpb25hbExlbmd0aDt2YXIgZHg9KHgyLXgxKS9hbmNob3JzUGVyRmFjZSxkeT0oeTIteTEpL2FuY2hvcnNQZXJGYWNlO2Zvcih2YXIgaT0wO2k8YW5jaG9yc1BlckZhY2U7aSsrKXthLnB1c2goW3gxK2R4KmkseTErZHkqaSwwLDBdKTt9fTtmb3IodmFyIGk9MDtpPHNlZ21lbnRzLmxlbmd0aDtpKyspe19jb21wdXRlRmFjZS5hcHBseShudWxsLHNlZ21lbnRzW2ldKTt9cmV0dXJuIGE7fSxfc2hhcGU9ZnVuY3Rpb24gX3NoYXBlKGZhY2VzKXt2YXIgcz1bXTtmb3IodmFyIGk9MDtpPGZhY2VzLmxlbmd0aDtpKyspe3MucHVzaChbZmFjZXNbaV1bMF0sZmFjZXNbaV1bMV0sZmFjZXNbaV1bMl0sZmFjZXNbaV1bM10sMS9mYWNlcy5sZW5ndGhdKTt9cmV0dXJuIF9wYXRoKHMpO30sX3JlY3RhbmdsZT1mdW5jdGlvbiBfcmVjdGFuZ2xlKCl7cmV0dXJuIF9zaGFwZShbWzAsMCwxLDBdLFsxLDAsMSwxXSxbMSwxLDAsMV0sWzAsMSwwLDBdXSk7fTt2YXIgX3NoYXBlcz17XCJDaXJjbGVcIjpfY2lyY2xlLFwiRWxsaXBzZVwiOl9jaXJjbGUsXCJEaWFtb25kXCI6ZnVuY3Rpb24gRGlhbW9uZCgpe3JldHVybiBfc2hhcGUoW1swLjUsMCwxLDAuNV0sWzEsMC41LDAuNSwxXSxbMC41LDEsMCwwLjVdLFswLDAuNSwwLjUsMF1dKTt9LFwiUmVjdGFuZ2xlXCI6X3JlY3RhbmdsZSxcIlNxdWFyZVwiOl9yZWN0YW5nbGUsXCJUcmlhbmdsZVwiOmZ1bmN0aW9uIFRyaWFuZ2xlKCl7cmV0dXJuIF9zaGFwZShbWzAuNSwwLDEsMV0sWzEsMSwwLDFdLFswLDEsMC41LDBdXSk7fSxcIlBhdGhcIjpmdW5jdGlvbiBQYXRoKHBhcmFtcyl7dmFyIHBvaW50cz1wYXJhbXMucG9pbnRzLHA9W10sdGw9MDtmb3IodmFyIGk9MDtpPHBvaW50cy5sZW5ndGgtMTtpKyspe3ZhciBsPU1hdGguc3FydChNYXRoLnBvdyhwb2ludHNbaV1bMl0tcG9pbnRzW2ldWzBdKStNYXRoLnBvdyhwb2ludHNbaV1bM10tcG9pbnRzW2ldWzFdKSk7dGwrPWw7cC5wdXNoKFtwb2ludHNbaV1bMF0scG9pbnRzW2ldWzFdLHBvaW50c1tpKzFdWzBdLHBvaW50c1tpKzFdWzFdLGxdKTt9Zm9yKHZhciBqPTA7ajxwLmxlbmd0aDtqKyspe3Bbal1bNF09cFtqXVs0XS90bDt9cmV0dXJuIF9wYXRoKHApO319LF9yb3RhdGU9ZnVuY3Rpb24gX3JvdGF0ZShwb2ludHMsYW1vdW50SW5EZWdyZWVzKXt2YXIgbz1bXSx0aGV0YT1hbW91bnRJbkRlZ3JlZXMvMTgwKk1hdGguUEk7Zm9yKHZhciBpPTA7aTxwb2ludHMubGVuZ3RoO2krKyl7dmFyIF94PXBvaW50c1tpXVswXS0wLjUsX3k9cG9pbnRzW2ldWzFdLTAuNTtvLnB1c2goWzAuNSsoX3gqTWF0aC5jb3ModGhldGEpLV95Kk1hdGguc2luKHRoZXRhKSksMC41KyhfeCpNYXRoLnNpbih0aGV0YSkrX3kqTWF0aC5jb3ModGhldGEpKSxwb2ludHNbaV1bMl0scG9pbnRzW2ldWzNdXSk7fXJldHVybiBvO307aWYoIV9zaGFwZXNbc2hhcGVdKXt0aHJvdyBuZXcgRXJyb3IoXCJTaGFwZSBbXCIrc2hhcGUrXCJdIGlzIHVua25vd24gYnkgUGVyaW1ldGVyIEFuY2hvciB0eXBlXCIpO312YXIgZGE9X3NoYXBlc1tzaGFwZV0ocGFyYW1zKTtpZihwYXJhbXMucm90YXRpb24pe2RhPV9yb3RhdGUoZGEscGFyYW1zLnJvdGF0aW9uKTt9dmFyIGE9cGFyYW1zLmpzUGx1bWJJbnN0YW5jZS5tYWtlRHluYW1pY0FuY2hvcihkYSk7YS50eXBlPVwiUGVyaW1ldGVyXCI7cmV0dXJuIGE7fTt9KS5jYWxsKHR5cGVvZiB3aW5kb3chPT0ndW5kZWZpbmVkJz93aW5kb3c6dGhpcyk7LypcclxuICogVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSBkZWZhdWx0IENvbm5lY3RvcnMsIEVuZHBvaW50IGFuZCBPdmVybGF5IGRlZmluaXRpb25zLlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgLSAyMDE4IGpzUGx1bWIgKGhlbGxvQGpzcGx1bWJ0b29sa2l0LmNvbSlcclxuICogXHJcbiAqIGh0dHBzOi8vanNwbHVtYnRvb2xraXQuY29tXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qc3BsdW1iL2pzcGx1bWJcclxuICogXHJcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMMiBsaWNlbnNlcy5cclxuICovOyhmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3ZhciByb290PXRoaXMsX2pwPXJvb3QuanNQbHVtYixfanU9cm9vdC5qc1BsdW1iVXRpbCxfamc9cm9vdC5CaWx0b25nO19qcC5TZWdtZW50cz17LypcclxuICAgICAgICAgKiBDbGFzczogQWJzdHJhY3RTZWdtZW50XHJcbiAgICAgICAgICogQSBDb25uZWN0b3IgaXMgbWFkZSB1cCBvZiAxLi5OIFNlZ21lbnRzLCBlYWNoIG9mIHdoaWNoIGhhcyBhIFR5cGUsIHN1Y2ggYXMgJ1N0cmFpZ2h0JywgJ0FyYycsXHJcbiAgICAgICAgICogJ0JlemllcicuIFRoaXMgaXMgbmV3IGZyb20gMS40LjIsIGFuZCBnaXZlcyB1cyBhIGxvdCBtb3JlIGZsZXhpYmlsaXR5IHdoZW4gZHJhd2luZyBjb25uZWN0aW9uczogdGhpbmdzIHN1Y2hcclxuICAgICAgICAgKiBhcyByb3VuZGVkIGNvcm5lcnMgZm9yIGZsb3djaGFydCBjb25uZWN0b3JzLCBmb3IgZXhhbXBsZSwgb3IgYSBzdHJhaWdodCBsaW5lIHN0dWIgZm9yIEJlemllciBjb25uZWN0aW9ucywgYXJlXHJcbiAgICAgICAgICogbXVjaCBlYXNpZXIgdG8gZG8gbm93LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQSBTZWdtZW50IGlzIHJlc3BvbnNpYmxlIGZvciBwcm92aWRpbmcgY29vcmRpbmF0ZXMgZm9yIHBhaW50aW5nIGl0LCBhbmQgYWxzbyBtdXN0IGJlIGFibGUgdG8gcmVwb3J0IGl0cyBsZW5ndGguXHJcbiAgICAgICAgICogXHJcbiAgICAgICAgICovQWJzdHJhY3RTZWdtZW50OmZ1bmN0aW9uIEFic3RyYWN0U2VnbWVudChwYXJhbXMpe3RoaXMucGFyYW1zPXBhcmFtczsvKipcclxuICAgICAgICAgICAgICogRnVuY3Rpb246IGZpbmRDbG9zZXN0UG9pbnRPblBhdGhcclxuICAgICAgICAgICAgICogRmluZHMgdGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhpcyBzZWdtZW50IHRvIHRoZSBnaXZlbiBbeCwgeV0sXHJcbiAgICAgICAgICAgICAqIHJldHVybmluZyBib3RoIHRoZSB4IGFuZCB5IG9mIHRoZSBwb2ludCBwbHVzIGl0cyBkaXN0YW5jZSBmcm9tXHJcbiAgICAgICAgICAgICAqIHRoZSBzdXBwbGllZCBwb2ludCwgYW5kIGl0cyBsb2NhdGlvbiBhbG9uZyB0aGUgbGVuZ3RoIG9mIHRoZVxyXG4gICAgICAgICAgICAgKiBwYXRoIGluc2NyaWJlZCBieSB0aGUgc2VnbWVudC4gIFRoaXMgaW1wbGVtZW50YXRpb24gcmV0dXJuc1xyXG4gICAgICAgICAgICAgKiBJbmZpbml0eSBmb3IgZGlzdGFuY2UgYW5kIG51bGwgdmFsdWVzIGZvciBldmVyeXRoaW5nIGVsc2U7XHJcbiAgICAgICAgICAgICAqIHN1YmNsYXNzZXMgYXJlIGV4cGVjdGVkIHRvIG92ZXJyaWRlLlxyXG4gICAgICAgICAgICAgKi90aGlzLmZpbmRDbG9zZXN0UG9pbnRPblBhdGg9ZnVuY3Rpb24oeCx5KXtyZXR1cm57ZDpJbmZpbml0eSx4Om51bGwseTpudWxsLGw6bnVsbH07fTt0aGlzLmdldEJvdW5kcz1mdW5jdGlvbigpe3JldHVybnttaW5YOk1hdGgubWluKHBhcmFtcy54MSxwYXJhbXMueDIpLG1pblk6TWF0aC5taW4ocGFyYW1zLnkxLHBhcmFtcy55MiksbWF4WDpNYXRoLm1heChwYXJhbXMueDEscGFyYW1zLngyKSxtYXhZOk1hdGgubWF4KHBhcmFtcy55MSxwYXJhbXMueTIpfTt9O30sU3RyYWlnaHQ6ZnVuY3Rpb24gU3RyYWlnaHQocGFyYW1zKXt2YXIgX3N1cGVyPV9qcC5TZWdtZW50cy5BYnN0cmFjdFNlZ21lbnQuYXBwbHkodGhpcyxhcmd1bWVudHMpLGxlbmd0aCxtLG0yLHgxLHgyLHkxLHkyLF9yZWNhbGM9ZnVuY3Rpb24gX3JlY2FsYygpe2xlbmd0aD1NYXRoLnNxcnQoTWF0aC5wb3coeDIteDEsMikrTWF0aC5wb3coeTIteTEsMikpO209X2pnLmdyYWRpZW50KHt4OngxLHk6eTF9LHt4OngyLHk6eTJ9KTttMj0tMS9tO307dGhpcy50eXBlPVwiU3RyYWlnaHRcIjt0aGlzLmdldExlbmd0aD1mdW5jdGlvbigpe3JldHVybiBsZW5ndGg7fTt0aGlzLmdldEdyYWRpZW50PWZ1bmN0aW9uKCl7cmV0dXJuIG07fTt0aGlzLmdldENvb3JkaW5hdGVzPWZ1bmN0aW9uKCl7cmV0dXJue3gxOngxLHkxOnkxLHgyOngyLHkyOnkyfTt9O3RoaXMuc2V0Q29vcmRpbmF0ZXM9ZnVuY3Rpb24oY29vcmRzKXt4MT1jb29yZHMueDE7eTE9Y29vcmRzLnkxO3gyPWNvb3Jkcy54Mjt5Mj1jb29yZHMueTI7X3JlY2FsYygpO307dGhpcy5zZXRDb29yZGluYXRlcyh7eDE6cGFyYW1zLngxLHkxOnBhcmFtcy55MSx4MjpwYXJhbXMueDIseTI6cGFyYW1zLnkyfSk7dGhpcy5nZXRCb3VuZHM9ZnVuY3Rpb24oKXtyZXR1cm57bWluWDpNYXRoLm1pbih4MSx4MiksbWluWTpNYXRoLm1pbih5MSx5MiksbWF4WDpNYXRoLm1heCh4MSx4MiksbWF4WTpNYXRoLm1heCh5MSx5Mil9O307LyoqXHJcbiAgICAgICAgICAgICAqIHJldHVybnMgdGhlIHBvaW50IG9uIHRoZSBzZWdtZW50J3MgcGF0aCB0aGF0IGlzICdsb2NhdGlvbicgYWxvbmcgdGhlIGxlbmd0aCBvZiB0aGUgcGF0aCwgd2hlcmUgJ2xvY2F0aW9uJyBpcyBhIGRlY2ltYWwgZnJvbVxyXG4gICAgICAgICAgICAgKiAwIHRvIDEgaW5jbHVzaXZlLiBmb3IgdGhlIHN0cmFpZ2h0IGxpbmUgc2VnbWVudCB0aGlzIGlzIHNpbXBsZSBtYXRocy5cclxuICAgICAgICAgICAgICovdGhpcy5wb2ludE9uUGF0aD1mdW5jdGlvbihsb2NhdGlvbixhYnNvbHV0ZSl7aWYobG9jYXRpb249PT0wJiYhYWJzb2x1dGUpe3JldHVybnt4OngxLHk6eTF9O31lbHNlIGlmKGxvY2F0aW9uPT09MSYmIWFic29sdXRlKXtyZXR1cm57eDp4Mix5OnkyfTt9ZWxzZXt2YXIgbD1hYnNvbHV0ZT9sb2NhdGlvbj4wP2xvY2F0aW9uOmxlbmd0aCtsb2NhdGlvbjpsb2NhdGlvbipsZW5ndGg7cmV0dXJuIF9qZy5wb2ludE9uTGluZSh7eDp4MSx5OnkxfSx7eDp4Mix5OnkyfSxsKTt9fTsvKipcclxuICAgICAgICAgICAgICogcmV0dXJucyB0aGUgZ3JhZGllbnQgb2YgdGhlIHNlZ21lbnQgYXQgdGhlIGdpdmVuIHBvaW50IC0gd2hpY2ggZm9yIHVzIGlzIGNvbnN0YW50LlxyXG4gICAgICAgICAgICAgKi90aGlzLmdyYWRpZW50QXRQb2ludD1mdW5jdGlvbihfKXtyZXR1cm4gbTt9Oy8qKlxyXG4gICAgICAgICAgICAgKiByZXR1cm5zIHRoZSBwb2ludCBvbiB0aGUgc2VnbWVudCdzIHBhdGggdGhhdCBpcyAnZGlzdGFuY2UnIGFsb25nIHRoZSBsZW5ndGggb2YgdGhlIHBhdGggZnJvbSAnbG9jYXRpb24nLCB3aGVyZVxyXG4gICAgICAgICAgICAgKiAnbG9jYXRpb24nIGlzIGEgZGVjaW1hbCBmcm9tIDAgdG8gMSBpbmNsdXNpdmUsIGFuZCAnZGlzdGFuY2UnIGlzIGEgbnVtYmVyIG9mIHBpeGVscy5cclxuICAgICAgICAgICAgICogdGhpcyBoYW5kcyBvZmYgdG8ganNQbHVtYlV0aWwgdG8gZG8gdGhlIG1hdGhzLCBzdXBwbHlpbmcgdHdvIHBvaW50cyBhbmQgdGhlIGRpc3RhbmNlLlxyXG4gICAgICAgICAgICAgKi90aGlzLnBvaW50QWxvbmdQYXRoRnJvbT1mdW5jdGlvbihsb2NhdGlvbixkaXN0YW5jZSxhYnNvbHV0ZSl7dmFyIHA9dGhpcy5wb2ludE9uUGF0aChsb2NhdGlvbixhYnNvbHV0ZSksZmFyQXdheVBvaW50PWRpc3RhbmNlPD0wP3t4OngxLHk6eTF9Ont4OngyLHk6eTJ9Oy8qXHJcbiAgICAgICAgICAgICAgICAgbG9jYXRpb24gPT0gMSA/IHtcclxuICAgICAgICAgICAgICAgICB4OngxICsgKCh4MiAtIHgxKSAqIDEwKSxcclxuICAgICAgICAgICAgICAgICB5OnkxICsgKCh5MSAtIHkyKSAqIDEwKVxyXG4gICAgICAgICAgICAgICAgIH0gOlxyXG4gICAgICAgICAgICAgICAgICovaWYoZGlzdGFuY2U8PTAmJk1hdGguYWJzKGRpc3RhbmNlKT4xKXtkaXN0YW5jZSo9LTE7fXJldHVybiBfamcucG9pbnRPbkxpbmUocCxmYXJBd2F5UG9pbnQsZGlzdGFuY2UpO307Ly8gaXMgYyBiZXR3ZWVuIGEgYW5kIGI/XG52YXIgd2l0aGluPWZ1bmN0aW9uIHdpdGhpbihhLGIsYyl7cmV0dXJuIGM+PU1hdGgubWluKGEsYikmJmM8PU1hdGgubWF4KGEsYik7fTsvLyBmaW5kIHdoaWNoIG9mIGEgYW5kIGIgaXMgY2xvc2VzdCB0byBjXG52YXIgY2xvc2VzdD1mdW5jdGlvbiBjbG9zZXN0KGEsYixjKXtyZXR1cm4gTWF0aC5hYnMoYy1hKTxNYXRoLmFicyhjLWIpP2E6Yjt9Oy8qKlxyXG4gICAgICAgICAgICAgRnVuY3Rpb246IGZpbmRDbG9zZXN0UG9pbnRPblBhdGhcclxuICAgICAgICAgICAgIEZpbmRzIHRoZSBjbG9zZXN0IHBvaW50IG9uIHRoaXMgc2VnbWVudCB0byBbeCx5XS4gU2VlXHJcbiAgICAgICAgICAgICBub3RlcyBvbiB0aGlzIG1ldGhvZCBpbiBBYnN0cmFjdFNlZ21lbnQuXHJcbiAgICAgICAgICAgICAqL3RoaXMuZmluZENsb3Nlc3RQb2ludE9uUGF0aD1mdW5jdGlvbih4LHkpe3ZhciBvdXQ9e2Q6SW5maW5pdHkseDpudWxsLHk6bnVsbCxsOm51bGwseDE6eDEseDI6eDIseTE6eTEseTI6eTJ9O2lmKG09PT0wKXtvdXQueT15MTtvdXQueD13aXRoaW4oeDEseDIseCk/eDpjbG9zZXN0KHgxLHgyLHgpO31lbHNlIGlmKG09PT1JbmZpbml0eXx8bT09PS1JbmZpbml0eSl7b3V0Lng9eDE7b3V0Lnk9d2l0aGluKHkxLHkyLHkpP3k6Y2xvc2VzdCh5MSx5Mix5KTt9ZWxzZXsvLyBjbG9zZXN0IHBvaW50IGxpZXMgb24gbm9ybWFsIGZyb20gZ2l2ZW4gcG9pbnQgdG8gdGhpcyBsaW5lLiAgXG52YXIgYj15MS1tKngxLGIyPXktbTIqeCwvLyB5MSA9IG0ueDEgKyBiIGFuZCB5MSA9IG0yLngxICsgYjJcbi8vIHNvIG0ueDEgKyBiID0gbTIueDEgKyBiMlxuLy8geDEobSAtIG0yKSA9IGIyIC0gYlxuLy8geDEgPSAoYjIgLSBiKSAvIChtIC0gbTIpXG5feDE9KGIyLWIpLyhtLW0yKSxfeTE9bSpfeDErYjtvdXQueD13aXRoaW4oeDEseDIsX3gxKT9feDE6Y2xvc2VzdCh4MSx4MixfeDEpOy8vX3gxO1xub3V0Lnk9d2l0aGluKHkxLHkyLF95MSk/X3kxOmNsb3Nlc3QoeTEseTIsX3kxKTsvL195MTtcbn12YXIgZnJhY3Rpb25JblNlZ21lbnQ9X2pnLmxpbmVMZW5ndGgoW291dC54LG91dC55XSxbeDEseTFdKTtvdXQuZD1famcubGluZUxlbmd0aChbeCx5XSxbb3V0Lngsb3V0LnldKTtvdXQubD1mcmFjdGlvbkluU2VnbWVudC9sZW5ndGg7cmV0dXJuIG91dDt9O30sLypcclxuICAgICAgICAgQXJjIFNlZ21lbnQuIFlvdSBuZWVkIHRvIHN1cHBseTpcclxuXHJcbiAgICAgICAgIHIgICAtICAgcmFkaXVzXHJcbiAgICAgICAgIGN4ICAtICAgY2VudGVyIHggZm9yIHRoZSBhcmNcclxuICAgICAgICAgY3kgIC0gICBjZW50ZXIgeSBmb3IgdGhlIGFyY1xyXG4gICAgICAgICBhYyAgLSAgIHdoZXRoZXIgdGhlIGFyYyBpcyBhbnRpY2xvY2t3aXNlIG9yIG5vdC4gZGVmYXVsdCBpcyBjbG9ja3dpc2UuXHJcblxyXG4gICAgICAgICBhbmQgdGhlbiBlaXRoZXI6XHJcblxyXG4gICAgICAgICBzdGFydEFuZ2xlICAtICAgc3RhcnRBbmdsZSBmb3IgdGhlIGFyYy5cclxuICAgICAgICAgZW5kQW5nbGUgICAgLSAgIGVuZEFuZ2xlIGZvciB0aGUgYXJjLlxyXG5cclxuICAgICAgICAgb3I6XHJcblxyXG4gICAgICAgICB4MSAgICAgICAgICAtICAgeCBmb3Igc3RhcnQgcG9pbnRcclxuICAgICAgICAgeTEgICAgICAgICAgLSAgIHkgZm9yIHN0YXJ0IHBvaW50XHJcbiAgICAgICAgIHgyICAgICAgICAgIC0gICB4IGZvciBlbmQgcG9pbnRcclxuICAgICAgICAgeTIgICAgICAgICAgLSAgIHkgZm9yIGVuZCBwb2ludFxyXG5cclxuICAgICAgICAgKi9BcmM6ZnVuY3Rpb24gQXJjKHBhcmFtcyl7dmFyIF9zdXBlcj1fanAuU2VnbWVudHMuQWJzdHJhY3RTZWdtZW50LmFwcGx5KHRoaXMsYXJndW1lbnRzKSxfY2FsY0FuZ2xlPWZ1bmN0aW9uIF9jYWxjQW5nbGUoX3gsX3kpe3JldHVybiBfamcudGhldGEoW3BhcmFtcy5jeCxwYXJhbXMuY3ldLFtfeCxfeV0pO30sX2NhbGNBbmdsZUZvckxvY2F0aW9uPWZ1bmN0aW9uIF9jYWxjQW5nbGVGb3JMb2NhdGlvbihzZWdtZW50LGxvY2F0aW9uKXtpZihzZWdtZW50LmFudGljbG9ja3dpc2Upe3ZhciBzYT1zZWdtZW50LnN0YXJ0QW5nbGU8c2VnbWVudC5lbmRBbmdsZT9zZWdtZW50LnN0YXJ0QW5nbGUrVFdPX1BJOnNlZ21lbnQuc3RhcnRBbmdsZSxzPU1hdGguYWJzKHNhLXNlZ21lbnQuZW5kQW5nbGUpO3JldHVybiBzYS1zKmxvY2F0aW9uO31lbHNle3ZhciBlYT1zZWdtZW50LmVuZEFuZ2xlPHNlZ21lbnQuc3RhcnRBbmdsZT9zZWdtZW50LmVuZEFuZ2xlK1RXT19QSTpzZWdtZW50LmVuZEFuZ2xlLHNzPU1hdGguYWJzKGVhLXNlZ21lbnQuc3RhcnRBbmdsZSk7cmV0dXJuIHNlZ21lbnQuc3RhcnRBbmdsZStzcypsb2NhdGlvbjt9fSxUV09fUEk9MipNYXRoLlBJO3RoaXMucmFkaXVzPXBhcmFtcy5yO3RoaXMuYW50aWNsb2Nrd2lzZT1wYXJhbXMuYWM7dGhpcy50eXBlPVwiQXJjXCI7aWYocGFyYW1zLnN0YXJ0QW5nbGUmJnBhcmFtcy5lbmRBbmdsZSl7dGhpcy5zdGFydEFuZ2xlPXBhcmFtcy5zdGFydEFuZ2xlO3RoaXMuZW5kQW5nbGU9cGFyYW1zLmVuZEFuZ2xlO3RoaXMueDE9cGFyYW1zLmN4K3RoaXMucmFkaXVzKk1hdGguY29zKHBhcmFtcy5zdGFydEFuZ2xlKTt0aGlzLnkxPXBhcmFtcy5jeSt0aGlzLnJhZGl1cypNYXRoLnNpbihwYXJhbXMuc3RhcnRBbmdsZSk7dGhpcy54Mj1wYXJhbXMuY3grdGhpcy5yYWRpdXMqTWF0aC5jb3MocGFyYW1zLmVuZEFuZ2xlKTt0aGlzLnkyPXBhcmFtcy5jeSt0aGlzLnJhZGl1cypNYXRoLnNpbihwYXJhbXMuZW5kQW5nbGUpO31lbHNle3RoaXMuc3RhcnRBbmdsZT1fY2FsY0FuZ2xlKHBhcmFtcy54MSxwYXJhbXMueTEpO3RoaXMuZW5kQW5nbGU9X2NhbGNBbmdsZShwYXJhbXMueDIscGFyYW1zLnkyKTt0aGlzLngxPXBhcmFtcy54MTt0aGlzLnkxPXBhcmFtcy55MTt0aGlzLngyPXBhcmFtcy54Mjt0aGlzLnkyPXBhcmFtcy55Mjt9aWYodGhpcy5lbmRBbmdsZTwwKXt0aGlzLmVuZEFuZ2xlKz1UV09fUEk7fWlmKHRoaXMuc3RhcnRBbmdsZTwwKXt0aGlzLnN0YXJ0QW5nbGUrPVRXT19QSTt9Ly8gc2VnbWVudCBpcyB1c2VkIGJ5IHZtbCAgICAgXG4vL3RoaXMuc2VnbWVudCA9IF9qZy5xdWFkcmFudChbdGhpcy54MSwgdGhpcy55MV0sIFt0aGlzLngyLCB0aGlzLnkyXSk7XG4vLyB3ZSBub3cgaGF2ZSBzdGFydEFuZ2xlIGFuZCBlbmRBbmdsZSBhcyBwb3NpdGl2ZSBudW1iZXJzLCBtZWFuaW5nIHRoZVxuLy8gYWJzb2x1dGUgZGlmZmVyZW5jZSAofGR8KSBiZXR3ZWVuIHRoZW0gaXMgdGhlIHN3ZWVwIChzKSBvZiB0aGlzIGFyYywgdW5sZXNzIHRoZVxuLy8gYXJjIGlzICdhbnRpY2xvY2t3aXNlJyBpbiB3aGljaCBjYXNlICdzJyBpcyBnaXZlbiBieSAyUEkgLSB8ZHwuXG52YXIgZWE9dGhpcy5lbmRBbmdsZTx0aGlzLnN0YXJ0QW5nbGU/dGhpcy5lbmRBbmdsZStUV09fUEk6dGhpcy5lbmRBbmdsZTt0aGlzLnN3ZWVwPU1hdGguYWJzKGVhLXRoaXMuc3RhcnRBbmdsZSk7aWYodGhpcy5hbnRpY2xvY2t3aXNlKXt0aGlzLnN3ZWVwPVRXT19QSS10aGlzLnN3ZWVwO312YXIgY2lyY3VtZmVyZW5jZT0yKk1hdGguUEkqdGhpcy5yYWRpdXMsZnJhYz10aGlzLnN3ZWVwL1RXT19QSSxsZW5ndGg9Y2lyY3VtZmVyZW5jZSpmcmFjO3RoaXMuZ2V0TGVuZ3RoPWZ1bmN0aW9uKCl7cmV0dXJuIGxlbmd0aDt9O3RoaXMuZ2V0Qm91bmRzPWZ1bmN0aW9uKCl7cmV0dXJue21pblg6cGFyYW1zLmN4LXBhcmFtcy5yLG1heFg6cGFyYW1zLmN4K3BhcmFtcy5yLG1pblk6cGFyYW1zLmN5LXBhcmFtcy5yLG1heFk6cGFyYW1zLmN5K3BhcmFtcy5yfTt9O3ZhciBWRVJZX1NNQUxMX1ZBTFVFPTAuMDAwMDAwMDAwMSxnZW50bGVSb3VuZD1mdW5jdGlvbiBnZW50bGVSb3VuZChuKXt2YXIgZj1NYXRoLmZsb29yKG4pLHI9TWF0aC5jZWlsKG4pO2lmKG4tZjxWRVJZX1NNQUxMX1ZBTFVFKXtyZXR1cm4gZjt9ZWxzZSBpZihyLW48VkVSWV9TTUFMTF9WQUxVRSl7cmV0dXJuIHI7fXJldHVybiBuO307LyoqXHJcbiAgICAgICAgICAgICAqIHJldHVybnMgdGhlIHBvaW50IG9uIHRoZSBzZWdtZW50J3MgcGF0aCB0aGF0IGlzICdsb2NhdGlvbicgYWxvbmcgdGhlIGxlbmd0aCBvZiB0aGUgcGF0aCwgd2hlcmUgJ2xvY2F0aW9uJyBpcyBhIGRlY2ltYWwgZnJvbVxyXG4gICAgICAgICAgICAgKiAwIHRvIDEgaW5jbHVzaXZlLlxyXG4gICAgICAgICAgICAgKi90aGlzLnBvaW50T25QYXRoPWZ1bmN0aW9uKGxvY2F0aW9uLGFic29sdXRlKXtpZihsb2NhdGlvbj09PTApe3JldHVybnt4OnRoaXMueDEseTp0aGlzLnkxLHRoZXRhOnRoaXMuc3RhcnRBbmdsZX07fWVsc2UgaWYobG9jYXRpb249PT0xKXtyZXR1cm57eDp0aGlzLngyLHk6dGhpcy55Mix0aGV0YTp0aGlzLmVuZEFuZ2xlfTt9aWYoYWJzb2x1dGUpe2xvY2F0aW9uPWxvY2F0aW9uL2xlbmd0aDt9dmFyIGFuZ2xlPV9jYWxjQW5nbGVGb3JMb2NhdGlvbih0aGlzLGxvY2F0aW9uKSxfeD1wYXJhbXMuY3grcGFyYW1zLnIqTWF0aC5jb3MoYW5nbGUpLF95PXBhcmFtcy5jeStwYXJhbXMucipNYXRoLnNpbihhbmdsZSk7cmV0dXJue3g6Z2VudGxlUm91bmQoX3gpLHk6Z2VudGxlUm91bmQoX3kpLHRoZXRhOmFuZ2xlfTt9Oy8qKlxyXG4gICAgICAgICAgICAgKiByZXR1cm5zIHRoZSBncmFkaWVudCBvZiB0aGUgc2VnbWVudCBhdCB0aGUgZ2l2ZW4gcG9pbnQuXHJcbiAgICAgICAgICAgICAqL3RoaXMuZ3JhZGllbnRBdFBvaW50PWZ1bmN0aW9uKGxvY2F0aW9uLGFic29sdXRlKXt2YXIgcD10aGlzLnBvaW50T25QYXRoKGxvY2F0aW9uLGFic29sdXRlKTt2YXIgbT1famcubm9ybWFsKFtwYXJhbXMuY3gscGFyYW1zLmN5XSxbcC54LHAueV0pO2lmKCF0aGlzLmFudGljbG9ja3dpc2UmJihtPT09SW5maW5pdHl8fG09PT0tSW5maW5pdHkpKXttKj0tMTt9cmV0dXJuIG07fTt0aGlzLnBvaW50QWxvbmdQYXRoRnJvbT1mdW5jdGlvbihsb2NhdGlvbixkaXN0YW5jZSxhYnNvbHV0ZSl7dmFyIHA9dGhpcy5wb2ludE9uUGF0aChsb2NhdGlvbixhYnNvbHV0ZSksYXJjU3Bhbj1kaXN0YW5jZS9jaXJjdW1mZXJlbmNlKjIqTWF0aC5QSSxkaXI9dGhpcy5hbnRpY2xvY2t3aXNlPy0xOjEsc3RhcnRBbmdsZT1wLnRoZXRhK2RpciphcmNTcGFuLHN0YXJ0WD1wYXJhbXMuY3grdGhpcy5yYWRpdXMqTWF0aC5jb3Moc3RhcnRBbmdsZSksc3RhcnRZPXBhcmFtcy5jeSt0aGlzLnJhZGl1cypNYXRoLnNpbihzdGFydEFuZ2xlKTtyZXR1cm57eDpzdGFydFgseTpzdGFydFl9O307fSxCZXppZXI6ZnVuY3Rpb24gQmV6aWVyKHBhcmFtcyl7dGhpcy5jdXJ2ZT1be3g6cGFyYW1zLngxLHk6cGFyYW1zLnkxfSx7eDpwYXJhbXMuY3AxeCx5OnBhcmFtcy5jcDF5fSx7eDpwYXJhbXMuY3AyeCx5OnBhcmFtcy5jcDJ5fSx7eDpwYXJhbXMueDIseTpwYXJhbXMueTJ9XTt2YXIgX3N1cGVyPV9qcC5TZWdtZW50cy5BYnN0cmFjdFNlZ21lbnQuYXBwbHkodGhpcyxhcmd1bWVudHMpOy8vIGFsdGhvdWdoIHRoaXMgaXMgbm90IGEgc3RyaWN0bHkgcmlnb3JvdXMgZGV0ZXJtaW5hdGlvbiBvZiBib3VuZHNcbi8vIG9mIGEgYmV6aWVyIGN1cnZlLCBpdCB3b3JrcyBmb3IgdGhlIHR5cGVzIG9mIGN1cnZlcyB0aGF0IHRoaXMgc2VnbWVudFxuLy8gdHlwZSBwcm9kdWNlcy5cbnRoaXMuYm91bmRzPXttaW5YOk1hdGgubWluKHBhcmFtcy54MSxwYXJhbXMueDIscGFyYW1zLmNwMXgscGFyYW1zLmNwMngpLG1pblk6TWF0aC5taW4ocGFyYW1zLnkxLHBhcmFtcy55MixwYXJhbXMuY3AxeSxwYXJhbXMuY3AyeSksbWF4WDpNYXRoLm1heChwYXJhbXMueDEscGFyYW1zLngyLHBhcmFtcy5jcDF4LHBhcmFtcy5jcDJ4KSxtYXhZOk1hdGgubWF4KHBhcmFtcy55MSxwYXJhbXMueTIscGFyYW1zLmNwMXkscGFyYW1zLmNwMnkpfTt0aGlzLnR5cGU9XCJCZXppZXJcIjt2YXIgX3RyYW5zbGF0ZUxvY2F0aW9uPWZ1bmN0aW9uIF90cmFuc2xhdGVMb2NhdGlvbihfY3VydmUsbG9jYXRpb24sYWJzb2x1dGUpe2lmKGFic29sdXRlKXtsb2NhdGlvbj1yb290LmpzQmV6aWVyLmxvY2F0aW9uQWxvbmdDdXJ2ZUZyb20oX2N1cnZlLGxvY2F0aW9uPjA/MDoxLGxvY2F0aW9uKTt9cmV0dXJuIGxvY2F0aW9uO307LyoqXHJcbiAgICAgICAgICAgICAqIHJldHVybnMgdGhlIHBvaW50IG9uIHRoZSBzZWdtZW50J3MgcGF0aCB0aGF0IGlzICdsb2NhdGlvbicgYWxvbmcgdGhlIGxlbmd0aCBvZiB0aGUgcGF0aCwgd2hlcmUgJ2xvY2F0aW9uJyBpcyBhIGRlY2ltYWwgZnJvbVxyXG4gICAgICAgICAgICAgKiAwIHRvIDEgaW5jbHVzaXZlLlxyXG4gICAgICAgICAgICAgKi90aGlzLnBvaW50T25QYXRoPWZ1bmN0aW9uKGxvY2F0aW9uLGFic29sdXRlKXtsb2NhdGlvbj1fdHJhbnNsYXRlTG9jYXRpb24odGhpcy5jdXJ2ZSxsb2NhdGlvbixhYnNvbHV0ZSk7cmV0dXJuIHJvb3QuanNCZXppZXIucG9pbnRPbkN1cnZlKHRoaXMuY3VydmUsbG9jYXRpb24pO307LyoqXHJcbiAgICAgICAgICAgICAqIHJldHVybnMgdGhlIGdyYWRpZW50IG9mIHRoZSBzZWdtZW50IGF0IHRoZSBnaXZlbiBwb2ludC5cclxuICAgICAgICAgICAgICovdGhpcy5ncmFkaWVudEF0UG9pbnQ9ZnVuY3Rpb24obG9jYXRpb24sYWJzb2x1dGUpe2xvY2F0aW9uPV90cmFuc2xhdGVMb2NhdGlvbih0aGlzLmN1cnZlLGxvY2F0aW9uLGFic29sdXRlKTtyZXR1cm4gcm9vdC5qc0Jlemllci5ncmFkaWVudEF0UG9pbnQodGhpcy5jdXJ2ZSxsb2NhdGlvbik7fTt0aGlzLnBvaW50QWxvbmdQYXRoRnJvbT1mdW5jdGlvbihsb2NhdGlvbixkaXN0YW5jZSxhYnNvbHV0ZSl7bG9jYXRpb249X3RyYW5zbGF0ZUxvY2F0aW9uKHRoaXMuY3VydmUsbG9jYXRpb24sYWJzb2x1dGUpO3JldHVybiByb290LmpzQmV6aWVyLnBvaW50QWxvbmdDdXJ2ZUZyb20odGhpcy5jdXJ2ZSxsb2NhdGlvbixkaXN0YW5jZSk7fTt0aGlzLmdldExlbmd0aD1mdW5jdGlvbigpe3JldHVybiByb290LmpzQmV6aWVyLmdldExlbmd0aCh0aGlzLmN1cnZlKTt9O3RoaXMuZ2V0Qm91bmRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYm91bmRzO307fX07X2pwLlNlZ21lbnRSZW5kZXJlcj17Z2V0UGF0aDpmdW5jdGlvbiBnZXRQYXRoKHNlZ21lbnQpe3JldHVybntcIlN0cmFpZ2h0XCI6ZnVuY3Rpb24gU3RyYWlnaHQoKXt2YXIgZD1zZWdtZW50LmdldENvb3JkaW5hdGVzKCk7cmV0dXJuXCJNIFwiK2QueDErXCIgXCIrZC55MStcIiBMIFwiK2QueDIrXCIgXCIrZC55Mjt9LFwiQmV6aWVyXCI6ZnVuY3Rpb24gQmV6aWVyKCl7dmFyIGQ9c2VnbWVudC5wYXJhbXM7cmV0dXJuXCJNIFwiK2QueDErXCIgXCIrZC55MStcIiBDIFwiK2QuY3AxeCtcIiBcIitkLmNwMXkrXCIgXCIrZC5jcDJ4K1wiIFwiK2QuY3AyeStcIiBcIitkLngyK1wiIFwiK2QueTI7fSxcIkFyY1wiOmZ1bmN0aW9uIEFyYygpe3ZhciBkPXNlZ21lbnQucGFyYW1zLGxhZj1zZWdtZW50LnN3ZWVwPk1hdGguUEk/MTowLHNmPXNlZ21lbnQuYW50aWNsb2Nrd2lzZT8wOjE7cmV0dXJuXCJNXCIrc2VnbWVudC54MStcIiBcIitzZWdtZW50LnkxK1wiIEEgXCIrc2VnbWVudC5yYWRpdXMrXCIgXCIrZC5yK1wiIDAgXCIrbGFmK1wiLFwiK3NmK1wiIFwiK3NlZ21lbnQueDIrXCIgXCIrc2VnbWVudC55Mjt9fVtzZWdtZW50LnR5cGVdKCk7fX07LypcclxuICAgICBDbGFzczogVUlDb21wb25lbnRcclxuICAgICBTdXBlcmNsYXNzIGZvciBDb25uZWN0b3IgYW5kIEFic3RyYWN0RW5kcG9pbnQuXHJcbiAgICAgKi92YXIgQWJzdHJhY3RDb21wb25lbnQ9ZnVuY3Rpb24gQWJzdHJhY3RDb21wb25lbnQoKXt0aGlzLnJlc2V0Qm91bmRzPWZ1bmN0aW9uKCl7dGhpcy5ib3VuZHM9e21pblg6SW5maW5pdHksbWluWTpJbmZpbml0eSxtYXhYOi1JbmZpbml0eSxtYXhZOi1JbmZpbml0eX07fTt0aGlzLnJlc2V0Qm91bmRzKCk7fTsvKlxyXG4gICAgICogQ2xhc3M6IENvbm5lY3RvclxyXG4gICAgICogU3VwZXJjbGFzcyBmb3IgYWxsIENvbm5lY3RvcnM7IGhlcmUgaXMgd2hlcmUgU2VnbWVudHMgYXJlIG1hbmFnZWQuICBUaGlzIGlzIGV4cG9zZWQgb24ganNQbHVtYiBqdXN0IHNvIGl0XHJcbiAgICAgKiBjYW4gYmUgYWNjZXNzZWQgZnJvbSBvdGhlciBmaWxlcy4gWW91IHNob3VsZCBub3QgdHJ5IHRvIGluc3RhbnRpYXRlIG9uZSBvZiB0aGVzZSBkaXJlY3RseS5cclxuICAgICAqXHJcbiAgICAgKiBXaGVuIHRoaXMgY2xhc3MgaXMgYXNrZWQgZm9yIGEgcG9pbnRPblBhdGgsIG9yIGdyYWRpZW50IGV0YywgaXQgbXVzdCBmaXJzdCBmaWd1cmUgb3V0IHdoaWNoIHNlZ21lbnQgdG8gZGlzcGF0Y2hcclxuICAgICAqIHRoYXQgcmVxdWVzdCB0by4gVGhpcyBpcyBkb25lIGJ5IGtlZXBpbmcgdHJhY2sgb2YgdGhlIHRvdGFsIGNvbm5lY3RvciBsZW5ndGggYXMgc2VnbWVudHMgYXJlIGFkZGVkLCBhbmQgYWxzb1xyXG4gICAgICogdGhlaXIgY3VtdWxhdGl2ZSByYXRpb3MgdG8gdGhlIHRvdGFsIGxlbmd0aC4gIFRoZW4gd2hlbiB0aGUgcmlnaHQgc2VnbWVudCBpcyBmb3VuZCBpdCBpcyBhIHNpbXBsZSBjYXNlIG9mIGRpc3BhdGNoaW5nXHJcbiAgICAgKiB0aGUgcmVxdWVzdCB0byBpdCAoYW5kIGFkanVzdGluZyAnbG9jYXRpb24nIHNvIHRoYXQgaXQgaXMgcmVsYXRpdmUgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGF0IHNlZ21lbnQuKVxyXG4gICAgICovX2pwLkNvbm5lY3RvcnMuQWJzdHJhY3RDb25uZWN0b3I9ZnVuY3Rpb24ocGFyYW1zKXtBYnN0cmFjdENvbXBvbmVudC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIHNlZ21lbnRzPVtdLHRvdGFsTGVuZ3RoPTAsc2VnbWVudFByb3BvcnRpb25zPVtdLHNlZ21lbnRQcm9wb3J0aW9uYWxMZW5ndGhzPVtdLHN0dWI9cGFyYW1zLnN0dWJ8fDAsc291cmNlU3R1Yj1fanUuaXNBcnJheShzdHViKT9zdHViWzBdOnN0dWIsdGFyZ2V0U3R1Yj1fanUuaXNBcnJheShzdHViKT9zdHViWzFdOnN0dWIsZ2FwPXBhcmFtcy5nYXB8fDAsc291cmNlR2FwPV9qdS5pc0FycmF5KGdhcCk/Z2FwWzBdOmdhcCx0YXJnZXRHYXA9X2p1LmlzQXJyYXkoZ2FwKT9nYXBbMV06Z2FwLHVzZXJQcm92aWRlZFNlZ21lbnRzPW51bGwscGFpbnRJbmZvPW51bGw7dGhpcy5nZXRQYXRoRGF0YT1mdW5jdGlvbigpe3ZhciBwPVwiXCI7Zm9yKHZhciBpPTA7aTxzZWdtZW50cy5sZW5ndGg7aSsrKXtwKz1fanAuU2VnbWVudFJlbmRlcmVyLmdldFBhdGgoc2VnbWVudHNbaV0pO3ArPVwiIFwiO31yZXR1cm4gcDt9Oy8qKlxyXG4gICAgICAgICAqIEZ1bmN0aW9uOiBmaW5kU2VnbWVudEZvclBvaW50XHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgc2VnbWVudCB0aGF0IGlzIGNsb3Nlc3QgdG8gdGhlIGdpdmVuIFt4LHldLFxyXG4gICAgICAgICAqIG51bGwgaWYgbm90aGluZyBmb3VuZC4gIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIEpTXHJcbiAgICAgICAgICogb2JqZWN0IHdpdGg6XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgIGQgICAtICAgZGlzdGFuY2UgZnJvbSBzZWdtZW50XHJcbiAgICAgICAgICogICBsICAgLSAgIHByb3BvcnRpb25hbCBsb2NhdGlvbiBpbiBzZWdtZW50XHJcbiAgICAgICAgICogICB4ICAgLSAgIHggcG9pbnQgb24gdGhlIHNlZ21lbnRcclxuICAgICAgICAgKiAgIHkgICAtICAgeSBwb2ludCBvbiB0aGUgc2VnbWVudFxyXG4gICAgICAgICAqICAgcyAgIC0gICB0aGUgc2VnbWVudCBpdHNlbGYuXHJcbiAgICAgICAgICovdGhpcy5maW5kU2VnbWVudEZvclBvaW50PWZ1bmN0aW9uKHgseSl7dmFyIG91dD17ZDpJbmZpbml0eSxzOm51bGwseDpudWxsLHk6bnVsbCxsOm51bGx9O2Zvcih2YXIgaT0wO2k8c2VnbWVudHMubGVuZ3RoO2krKyl7dmFyIF9zPXNlZ21lbnRzW2ldLmZpbmRDbG9zZXN0UG9pbnRPblBhdGgoeCx5KTtpZihfcy5kPG91dC5kKXtvdXQuZD1fcy5kO291dC5sPV9zLmw7b3V0Lng9X3MueDtvdXQueT1fcy55O291dC5zPXNlZ21lbnRzW2ldO291dC54MT1fcy54MTtvdXQueDI9X3MueDI7b3V0LnkxPV9zLnkxO291dC55Mj1fcy55MjtvdXQuaW5kZXg9aTt9fXJldHVybiBvdXQ7fTt2YXIgX3VwZGF0ZVNlZ21lbnRQcm9wb3J0aW9ucz1mdW5jdGlvbiBfdXBkYXRlU2VnbWVudFByb3BvcnRpb25zKCl7dmFyIGN1ckxvYz0wO2Zvcih2YXIgaT0wO2k8c2VnbWVudHMubGVuZ3RoO2krKyl7dmFyIHNsPXNlZ21lbnRzW2ldLmdldExlbmd0aCgpO3NlZ21lbnRQcm9wb3J0aW9uYWxMZW5ndGhzW2ldPXNsL3RvdGFsTGVuZ3RoO3NlZ21lbnRQcm9wb3J0aW9uc1tpXT1bY3VyTG9jLGN1ckxvYys9c2wvdG90YWxMZW5ndGhdO319LC8qKlxyXG4gICAgICAgICAgICAgKiByZXR1cm5zIFtzZWdtZW50LCBwcm9wb3J0aW9uIG9mIHRyYXZlbCBpbiBzZWdtZW50LCBzZWdtZW50IGluZGV4XSBmb3IgdGhlIHNlZ21lbnRcclxuICAgICAgICAgICAgICogdGhhdCBjb250YWlucyB0aGUgcG9pbnQgd2hpY2ggaXMgJ2xvY2F0aW9uJyBkaXN0YW5jZSBhbG9uZyB0aGUgZW50aXJlIHBhdGgsIHdoZXJlXHJcbiAgICAgICAgICAgICAqICdsb2NhdGlvbicgaXMgYSBkZWNpbWFsIGJldHdlZW4gMCBhbmQgMSBpbmNsdXNpdmUuIGluIHRoaXMgY29ubmVjdG9yIHR5cGUsIHBhdGhzXHJcbiAgICAgICAgICAgICAqIGFyZSBtYWRlIHVwIG9mIGEgbGlzdCBvZiBzZWdtZW50cywgZWFjaCBvZiB3aGljaCBjb250cmlidXRlcyBzb21lIGZyYWN0aW9uIHRvXHJcbiAgICAgICAgICAgICAqIHRoZSB0b3RhbCBsZW5ndGguXHJcbiAgICAgICAgICAgICAqIEZyb20gMS4zLjEwIHRoaXMgYWxzbyBzdXBwb3J0cyB0aGUgJ2Fic29sdXRlJyBwcm9wZXJ0eSwgd2hpY2ggbGV0cyB1cyBzcGVjaWZ5IGEgbG9jYXRpb25cclxuICAgICAgICAgICAgICogYXMgdGhlIGFic29sdXRlIGRpc3RhbmNlIGluIHBpeGVscywgcmF0aGVyIHRoYW4gYSBwcm9wb3J0aW9uIG9mIHRoZSB0b3RhbCBwYXRoLlxyXG4gICAgICAgICAgICAgKi9fZmluZFNlZ21lbnRGb3JMb2NhdGlvbj1mdW5jdGlvbiBfZmluZFNlZ21lbnRGb3JMb2NhdGlvbihsb2NhdGlvbixhYnNvbHV0ZSl7aWYoYWJzb2x1dGUpe2xvY2F0aW9uPWxvY2F0aW9uPjA/bG9jYXRpb24vdG90YWxMZW5ndGg6KHRvdGFsTGVuZ3RoK2xvY2F0aW9uKS90b3RhbExlbmd0aDt9dmFyIGlkeD1zZWdtZW50UHJvcG9ydGlvbnMubGVuZ3RoLTEsaW5TZWdtZW50UHJvcG9ydGlvbj0xO2Zvcih2YXIgaT0wO2k8c2VnbWVudFByb3BvcnRpb25zLmxlbmd0aDtpKyspe2lmKHNlZ21lbnRQcm9wb3J0aW9uc1tpXVsxXT49bG9jYXRpb24pe2lkeD1pOy8vIHRvZG8gaXMgdGhpcyBjb3JyZWN0IGZvciBhbGwgY29ubmVjdG9yIHBhdGggdHlwZXM/XG5pblNlZ21lbnRQcm9wb3J0aW9uPWxvY2F0aW9uPT09MT8xOmxvY2F0aW9uPT09MD8wOihsb2NhdGlvbi1zZWdtZW50UHJvcG9ydGlvbnNbaV1bMF0pL3NlZ21lbnRQcm9wb3J0aW9uYWxMZW5ndGhzW2ldO2JyZWFrO319cmV0dXJue3NlZ21lbnQ6c2VnbWVudHNbaWR4XSxwcm9wb3J0aW9uOmluU2VnbWVudFByb3BvcnRpb24saW5kZXg6aWR4fTt9LF9hZGRTZWdtZW50PWZ1bmN0aW9uIF9hZGRTZWdtZW50KGNvbm4sdHlwZSxwYXJhbXMpe2lmKHBhcmFtcy54MT09PXBhcmFtcy54MiYmcGFyYW1zLnkxPT09cGFyYW1zLnkyKXtyZXR1cm47fXZhciBzPW5ldyBfanAuU2VnbWVudHNbdHlwZV0ocGFyYW1zKTtzZWdtZW50cy5wdXNoKHMpO3RvdGFsTGVuZ3RoKz1zLmdldExlbmd0aCgpO2Nvbm4udXBkYXRlQm91bmRzKHMpO30sX2NsZWFyU2VnbWVudHM9ZnVuY3Rpb24gX2NsZWFyU2VnbWVudHMoKXt0b3RhbExlbmd0aD1zZWdtZW50cy5sZW5ndGg9c2VnbWVudFByb3BvcnRpb25zLmxlbmd0aD1zZWdtZW50UHJvcG9ydGlvbmFsTGVuZ3Rocy5sZW5ndGg9MDt9O3RoaXMuc2V0U2VnbWVudHM9ZnVuY3Rpb24oX3NlZ3Mpe3VzZXJQcm92aWRlZFNlZ21lbnRzPVtdO3RvdGFsTGVuZ3RoPTA7Zm9yKHZhciBpPTA7aTxfc2Vncy5sZW5ndGg7aSsrKXt1c2VyUHJvdmlkZWRTZWdtZW50cy5wdXNoKF9zZWdzW2ldKTt0b3RhbExlbmd0aCs9X3NlZ3NbaV0uZ2V0TGVuZ3RoKCk7fX07dGhpcy5nZXRMZW5ndGg9ZnVuY3Rpb24oKXtyZXR1cm4gdG90YWxMZW5ndGg7fTt2YXIgX3ByZXBhcmVDb21wdXRlPWZ1bmN0aW9uIF9wcmVwYXJlQ29tcHV0ZShwYXJhbXMpe3RoaXMuc3Ryb2tlV2lkdGg9cGFyYW1zLnN0cm9rZVdpZHRoO3ZhciBzZWdtZW50PV9qZy5xdWFkcmFudChwYXJhbXMuc291cmNlUG9zLHBhcmFtcy50YXJnZXRQb3MpLHN3YXBYPXBhcmFtcy50YXJnZXRQb3NbMF08cGFyYW1zLnNvdXJjZVBvc1swXSxzd2FwWT1wYXJhbXMudGFyZ2V0UG9zWzFdPHBhcmFtcy5zb3VyY2VQb3NbMV0sbHc9cGFyYW1zLnN0cm9rZVdpZHRofHwxLHNvPXBhcmFtcy5zb3VyY2VFbmRwb2ludC5hbmNob3IuZ2V0T3JpZW50YXRpb24ocGFyYW1zLnNvdXJjZUVuZHBvaW50KSx0bz1wYXJhbXMudGFyZ2V0RW5kcG9pbnQuYW5jaG9yLmdldE9yaWVudGF0aW9uKHBhcmFtcy50YXJnZXRFbmRwb2ludCkseD1zd2FwWD9wYXJhbXMudGFyZ2V0UG9zWzBdOnBhcmFtcy5zb3VyY2VQb3NbMF0seT1zd2FwWT9wYXJhbXMudGFyZ2V0UG9zWzFdOnBhcmFtcy5zb3VyY2VQb3NbMV0sdz1NYXRoLmFicyhwYXJhbXMudGFyZ2V0UG9zWzBdLXBhcmFtcy5zb3VyY2VQb3NbMF0pLGg9TWF0aC5hYnMocGFyYW1zLnRhcmdldFBvc1sxXS1wYXJhbXMuc291cmNlUG9zWzFdKTsvLyBpZiBlaXRoZXIgYW5jaG9yIGRvZXMgbm90IGhhdmUgYW4gb3JpZW50YXRpb24gc2V0LCB3ZSBkZXJpdmUgb25lIGZyb20gdGhlaXIgcmVsYXRpdmVcbi8vIHBvc2l0aW9ucy4gIHdlIGZpeCB0aGUgYXhpcyB0byBiZSB0aGUgb25lIGluIHdoaWNoIHRoZSB0d28gZWxlbWVudHMgYXJlIGZ1cnRoZXIgYXBhcnQsIGFuZFxuLy8gcG9pbnQgZWFjaCBhbmNob3IgYXQgdGhlIG90aGVyIGVsZW1lbnQuICB0aGlzIGlzIGFsc28gdXNlZCB3aGVuIGRyYWdnaW5nIGEgbmV3IGNvbm5lY3Rpb24uXG5pZihzb1swXT09PTAmJnNvWzFdPT09MHx8dG9bMF09PT0wJiZ0b1sxXT09PTApe3ZhciBpbmRleD13Pmg/MDoxLG9JbmRleD1bMSwwXVtpbmRleF07c289W107dG89W107c29baW5kZXhdPXBhcmFtcy5zb3VyY2VQb3NbaW5kZXhdPnBhcmFtcy50YXJnZXRQb3NbaW5kZXhdPy0xOjE7dG9baW5kZXhdPXBhcmFtcy5zb3VyY2VQb3NbaW5kZXhdPnBhcmFtcy50YXJnZXRQb3NbaW5kZXhdPzE6LTE7c29bb0luZGV4XT0wO3RvW29JbmRleF09MDt9dmFyIHN4PXN3YXBYP3crc291cmNlR2FwKnNvWzBdOnNvdXJjZUdhcCpzb1swXSxzeT1zd2FwWT9oK3NvdXJjZUdhcCpzb1sxXTpzb3VyY2VHYXAqc29bMV0sdHg9c3dhcFg/dGFyZ2V0R2FwKnRvWzBdOncrdGFyZ2V0R2FwKnRvWzBdLHR5PXN3YXBZP3RhcmdldEdhcCp0b1sxXTpoK3RhcmdldEdhcCp0b1sxXSxvUHJvZHVjdD1zb1swXSp0b1swXStzb1sxXSp0b1sxXTt2YXIgcmVzdWx0PXtzeDpzeCxzeTpzeSx0eDp0eCx0eTp0eSxsdzpsdyx4U3BhbjpNYXRoLmFicyh0eC1zeCkseVNwYW46TWF0aC5hYnModHktc3kpLG14OihzeCt0eCkvMixteTooc3krdHkpLzIsc286c28sdG86dG8seDp4LHk6eSx3OncsaDpoLHNlZ21lbnQ6c2VnbWVudCxzdGFydFN0dWJYOnN4K3NvWzBdKnNvdXJjZVN0dWIsc3RhcnRTdHViWTpzeStzb1sxXSpzb3VyY2VTdHViLGVuZFN0dWJYOnR4K3RvWzBdKnRhcmdldFN0dWIsZW5kU3R1Ylk6dHkrdG9bMV0qdGFyZ2V0U3R1Yixpc1hHcmVhdGVyVGhhblN0dWJUaW1lczI6TWF0aC5hYnMoc3gtdHgpPnNvdXJjZVN0dWIrdGFyZ2V0U3R1Yixpc1lHcmVhdGVyVGhhblN0dWJUaW1lczI6TWF0aC5hYnMoc3ktdHkpPnNvdXJjZVN0dWIrdGFyZ2V0U3R1YixvcHBvc2l0ZTpvUHJvZHVjdD09PS0xLHBlcnBlbmRpY3VsYXI6b1Byb2R1Y3Q9PT0wLG9ydGhvZ29uYWw6b1Byb2R1Y3Q9PT0xLHNvdXJjZUF4aXM6c29bMF09PT0wP1wieVwiOlwieFwiLHBvaW50czpbeCx5LHcsaCxzeCxzeSx0eCx0eV0sc3R1YnM6W3NvdXJjZVN0dWIsdGFyZ2V0U3R1Yl19O3Jlc3VsdC5hbmNob3JPcmllbnRhdGlvbj1yZXN1bHQub3Bwb3NpdGU/XCJvcHBvc2l0ZVwiOnJlc3VsdC5vcnRob2dvbmFsP1wib3J0aG9nb25hbFwiOlwicGVycGVuZGljdWxhclwiO3JldHVybiByZXN1bHQ7fTt0aGlzLmdldFNlZ21lbnRzPWZ1bmN0aW9uKCl7cmV0dXJuIHNlZ21lbnRzO307dGhpcy51cGRhdGVCb3VuZHM9ZnVuY3Rpb24oc2VnbWVudCl7dmFyIHNlZ0JvdW5kcz1zZWdtZW50LmdldEJvdW5kcygpO3RoaXMuYm91bmRzLm1pblg9TWF0aC5taW4odGhpcy5ib3VuZHMubWluWCxzZWdCb3VuZHMubWluWCk7dGhpcy5ib3VuZHMubWF4WD1NYXRoLm1heCh0aGlzLmJvdW5kcy5tYXhYLHNlZ0JvdW5kcy5tYXhYKTt0aGlzLmJvdW5kcy5taW5ZPU1hdGgubWluKHRoaXMuYm91bmRzLm1pblksc2VnQm91bmRzLm1pblkpO3RoaXMuYm91bmRzLm1heFk9TWF0aC5tYXgodGhpcy5ib3VuZHMubWF4WSxzZWdCb3VuZHMubWF4WSk7fTt2YXIgZHVtcFNlZ21lbnRzVG9Db25zb2xlPWZ1bmN0aW9uIGR1bXBTZWdtZW50c1RvQ29uc29sZSgpe2NvbnNvbGUubG9nKFwiU0VHTUVOVFM6XCIpO2Zvcih2YXIgaT0wO2k8c2VnbWVudHMubGVuZ3RoO2krKyl7Y29uc29sZS5sb2coc2VnbWVudHNbaV0udHlwZSxzZWdtZW50c1tpXS5nZXRMZW5ndGgoKSxzZWdtZW50UHJvcG9ydGlvbnNbaV0pO319O3RoaXMucG9pbnRPblBhdGg9ZnVuY3Rpb24obG9jYXRpb24sYWJzb2x1dGUpe3ZhciBzZWc9X2ZpbmRTZWdtZW50Rm9yTG9jYXRpb24obG9jYXRpb24sYWJzb2x1dGUpO3JldHVybiBzZWcuc2VnbWVudCYmc2VnLnNlZ21lbnQucG9pbnRPblBhdGgoc2VnLnByb3BvcnRpb24sZmFsc2UpfHxbMCwwXTt9O3RoaXMuZ3JhZGllbnRBdFBvaW50PWZ1bmN0aW9uKGxvY2F0aW9uLGFic29sdXRlKXt2YXIgc2VnPV9maW5kU2VnbWVudEZvckxvY2F0aW9uKGxvY2F0aW9uLGFic29sdXRlKTtyZXR1cm4gc2VnLnNlZ21lbnQmJnNlZy5zZWdtZW50LmdyYWRpZW50QXRQb2ludChzZWcucHJvcG9ydGlvbixmYWxzZSl8fDA7fTt0aGlzLnBvaW50QWxvbmdQYXRoRnJvbT1mdW5jdGlvbihsb2NhdGlvbixkaXN0YW5jZSxhYnNvbHV0ZSl7dmFyIHNlZz1fZmluZFNlZ21lbnRGb3JMb2NhdGlvbihsb2NhdGlvbixhYnNvbHV0ZSk7Ly8gVE9ETyB3aGF0IGhhcHBlbnMgaWYgdGhpcyBjcm9zc2VzIHRvIHRoZSBuZXh0IHNlZ21lbnQ/XG5yZXR1cm4gc2VnLnNlZ21lbnQmJnNlZy5zZWdtZW50LnBvaW50QWxvbmdQYXRoRnJvbShzZWcucHJvcG9ydGlvbixkaXN0YW5jZSxmYWxzZSl8fFswLDBdO307dGhpcy5jb21wdXRlPWZ1bmN0aW9uKHBhcmFtcyl7cGFpbnRJbmZvPV9wcmVwYXJlQ29tcHV0ZS5jYWxsKHRoaXMscGFyYW1zKTtfY2xlYXJTZWdtZW50cygpO3RoaXMuX2NvbXB1dGUocGFpbnRJbmZvLHBhcmFtcyk7dGhpcy54PXBhaW50SW5mby5wb2ludHNbMF07dGhpcy55PXBhaW50SW5mby5wb2ludHNbMV07dGhpcy53PXBhaW50SW5mby5wb2ludHNbMl07dGhpcy5oPXBhaW50SW5mby5wb2ludHNbM107dGhpcy5zZWdtZW50PXBhaW50SW5mby5zZWdtZW50O191cGRhdGVTZWdtZW50UHJvcG9ydGlvbnMoKTt9O3JldHVybnthZGRTZWdtZW50Ol9hZGRTZWdtZW50LHByZXBhcmVDb21wdXRlOl9wcmVwYXJlQ29tcHV0ZSxzb3VyY2VTdHViOnNvdXJjZVN0dWIsdGFyZ2V0U3R1Yjp0YXJnZXRTdHViLG1heFN0dWI6TWF0aC5tYXgoc291cmNlU3R1Yix0YXJnZXRTdHViKSxzb3VyY2VHYXA6c291cmNlR2FwLHRhcmdldEdhcDp0YXJnZXRHYXAsbWF4R2FwOk1hdGgubWF4KHNvdXJjZUdhcCx0YXJnZXRHYXApfTt9O19qdS5leHRlbmQoX2pwLkNvbm5lY3RvcnMuQWJzdHJhY3RDb25uZWN0b3IsQWJzdHJhY3RDb21wb25lbnQpOy8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBFTkQgT0YgQ09OTkVDVE9SIFRZUEVTICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBFTkRQT0lOVCBUWVBFUyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5fanAuRW5kcG9pbnRzLkFic3RyYWN0RW5kcG9pbnQ9ZnVuY3Rpb24ocGFyYW1zKXtBYnN0cmFjdENvbXBvbmVudC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIGNvbXB1dGU9dGhpcy5jb21wdXRlPWZ1bmN0aW9uKGFuY2hvclBvaW50LG9yaWVudGF0aW9uLGVuZHBvaW50U3R5bGUsY29ubmVjdG9yUGFpbnRTdHlsZSl7dmFyIG91dD10aGlzLl9jb21wdXRlLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aGlzLng9b3V0WzBdO3RoaXMueT1vdXRbMV07dGhpcy53PW91dFsyXTt0aGlzLmg9b3V0WzNdO3RoaXMuYm91bmRzLm1pblg9dGhpcy54O3RoaXMuYm91bmRzLm1pblk9dGhpcy55O3RoaXMuYm91bmRzLm1heFg9dGhpcy54K3RoaXMudzt0aGlzLmJvdW5kcy5tYXhZPXRoaXMueSt0aGlzLmg7cmV0dXJuIG91dDt9O3JldHVybntjb21wdXRlOmNvbXB1dGUsY3NzQ2xhc3M6cGFyYW1zLmNzc0NsYXNzfTt9O19qdS5leHRlbmQoX2pwLkVuZHBvaW50cy5BYnN0cmFjdEVuZHBvaW50LEFic3RyYWN0Q29tcG9uZW50KTsvKipcclxuICAgICAqIENsYXNzOiBFbmRwb2ludHMuRG90XHJcbiAgICAgKiBBIHJvdW5kIGVuZHBvaW50LCB3aXRoIGRlZmF1bHQgcmFkaXVzIDEwIHBpeGVscy5cclxuICAgICAqLy8qKlxyXG4gICAgICogRnVuY3Rpb246IENvbnN0cnVjdG9yXHJcbiAgICAgKlxyXG4gICAgICogUGFyYW1ldGVyczpcclxuICAgICAqXHJcbiAgICAgKiAgICByYWRpdXMgICAgLSAgICByYWRpdXMgb2YgdGhlIGVuZHBvaW50LiAgZGVmYXVsdHMgdG8gMTAgcGl4ZWxzLlxyXG4gICAgICovX2pwLkVuZHBvaW50cy5Eb3Q9ZnVuY3Rpb24ocGFyYW1zKXt0aGlzLnR5cGU9XCJEb3RcIjt2YXIgX3N1cGVyPV9qcC5FbmRwb2ludHMuQWJzdHJhY3RFbmRwb2ludC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cGFyYW1zPXBhcmFtc3x8e307dGhpcy5yYWRpdXM9cGFyYW1zLnJhZGl1c3x8MTA7dGhpcy5kZWZhdWx0T2Zmc2V0PTAuNSp0aGlzLnJhZGl1czt0aGlzLmRlZmF1bHRJbm5lclJhZGl1cz10aGlzLnJhZGl1cy8zO3RoaXMuX2NvbXB1dGU9ZnVuY3Rpb24oYW5jaG9yUG9pbnQsb3JpZW50YXRpb24sZW5kcG9pbnRTdHlsZSxjb25uZWN0b3JQYWludFN0eWxlKXt0aGlzLnJhZGl1cz1lbmRwb2ludFN0eWxlLnJhZGl1c3x8dGhpcy5yYWRpdXM7dmFyIHg9YW5jaG9yUG9pbnRbMF0tdGhpcy5yYWRpdXMseT1hbmNob3JQb2ludFsxXS10aGlzLnJhZGl1cyx3PXRoaXMucmFkaXVzKjIsaD10aGlzLnJhZGl1cyoyO2lmKGVuZHBvaW50U3R5bGUuc3Ryb2tlKXt2YXIgbHc9ZW5kcG9pbnRTdHlsZS5zdHJva2VXaWR0aHx8MTt4LT1sdzt5LT1sdzt3Kz1sdyoyO2grPWx3KjI7fXJldHVyblt4LHksdyxoLHRoaXMucmFkaXVzXTt9O307X2p1LmV4dGVuZChfanAuRW5kcG9pbnRzLkRvdCxfanAuRW5kcG9pbnRzLkFic3RyYWN0RW5kcG9pbnQpO19qcC5FbmRwb2ludHMuUmVjdGFuZ2xlPWZ1bmN0aW9uKHBhcmFtcyl7dGhpcy50eXBlPVwiUmVjdGFuZ2xlXCI7dmFyIF9zdXBlcj1fanAuRW5kcG9pbnRzLkFic3RyYWN0RW5kcG9pbnQuYXBwbHkodGhpcyxhcmd1bWVudHMpO3BhcmFtcz1wYXJhbXN8fHt9O3RoaXMud2lkdGg9cGFyYW1zLndpZHRofHwyMDt0aGlzLmhlaWdodD1wYXJhbXMuaGVpZ2h0fHwyMDt0aGlzLl9jb21wdXRlPWZ1bmN0aW9uKGFuY2hvclBvaW50LG9yaWVudGF0aW9uLGVuZHBvaW50U3R5bGUsY29ubmVjdG9yUGFpbnRTdHlsZSl7dmFyIHdpZHRoPWVuZHBvaW50U3R5bGUud2lkdGh8fHRoaXMud2lkdGgsaGVpZ2h0PWVuZHBvaW50U3R5bGUuaGVpZ2h0fHx0aGlzLmhlaWdodCx4PWFuY2hvclBvaW50WzBdLXdpZHRoLzIseT1hbmNob3JQb2ludFsxXS1oZWlnaHQvMjtyZXR1cm5beCx5LHdpZHRoLGhlaWdodF07fTt9O19qdS5leHRlbmQoX2pwLkVuZHBvaW50cy5SZWN0YW5nbGUsX2pwLkVuZHBvaW50cy5BYnN0cmFjdEVuZHBvaW50KTt2YXIgRE9NRWxlbWVudEVuZHBvaW50PWZ1bmN0aW9uIERPTUVsZW1lbnRFbmRwb2ludChwYXJhbXMpe19qcC5qc1BsdW1iVUlDb21wb25lbnQuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMuX2pzUGx1bWIuZGlzcGxheUVsZW1lbnRzPVtdO307X2p1LmV4dGVuZChET01FbGVtZW50RW5kcG9pbnQsX2pwLmpzUGx1bWJVSUNvbXBvbmVudCx7Z2V0RGlzcGxheUVsZW1lbnRzOmZ1bmN0aW9uIGdldERpc3BsYXlFbGVtZW50cygpe3JldHVybiB0aGlzLl9qc1BsdW1iLmRpc3BsYXlFbGVtZW50czt9LGFwcGVuZERpc3BsYXlFbGVtZW50OmZ1bmN0aW9uIGFwcGVuZERpc3BsYXlFbGVtZW50KGVsKXt0aGlzLl9qc1BsdW1iLmRpc3BsYXlFbGVtZW50cy5wdXNoKGVsKTt9fSk7LyoqXHJcbiAgICAgKiBDbGFzczogRW5kcG9pbnRzLkltYWdlXHJcbiAgICAgKiBEcmF3cyBhbiBpbWFnZSBhcyB0aGUgRW5kcG9pbnQuXHJcbiAgICAgKi8vKipcclxuICAgICAqIEZ1bmN0aW9uOiBDb25zdHJ1Y3RvclxyXG4gICAgICpcclxuICAgICAqIFBhcmFtZXRlcnM6XHJcbiAgICAgKlxyXG4gICAgICogICAgc3JjICAgIC0gICAgbG9jYXRpb24gb2YgdGhlIGltYWdlIHRvIHVzZS5cclxuXHJcbiAgICAgVE9ETzogbXVsdGlwbGUgcmVmZXJlbmNlcyB0byBzZWxmLiBub3Qgc3VyZSBxdWl0ZSBob3cgdG8gZ2V0IHJpZCBvZiB0aGVtIGVudGlyZWx5LiBwZXJoYXBzIHNlbGYgPSBudWxsIGluIHRoZSBjbGVhbnVwXHJcbiAgICAgZnVuY3Rpb24gd2lsbCBzdWZmaWNlXHJcblxyXG4gICAgIFRPRE8gdGhpcyBjbGFzcyBzdGlsbCBtaWdodCBsZWFrIG1lbW9yeS5cclxuXHJcbiAgICAgKi9fanAuRW5kcG9pbnRzLkltYWdlPWZ1bmN0aW9uKHBhcmFtcyl7dGhpcy50eXBlPVwiSW1hZ2VcIjtET01FbGVtZW50RW5kcG9pbnQuYXBwbHkodGhpcyxhcmd1bWVudHMpO19qcC5FbmRwb2ludHMuQWJzdHJhY3RFbmRwb2ludC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIF9vbmxvYWQ9cGFyYW1zLm9ubG9hZCxzcmM9cGFyYW1zLnNyY3x8cGFyYW1zLnVybCxjbGF6ej1wYXJhbXMuY3NzQ2xhc3M/XCIgXCIrcGFyYW1zLmNzc0NsYXNzOlwiXCI7dGhpcy5fanNQbHVtYi5pbWc9bmV3IEltYWdlKCk7dGhpcy5fanNQbHVtYi5yZWFkeT1mYWxzZTt0aGlzLl9qc1BsdW1iLmluaXRpYWxpemVkPWZhbHNlO3RoaXMuX2pzUGx1bWIuZGVsZXRlZD1mYWxzZTt0aGlzLl9qc1BsdW1iLndpZHRoVG9Vc2U9cGFyYW1zLndpZHRoO3RoaXMuX2pzUGx1bWIuaGVpZ2h0VG9Vc2U9cGFyYW1zLmhlaWdodDt0aGlzLl9qc1BsdW1iLmVuZHBvaW50PXBhcmFtcy5lbmRwb2ludDt0aGlzLl9qc1BsdW1iLmltZy5vbmxvYWQ9ZnVuY3Rpb24oKXtpZih0aGlzLl9qc1BsdW1iIT1udWxsKXt0aGlzLl9qc1BsdW1iLnJlYWR5PXRydWU7dGhpcy5fanNQbHVtYi53aWR0aFRvVXNlPXRoaXMuX2pzUGx1bWIud2lkdGhUb1VzZXx8dGhpcy5fanNQbHVtYi5pbWcud2lkdGg7dGhpcy5fanNQbHVtYi5oZWlnaHRUb1VzZT10aGlzLl9qc1BsdW1iLmhlaWdodFRvVXNlfHx0aGlzLl9qc1BsdW1iLmltZy5oZWlnaHQ7aWYoX29ubG9hZCl7X29ubG9hZCh0aGlzKTt9fX0uYmluZCh0aGlzKTsvKlxyXG4gICAgICAgICBGdW5jdGlvbjogc2V0SW1hZ2VcclxuICAgICAgICAgU2V0cyB0aGUgSW1hZ2UgdG8gdXNlIGluIHRoaXMgRW5kcG9pbnQuXHJcblxyXG4gICAgICAgICBQYXJhbWV0ZXJzOlxyXG4gICAgICAgICBpbWcgICAgICAgICAtICAgbWF5IGJlIGEgVVJMIG9yIGFuIEltYWdlIG9iamVjdFxyXG4gICAgICAgICBvbmxvYWQgICAgICAtICAgb3B0aW9uYWw7IGEgY2FsbGJhY2sgdG8gZXhlY3V0ZSBvbmNlIHRoZSBpbWFnZSBoYXMgbG9hZGVkLlxyXG4gICAgICAgICAqL3RoaXMuX2pzUGx1bWIuZW5kcG9pbnQuc2V0SW1hZ2U9ZnVuY3Rpb24oX2ltZyxvbmxvYWQpe3ZhciBzPV9pbWcuY29uc3RydWN0b3I9PT1TdHJpbmc/X2ltZzpfaW1nLnNyYztfb25sb2FkPW9ubG9hZDt0aGlzLl9qc1BsdW1iLmltZy5zcmM9cztpZih0aGlzLmNhbnZhcyE9bnVsbCl7dGhpcy5jYW52YXMuc2V0QXR0cmlidXRlKFwic3JjXCIsdGhpcy5fanNQbHVtYi5pbWcuc3JjKTt9fS5iaW5kKHRoaXMpO3RoaXMuX2pzUGx1bWIuZW5kcG9pbnQuc2V0SW1hZ2Uoc3JjLF9vbmxvYWQpO3RoaXMuX2NvbXB1dGU9ZnVuY3Rpb24oYW5jaG9yUG9pbnQsb3JpZW50YXRpb24sZW5kcG9pbnRTdHlsZSxjb25uZWN0b3JQYWludFN0eWxlKXt0aGlzLmFuY2hvclBvaW50PWFuY2hvclBvaW50O2lmKHRoaXMuX2pzUGx1bWIucmVhZHkpe3JldHVyblthbmNob3JQb2ludFswXS10aGlzLl9qc1BsdW1iLndpZHRoVG9Vc2UvMixhbmNob3JQb2ludFsxXS10aGlzLl9qc1BsdW1iLmhlaWdodFRvVXNlLzIsdGhpcy5fanNQbHVtYi53aWR0aFRvVXNlLHRoaXMuX2pzUGx1bWIuaGVpZ2h0VG9Vc2VdO31lbHNle3JldHVyblswLDAsMCwwXTt9fTt0aGlzLmNhbnZhcz1fanAuY3JlYXRlRWxlbWVudChcImltZ1wiLHtwb3NpdGlvbjpcImFic29sdXRlXCIsbWFyZ2luOjAscGFkZGluZzowLG91dGxpbmU6MH0sdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5lbmRwb2ludENsYXNzK2NsYXp6KTtpZih0aGlzLl9qc1BsdW1iLndpZHRoVG9Vc2Upe3RoaXMuY2FudmFzLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsdGhpcy5fanNQbHVtYi53aWR0aFRvVXNlKTt9aWYodGhpcy5fanNQbHVtYi5oZWlnaHRUb1VzZSl7dGhpcy5jYW52YXMuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsdGhpcy5fanNQbHVtYi5oZWlnaHRUb1VzZSk7fXRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuYXBwZW5kRWxlbWVudCh0aGlzLmNhbnZhcyk7dGhpcy5hY3R1YWxseVBhaW50PWZ1bmN0aW9uKGQsc3R5bGUsYW5jaG9yKXtpZighdGhpcy5fanNQbHVtYi5kZWxldGVkKXtpZighdGhpcy5fanNQbHVtYi5pbml0aWFsaXplZCl7dGhpcy5jYW52YXMuc2V0QXR0cmlidXRlKFwic3JjXCIsdGhpcy5fanNQbHVtYi5pbWcuc3JjKTt0aGlzLmFwcGVuZERpc3BsYXlFbGVtZW50KHRoaXMuY2FudmFzKTt0aGlzLl9qc1BsdW1iLmluaXRpYWxpemVkPXRydWU7fXZhciB4PXRoaXMuYW5jaG9yUG9pbnRbMF0tdGhpcy5fanNQbHVtYi53aWR0aFRvVXNlLzIseT10aGlzLmFuY2hvclBvaW50WzFdLXRoaXMuX2pzUGx1bWIuaGVpZ2h0VG9Vc2UvMjtfanUuc2l6ZUVsZW1lbnQodGhpcy5jYW52YXMseCx5LHRoaXMuX2pzUGx1bWIud2lkdGhUb1VzZSx0aGlzLl9qc1BsdW1iLmhlaWdodFRvVXNlKTt9fTt0aGlzLnBhaW50PWZ1bmN0aW9uKHN0eWxlLGFuY2hvcil7aWYodGhpcy5fanNQbHVtYiE9bnVsbCl7Ly8gbWF5IGhhdmUgYmVlbiBkZWxldGVkXG5pZih0aGlzLl9qc1BsdW1iLnJlYWR5KXt0aGlzLmFjdHVhbGx5UGFpbnQoc3R5bGUsYW5jaG9yKTt9ZWxzZXtyb290LnNldFRpbWVvdXQoZnVuY3Rpb24oKXt0aGlzLnBhaW50KHN0eWxlLGFuY2hvcik7fS5iaW5kKHRoaXMpLDIwMCk7fX19O307X2p1LmV4dGVuZChfanAuRW5kcG9pbnRzLkltYWdlLFtET01FbGVtZW50RW5kcG9pbnQsX2pwLkVuZHBvaW50cy5BYnN0cmFjdEVuZHBvaW50XSx7Y2xlYW51cDpmdW5jdGlvbiBjbGVhbnVwKGZvcmNlKXtpZihmb3JjZSl7dGhpcy5fanNQbHVtYi5kZWxldGVkPXRydWU7aWYodGhpcy5jYW52YXMpe3RoaXMuY2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5jYW52YXMpO310aGlzLmNhbnZhcz1udWxsO319fSk7LypcclxuICAgICAqIENsYXNzOiBFbmRwb2ludHMuQmxhbmtcclxuICAgICAqIEFuIEVuZHBvaW50IHRoYXQgcGFpbnRzIG5vdGhpbmcgKHZpc2libGUpIG9uIHRoZSBzY3JlZW4uICBTdXBwb3J0cyBjc3NDbGFzcyBhbmQgaG92ZXJDbGFzcyBwYXJhbWV0ZXJzIGxpa2UgYWxsIEVuZHBvaW50cy5cclxuICAgICAqL19qcC5FbmRwb2ludHMuQmxhbms9ZnVuY3Rpb24ocGFyYW1zKXt2YXIgX3N1cGVyPV9qcC5FbmRwb2ludHMuQWJzdHJhY3RFbmRwb2ludC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dGhpcy50eXBlPVwiQmxhbmtcIjtET01FbGVtZW50RW5kcG9pbnQuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMuX2NvbXB1dGU9ZnVuY3Rpb24oYW5jaG9yUG9pbnQsb3JpZW50YXRpb24sZW5kcG9pbnRTdHlsZSxjb25uZWN0b3JQYWludFN0eWxlKXtyZXR1cm5bYW5jaG9yUG9pbnRbMF0sYW5jaG9yUG9pbnRbMV0sMTAsMF07fTt2YXIgY2xheno9cGFyYW1zLmNzc0NsYXNzP1wiIFwiK3BhcmFtcy5jc3NDbGFzczpcIlwiO3RoaXMuY2FudmFzPV9qcC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2Rpc3BsYXk6XCJibG9ja1wiLHdpZHRoOlwiMXB4XCIsaGVpZ2h0OlwiMXB4XCIsYmFja2dyb3VuZDpcInRyYW5zcGFyZW50XCIscG9zaXRpb246XCJhYnNvbHV0ZVwifSx0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmVuZHBvaW50Q2xhc3MrY2xhenopO3RoaXMuX2pzUGx1bWIuaW5zdGFuY2UuYXBwZW5kRWxlbWVudCh0aGlzLmNhbnZhcyk7dGhpcy5wYWludD1mdW5jdGlvbihzdHlsZSxhbmNob3Ipe19qdS5zaXplRWxlbWVudCh0aGlzLmNhbnZhcyx0aGlzLngsdGhpcy55LHRoaXMudyx0aGlzLmgpO307fTtfanUuZXh0ZW5kKF9qcC5FbmRwb2ludHMuQmxhbmssW19qcC5FbmRwb2ludHMuQWJzdHJhY3RFbmRwb2ludCxET01FbGVtZW50RW5kcG9pbnRdLHtjbGVhbnVwOmZ1bmN0aW9uIGNsZWFudXAoKXtpZih0aGlzLmNhbnZhcyYmdGhpcy5jYW52YXMucGFyZW50Tm9kZSl7dGhpcy5jYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNhbnZhcyk7fX19KTsvKlxyXG4gICAgICogQ2xhc3M6IEVuZHBvaW50cy5UcmlhbmdsZVxyXG4gICAgICogQSB0cmlhbmd1bGFyIEVuZHBvaW50LlxyXG4gICAgICovLypcclxuICAgICAqIEZ1bmN0aW9uOiBDb25zdHJ1Y3RvclxyXG4gICAgICpcclxuICAgICAqIFBhcmFtZXRlcnM6XHJcbiAgICAgKlxyXG4gICAgICogd2lkdGggICB3aWR0aCBvZiB0aGUgdHJpYW5nbGUncyBiYXNlLiAgZGVmYXVsdHMgdG8gNTUgcGl4ZWxzLlxyXG4gICAgICogaGVpZ2h0ICBoZWlnaHQgb2YgdGhlIHRyaWFuZ2xlIGZyb20gYmFzZSB0byBhcGV4LiAgZGVmYXVsdHMgdG8gNTUgcGl4ZWxzLlxyXG4gICAgICovX2pwLkVuZHBvaW50cy5UcmlhbmdsZT1mdW5jdGlvbihwYXJhbXMpe3RoaXMudHlwZT1cIlRyaWFuZ2xlXCI7X2pwLkVuZHBvaW50cy5BYnN0cmFjdEVuZHBvaW50LmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgc2VsZj10aGlzO3BhcmFtcz1wYXJhbXN8fHt9O3BhcmFtcy53aWR0aD1wYXJhbXMud2lkdGh8fDU1O3BhcmFtcy5oZWlnaHQ9cGFyYW1zLmhlaWdodHx8NTU7dGhpcy53aWR0aD1wYXJhbXMud2lkdGg7dGhpcy5oZWlnaHQ9cGFyYW1zLmhlaWdodDt0aGlzLl9jb21wdXRlPWZ1bmN0aW9uKGFuY2hvclBvaW50LG9yaWVudGF0aW9uLGVuZHBvaW50U3R5bGUsY29ubmVjdG9yUGFpbnRTdHlsZSl7dmFyIHdpZHRoPWVuZHBvaW50U3R5bGUud2lkdGh8fHNlbGYud2lkdGgsaGVpZ2h0PWVuZHBvaW50U3R5bGUuaGVpZ2h0fHxzZWxmLmhlaWdodCx4PWFuY2hvclBvaW50WzBdLXdpZHRoLzIseT1hbmNob3JQb2ludFsxXS1oZWlnaHQvMjtyZXR1cm5beCx5LHdpZHRoLGhlaWdodF07fTt9Oy8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBFTkQgT0YgRU5EUE9JTlQgVFlQRVMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIE9WRVJMQVkgREVGSU5JVElPTlMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogICAgXG52YXIgQWJzdHJhY3RPdmVybGF5PV9qcC5PdmVybGF5cy5BYnN0cmFjdE92ZXJsYXk9ZnVuY3Rpb24ocGFyYW1zKXt0aGlzLnZpc2libGU9dHJ1ZTt0aGlzLmlzQXBwZW5kZWRBdFRvcExldmVsPXRydWU7dGhpcy5jb21wb25lbnQ9cGFyYW1zLmNvbXBvbmVudDt0aGlzLmxvYz1wYXJhbXMubG9jYXRpb249PW51bGw/MC41OnBhcmFtcy5sb2NhdGlvbjt0aGlzLmVuZHBvaW50TG9jPXBhcmFtcy5lbmRwb2ludExvY2F0aW9uPT1udWxsP1swLjUsMC41XTpwYXJhbXMuZW5kcG9pbnRMb2NhdGlvbjt0aGlzLnZpc2libGU9cGFyYW1zLnZpc2libGUhPT1mYWxzZTt9O0Fic3RyYWN0T3ZlcmxheS5wcm90b3R5cGU9e2NsZWFudXA6ZnVuY3Rpb24gY2xlYW51cChmb3JjZSl7aWYoZm9yY2Upe3RoaXMuY29tcG9uZW50PW51bGw7dGhpcy5jYW52YXM9bnVsbDt0aGlzLmVuZHBvaW50TG9jPW51bGw7fX0scmVhdHRhY2g6ZnVuY3Rpb24gcmVhdHRhY2goaW5zdGFuY2UsY29tcG9uZW50KXt9LHNldFZpc2libGU6ZnVuY3Rpb24gc2V0VmlzaWJsZSh2YWwpe3RoaXMudmlzaWJsZT12YWw7dGhpcy5jb21wb25lbnQucmVwYWludCgpO30saXNWaXNpYmxlOmZ1bmN0aW9uIGlzVmlzaWJsZSgpe3JldHVybiB0aGlzLnZpc2libGU7fSxoaWRlOmZ1bmN0aW9uIGhpZGUoKXt0aGlzLnNldFZpc2libGUoZmFsc2UpO30sc2hvdzpmdW5jdGlvbiBzaG93KCl7dGhpcy5zZXRWaXNpYmxlKHRydWUpO30saW5jcmVtZW50TG9jYXRpb246ZnVuY3Rpb24gaW5jcmVtZW50TG9jYXRpb24oYW1vdW50KXt0aGlzLmxvYys9YW1vdW50O3RoaXMuY29tcG9uZW50LnJlcGFpbnQoKTt9LHNldExvY2F0aW9uOmZ1bmN0aW9uIHNldExvY2F0aW9uKGwpe3RoaXMubG9jPWw7dGhpcy5jb21wb25lbnQucmVwYWludCgpO30sZ2V0TG9jYXRpb246ZnVuY3Rpb24gZ2V0TG9jYXRpb24oKXtyZXR1cm4gdGhpcy5sb2M7fSx1cGRhdGVGcm9tOmZ1bmN0aW9uIHVwZGF0ZUZyb20oKXt9fTsvKlxyXG4gICAgICogQ2xhc3M6IE92ZXJsYXlzLkFycm93XHJcbiAgICAgKlxyXG4gICAgICogQW4gYXJyb3cgb3ZlcmxheSwgZGVmaW5lZCBieSBmb3VyIHBvaW50czogdGhlIGhlYWQsIHRoZSB0d28gc2lkZXMgb2YgdGhlIHRhaWwsIGFuZCBhICdmb2xkYmFjaycgcG9pbnQgYXQgc29tZSBkaXN0YW5jZSBhbG9uZyB0aGUgbGVuZ3RoXHJcbiAgICAgKiBvZiB0aGUgYXJyb3cgdGhhdCBsaW5lcyBmcm9tIGVhY2ggdGFpbCBwb2ludCBjb252ZXJnZSBpbnRvLiAgVGhlIGZvbGRiYWNrIHBvaW50IGlzIGRlZmluZWQgdXNpbmcgYSBkZWNpbWFsIHRoYXQgaW5kaWNhdGVzIHNvbWUgZnJhY3Rpb25cclxuICAgICAqIG9mIHRoZSBsZW5ndGggb2YgdGhlIGFycm93IGFuZCBoYXMgYSBkZWZhdWx0IHZhbHVlIG9mIDAuNjIzLiAgQSBmb2xkYmFjayBwb2ludCB2YWx1ZSBvZiAxIHdvdWxkIG1lYW4gdGhhdCB0aGUgYXJyb3cgaGFkIGEgc3RyYWlnaHQgbGluZVxyXG4gICAgICogYWNyb3NzIHRoZSB0YWlsLlxyXG4gICAgICovLypcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgQ29uc3RydWN0b3IgcGFyYW1zLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMubGVuZ3RoXSBEaXN0YW5jZSBpbiBwaXhlbHMgZnJvbSBoZWFkIHRvIHRhaWwgYmFzZWxpbmUuIGRlZmF1bHQgMjAuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy53aWR0aF0gV2lkdGggaW4gcGl4ZWxzIG9mIHRoZSB0YWlsIGJhc2VsaW5lLiBkZWZhdWx0IDIwLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMuZmlsbF0gU3R5bGUgdG8gdXNlIHdoZW4gZmlsbGluZyB0aGUgYXJyb3cuICBkZWZhdWx0cyB0byBcImJsYWNrXCIuXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy5zdHJva2VdIFN0eWxlIHRvIHVzZSB3aGVuIHN0cm9raW5nIHRoZSBhcnJvdy4gZGVmYXVsdHMgdG8gbnVsbCwgd2hpY2ggbWVhbnMgdGhlIGFycm93IGlzIG5vdCBzdHJva2VkLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMuc3Ryb2tlLXdpZHRoXSBMaW5lIHdpZHRoIHRvIHVzZSB3aGVuIHN0cm9raW5nIHRoZSBhcnJvdy4gZGVmYXVsdHMgdG8gMSwgYnV0IG9ubHkgdXNlZCBpZiBzdHJva2UgaXMgbm90IG51bGwuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5mb2xkYmFja10gRGlzdGFuY2UgKGFzIGEgZGVjaW1hbCBmcm9tIDAgdG8gMSBpbmNsdXNpdmUpIGFsb25nIHRoZSBsZW5ndGggb2YgdGhlIGFycm93IG1hcmtpbmcgdGhlIHBvaW50IHRoZSB0YWlsIHBvaW50cyBzaG91bGQgZm9sZCBiYWNrIHRvLiAgZGVmYXVsdHMgdG8gMC42MjMuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5sb2NhdGlvbl0gRGlzdGFuY2UgKGFzIGEgZGVjaW1hbCBmcm9tIDAgdG8gMSBpbmNsdXNpdmUpIG1hcmtpbmcgd2hlcmUgdGhlIGFycm93IHNob3VsZCBzaXQgb24gdGhlIGNvbm5lY3Rvci4gZGVmYXVsdHMgdG8gMC41LlxyXG4gICAgICogQHBhcmFtIHtOVW1iZXJ9IFtwYXJhbXMuZGlyZWN0aW9uXSBJbmRpY2F0ZXMgdGhlIGRpcmVjdGlvbiB0aGUgYXJyb3cgcG9pbnRzIGluLiB2YWxpZCB2YWx1ZXMgYXJlIC0xIGFuZCAxOyAxIGlzIGRlZmF1bHQuXHJcbiAgICAgKi9fanAuT3ZlcmxheXMuQXJyb3c9ZnVuY3Rpb24ocGFyYW1zKXt0aGlzLnR5cGU9XCJBcnJvd1wiO0Fic3RyYWN0T3ZlcmxheS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dGhpcy5pc0FwcGVuZGVkQXRUb3BMZXZlbD1mYWxzZTtwYXJhbXM9cGFyYW1zfHx7fTt2YXIgc2VsZj10aGlzO3RoaXMubGVuZ3RoPXBhcmFtcy5sZW5ndGh8fDIwO3RoaXMud2lkdGg9cGFyYW1zLndpZHRofHwyMDt0aGlzLmlkPXBhcmFtcy5pZDt2YXIgZGlyZWN0aW9uPShwYXJhbXMuZGlyZWN0aW9ufHwxKTwwPy0xOjEscGFpbnRTdHlsZT1wYXJhbXMucGFpbnRTdHlsZXx8e1wic3Ryb2tlLXdpZHRoXCI6MX0sLy8gaG93IGZhciBhbG9uZyB0aGUgYXJyb3cgdGhlIGxpbmVzIGZvbGRpbmcgYmFjayBpbiBjb21lIHRvLiBkZWZhdWx0IGlzIDYyLjMlLlxuZm9sZGJhY2s9cGFyYW1zLmZvbGRiYWNrfHwwLjYyMzt0aGlzLmNvbXB1dGVNYXhTaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHNlbGYud2lkdGgqMS41O307dGhpcy5lbGVtZW50Q3JlYXRlZD1mdW5jdGlvbihwLGNvbXBvbmVudCl7dGhpcy5wYXRoPXA7aWYocGFyYW1zLmV2ZW50cyl7Zm9yKHZhciBpIGluIHBhcmFtcy5ldmVudHMpe19qcC5vbihwLGkscGFyYW1zLmV2ZW50c1tpXSk7fX19O3RoaXMuZHJhdz1mdW5jdGlvbihjb21wb25lbnQsY3VycmVudENvbm5lY3Rpb25QYWludFN0eWxlKXt2YXIgaHh5LG1pZCx0eHksdGFpbCxjeHk7aWYoY29tcG9uZW50LnBvaW50QWxvbmdQYXRoRnJvbSl7aWYoX2p1LmlzU3RyaW5nKHRoaXMubG9jKXx8dGhpcy5sb2M+MXx8dGhpcy5sb2M8MCl7dmFyIGw9cGFyc2VJbnQodGhpcy5sb2MsMTApLGZyb21Mb2M9dGhpcy5sb2M8MD8xOjA7aHh5PWNvbXBvbmVudC5wb2ludEFsb25nUGF0aEZyb20oZnJvbUxvYyxsLGZhbHNlKTttaWQ9Y29tcG9uZW50LnBvaW50QWxvbmdQYXRoRnJvbShmcm9tTG9jLGwtZGlyZWN0aW9uKnRoaXMubGVuZ3RoLzIsZmFsc2UpO3R4eT1famcucG9pbnRPbkxpbmUoaHh5LG1pZCx0aGlzLmxlbmd0aCk7fWVsc2UgaWYodGhpcy5sb2M9PT0xKXtoeHk9Y29tcG9uZW50LnBvaW50T25QYXRoKHRoaXMubG9jKTttaWQ9Y29tcG9uZW50LnBvaW50QWxvbmdQYXRoRnJvbSh0aGlzLmxvYywtdGhpcy5sZW5ndGgpO3R4eT1famcucG9pbnRPbkxpbmUoaHh5LG1pZCx0aGlzLmxlbmd0aCk7aWYoZGlyZWN0aW9uPT09LTEpe3ZhciBfPXR4eTt0eHk9aHh5O2h4eT1fO319ZWxzZSBpZih0aGlzLmxvYz09PTApe3R4eT1jb21wb25lbnQucG9pbnRPblBhdGgodGhpcy5sb2MpO21pZD1jb21wb25lbnQucG9pbnRBbG9uZ1BhdGhGcm9tKHRoaXMubG9jLHRoaXMubGVuZ3RoKTtoeHk9X2pnLnBvaW50T25MaW5lKHR4eSxtaWQsdGhpcy5sZW5ndGgpO2lmKGRpcmVjdGlvbj09PS0xKXt2YXIgX189dHh5O3R4eT1oeHk7aHh5PV9fO319ZWxzZXtoeHk9Y29tcG9uZW50LnBvaW50QWxvbmdQYXRoRnJvbSh0aGlzLmxvYyxkaXJlY3Rpb24qdGhpcy5sZW5ndGgvMik7bWlkPWNvbXBvbmVudC5wb2ludE9uUGF0aCh0aGlzLmxvYyk7dHh5PV9qZy5wb2ludE9uTGluZShoeHksbWlkLHRoaXMubGVuZ3RoKTt9dGFpbD1famcucGVycGVuZGljdWxhckxpbmVUbyhoeHksdHh5LHRoaXMud2lkdGgpO2N4eT1famcucG9pbnRPbkxpbmUoaHh5LHR4eSxmb2xkYmFjayp0aGlzLmxlbmd0aCk7dmFyIGQ9e2h4eTpoeHksdGFpbDp0YWlsLGN4eTpjeHl9LHN0cm9rZT1wYWludFN0eWxlLnN0cm9rZXx8Y3VycmVudENvbm5lY3Rpb25QYWludFN0eWxlLnN0cm9rZSxmaWxsPXBhaW50U3R5bGUuZmlsbHx8Y3VycmVudENvbm5lY3Rpb25QYWludFN0eWxlLnN0cm9rZSxsaW5lV2lkdGg9cGFpbnRTdHlsZS5zdHJva2VXaWR0aHx8Y3VycmVudENvbm5lY3Rpb25QYWludFN0eWxlLnN0cm9rZVdpZHRoO3JldHVybntjb21wb25lbnQ6Y29tcG9uZW50LGQ6ZCxcInN0cm9rZS13aWR0aFwiOmxpbmVXaWR0aCxzdHJva2U6c3Ryb2tlLGZpbGw6ZmlsbCxtaW5YOk1hdGgubWluKGh4eS54LHRhaWxbMF0ueCx0YWlsWzFdLngpLG1heFg6TWF0aC5tYXgoaHh5LngsdGFpbFswXS54LHRhaWxbMV0ueCksbWluWTpNYXRoLm1pbihoeHkueSx0YWlsWzBdLnksdGFpbFsxXS55KSxtYXhZOk1hdGgubWF4KGh4eS55LHRhaWxbMF0ueSx0YWlsWzFdLnkpfTt9ZWxzZXtyZXR1cm57Y29tcG9uZW50OmNvbXBvbmVudCxtaW5YOjAsbWF4WDowLG1pblk6MCxtYXhZOjB9O319O307X2p1LmV4dGVuZChfanAuT3ZlcmxheXMuQXJyb3csQWJzdHJhY3RPdmVybGF5LHt1cGRhdGVGcm9tOmZ1bmN0aW9uIHVwZGF0ZUZyb20oZCl7dGhpcy5sZW5ndGg9ZC5sZW5ndGh8fHRoaXMubGVuZ3RoO3RoaXMud2lkdGg9ZC53aWR0aHx8dGhpcy53aWR0aDt0aGlzLmRpcmVjdGlvbj1kLmRpcmVjdGlvbiE9bnVsbD9kLmRpcmVjdGlvbjp0aGlzLmRpcmVjdGlvbjt0aGlzLmZvbGRiYWNrPWQuZm9sZGJhY2t8fHRoaXMuZm9sZGJhY2s7fX0pOy8qXHJcbiAgICAgKiBDbGFzczogT3ZlcmxheXMuUGxhaW5BcnJvd1xyXG4gICAgICpcclxuICAgICAqIEEgYmFzaWMgYXJyb3cuICBUaGlzIGlzIGluIGZhY3QganVzdCBvbmUgaW5zdGFuY2Ugb2YgdGhlIG1vcmUgZ2VuZXJpYyBjYXNlIGluIHdoaWNoIHRoZSB0YWlsIGZvbGRzIGJhY2sgb24gaXRzZWxmIHRvIHNvbWVcclxuICAgICAqIHBvaW50IGFsb25nIHRoZSBsZW5ndGggb2YgdGhlIGFycm93OiBpbiB0aGlzIGNhc2UsIHRoYXQgZm9sZGJhY2sgcG9pbnQgaXMgdGhlIGZ1bGwgbGVuZ3RoIG9mIHRoZSBhcnJvdy4gIHNvIGl0IGp1c3QgZG9lc1xyXG4gICAgICogYSAnY2FsbCcgdG8gQXJyb3cgd2l0aCBmb2xkYmFjayBzZXQgYXBwcm9wcmlhdGVseS5cclxuICAgICAqLy8qXHJcbiAgICAgKiBGdW5jdGlvbjogQ29uc3RydWN0b3JcclxuICAgICAqIFNlZSA8T3ZlcmxheXMuQXJyb3c+IGZvciBhbGxvd2VkIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3ZlcmxheS5cclxuICAgICAqL19qcC5PdmVybGF5cy5QbGFpbkFycm93PWZ1bmN0aW9uKHBhcmFtcyl7cGFyYW1zPXBhcmFtc3x8e307dmFyIHA9X2pwLmV4dGVuZChwYXJhbXMse2ZvbGRiYWNrOjF9KTtfanAuT3ZlcmxheXMuQXJyb3cuY2FsbCh0aGlzLHApO3RoaXMudHlwZT1cIlBsYWluQXJyb3dcIjt9O19qdS5leHRlbmQoX2pwLk92ZXJsYXlzLlBsYWluQXJyb3csX2pwLk92ZXJsYXlzLkFycm93KTsvKlxyXG4gICAgICogQ2xhc3M6IE92ZXJsYXlzLkRpYW1vbmRcclxuICAgICAqIFxyXG4gICAgICogQSBkaWFtb25kLiBMaWtlIFBsYWluQXJyb3csIHRoaXMgaXMgYSBjb25jcmV0ZSBjYXNlIG9mIHRoZSBtb3JlIGdlbmVyaWMgY2FzZSBvZiB0aGUgdGFpbCBwb2ludHMgY29udmVyZ2luZyBvbiBzb21lIHBvaW50Li4uaXQganVzdFxyXG4gICAgICogaGFwcGVucyB0aGF0IGluIHRoaXMgY2FzZSwgdGhhdCBwb2ludCBpcyBncmVhdGVyIHRoYW4gdGhlIGxlbmd0aCBvZiB0aGUgdGhlIGFycm93LlxyXG4gICAgICpcclxuICAgICAqICAgICAgdGhpcyBjb3VsZCBwcm9iYWJseSBkbyB3aXRoIHNvbWUgaGVscCB3aXRoIHBvc2l0aW9uaW5nLi4uZHVlIHRvIHRoZSB3YXkgaXQgcmV1c2VzIHRoZSBBcnJvdyBwYWludCBjb2RlLCB3aGF0IEFycm93IHRoaW5rcyBpcyB0aGVcclxuICAgICAqICAgICAgY2VudGVyIGlzIGFjdHVhbGx5IDEvNCBvZiB0aGUgd2F5IGFsb25nIGZvciB0aGlzIGd1eS4gIGJ1dCB3ZSBkb24ndCBoYXZlIGFueSBrbm93bGVkZ2Ugb2YgcGl4ZWxzIGF0IHRoaXMgcG9pbnQsIHNvIHdlJ3JlIGtpbmQgb2ZcclxuICAgICAqICAgICAgc3R1Y2sgd2hlbiBpdCBjb21lcyB0byBoZWxwaW5nIG91dCB0aGUgQXJyb3cgY2xhc3MuIHBvc3NpYmx5IHdlIGNvdWxkIHBhc3MgaW4gYSAndHJhbnNwb3NlJyBwYXJhbWV0ZXIgb3Igc29tZXRoaW5nLiB0aGUgdmFsdWVcclxuICAgICAqICAgICAgd291bGQgYmUgLWwvNCBpbiB0aGlzIGNhc2UgLSBtb3ZlIGFsb25nIG9uZSBxdWFydGVyIG9mIHRoZSB0b3RhbCBsZW5ndGguXHJcbiAgICAgKi8vKlxyXG4gICAgICogRnVuY3Rpb246IENvbnN0cnVjdG9yXHJcbiAgICAgKiBTZWUgPE92ZXJsYXlzLkFycm93PiBmb3IgYWxsb3dlZCBwYXJhbWV0ZXJzIGZvciB0aGlzIG92ZXJsYXkuXHJcbiAgICAgKi9fanAuT3ZlcmxheXMuRGlhbW9uZD1mdW5jdGlvbihwYXJhbXMpe3BhcmFtcz1wYXJhbXN8fHt9O3ZhciBsPXBhcmFtcy5sZW5ndGh8fDQwLHA9X2pwLmV4dGVuZChwYXJhbXMse2xlbmd0aDpsLzIsZm9sZGJhY2s6Mn0pO19qcC5PdmVybGF5cy5BcnJvdy5jYWxsKHRoaXMscCk7dGhpcy50eXBlPVwiRGlhbW9uZFwiO307X2p1LmV4dGVuZChfanAuT3ZlcmxheXMuRGlhbW9uZCxfanAuT3ZlcmxheXMuQXJyb3cpO3ZhciBfZ2V0RGltZW5zaW9ucz1mdW5jdGlvbiBfZ2V0RGltZW5zaW9ucyhjb21wb25lbnQsZm9yY2VSZWZyZXNoKXtpZihjb21wb25lbnQuX2pzUGx1bWIuY2FjaGVkRGltZW5zaW9ucz09bnVsbHx8Zm9yY2VSZWZyZXNoKXtjb21wb25lbnQuX2pzUGx1bWIuY2FjaGVkRGltZW5zaW9ucz1jb21wb25lbnQuZ2V0RGltZW5zaW9ucygpO31yZXR1cm4gY29tcG9uZW50Ll9qc1BsdW1iLmNhY2hlZERpbWVuc2lvbnM7fTsvLyBhYnN0cmFjdCBzdXBlcmNsYXNzIGZvciBvdmVybGF5cyB0aGF0IGFkZCBhbiBlbGVtZW50IHRvIHRoZSBET00uXG52YXIgQWJzdHJhY3RET01PdmVybGF5PWZ1bmN0aW9uIEFic3RyYWN0RE9NT3ZlcmxheShwYXJhbXMpe19qcC5qc1BsdW1iVUlDb21wb25lbnQuYXBwbHkodGhpcyxhcmd1bWVudHMpO0Fic3RyYWN0T3ZlcmxheS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7Ly8gaGFuZCBvZmYgZmlyZWQgZXZlbnRzIHRvIGFzc29jaWF0ZWQgY29tcG9uZW50LlxudmFyIF9mPXRoaXMuZmlyZTt0aGlzLmZpcmU9ZnVuY3Rpb24oKXtfZi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7aWYodGhpcy5jb21wb25lbnQpe3RoaXMuY29tcG9uZW50LmZpcmUuYXBwbHkodGhpcy5jb21wb25lbnQsYXJndW1lbnRzKTt9fTt0aGlzLmRldGFjaGVkPWZhbHNlO3RoaXMuaWQ9cGFyYW1zLmlkO3RoaXMuX2pzUGx1bWIuZGl2PW51bGw7dGhpcy5fanNQbHVtYi5pbml0aWFsaXNlZD1mYWxzZTt0aGlzLl9qc1BsdW1iLmNvbXBvbmVudD1wYXJhbXMuY29tcG9uZW50O3RoaXMuX2pzUGx1bWIuY2FjaGVkRGltZW5zaW9ucz1udWxsO3RoaXMuX2pzUGx1bWIuY3JlYXRlPXBhcmFtcy5jcmVhdGU7dGhpcy5fanNQbHVtYi5pbml0aWFsbHlJbnZpc2libGU9cGFyYW1zLnZpc2libGU9PT1mYWxzZTt0aGlzLmdldEVsZW1lbnQ9ZnVuY3Rpb24oKXtpZih0aGlzLl9qc1BsdW1iLmRpdj09bnVsbCl7dmFyIGRpdj10aGlzLl9qc1BsdW1iLmRpdj1fanAuZ2V0RWxlbWVudCh0aGlzLl9qc1BsdW1iLmNyZWF0ZSh0aGlzLl9qc1BsdW1iLmNvbXBvbmVudCkpO2Rpdi5zdHlsZS5wb3NpdGlvbj1cImFic29sdXRlXCI7ZGl2LmNsYXNzTmFtZT10aGlzLl9qc1BsdW1iLmluc3RhbmNlLm92ZXJsYXlDbGFzcytcIiBcIisodGhpcy5jc3NDbGFzcz90aGlzLmNzc0NsYXNzOnBhcmFtcy5jc3NDbGFzcz9wYXJhbXMuY3NzQ2xhc3M6XCJcIik7dGhpcy5fanNQbHVtYi5pbnN0YW5jZS5hcHBlbmRFbGVtZW50KGRpdik7dGhpcy5fanNQbHVtYi5pbnN0YW5jZS5nZXRJZChkaXYpO3RoaXMuY2FudmFzPWRpdjsvLyBpbiBJRSB0aGUgdG9wIGxlZnQgY29ybmVyIGlzIHdoYXQgaXQgcGxhY2VkIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uLiAgVGhpcyB3aWxsIG5vdFxuLy8gYmUgZml4ZWQuIElFOCBpcyBub3QgZ29pbmcgdG8gYmUgc3VwcG9ydGVkIGZvciBtdWNoIGxvbmdlci5cbnZhciB0cz1cInRyYW5zbGF0ZSgtNTAlLCAtNTAlKVwiO2Rpdi5zdHlsZS53ZWJraXRUcmFuc2Zvcm09dHM7ZGl2LnN0eWxlLm1velRyYW5zZm9ybT10cztkaXYuc3R5bGUubXNUcmFuc2Zvcm09dHM7ZGl2LnN0eWxlLm9UcmFuc2Zvcm09dHM7ZGl2LnN0eWxlLnRyYW5zZm9ybT10czsvLyB3cml0ZSB0aGUgcmVsYXRlZCBjb21wb25lbnQgaW50byB0aGUgY3JlYXRlZCBlbGVtZW50XG5kaXYuX2pzUGx1bWI9dGhpcztpZihwYXJhbXMudmlzaWJsZT09PWZhbHNlKXtkaXYuc3R5bGUuZGlzcGxheT1cIm5vbmVcIjt9fXJldHVybiB0aGlzLl9qc1BsdW1iLmRpdjt9O3RoaXMuZHJhdz1mdW5jdGlvbihjb21wb25lbnQsY3VycmVudENvbm5lY3Rpb25QYWludFN0eWxlLGFic29sdXRlUG9zaXRpb24pe3ZhciB0ZD1fZ2V0RGltZW5zaW9ucyh0aGlzKTtpZih0ZCE9bnVsbCYmdGQubGVuZ3RoPT09Mil7dmFyIGN4eT17eDowLHk6MH07Ly8gYWJzb2x1dGVQb3NpdGlvbiB3b3VsZCBoYXZlIGJlZW4gc2V0IGJ5IGEgY2FsbCB0byBjb25uZWN0aW9uLnNldEFic29sdXRlT3ZlcmxheVBvc2l0aW9uLlxuaWYoYWJzb2x1dGVQb3NpdGlvbil7Y3h5PXt4OmFic29sdXRlUG9zaXRpb25bMF0seTphYnNvbHV0ZVBvc2l0aW9uWzFdfTt9ZWxzZSBpZihjb21wb25lbnQucG9pbnRPblBhdGgpe3ZhciBsb2M9dGhpcy5sb2MsYWJzb2x1dGU9ZmFsc2U7aWYoX2p1LmlzU3RyaW5nKHRoaXMubG9jKXx8dGhpcy5sb2M8MHx8dGhpcy5sb2M+MSl7bG9jPXBhcnNlSW50KHRoaXMubG9jLDEwKTthYnNvbHV0ZT10cnVlO31jeHk9Y29tcG9uZW50LnBvaW50T25QYXRoKGxvYyxhYnNvbHV0ZSk7Ly8gYSBjb25uZWN0aW9uXG59ZWxzZXt2YXIgbG9jVG9Vc2U9dGhpcy5sb2MuY29uc3RydWN0b3I9PT1BcnJheT90aGlzLmxvYzp0aGlzLmVuZHBvaW50TG9jO2N4eT17eDpsb2NUb1VzZVswXSpjb21wb25lbnQudyx5OmxvY1RvVXNlWzFdKmNvbXBvbmVudC5ofTt9dmFyIG1pbng9Y3h5LngtdGRbMF0vMixtaW55PWN4eS55LXRkWzFdLzI7cmV0dXJue2NvbXBvbmVudDpjb21wb25lbnQsZDp7bWlueDptaW54LG1pbnk6bWlueSx0ZDp0ZCxjeHk6Y3h5fSxtaW5YOm1pbngsbWF4WDptaW54K3RkWzBdLG1pblk6bWlueSxtYXhZOm1pbnkrdGRbMV19O31lbHNle3JldHVybnttaW5YOjAsbWF4WDowLG1pblk6MCxtYXhZOjB9O319O307X2p1LmV4dGVuZChBYnN0cmFjdERPTU92ZXJsYXksW19qcC5qc1BsdW1iVUlDb21wb25lbnQsQWJzdHJhY3RPdmVybGF5XSx7Z2V0RGltZW5zaW9uczpmdW5jdGlvbiBnZXREaW1lbnNpb25zKCl7cmV0dXJuWzEsMV07fSxzZXRWaXNpYmxlOmZ1bmN0aW9uIHNldFZpc2libGUoc3RhdGUpe2lmKHRoaXMuX2pzUGx1bWIuZGl2KXt0aGlzLl9qc1BsdW1iLmRpdi5zdHlsZS5kaXNwbGF5PXN0YXRlP1wiYmxvY2tcIjpcIm5vbmVcIjsvLyBpZiBpbml0aWFsbHkgaW52aXNpYmxlLCBkaW1lbnNpb25zIGFyZSAwLDAgYW5kIG5ldmVyIGdldCB1cGRhdGVkXG5pZihzdGF0ZSYmdGhpcy5fanNQbHVtYi5pbml0aWFsbHlJbnZpc2libGUpe19nZXREaW1lbnNpb25zKHRoaXMsdHJ1ZSk7dGhpcy5jb21wb25lbnQucmVwYWludCgpO3RoaXMuX2pzUGx1bWIuaW5pdGlhbGx5SW52aXNpYmxlPWZhbHNlO319fSwvKlxyXG4gICAgICAgICAqIEZ1bmN0aW9uOiBjbGVhckNhY2hlZERpbWVuc2lvbnNcclxuICAgICAgICAgKiBDbGVhcnMgdGhlIGNhY2hlZCBkaW1lbnNpb25zIGZvciB0aGUgbGFiZWwuIEFzIGEgcGVyZm9ybWFuY2UgZW5oYW5jZW1lbnQsIGxhYmVsIGRpbWVuc2lvbnMgYXJlXHJcbiAgICAgICAgICogY2FjaGVkIGZyb20gMS4zLjEyIG9ud2FyZHMuIFRoZSBjYWNoZSBpcyBjbGVhcmVkIHdoZW4geW91IGNoYW5nZSB0aGUgbGFiZWwgdGV4dCwgb2YgY291cnNlLCBidXRcclxuICAgICAgICAgKiB0aGVyZSBhcmUgb3RoZXIgcmVhc29ucyB3aHkgdGhlIHRleHQgZGltZW5zaW9ucyBtaWdodCBjaGFuZ2UgLSBpZiB5b3UgbWFrZSBhIGNoYW5nZSB0aHJvdWdoIENTUywgZm9yXHJcbiAgICAgICAgICogZXhhbXBsZSwgeW91IG1pZ2h0IGNoYW5nZSB0aGUgZm9udCBzaXplLiAgaW4gdGhhdCBjYXNlIHlvdSBzaG91bGQgZXhwbGljaXRseSBjYWxsIHRoaXMgbWV0aG9kLlxyXG4gICAgICAgICAqL2NsZWFyQ2FjaGVkRGltZW5zaW9uczpmdW5jdGlvbiBjbGVhckNhY2hlZERpbWVuc2lvbnMoKXt0aGlzLl9qc1BsdW1iLmNhY2hlZERpbWVuc2lvbnM9bnVsbDt9LGNsZWFudXA6ZnVuY3Rpb24gY2xlYW51cChmb3JjZSl7aWYoZm9yY2Upe2lmKHRoaXMuX2pzUGx1bWIuZGl2IT1udWxsKXt0aGlzLl9qc1BsdW1iLmRpdi5fanNQbHVtYj1udWxsO3RoaXMuX2pzUGx1bWIuaW5zdGFuY2UucmVtb3ZlRWxlbWVudCh0aGlzLl9qc1BsdW1iLmRpdik7fX1lbHNley8vIGlmIG5vdCBhIGZvcmNlZCBjbGVhbnVwLCBqdXN0IGRldGFjaCBjaGlsZCBmcm9tIHBhcmVudCBmb3Igbm93LlxuaWYodGhpcy5fanNQbHVtYiYmdGhpcy5fanNQbHVtYi5kaXYmJnRoaXMuX2pzUGx1bWIuZGl2LnBhcmVudE5vZGUpe3RoaXMuX2pzUGx1bWIuZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fanNQbHVtYi5kaXYpO310aGlzLmRldGFjaGVkPXRydWU7fX0scmVhdHRhY2g6ZnVuY3Rpb24gcmVhdHRhY2goaW5zdGFuY2UsY29tcG9uZW50KXtpZih0aGlzLl9qc1BsdW1iLmRpdiE9bnVsbCl7aW5zdGFuY2UuZ2V0Q29udGFpbmVyKCkuYXBwZW5kQ2hpbGQodGhpcy5fanNQbHVtYi5kaXYpO310aGlzLmRldGFjaGVkPWZhbHNlO30sY29tcHV0ZU1heFNpemU6ZnVuY3Rpb24gY29tcHV0ZU1heFNpemUoKXt2YXIgdGQ9X2dldERpbWVuc2lvbnModGhpcyk7cmV0dXJuIE1hdGgubWF4KHRkWzBdLHRkWzFdKTt9LHBhaW50OmZ1bmN0aW9uIHBhaW50KHAsY29udGFpbmVyRXh0ZW50cyl7aWYoIXRoaXMuX2pzUGx1bWIuaW5pdGlhbGlzZWQpe3RoaXMuZ2V0RWxlbWVudCgpO3AuY29tcG9uZW50LmFwcGVuZERpc3BsYXlFbGVtZW50KHRoaXMuX2pzUGx1bWIuZGl2KTt0aGlzLl9qc1BsdW1iLmluaXRpYWxpc2VkPXRydWU7aWYodGhpcy5kZXRhY2hlZCl7dGhpcy5fanNQbHVtYi5kaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9qc1BsdW1iLmRpdik7fX10aGlzLl9qc1BsdW1iLmRpdi5zdHlsZS5sZWZ0PXAuY29tcG9uZW50LngrcC5kLm1pbngrXCJweFwiO3RoaXMuX2pzUGx1bWIuZGl2LnN0eWxlLnRvcD1wLmNvbXBvbmVudC55K3AuZC5taW55K1wicHhcIjt9fSk7LypcclxuICAgICAqIENsYXNzOiBPdmVybGF5cy5DdXN0b21cclxuICAgICAqIEEgQ3VzdG9tIG92ZXJsYXkuIFlvdSBzdXBwbHkgYSAnY3JlYXRlJyBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHNvbWUgRE9NIGVsZW1lbnQsIGFuZCBqc1BsdW1iIHBvc2l0aW9ucyBpdC5cclxuICAgICAqIFRoZSAnY3JlYXRlJyBmdW5jdGlvbiBpcyBwYXNzZWQgYSBDb25uZWN0aW9uIG9yIEVuZHBvaW50LlxyXG4gICAgICovLypcclxuICAgICAqIEZ1bmN0aW9uOiBDb25zdHJ1Y3RvclxyXG4gICAgICogXHJcbiAgICAgKiBQYXJhbWV0ZXJzOlxyXG4gICAgICogY3JlYXRlIC0gZnVuY3Rpb24gZm9yIGpzUGx1bWIgdG8gY2FsbCB0aGF0IHJldHVybnMgYSBET00gZWxlbWVudC5cclxuICAgICAqIGxvY2F0aW9uIC0gZGlzdGFuY2UgKGFzIGEgZGVjaW1hbCBmcm9tIDAgdG8gMSBpbmNsdXNpdmUpIG1hcmtpbmcgd2hlcmUgdGhlIGxhYmVsIHNob3VsZCBzaXQgb24gdGhlIGNvbm5lY3Rvci4gZGVmYXVsdHMgdG8gMC41LlxyXG4gICAgICogaWQgLSBvcHRpb25hbCBpZCB0byB1c2UgZm9yIGxhdGVyIHJldHJpZXZhbCBvZiB0aGlzIG92ZXJsYXkuXHJcbiAgICAgKlxyXG4gICAgICovX2pwLk92ZXJsYXlzLkN1c3RvbT1mdW5jdGlvbihwYXJhbXMpe3RoaXMudHlwZT1cIkN1c3RvbVwiO0Fic3RyYWN0RE9NT3ZlcmxheS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7fTtfanUuZXh0ZW5kKF9qcC5PdmVybGF5cy5DdXN0b20sQWJzdHJhY3RET01PdmVybGF5KTtfanAuT3ZlcmxheXMuR3VpZGVMaW5lcz1mdW5jdGlvbigpe3ZhciBzZWxmPXRoaXM7c2VsZi5sZW5ndGg9NTA7c2VsZi5zdHJva2VXaWR0aD01O3RoaXMudHlwZT1cIkd1aWRlTGluZXNcIjtBYnN0cmFjdE92ZXJsYXkuYXBwbHkodGhpcyxhcmd1bWVudHMpO19qcC5qc1BsdW1iVUlDb21wb25lbnQuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMuZHJhdz1mdW5jdGlvbihjb25uZWN0b3IsY3VycmVudENvbm5lY3Rpb25QYWludFN0eWxlKXt2YXIgaGVhZD1jb25uZWN0b3IucG9pbnRBbG9uZ1BhdGhGcm9tKHNlbGYubG9jLHNlbGYubGVuZ3RoLzIpLG1pZD1jb25uZWN0b3IucG9pbnRPblBhdGgoc2VsZi5sb2MpLHRhaWw9X2pnLnBvaW50T25MaW5lKGhlYWQsbWlkLHNlbGYubGVuZ3RoKSx0YWlsTGluZT1famcucGVycGVuZGljdWxhckxpbmVUbyhoZWFkLHRhaWwsNDApLGhlYWRMaW5lPV9qZy5wZXJwZW5kaWN1bGFyTGluZVRvKHRhaWwsaGVhZCwyMCk7cmV0dXJue2Nvbm5lY3Rvcjpjb25uZWN0b3IsaGVhZDpoZWFkLHRhaWw6dGFpbCxoZWFkTGluZTpoZWFkTGluZSx0YWlsTGluZTp0YWlsTGluZSxtaW5YOk1hdGgubWluKGhlYWQueCx0YWlsLngsaGVhZExpbmVbMF0ueCxoZWFkTGluZVsxXS54KSxtaW5ZOk1hdGgubWluKGhlYWQueSx0YWlsLnksaGVhZExpbmVbMF0ueSxoZWFkTGluZVsxXS55KSxtYXhYOk1hdGgubWF4KGhlYWQueCx0YWlsLngsaGVhZExpbmVbMF0ueCxoZWFkTGluZVsxXS54KSxtYXhZOk1hdGgubWF4KGhlYWQueSx0YWlsLnksaGVhZExpbmVbMF0ueSxoZWFkTGluZVsxXS55KX07fTsvLyB0aGlzLmNsZWFudXAgPSBmdW5jdGlvbigpIHsgfTsgIC8vIG5vdGhpbmcgdG8gY2xlYW4gdXAgZm9yIEd1aWRlTGluZXNcbn07LypcclxuICAgICAqIENsYXNzOiBPdmVybGF5cy5MYWJlbFxyXG5cclxuICAgICAqLy8qXHJcbiAgICAgKiBGdW5jdGlvbjogQ29uc3RydWN0b3JcclxuICAgICAqIFxyXG4gICAgICogUGFyYW1ldGVyczpcclxuICAgICAqIGNzc0NsYXNzIC0gb3B0aW9uYWwgY3NzIGNsYXNzIHN0cmluZyB0byBhcHBlbmQgdG8gY3NzIGNsYXNzLiBUaGlzIHN0cmluZyBpcyBhcHBlbmRlZCBcImFzLWlzXCIsIHNvIHlvdSBjYW4gb2YgY291cnNlIGhhdmUgbXVsdGlwbGUgY2xhc3Nlc1xyXG4gICAgICogICAgICAgICAgICAgZGVmaW5lZC4gIFRoaXMgcGFyYW1ldGVyIGlzIHByZWZlcnJlZCB0byB1c2luZyBsYWJlbFN0eWxlLCBib3JkZXJXaWR0aCBhbmQgYm9yZGVyU3R5bGUuXHJcbiAgICAgKiBsYWJlbCAtIHRoZSBsYWJlbCB0byBwYWludC4gIE1heSBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHN0cmluZy4gIE5vdGhpbmcgd2lsbCBiZSBwYWludGVkIGlmIHlvdXIgbGFiZWwgaXMgbnVsbCBvciB5b3VyXHJcbiAgICAgKiAgICAgICAgIGxhYmVsIGZ1bmN0aW9uIHJldHVybnMgbnVsbC4gIGVtcHR5IHN0cmluZ3MgX3dpbGxfIGJlIHBhaW50ZWQuXHJcbiAgICAgKiBsb2NhdGlvbiAtIGRpc3RhbmNlIChhcyBhIGRlY2ltYWwgZnJvbSAwIHRvIDEgaW5jbHVzaXZlKSBtYXJraW5nIHdoZXJlIHRoZSBsYWJlbCBzaG91bGQgc2l0IG9uIHRoZSBjb25uZWN0b3IuIGRlZmF1bHRzIHRvIDAuNS5cclxuICAgICAqIGlkIC0gb3B0aW9uYWwgaWQgdG8gdXNlIGZvciBsYXRlciByZXRyaWV2YWwgb2YgdGhpcyBvdmVybGF5LlxyXG4gICAgICogXHJcbiAgICAgKlxyXG4gICAgICovX2pwLk92ZXJsYXlzLkxhYmVsPWZ1bmN0aW9uKHBhcmFtcyl7dGhpcy5sYWJlbFN0eWxlPXBhcmFtcy5sYWJlbFN0eWxlO3ZhciBsYWJlbFdpZHRoPW51bGwsbGFiZWxIZWlnaHQ9bnVsbCxsYWJlbFRleHQ9bnVsbCxsYWJlbFBhZGRpbmc9bnVsbDt0aGlzLmNzc0NsYXNzPXRoaXMubGFiZWxTdHlsZSE9bnVsbD90aGlzLmxhYmVsU3R5bGUuY3NzQ2xhc3M6bnVsbDt2YXIgcD1fanAuZXh0ZW5kKHtjcmVhdGU6ZnVuY3Rpb24gY3JlYXRlKCl7cmV0dXJuIF9qcC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO319LHBhcmFtcyk7X2pwLk92ZXJsYXlzLkN1c3RvbS5jYWxsKHRoaXMscCk7dGhpcy50eXBlPVwiTGFiZWxcIjt0aGlzLmxhYmVsPXBhcmFtcy5sYWJlbHx8XCJcIjt0aGlzLmxhYmVsVGV4dD1udWxsO2lmKHRoaXMubGFiZWxTdHlsZSl7dmFyIGVsPXRoaXMuZ2V0RWxlbWVudCgpO3RoaXMubGFiZWxTdHlsZS5mb250PXRoaXMubGFiZWxTdHlsZS5mb250fHxcIjEycHggc2Fucy1zZXJpZlwiO2VsLnN0eWxlLmZvbnQ9dGhpcy5sYWJlbFN0eWxlLmZvbnQ7ZWwuc3R5bGUuY29sb3I9dGhpcy5sYWJlbFN0eWxlLmNvbG9yfHxcImJsYWNrXCI7aWYodGhpcy5sYWJlbFN0eWxlLmZpbGwpe2VsLnN0eWxlLmJhY2tncm91bmQ9dGhpcy5sYWJlbFN0eWxlLmZpbGw7fWlmKHRoaXMubGFiZWxTdHlsZS5ib3JkZXJXaWR0aD4wKXt2YXIgZFN0eWxlPXRoaXMubGFiZWxTdHlsZS5ib3JkZXJTdHlsZT90aGlzLmxhYmVsU3R5bGUuYm9yZGVyU3R5bGU6XCJibGFja1wiO2VsLnN0eWxlLmJvcmRlcj10aGlzLmxhYmVsU3R5bGUuYm9yZGVyV2lkdGgrXCJweCBzb2xpZCBcIitkU3R5bGU7fWlmKHRoaXMubGFiZWxTdHlsZS5wYWRkaW5nKXtlbC5zdHlsZS5wYWRkaW5nPXRoaXMubGFiZWxTdHlsZS5wYWRkaW5nO319fTtfanUuZXh0ZW5kKF9qcC5PdmVybGF5cy5MYWJlbCxfanAuT3ZlcmxheXMuQ3VzdG9tLHtjbGVhbnVwOmZ1bmN0aW9uIGNsZWFudXAoZm9yY2Upe2lmKGZvcmNlKXt0aGlzLmRpdj1udWxsO3RoaXMubGFiZWw9bnVsbDt0aGlzLmxhYmVsVGV4dD1udWxsO3RoaXMuY3NzQ2xhc3M9bnVsbDt0aGlzLmxhYmVsU3R5bGU9bnVsbDt9fSxnZXRMYWJlbDpmdW5jdGlvbiBnZXRMYWJlbCgpe3JldHVybiB0aGlzLmxhYmVsO30sLypcclxuICAgICAgICAgKiBGdW5jdGlvbjogc2V0TGFiZWxcclxuICAgICAgICAgKiBzZXRzIHRoZSBsYWJlbCdzLCB1bSwgbGFiZWwuICB5b3Ugd291bGQgdGhpbmsgaSdkIGNhbGwgdGhpcyBmdW5jdGlvblxyXG4gICAgICAgICAqICdzZXRUZXh0JywgYnV0IHlvdSBjYW4gcGFzcyBlaXRoZXIgYSBGdW5jdGlvbiBvciBhIFN0cmluZyB0byB0aGlzLCBzb1xyXG4gICAgICAgICAqIGl0IG1ha2VzIG1vcmUgc2Vuc2UgYXMgJ3NldExhYmVsJy4gVGhpcyB1c2VzIGlubmVySFRNTCBvbiB0aGUgbGFiZWwgZGl2LCBzbyBrZWVwXHJcbiAgICAgICAgICogdGhhdCBpbiBtaW5kIGlmIHlvdSBuZWVkIGVzY2FwZWQgSFRNTC5cclxuICAgICAgICAgKi9zZXRMYWJlbDpmdW5jdGlvbiBzZXRMYWJlbChsKXt0aGlzLmxhYmVsPWw7dGhpcy5sYWJlbFRleHQ9bnVsbDt0aGlzLmNsZWFyQ2FjaGVkRGltZW5zaW9ucygpO3RoaXMudXBkYXRlKCk7dGhpcy5jb21wb25lbnQucmVwYWludCgpO30sZ2V0RGltZW5zaW9uczpmdW5jdGlvbiBnZXREaW1lbnNpb25zKCl7dGhpcy51cGRhdGUoKTtyZXR1cm4gQWJzdHJhY3RET01PdmVybGF5LnByb3RvdHlwZS5nZXREaW1lbnNpb25zLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt9LHVwZGF0ZTpmdW5jdGlvbiB1cGRhdGUoKXtpZih0eXBlb2YgdGhpcy5sYWJlbD09PVwiZnVuY3Rpb25cIil7dmFyIGx0PXRoaXMubGFiZWwodGhpcyk7dGhpcy5nZXRFbGVtZW50KCkuaW5uZXJIVE1MPWx0LnJlcGxhY2UoL1xcclxcbi9nLFwiPGJyLz5cIik7fWVsc2V7aWYodGhpcy5sYWJlbFRleHQ9PW51bGwpe3RoaXMubGFiZWxUZXh0PXRoaXMubGFiZWw7dGhpcy5nZXRFbGVtZW50KCkuaW5uZXJIVE1MPXRoaXMubGFiZWxUZXh0LnJlcGxhY2UoL1xcclxcbi9nLFwiPGJyLz5cIik7fX19LHVwZGF0ZUZyb206ZnVuY3Rpb24gdXBkYXRlRnJvbShkKXtpZihkLmxhYmVsIT1udWxsKXt0aGlzLnNldExhYmVsKGQubGFiZWwpO319fSk7Ly8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEVORCBPRiBPVkVSTEFZIERFRklOSVRJT05TICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG59KS5jYWxsKHR5cGVvZiB3aW5kb3chPT0ndW5kZWZpbmVkJz93aW5kb3c6dGhpcyk7LypcclxuICogVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSBiYXNlIGNsYXNzIGZvciBsaWJyYXJ5IGFkYXB0ZXJzLlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgLSAyMDE4IGpzUGx1bWIgKGhlbGxvQGpzcGx1bWJ0b29sa2l0LmNvbSlcclxuICpcclxuICogaHR0cHM6Ly9qc3BsdW1idG9vbGtpdC5jb21cclxuICogaHR0cHM6Ly9naXRodWIuY29tL2pzcGx1bWIvanNwbHVtYlxyXG4gKlxyXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgYW5kIEdQTDIgbGljZW5zZXMuXHJcbiAqLzsoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgcm9vdD10aGlzLF9qcD1yb290LmpzUGx1bWI7dmFyIF9nZXRFdmVudE1hbmFnZXI9ZnVuY3Rpb24gX2dldEV2ZW50TWFuYWdlcihpbnN0YW5jZSl7dmFyIGU9aW5zdGFuY2UuX21vdHRsZTtpZighZSl7ZT1pbnN0YW5jZS5fbW90dGxlPW5ldyByb290Lk1vdHRsZSgpO31yZXR1cm4gZTt9O19qcC5leHRlbmQocm9vdC5qc1BsdW1iSW5zdGFuY2UucHJvdG90eXBlLHtnZXRFdmVudE1hbmFnZXI6ZnVuY3Rpb24gZ2V0RXZlbnRNYW5hZ2VyKCl7cmV0dXJuIF9nZXRFdmVudE1hbmFnZXIodGhpcyk7fSxvbjpmdW5jdGlvbiBvbihlbCxldmVudCxjYWxsYmFjayl7Ly8gVE9ETzogaGVyZSB3ZSB3b3VsZCBsaWtlIHRvIG1hcCB0aGUgdGFwIGV2ZW50IGlmIHdlIGtub3cgaXRzXG4vLyBhbiBpbnRlcm5hbCBiaW5kIHRvIGEgY2xpY2suIHdlIGhhdmUgdG8ga25vdyBpdHMgaW50ZXJuYWwgYmVjYXVzZSBvbmx5XG4vLyB0aGVuIGNhbiB3ZSBiZSBzdXJlIHRoYXQgdGhlIFVQIGV2ZW50IHdvbnQgYmUgY29uc3VtZWQgKHRhcCBpcyBhIHN5bnRoZXNpemVkXG4vLyBldmVudCBmcm9tIGEgbW91c2Vkb3duIGZvbGxvd2VkIGJ5IGEgbW91c2V1cCkuXG4vL2V2ZW50ID0geyBcImNsaWNrXCI6XCJ0YXBcIiwgXCJkYmxjbGlja1wiOlwiZGJsdGFwXCJ9W2V2ZW50XSB8fCBldmVudDtcbnRoaXMuZ2V0RXZlbnRNYW5hZ2VyKCkub24uYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB0aGlzO30sb2ZmOmZ1bmN0aW9uIG9mZihlbCxldmVudCxjYWxsYmFjayl7dGhpcy5nZXRFdmVudE1hbmFnZXIoKS5vZmYuYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB0aGlzO319KTt9KS5jYWxsKHR5cGVvZiB3aW5kb3chPT0ndW5kZWZpbmVkJz93aW5kb3c6dGhpcyk7LypcclxuICogQ29weXJpZ2h0IChjKSAyMDEwIC0gMjAxOCBqc1BsdW1iIChoZWxsb0Bqc3BsdW1idG9vbGtpdC5jb20pXHJcbiAqXHJcbiAqIGh0dHBzOi8vanNwbHVtYnRvb2xraXQuY29tXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qc3BsdW1iL2pzcGx1bWJcclxuICpcclxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwyIGxpY2Vuc2VzLlxyXG4gKi87KGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHJvb3Q9dGhpcyxfanU9cm9vdC5qc1BsdW1iVXRpbCxfanBpPXJvb3QuanNQbHVtYkluc3RhbmNlO3ZhciBHUk9VUF9DT0xMQVBTRURfQ0xBU1M9XCJqdGstZ3JvdXAtY29sbGFwc2VkXCI7dmFyIEdST1VQX0VYUEFOREVEX0NMQVNTPVwianRrLWdyb3VwLWV4cGFuZGVkXCI7dmFyIEdST1VQX0NPTlRBSU5FUl9TRUxFQ1RPUj1cIltqdGstZ3JvdXAtY29udGVudF1cIjt2YXIgRUxFTUVOVF9EUkFHR0FCTEVfRVZFTlQ9XCJlbGVtZW50RHJhZ2dhYmxlXCI7dmFyIFNUT1A9XCJzdG9wXCI7dmFyIFJFVkVSVD1cInJldmVydFwiO3ZhciBHUk9VUF9NQU5BR0VSPVwiX2dyb3VwTWFuYWdlclwiO3ZhciBHUk9VUD1cIl9qc1BsdW1iR3JvdXBcIjt2YXIgR1JPVVBfRFJBR19TQ09QRT1cIl9qc1BsdW1iR3JvdXBEcmFnXCI7dmFyIEVWVF9DSElMRF9BRERFRD1cImdyb3VwOmFkZE1lbWJlclwiO3ZhciBFVlRfQ0hJTERfUkVNT1ZFRD1cImdyb3VwOnJlbW92ZU1lbWJlclwiO3ZhciBFVlRfR1JPVVBfQURERUQ9XCJncm91cDphZGRcIjt2YXIgRVZUX0dST1VQX1JFTU9WRUQ9XCJncm91cDpyZW1vdmVcIjt2YXIgRVZUX0VYUEFORD1cImdyb3VwOmV4cGFuZFwiO3ZhciBFVlRfQ09MTEFQU0U9XCJncm91cDpjb2xsYXBzZVwiO3ZhciBFVlRfR1JPVVBfRFJBR19TVE9QPVwiZ3JvdXBEcmFnU3RvcFwiO3ZhciBFVlRfQ09OTkVDVElPTl9NT1ZFRD1cImNvbm5lY3Rpb25Nb3ZlZFwiO3ZhciBFVlRfSU5URVJOQUxfQ09OTkVDVElPTl9ERVRBQ0hFRD1cImludGVybmFsLmNvbm5lY3Rpb25EZXRhY2hlZFwiO3ZhciBDTURfUkVNT1ZFX0FMTD1cInJlbW92ZUFsbFwiO3ZhciBDTURfT1JQSEFOX0FMTD1cIm9ycGhhbkFsbFwiO3ZhciBDTURfU0hPVz1cInNob3dcIjt2YXIgQ01EX0hJREU9XCJoaWRlXCI7dmFyIEdyb3VwTWFuYWdlcj1mdW5jdGlvbiBHcm91cE1hbmFnZXIoX2pzUGx1bWIpe3ZhciBfbWFuYWdlZEdyb3Vwcz17fSxfY29ubmVjdGlvblNvdXJjZU1hcD17fSxfY29ubmVjdGlvblRhcmdldE1hcD17fSxzZWxmPXRoaXM7X2pzUGx1bWIuYmluZChcImNvbm5lY3Rpb25cIixmdW5jdGlvbihwKXtpZihwLnNvdXJjZVtHUk9VUF0hPW51bGwmJnAudGFyZ2V0W0dST1VQXSE9bnVsbCYmcC5zb3VyY2VbR1JPVVBdPT09cC50YXJnZXRbR1JPVVBdKXtfY29ubmVjdGlvblNvdXJjZU1hcFtwLmNvbm5lY3Rpb24uaWRdPXAuc291cmNlW0dST1VQXTtfY29ubmVjdGlvblRhcmdldE1hcFtwLmNvbm5lY3Rpb24uaWRdPXAuc291cmNlW0dST1VQXTt9ZWxzZXtpZihwLnNvdXJjZVtHUk9VUF0hPW51bGwpe19qdS5zdWdnZXN0KHAuc291cmNlW0dST1VQXS5jb25uZWN0aW9ucy5zb3VyY2UscC5jb25uZWN0aW9uKTtfY29ubmVjdGlvblNvdXJjZU1hcFtwLmNvbm5lY3Rpb24uaWRdPXAuc291cmNlW0dST1VQXTt9aWYocC50YXJnZXRbR1JPVVBdIT1udWxsKXtfanUuc3VnZ2VzdChwLnRhcmdldFtHUk9VUF0uY29ubmVjdGlvbnMudGFyZ2V0LHAuY29ubmVjdGlvbik7X2Nvbm5lY3Rpb25UYXJnZXRNYXBbcC5jb25uZWN0aW9uLmlkXT1wLnRhcmdldFtHUk9VUF07fX19KTtmdW5jdGlvbiBfY2xlYW51cERldGFjaGVkQ29ubmVjdGlvbihjb25uKXtkZWxldGUgY29ubi5wcm94aWVzO3ZhciBncm91cD1fY29ubmVjdGlvblNvdXJjZU1hcFtjb25uLmlkXSxmO2lmKGdyb3VwIT1udWxsKXtmPWZ1bmN0aW9uIGYoYyl7cmV0dXJuIGMuaWQ9PT1jb25uLmlkO307X2p1LnJlbW92ZVdpdGhGdW5jdGlvbihncm91cC5jb25uZWN0aW9ucy5zb3VyY2UsZik7X2p1LnJlbW92ZVdpdGhGdW5jdGlvbihncm91cC5jb25uZWN0aW9ucy50YXJnZXQsZik7ZGVsZXRlIF9jb25uZWN0aW9uU291cmNlTWFwW2Nvbm4uaWRdO31ncm91cD1fY29ubmVjdGlvblRhcmdldE1hcFtjb25uLmlkXTtpZihncm91cCE9bnVsbCl7Zj1mdW5jdGlvbiBmKGMpe3JldHVybiBjLmlkPT09Y29ubi5pZDt9O19qdS5yZW1vdmVXaXRoRnVuY3Rpb24oZ3JvdXAuY29ubmVjdGlvbnMuc291cmNlLGYpO19qdS5yZW1vdmVXaXRoRnVuY3Rpb24oZ3JvdXAuY29ubmVjdGlvbnMudGFyZ2V0LGYpO2RlbGV0ZSBfY29ubmVjdGlvblRhcmdldE1hcFtjb25uLmlkXTt9fV9qc1BsdW1iLmJpbmQoRVZUX0lOVEVSTkFMX0NPTk5FQ1RJT05fREVUQUNIRUQsZnVuY3Rpb24ocCl7X2NsZWFudXBEZXRhY2hlZENvbm5lY3Rpb24ocC5jb25uZWN0aW9uKTt9KTtfanNQbHVtYi5iaW5kKEVWVF9DT05ORUNUSU9OX01PVkVELGZ1bmN0aW9uKHApe3ZhciBjb25uTWFwPXAuaW5kZXg9PT0wP19jb25uZWN0aW9uU291cmNlTWFwOl9jb25uZWN0aW9uVGFyZ2V0TWFwO3ZhciBncm91cD1jb25uTWFwW3AuY29ubmVjdGlvbi5pZF07aWYoZ3JvdXApe3ZhciBsaXN0PWdyb3VwLmNvbm5lY3Rpb25zW3AuaW5kZXg9PT0wP1wic291cmNlXCI6XCJ0YXJnZXRcIl07dmFyIGlkeD1saXN0LmluZGV4T2YocC5jb25uZWN0aW9uKTtpZihpZHghPT0tMSl7bGlzdC5zcGxpY2UoaWR4LDEpO319fSk7dGhpcy5hZGRHcm91cD1mdW5jdGlvbihncm91cCl7X2pzUGx1bWIuYWRkQ2xhc3MoZ3JvdXAuZ2V0RWwoKSxHUk9VUF9FWFBBTkRFRF9DTEFTUyk7X21hbmFnZWRHcm91cHNbZ3JvdXAuaWRdPWdyb3VwO2dyb3VwLm1hbmFnZXI9dGhpcztfdXBkYXRlQ29ubmVjdGlvbnNGb3JHcm91cChncm91cCk7X2pzUGx1bWIuZmlyZShFVlRfR1JPVVBfQURERUQse2dyb3VwOmdyb3VwfSk7fTt0aGlzLmFkZFRvR3JvdXA9ZnVuY3Rpb24oZ3JvdXAsZWwsZG9Ob3RGaXJlRXZlbnQpe2dyb3VwPXRoaXMuZ2V0R3JvdXAoZ3JvdXApO2lmKGdyb3VwKXsvL2dyb3VwLmFkZChlbCwgZG9Ob3RGaXJlRXZlbnQpO1xudmFyIGdyb3VwRWw9Z3JvdXAuZ2V0RWwoKTtpZihlbC5faXNKc1BsdW1iR3JvdXApe3JldHVybjt9dmFyIGN1cnJlbnRHcm91cD1lbC5fanNQbHVtYkdyb3VwOy8vIGlmIGFscmVhZHkgYSBtZW1iZXIgb2YgdGhpcyBncm91cCwgZG8gbm90aGluZ1xuaWYoY3VycmVudEdyb3VwIT09Z3JvdXApe3ZhciBlbHBvcz1fanNQbHVtYi5nZXRPZmZzZXQoZWwsdHJ1ZSk7dmFyIGNwb3M9Z3JvdXAuY29sbGFwc2VkP19qc1BsdW1iLmdldE9mZnNldChncm91cEVsLHRydWUpOl9qc1BsdW1iLmdldE9mZnNldChncm91cC5nZXREcmFnQXJlYSgpLHRydWUpOy8vIG90aGVyd2lzZSwgdHJhbnNmZXIgdG8gdGhpcyBncm91cC5cbmlmKGN1cnJlbnRHcm91cCE9bnVsbCl7Y3VycmVudEdyb3VwLnJlbW92ZShlbCxkb05vdEZpcmVFdmVudCk7c2VsZi51cGRhdGVDb25uZWN0aW9uc0Zvckdyb3VwKGN1cnJlbnRHcm91cCk7fWdyb3VwLmFkZChlbCxkb05vdEZpcmVFdmVudCk7dmFyIGhhbmRsZURyb3BwZWRDb25uZWN0aW9ucz1mdW5jdGlvbiBoYW5kbGVEcm9wcGVkQ29ubmVjdGlvbnMobGlzdCxpbmRleCl7dmFyIG9pZHg9aW5kZXg9PT0wPzE6MDtsaXN0LmVhY2goZnVuY3Rpb24oYyl7Yy5zZXRWaXNpYmxlKGZhbHNlKTtpZihjLmVuZHBvaW50c1tvaWR4XS5lbGVtZW50Ll9qc1BsdW1iR3JvdXA9PT1ncm91cCl7Yy5lbmRwb2ludHNbb2lkeF0uc2V0VmlzaWJsZShmYWxzZSk7c2VsZi5leHBhbmRDb25uZWN0aW9uKGMsb2lkeCxncm91cCk7fWVsc2V7Yy5lbmRwb2ludHNbaW5kZXhdLnNldFZpc2libGUoZmFsc2UpO3NlbGYuY29sbGFwc2VDb25uZWN0aW9uKGMsaW5kZXgsZ3JvdXApO319KTt9O2lmKGdyb3VwLmNvbGxhcHNlZCl7aGFuZGxlRHJvcHBlZENvbm5lY3Rpb25zKF9qc1BsdW1iLnNlbGVjdCh7c291cmNlOmVsfSksMCk7aGFuZGxlRHJvcHBlZENvbm5lY3Rpb25zKF9qc1BsdW1iLnNlbGVjdCh7dGFyZ2V0OmVsfSksMSk7fXZhciBlbElkPV9qc1BsdW1iLmdldElkKGVsKTtfanNQbHVtYi5kcmFnTWFuYWdlci5zZXRQYXJlbnQoZWwsZWxJZCxncm91cEVsLF9qc1BsdW1iLmdldElkKGdyb3VwRWwpLGVscG9zKTt2YXIgbmV3UG9zaXRpb249e2xlZnQ6ZWxwb3MubGVmdC1jcG9zLmxlZnQsdG9wOmVscG9zLnRvcC1jcG9zLnRvcH07X2pzUGx1bWIuc2V0UG9zaXRpb24oZWwsbmV3UG9zaXRpb24pO19qc1BsdW1iLmRyYWdNYW5hZ2VyLnJldmFsaWRhdGVQYXJlbnQoZWwsZWxJZCxlbHBvcyk7c2VsZi51cGRhdGVDb25uZWN0aW9uc0Zvckdyb3VwKGdyb3VwKTtfanNQbHVtYi5yZXZhbGlkYXRlKGVsSWQpO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtfanNQbHVtYi5maXJlKEVWVF9DSElMRF9BRERFRCx7Z3JvdXA6Z3JvdXAsZWw6ZWx9KTt9LDApO319fTt0aGlzLnJlbW92ZUZyb21Hcm91cD1mdW5jdGlvbihncm91cCxlbCxkb05vdEZpcmVFdmVudCl7Z3JvdXA9dGhpcy5nZXRHcm91cChncm91cCk7aWYoZ3JvdXApe2dyb3VwLnJlbW92ZShlbCxudWxsLGRvTm90RmlyZUV2ZW50KTt9fTt0aGlzLmdldEdyb3VwPWZ1bmN0aW9uKGdyb3VwSWQpe3ZhciBncm91cD1ncm91cElkO2lmKF9qdS5pc1N0cmluZyhncm91cElkKSl7Z3JvdXA9X21hbmFnZWRHcm91cHNbZ3JvdXBJZF07aWYoZ3JvdXA9PW51bGwpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJObyBzdWNoIGdyb3VwIFtcIitncm91cElkK1wiXVwiKTt9fXJldHVybiBncm91cDt9O3RoaXMuZ2V0R3JvdXBzPWZ1bmN0aW9uKCl7dmFyIG89W107Zm9yKHZhciBnIGluIF9tYW5hZ2VkR3JvdXBzKXtvLnB1c2goX21hbmFnZWRHcm91cHNbZ10pO31yZXR1cm4gbzt9O3RoaXMucmVtb3ZlR3JvdXA9ZnVuY3Rpb24oZ3JvdXAsZGVsZXRlTWVtYmVycyxtYW5pcHVsYXRlRE9NLGRvTm90RmlyZUV2ZW50KXtncm91cD10aGlzLmdldEdyb3VwKGdyb3VwKTt0aGlzLmV4cGFuZEdyb3VwKGdyb3VwLHRydWUpOy8vIHRoaXMgcmVpbnN0YXRlcyBhbnkgb3JpZ2luYWwgY29ubmVjdGlvbnMgYW5kIHJlbW92ZXMgYWxsIHByb3hpZXMsIGJ1dCBkb2VzIG5vdCBmaXJlIGFuIGV2ZW50LlxuZ3JvdXBbZGVsZXRlTWVtYmVycz9DTURfUkVNT1ZFX0FMTDpDTURfT1JQSEFOX0FMTF0obWFuaXB1bGF0ZURPTSxkb05vdEZpcmVFdmVudCk7X2pzUGx1bWIucmVtb3ZlKGdyb3VwLmdldEVsKCkpO2RlbGV0ZSBfbWFuYWdlZEdyb3Vwc1tncm91cC5pZF07ZGVsZXRlIF9qc1BsdW1iLl9ncm91cHNbZ3JvdXAuaWRdO19qc1BsdW1iLmZpcmUoRVZUX0dST1VQX1JFTU9WRUQse2dyb3VwOmdyb3VwfSk7fTt0aGlzLnJlbW92ZUFsbEdyb3Vwcz1mdW5jdGlvbihkZWxldGVNZW1iZXJzLG1hbmlwdWxhdGVET00sZG9Ob3RGaXJlRXZlbnQpe2Zvcih2YXIgZyBpbiBfbWFuYWdlZEdyb3Vwcyl7dGhpcy5yZW1vdmVHcm91cChfbWFuYWdlZEdyb3Vwc1tnXSxkZWxldGVNZW1iZXJzLG1hbmlwdWxhdGVET00sZG9Ob3RGaXJlRXZlbnQpO319O2Z1bmN0aW9uIF9zZXRWaXNpYmxlKGdyb3VwLHN0YXRlKXt2YXIgbT1ncm91cC5nZXRNZW1iZXJzKCk7Zm9yKHZhciBpPTA7aTxtLmxlbmd0aDtpKyspe19qc1BsdW1iW3N0YXRlP0NNRF9TSE9XOkNNRF9ISURFXShtW2ldLHRydWUpO319dmFyIF9jb2xsYXBzZUNvbm5lY3Rpb249dGhpcy5jb2xsYXBzZUNvbm5lY3Rpb249ZnVuY3Rpb24oYyxpbmRleCxncm91cCl7dmFyIHByb3h5RXAsZ3JvdXBFbD1ncm91cC5nZXRFbCgpLGdyb3VwRWxJZD1fanNQbHVtYi5nZXRJZChncm91cEVsKSxvcmlnaW5hbEVsZW1lbnRJZD1jLmVuZHBvaW50c1tpbmRleF0uZWxlbWVudElkO3ZhciBvdGhlckVsPWMuZW5kcG9pbnRzW2luZGV4PT09MD8xOjBdLmVsZW1lbnQ7aWYob3RoZXJFbFtHUk9VUF0mJiFvdGhlckVsW0dST1VQXS5zaG91bGRQcm94eSgpJiZvdGhlckVsW0dST1VQXS5jb2xsYXBzZWQpe3JldHVybjt9Yy5wcm94aWVzPWMucHJveGllc3x8W107aWYoYy5wcm94aWVzW2luZGV4XSl7cHJveHlFcD1jLnByb3hpZXNbaW5kZXhdLmVwO31lbHNle3Byb3h5RXA9X2pzUGx1bWIuYWRkRW5kcG9pbnQoZ3JvdXBFbCx7ZW5kcG9pbnQ6Z3JvdXAuZ2V0RW5kcG9pbnQoYyxpbmRleCksYW5jaG9yOmdyb3VwLmdldEFuY2hvcihjLGluZGV4KSxwYXJhbWV0ZXJzOntpc1Byb3h5RW5kcG9pbnQ6dHJ1ZX19KTt9cHJveHlFcC5zZXREZWxldGVPbkVtcHR5KHRydWUpOy8vIGZvciB0aGlzIGluZGV4LCBzdGFzaCBwcm94eSBpbmZvOiB0aGUgbmV3IEVQLCB0aGUgb3JpZ2luYWwgRVAuXG5jLnByb3hpZXNbaW5kZXhdPXtlcDpwcm94eUVwLG9yaWdpbmFsRXA6Yy5lbmRwb2ludHNbaW5kZXhdfTsvLyBhbmQgYWR2aXNlIHRoZSBhbmNob3IgbWFuYWdlclxuaWYoaW5kZXg9PT0wKXsvLyBUT0RPIHdoeSBhcmUgdGhlcmUgdHdvIGRpZmZlcmVudGx5IG5hbWVkIG1ldGhvZHM/IFdoeSBpcyB0aGVyZSBub3Qgb25lIG1ldGhvZCB0aGF0IHNheXMgXCJzb21lIGVuZCBvZiB0aGlzXG4vLyBjb25uZWN0aW9uIGNoYW5nZWQgKHlvdSBnaXZlIHRoZSBpbmRleCksIGFuZCBoZXJlJ3MgdGhlIG5ldyBlbGVtZW50IGFuZCBlbGVtZW50IGlkLlwiXG5fanNQbHVtYi5hbmNob3JNYW5hZ2VyLnNvdXJjZUNoYW5nZWQob3JpZ2luYWxFbGVtZW50SWQsZ3JvdXBFbElkLGMsZ3JvdXBFbCk7fWVsc2V7X2pzUGx1bWIuYW5jaG9yTWFuYWdlci51cGRhdGVPdGhlckVuZHBvaW50KGMuZW5kcG9pbnRzWzBdLmVsZW1lbnRJZCxvcmlnaW5hbEVsZW1lbnRJZCxncm91cEVsSWQsYyk7Yy50YXJnZXQ9Z3JvdXBFbDtjLnRhcmdldElkPWdyb3VwRWxJZDt9Ly8gZGV0YWNoIHRoZSBvcmlnaW5hbCBFUCBmcm9tIHRoZSBjb25uZWN0aW9uLlxuYy5wcm94aWVzW2luZGV4XS5vcmlnaW5hbEVwLmRldGFjaEZyb21Db25uZWN0aW9uKGMsbnVsbCx0cnVlKTsvLyBzZXQgdGhlIHByb3h5IGFzIHRoZSBuZXcgZXBcbnByb3h5RXAuY29ubmVjdGlvbnM9W2NdO2MuZW5kcG9pbnRzW2luZGV4XT1wcm94eUVwO2Muc2V0VmlzaWJsZSh0cnVlKTt9O3RoaXMuY29sbGFwc2VHcm91cD1mdW5jdGlvbihncm91cCl7Z3JvdXA9dGhpcy5nZXRHcm91cChncm91cCk7aWYoZ3JvdXA9PW51bGx8fGdyb3VwLmNvbGxhcHNlZCl7cmV0dXJuO312YXIgZ3JvdXBFbD1ncm91cC5nZXRFbCgpOy8vIHRvZG8gcmVtb3ZlIG9sZCBwcm94eSBlbmRwb2ludHMgZmlyc3QsIGp1c3QgaW4gY2FzZT9cbi8vZ3JvdXAucHJveGllcy5sZW5ndGggPSAwO1xuLy8gaGlkZSBhbGwgY29ubmVjdGlvbnNcbl9zZXRWaXNpYmxlKGdyb3VwLGZhbHNlKTtpZihncm91cC5zaG91bGRQcm94eSgpKXsvLyBjb2xsYXBzZXMgYWxsIGNvbm5lY3Rpb25zIGluIGEgZ3JvdXAuXG52YXIgX2NvbGxhcHNlU2V0PWZ1bmN0aW9uIF9jb2xsYXBzZVNldChjb25ucyxpbmRleCl7Zm9yKHZhciBpPTA7aTxjb25ucy5sZW5ndGg7aSsrKXt2YXIgYz1jb25uc1tpXTtfY29sbGFwc2VDb25uZWN0aW9uKGMsaW5kZXgsZ3JvdXApO319Oy8vIHNldHVwIHByb3hpZXMgZm9yIHNvdXJjZXMgYW5kIHRhcmdldHNcbl9jb2xsYXBzZVNldChncm91cC5jb25uZWN0aW9ucy5zb3VyY2UsMCk7X2NvbGxhcHNlU2V0KGdyb3VwLmNvbm5lY3Rpb25zLnRhcmdldCwxKTt9Z3JvdXAuY29sbGFwc2VkPXRydWU7X2pzUGx1bWIucmVtb3ZlQ2xhc3MoZ3JvdXBFbCxHUk9VUF9FWFBBTkRFRF9DTEFTUyk7X2pzUGx1bWIuYWRkQ2xhc3MoZ3JvdXBFbCxHUk9VUF9DT0xMQVBTRURfQ0xBU1MpO19qc1BsdW1iLnJldmFsaWRhdGUoZ3JvdXBFbCk7X2pzUGx1bWIuZmlyZShFVlRfQ09MTEFQU0Use2dyb3VwOmdyb3VwfSk7fTt2YXIgX2V4cGFuZENvbm5lY3Rpb249dGhpcy5leHBhbmRDb25uZWN0aW9uPWZ1bmN0aW9uKGMsaW5kZXgsZ3JvdXApey8vIGlmIG5vIHByb3hpZXMgb3Igbm9uZSBmb3IgdGhpcyBlbmQgb2YgdGhlIGNvbm5lY3Rpb24sIGFib3J0LlxuaWYoYy5wcm94aWVzPT1udWxsfHxjLnByb3hpZXNbaW5kZXhdPT1udWxsKXtyZXR1cm47fXZhciBncm91cEVsSWQ9X2pzUGx1bWIuZ2V0SWQoZ3JvdXAuZ2V0RWwoKSksb3JpZ2luYWxFbGVtZW50PWMucHJveGllc1tpbmRleF0ub3JpZ2luYWxFcC5lbGVtZW50LG9yaWdpbmFsRWxlbWVudElkPWMucHJveGllc1tpbmRleF0ub3JpZ2luYWxFcC5lbGVtZW50SWQ7Yy5lbmRwb2ludHNbaW5kZXhdPWMucHJveGllc1tpbmRleF0ub3JpZ2luYWxFcDsvLyBhbmQgYWR2aXNlIHRoZSBhbmNob3IgbWFuYWdlclxuaWYoaW5kZXg9PT0wKXsvLyBUT0RPIHdoeSBhcmUgdGhlcmUgdHdvIGRpZmZlcmVudGx5IG5hbWVkIG1ldGhvZHM/IFdoeSBpcyB0aGVyZSBub3Qgb25lIG1ldGhvZCB0aGF0IHNheXMgXCJzb21lIGVuZCBvZiB0aGlzXG4vLyBjb25uZWN0aW9uIGNoYW5nZWQgKHlvdSBnaXZlIHRoZSBpbmRleCksIGFuZCBoZXJlJ3MgdGhlIG5ldyBlbGVtZW50IGFuZCBlbGVtZW50IGlkLlwiXG5fanNQbHVtYi5hbmNob3JNYW5hZ2VyLnNvdXJjZUNoYW5nZWQoZ3JvdXBFbElkLG9yaWdpbmFsRWxlbWVudElkLGMsb3JpZ2luYWxFbGVtZW50KTt9ZWxzZXtfanNQbHVtYi5hbmNob3JNYW5hZ2VyLnVwZGF0ZU90aGVyRW5kcG9pbnQoYy5lbmRwb2ludHNbMF0uZWxlbWVudElkLGdyb3VwRWxJZCxvcmlnaW5hbEVsZW1lbnRJZCxjKTtjLnRhcmdldD1vcmlnaW5hbEVsZW1lbnQ7Yy50YXJnZXRJZD1vcmlnaW5hbEVsZW1lbnRJZDt9Ly8gZGV0YWNoIHRoZSBwcm94eSBFUCBmcm9tIHRoZSBjb25uZWN0aW9uICh3aGljaCB3aWxsIGNhdXNlIGl0IHRvIGJlIHJlbW92ZWQgYXMgd2Ugbm8gbG9uZ2VyIG5lZWQgaXQpXG5jLnByb3hpZXNbaW5kZXhdLmVwLmRldGFjaEZyb21Db25uZWN0aW9uKGMsbnVsbCk7Yy5wcm94aWVzW2luZGV4XS5vcmlnaW5hbEVwLmFkZENvbm5lY3Rpb24oYyk7Ly8gY2xlYW51cFxuZGVsZXRlIGMucHJveGllc1tpbmRleF07fTt0aGlzLmV4cGFuZEdyb3VwPWZ1bmN0aW9uKGdyb3VwLGRvTm90RmlyZUV2ZW50KXtncm91cD10aGlzLmdldEdyb3VwKGdyb3VwKTtpZihncm91cD09bnVsbHx8IWdyb3VwLmNvbGxhcHNlZCl7cmV0dXJuO312YXIgZ3JvdXBFbD1ncm91cC5nZXRFbCgpO19zZXRWaXNpYmxlKGdyb3VwLHRydWUpO2lmKGdyb3VwLnNob3VsZFByb3h5KCkpey8vIGNvbGxhcHNlcyBhbGwgY29ubmVjdGlvbnMgaW4gYSBncm91cC5cbnZhciBfZXhwYW5kU2V0PWZ1bmN0aW9uIF9leHBhbmRTZXQoY29ubnMsaW5kZXgpe2Zvcih2YXIgaT0wO2k8Y29ubnMubGVuZ3RoO2krKyl7dmFyIGM9Y29ubnNbaV07X2V4cGFuZENvbm5lY3Rpb24oYyxpbmRleCxncm91cCk7fX07Ly8gc2V0dXAgcHJveGllcyBmb3Igc291cmNlcyBhbmQgdGFyZ2V0c1xuX2V4cGFuZFNldChncm91cC5jb25uZWN0aW9ucy5zb3VyY2UsMCk7X2V4cGFuZFNldChncm91cC5jb25uZWN0aW9ucy50YXJnZXQsMSk7fWdyb3VwLmNvbGxhcHNlZD1mYWxzZTtfanNQbHVtYi5hZGRDbGFzcyhncm91cEVsLEdST1VQX0VYUEFOREVEX0NMQVNTKTtfanNQbHVtYi5yZW1vdmVDbGFzcyhncm91cEVsLEdST1VQX0NPTExBUFNFRF9DTEFTUyk7X2pzUGx1bWIucmV2YWxpZGF0ZShncm91cEVsKTt0aGlzLnJlcGFpbnRHcm91cChncm91cCk7aWYoIWRvTm90RmlyZUV2ZW50KXtfanNQbHVtYi5maXJlKEVWVF9FWFBBTkQse2dyb3VwOmdyb3VwfSk7fX07dGhpcy5yZXBhaW50R3JvdXA9ZnVuY3Rpb24oZ3JvdXApe2dyb3VwPXRoaXMuZ2V0R3JvdXAoZ3JvdXApO3ZhciBtPWdyb3VwLmdldE1lbWJlcnMoKTtmb3IodmFyIGk9MDtpPG0ubGVuZ3RoO2krKyl7X2pzUGx1bWIucmV2YWxpZGF0ZShtW2ldKTt9fTsvLyBUT0RPIHJlZmFjdG9yIHRoaXMgd2l0aCB0aGUgY29kZSB0aGF0IHJlc3BvbmRzIHRvIGBjb25uZWN0aW9uYCBldmVudHMuXG5mdW5jdGlvbiBfdXBkYXRlQ29ubmVjdGlvbnNGb3JHcm91cChncm91cCl7dmFyIG1lbWJlcnM9Z3JvdXAuZ2V0TWVtYmVycygpO3ZhciBjMT1fanNQbHVtYi5nZXRDb25uZWN0aW9ucyh7c291cmNlOm1lbWJlcnMsc2NvcGU6XCIqXCJ9LHRydWUpO3ZhciBjMj1fanNQbHVtYi5nZXRDb25uZWN0aW9ucyh7dGFyZ2V0Om1lbWJlcnMsc2NvcGU6XCIqXCJ9LHRydWUpO3ZhciBwcm9jZXNzZWQ9e307Z3JvdXAuY29ubmVjdGlvbnMuc291cmNlLmxlbmd0aD0wO2dyb3VwLmNvbm5lY3Rpb25zLnRhcmdldC5sZW5ndGg9MDt2YXIgb25lU2V0PWZ1bmN0aW9uIG9uZVNldChjKXtmb3IodmFyIGk9MDtpPGMubGVuZ3RoO2krKyl7aWYocHJvY2Vzc2VkW2NbaV0uaWRdKXtjb250aW51ZTt9cHJvY2Vzc2VkW2NbaV0uaWRdPXRydWU7aWYoY1tpXS5zb3VyY2UuX2pzUGx1bWJHcm91cD09PWdyb3VwKXtpZihjW2ldLnRhcmdldC5fanNQbHVtYkdyb3VwIT09Z3JvdXApe2dyb3VwLmNvbm5lY3Rpb25zLnNvdXJjZS5wdXNoKGNbaV0pO31fY29ubmVjdGlvblNvdXJjZU1hcFtjW2ldLmlkXT1ncm91cDt9ZWxzZSBpZihjW2ldLnRhcmdldC5fanNQbHVtYkdyb3VwPT09Z3JvdXApe2dyb3VwLmNvbm5lY3Rpb25zLnRhcmdldC5wdXNoKGNbaV0pO19jb25uZWN0aW9uVGFyZ2V0TWFwW2NbaV0uaWRdPWdyb3VwO319fTtvbmVTZXQoYzEpO29uZVNldChjMik7fXRoaXMudXBkYXRlQ29ubmVjdGlvbnNGb3JHcm91cD1fdXBkYXRlQ29ubmVjdGlvbnNGb3JHcm91cDt0aGlzLnJlZnJlc2hBbGxHcm91cHM9ZnVuY3Rpb24oKXtmb3IodmFyIGcgaW4gX21hbmFnZWRHcm91cHMpe191cGRhdGVDb25uZWN0aW9uc0Zvckdyb3VwKF9tYW5hZ2VkR3JvdXBzW2ddKTtfanNQbHVtYi5kcmFnTWFuYWdlci51cGRhdGVPZmZzZXRzKF9qc1BsdW1iLmdldElkKF9tYW5hZ2VkR3JvdXBzW2ddLmdldEVsKCkpKTt9fTt9Oy8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7anNQbHVtYkluc3RhbmNlfSBfanNQbHVtYiBBc3NvY2lhdGVkIGpzUGx1bWIgaW5zdGFuY2UuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmFtcy5lbCBUaGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBHcm91cC5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLmlkXSBPcHRpb25hbCBJRCBmb3IgdGhlIEdyb3VwLiBBIFVVSUQgd2lsbCBiZSBhc3NpZ25lZCBhcyB0aGUgR3JvdXAncyBJRCBpZiB5b3UgZG8gbm90IHByb3ZpZGUgb25lLlxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLmNvbnN0cmFpbj1mYWxzZV0gSWYgdHJ1ZSwgY2hpbGQgZWxlbWVudHMgd2lsbCBub3QgYmUgYWJsZSB0byBiZSBkcmFnZ2VkIG91dHNpZGUgb2YgdGhlIEdyb3VwIGNvbnRhaW5lci5cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtcy5yZXZlcnQ9dHJ1ZV0gQnkgZGVmYXVsdCwgY2hpbGQgZWxlbWVudHMgcmV2ZXJ0IHRvIHRoZSBjb250YWluZXIgaWYgZHJhZ2dlZCBvdXRzaWRlLiBZb3UgY2FuIGNoYW5nZSB0aGlzIGJ5IHNldHRpbmcgYHJldmVydDpmYWxzZWAuIFRoaXMgYmVoYXZpb3VyIGlzIGFsc28gb3ZlcnJpZGRlbiBpZiB5b3Ugc2V0IGBvcnBoYW5gIG9yIGBwcnVuZWAuXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbXMub3JwaGFuPWZhbHNlXSBJZiB0cnVlLCBjaGlsZCBlbGVtZW50cyBkcm9wcGVkIG91dHNpZGUgb2YgdGhlIEdyb3VwIGNvbnRhaW5lciB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgR3JvdXAgKGJ1dCBub3QgZnJvbSB0aGUgRE9NKS5cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtcy5wcnVuZT1mYWxzZV0gSWYgdHJ1ZSwgY2hpbGQgZWxlbWVudHMgZHJvcHBlZCBvdXRzaWRlIG9mIHRoZSBHcm91cCBjb250YWluZXIgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEdyb3VwIGFuZCBhbHNvIGZyb20gdGhlIERPTS5cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtcy5kcm9wT3ZlcnJpZGU9ZmFsc2VdIElmIHRydWUsIGEgY2hpbGQgZWxlbWVudCB0aGF0IGhhcyBiZWVuIGRyb3BwZWQgb250byBzb21lIG90aGVyIEdyb3VwIHdpbGwgbm90IGJlIHN1YmplY3QgdG8gdGhlIGNvbnRyb2xzIGltcG9zZWQgYnkgYHBydW5lYCwgYHJldmVydGAgb3IgYG9ycGhhbmAuXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL3ZhciBHcm91cD1mdW5jdGlvbiBHcm91cChfanNQbHVtYixwYXJhbXMpe3ZhciBzZWxmPXRoaXM7dmFyIGVsPXBhcmFtcy5lbDt0aGlzLmdldEVsPWZ1bmN0aW9uKCl7cmV0dXJuIGVsO307dGhpcy5pZD1wYXJhbXMuaWR8fF9qdS51dWlkKCk7ZWwuX2lzSnNQbHVtYkdyb3VwPXRydWU7dmFyIGdldERyYWdBcmVhPXRoaXMuZ2V0RHJhZ0FyZWE9ZnVuY3Rpb24oKXt2YXIgZGE9X2pzUGx1bWIuZ2V0U2VsZWN0b3IoZWwsR1JPVVBfQ09OVEFJTkVSX1NFTEVDVE9SKTtyZXR1cm4gZGEmJmRhLmxlbmd0aD4wP2RhWzBdOmVsO307dmFyIGdob3N0PXBhcmFtcy5naG9zdD09PXRydWU7dmFyIGNvbnN0cmFpbj1naG9zdHx8cGFyYW1zLmNvbnN0cmFpbj09PXRydWU7dmFyIHJldmVydD1wYXJhbXMucmV2ZXJ0IT09ZmFsc2U7dmFyIG9ycGhhbj1wYXJhbXMub3JwaGFuPT09dHJ1ZTt2YXIgcHJ1bmU9cGFyYW1zLnBydW5lPT09dHJ1ZTt2YXIgZHJvcE92ZXJyaWRlPXBhcmFtcy5kcm9wT3ZlcnJpZGU9PT10cnVlO3ZhciBwcm94aWVkPXBhcmFtcy5wcm94aWVkIT09ZmFsc2U7dmFyIGVsZW1lbnRzPVtdO3RoaXMuY29ubmVjdGlvbnM9e3NvdXJjZTpbXSx0YXJnZXQ6W10saW50ZXJuYWw6W119Oy8vIHRoaXMgZnVuY3Rpb24sIGFuZCBnZXRFbmRwb2ludCBiZWxvdywgYXJlIHN0dWJzIGZvciBhIGZ1dHVyZSBzZXR1cCBpbiB3aGljaCB3ZSBjYW4gY2hvb3NlIGVuZHBvaW50XG4vLyBhbmQgYW5jaG9yIGJhc2VkIHVwb24gdGhlIGNvbm5lY3Rpb24gYW5kIHRoZSBpbmRleCAoc291cmNlL3RhcmdldCkgb2YgdGhlIGVuZHBvaW50IHRvIGJlIHByb3hpZWQuXG50aGlzLmdldEFuY2hvcj1mdW5jdGlvbihjb25uLGVuZHBvaW50SW5kZXgpe3JldHVybiBwYXJhbXMuYW5jaG9yfHxcIkNvbnRpbnVvdXNcIjt9O3RoaXMuZ2V0RW5kcG9pbnQ9ZnVuY3Rpb24oY29ubixlbmRwb2ludEluZGV4KXtyZXR1cm4gcGFyYW1zLmVuZHBvaW50fHxbXCJEb3RcIix7cmFkaXVzOjEwfV07fTt0aGlzLmNvbGxhcHNlZD1mYWxzZTtpZihwYXJhbXMuZHJhZ2dhYmxlIT09ZmFsc2Upe3ZhciBvcHRzPXtzdG9wOmZ1bmN0aW9uIHN0b3AocGFyYW1zKXtfanNQbHVtYi5maXJlKEVWVF9HUk9VUF9EUkFHX1NUT1AsanNQbHVtYi5leHRlbmQocGFyYW1zLHtncm91cDpzZWxmfSkpO30sc2NvcGU6R1JPVVBfRFJBR19TQ09QRX07aWYocGFyYW1zLmRyYWdPcHRpb25zKXtyb290LmpzUGx1bWIuZXh0ZW5kKG9wdHMscGFyYW1zLmRyYWdPcHRpb25zKTt9X2pzUGx1bWIuZHJhZ2dhYmxlKHBhcmFtcy5lbCxvcHRzKTt9aWYocGFyYW1zLmRyb3BwYWJsZSE9PWZhbHNlKXtfanNQbHVtYi5kcm9wcGFibGUocGFyYW1zLmVsLHtkcm9wOmZ1bmN0aW9uIGRyb3AocCl7dmFyIGVsPXAuZHJhZy5lbDtpZihlbC5faXNKc1BsdW1iR3JvdXApe3JldHVybjt9dmFyIGN1cnJlbnRHcm91cD1lbC5fanNQbHVtYkdyb3VwO2lmKGN1cnJlbnRHcm91cCE9PXNlbGYpe2lmKGN1cnJlbnRHcm91cCE9bnVsbCl7aWYoY3VycmVudEdyb3VwLm92ZXJyaWRlRHJvcChlbCxzZWxmKSl7cmV0dXJuO319X2pzUGx1bWIuZ2V0R3JvdXBNYW5hZ2VyKCkuYWRkVG9Hcm91cChzZWxmLGVsLGZhbHNlKTt9fX0pO312YXIgX2VhY2g9ZnVuY3Rpb24gX2VhY2goX2VsLGZuKXt2YXIgZWxzPV9lbC5ub2RlVHlwZT09bnVsbD9fZWw6W19lbF07Zm9yKHZhciBpPTA7aTxlbHMubGVuZ3RoO2krKyl7Zm4oZWxzW2ldKTt9fTt0aGlzLm92ZXJyaWRlRHJvcD1mdW5jdGlvbihfZWwsdGFyZ2V0R3JvdXApe3JldHVybiBkcm9wT3ZlcnJpZGUmJihyZXZlcnR8fHBydW5lfHxvcnBoYW4pO307dGhpcy5hZGQ9ZnVuY3Rpb24oX2VsLGRvTm90RmlyZUV2ZW50KXt2YXIgZHJhZ0FyZWE9Z2V0RHJhZ0FyZWEoKTtfZWFjaChfZWwsZnVuY3Rpb24oX19lbCl7aWYoX19lbC5fanNQbHVtYkdyb3VwIT1udWxsKXtpZihfX2VsLl9qc1BsdW1iR3JvdXA9PT1zZWxmKXtyZXR1cm47fWVsc2V7X19lbC5fanNQbHVtYkdyb3VwLnJlbW92ZShfX2VsLHRydWUsZG9Ob3RGaXJlRXZlbnQsZmFsc2UpO319X19lbC5fanNQbHVtYkdyb3VwPXNlbGY7ZWxlbWVudHMucHVzaChfX2VsKTsvLyB0ZXN0IGlmIGRyYWdnYWJsZSBhbmQgYWRkIGhhbmRsZXJzIGlmIHNvLlxuaWYoX2pzUGx1bWIuaXNBbHJlYWR5RHJhZ2dhYmxlKF9fZWwpKXtfYmluZERyYWdIYW5kbGVycyhfX2VsKTt9aWYoX19lbC5wYXJlbnROb2RlIT09ZHJhZ0FyZWEpe2RyYWdBcmVhLmFwcGVuZENoaWxkKF9fZWwpO31pZighZG9Ob3RGaXJlRXZlbnQpe19qc1BsdW1iLmZpcmUoRVZUX0NISUxEX0FEREVELHtncm91cDpzZWxmLGVsOl9fZWx9KTt9fSk7X2pzUGx1bWIuZ2V0R3JvdXBNYW5hZ2VyKCkudXBkYXRlQ29ubmVjdGlvbnNGb3JHcm91cChzZWxmKTt9O3RoaXMucmVtb3ZlPWZ1bmN0aW9uKGVsLG1hbmlwdWxhdGVET00sZG9Ob3RGaXJlRXZlbnQsZG9Ob3RVcGRhdGVDb25uZWN0aW9ucyl7X2VhY2goZWwsZnVuY3Rpb24oX19lbCl7ZGVsZXRlIF9fZWwuX2pzUGx1bWJHcm91cDtfanUucmVtb3ZlV2l0aEZ1bmN0aW9uKGVsZW1lbnRzLGZ1bmN0aW9uKGUpe3JldHVybiBlPT09X19lbDt9KTtpZihtYW5pcHVsYXRlRE9NKXt0cnl7c2VsZi5nZXREcmFnQXJlYSgpLnJlbW92ZUNoaWxkKF9fZWwpO31jYXRjaChlKXtqc1BsdW1iVXRpbC5sb2coXCJDb3VsZCBub3QgcmVtb3ZlIGVsZW1lbnQgZnJvbSBHcm91cCBcIitlKTt9fV91bmJpbmREcmFnSGFuZGxlcnMoX19lbCk7aWYoIWRvTm90RmlyZUV2ZW50KXtfanNQbHVtYi5maXJlKEVWVF9DSElMRF9SRU1PVkVELHtncm91cDpzZWxmLGVsOl9fZWx9KTt9fSk7aWYoIWRvTm90VXBkYXRlQ29ubmVjdGlvbnMpe19qc1BsdW1iLmdldEdyb3VwTWFuYWdlcigpLnVwZGF0ZUNvbm5lY3Rpb25zRm9yR3JvdXAoc2VsZik7fX07dGhpcy5yZW1vdmVBbGw9ZnVuY3Rpb24obWFuaXB1bGF0ZURPTSxkb05vdEZpcmVFdmVudCl7Zm9yKHZhciBpPTAsbD1lbGVtZW50cy5sZW5ndGg7aTxsO2krKyl7c2VsZi5yZW1vdmUoZWxlbWVudHNbMF0sbWFuaXB1bGF0ZURPTSxkb05vdEZpcmVFdmVudCx0cnVlKTt9ZWxlbWVudHMubGVuZ3RoPTA7X2pzUGx1bWIuZ2V0R3JvdXBNYW5hZ2VyKCkudXBkYXRlQ29ubmVjdGlvbnNGb3JHcm91cChzZWxmKTt9O3RoaXMub3JwaGFuQWxsPWZ1bmN0aW9uKCl7Zm9yKHZhciBpPTA7aTxlbGVtZW50cy5sZW5ndGg7aSsrKXtfb3JwaGFuKGVsZW1lbnRzW2ldKTt9ZWxlbWVudHMubGVuZ3RoPTA7fTt0aGlzLmdldE1lbWJlcnM9ZnVuY3Rpb24oKXtyZXR1cm4gZWxlbWVudHM7fTtlbFtHUk9VUF09dGhpcztfanNQbHVtYi5iaW5kKEVMRU1FTlRfRFJBR0dBQkxFX0VWRU5ULGZ1bmN0aW9uKGRyYWdQYXJhbXMpey8vIGlmIGl0cyBmb3IgdGhlIGN1cnJlbnQgZ3JvdXAsXG5pZihkcmFnUGFyYW1zLmVsLl9qc1BsdW1iR3JvdXA9PT10aGlzKXtfYmluZERyYWdIYW5kbGVycyhkcmFnUGFyYW1zLmVsKTt9fS5iaW5kKHRoaXMpKTtmdW5jdGlvbiBfZmluZFBhcmVudChfZWwpe3JldHVybiBfZWwub2Zmc2V0UGFyZW50O31mdW5jdGlvbiBfaXNJbnNpZGVQYXJlbnQoX2VsLHBvcyl7dmFyIHA9X2ZpbmRQYXJlbnQoX2VsKSxzPV9qc1BsdW1iLmdldFNpemUocCksc3M9X2pzUGx1bWIuZ2V0U2l6ZShfZWwpLGxlZnRFZGdlPXBvc1swXSxyaWdodEVkZ2U9bGVmdEVkZ2Urc3NbMF0sdG9wRWRnZT1wb3NbMV0sYm90dG9tRWRnZT10b3BFZGdlK3NzWzFdO3JldHVybiByaWdodEVkZ2U+MCYmbGVmdEVkZ2U8c1swXSYmYm90dG9tRWRnZT4wJiZ0b3BFZGdlPHNbMV07fS8vXG4vLyBvcnBoYW5pbmcgYW4gZWxlbWVudCBtZWFucyB0YWtpbmcgaXQgb3V0IG9mIHRoZSBncm91cCBhbmQgYWRkaW5nIGl0IHRvIHRoZSBtYWluIGpzcGx1bWIgY29udGFpbmVyLlxuLy9cbmZ1bmN0aW9uIF9vcnBoYW4oX2VsKXt2YXIgaWQ9X2pzUGx1bWIuZ2V0SWQoX2VsKTt2YXIgcG9zPV9qc1BsdW1iLmdldE9mZnNldChfZWwpO19lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKF9lbCk7X2pzUGx1bWIuZ2V0Q29udGFpbmVyKCkuYXBwZW5kQ2hpbGQoX2VsKTtfanNQbHVtYi5zZXRQb3NpdGlvbihfZWwscG9zKTtkZWxldGUgX2VsLl9qc1BsdW1iR3JvdXA7X3VuYmluZERyYWdIYW5kbGVycyhfZWwpO19qc1BsdW1iLmRyYWdNYW5hZ2VyLmNsZWFyUGFyZW50KF9lbCxpZCk7fS8vXG4vLyByZW1vdmUgYW4gZWxlbWVudCBmcm9tIHRoZSBncm91cCwgdGhlbiBlaXRoZXIgcHJ1bmUgaXQgZnJvbSB0aGUganNwbHVtYiBpbnN0YW5jZSwgb3IganVzdCBvcnBoYW4gaXQuXG4vL1xuZnVuY3Rpb24gX3BydW5lT3JPcnBoYW4ocCl7aWYoIV9pc0luc2lkZVBhcmVudChwLmVsLHAucG9zKSl7dmFyIGdyb3VwPXAuZWwuX2pzUGx1bWJHcm91cDtpZihwcnVuZSl7X2pzUGx1bWIucmVtb3ZlKHAuZWwpO31lbHNle19vcnBoYW4ocC5lbCk7fWdyb3VwLnJlbW92ZShwLmVsKTt9fS8vXG4vLyByZWRyYXdzIHRoZSBlbGVtZW50XG4vL1xuZnVuY3Rpb24gX3JldmFsaWRhdGUoX2VsKXt2YXIgaWQ9X2pzUGx1bWIuZ2V0SWQoX2VsKTtfanNQbHVtYi5yZXZhbGlkYXRlKF9lbCk7X2pzUGx1bWIuZHJhZ01hbmFnZXIucmV2YWxpZGF0ZVBhcmVudChfZWwsaWQpO30vL1xuLy8gdW5iaW5kIHRoZSBncm91cCBzcGVjaWZpYyBkcmFnL3JldmVydCBoYW5kbGVycy5cbi8vXG5mdW5jdGlvbiBfdW5iaW5kRHJhZ0hhbmRsZXJzKF9lbCl7aWYoIV9lbC5fa2F0YXZvcmlvRHJhZyl7cmV0dXJuO31pZihwcnVuZXx8b3JwaGFuKXtfZWwuX2thdGF2b3Jpb0RyYWcub2ZmKFNUT1AsX3BydW5lT3JPcnBoYW4pO31pZighcHJ1bmUmJiFvcnBoYW4mJnJldmVydCl7X2VsLl9rYXRhdm9yaW9EcmFnLm9mZihSRVZFUlQsX3JldmFsaWRhdGUpO19lbC5fa2F0YXZvcmlvRHJhZy5zZXRSZXZlcnQobnVsbCk7fX1mdW5jdGlvbiBfYmluZERyYWdIYW5kbGVycyhfZWwpe2lmKCFfZWwuX2thdGF2b3Jpb0RyYWcpe3JldHVybjt9aWYocHJ1bmV8fG9ycGhhbil7X2VsLl9rYXRhdm9yaW9EcmFnLm9uKFNUT1AsX3BydW5lT3JPcnBoYW4pO31pZihjb25zdHJhaW4pe19lbC5fa2F0YXZvcmlvRHJhZy5zZXRDb25zdHJhaW4odHJ1ZSk7fWlmKGdob3N0KXtfZWwuX2thdGF2b3Jpb0RyYWcuc2V0VXNlR2hvc3RQcm94eSh0cnVlKTt9aWYoIXBydW5lJiYhb3JwaGFuJiZyZXZlcnQpe19lbC5fa2F0YXZvcmlvRHJhZy5vbihSRVZFUlQsX3JldmFsaWRhdGUpO19lbC5fa2F0YXZvcmlvRHJhZy5zZXRSZXZlcnQoZnVuY3Rpb24oX19lbCxwb3Mpe3JldHVybiFfaXNJbnNpZGVQYXJlbnQoX19lbCxwb3MpO30pO319dGhpcy5zaG91bGRQcm94eT1mdW5jdGlvbigpe3JldHVybiBwcm94aWVkO307X2pzUGx1bWIuZ2V0R3JvdXBNYW5hZ2VyKCkuYWRkR3JvdXAodGhpcyk7fTsvKipcclxuICAgICAqIEFkZHMgYSBncm91cCB0byB0aGUganNQbHVtYiBpbnN0YW5jZS5cclxuICAgICAqIEBtZXRob2QgYWRkR3JvdXBcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcclxuICAgICAqIEByZXR1cm4ge0dyb3VwfSBUaGUgbmV3bHkgY3JlYXRlZCBHcm91cC5cclxuICAgICAqL19qcGkucHJvdG90eXBlLmFkZEdyb3VwPWZ1bmN0aW9uKHBhcmFtcyl7dmFyIGo9dGhpcztqLl9ncm91cHM9ai5fZ3JvdXBzfHx7fTtpZihqLl9ncm91cHNbcGFyYW1zLmlkXSE9bnVsbCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbm5vdCBjcmVhdGUgR3JvdXAgW1wiK3BhcmFtcy5pZCtcIl07IGEgR3JvdXAgd2l0aCB0aGF0IElEIGV4aXN0c1wiKTt9aWYocGFyYW1zLmVsW0dST1VQXSE9bnVsbCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbm5vdCBjcmVhdGUgR3JvdXAgW1wiK3BhcmFtcy5pZCtcIl07IHRoZSBnaXZlbiBlbGVtZW50IGlzIGFscmVhZHkgYSBHcm91cFwiKTt9dmFyIGdyb3VwPW5ldyBHcm91cChqLHBhcmFtcyk7ai5fZ3JvdXBzW2dyb3VwLmlkXT1ncm91cDtpZihwYXJhbXMuY29sbGFwc2VkKXt0aGlzLmNvbGxhcHNlR3JvdXAoZ3JvdXApO31yZXR1cm4gZ3JvdXA7fTsvKipcclxuICAgICAqIEFkZCBhbiBlbGVtZW50IHRvIGEgZ3JvdXAuXHJcbiAgICAgKiBAbWV0aG9kIGFkZFRvR3JvdXBcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBncm91cCBHcm91cCwgb3IgSUQgb2YgdGhlIGdyb3VwLCB0byBhZGQgdGhlIGVsZW1lbnQgdG8uXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsIEVsZW1lbnQgdG8gYWRkIHRvIHRoZSBncm91cC5cclxuICAgICAqL19qcGkucHJvdG90eXBlLmFkZFRvR3JvdXA9ZnVuY3Rpb24oZ3JvdXAsZWwsZG9Ob3RGaXJlRXZlbnQpe3ZhciBfb25lPWZ1bmN0aW9uKF9lbCl7dmFyIGlkPXRoaXMuZ2V0SWQoX2VsKTt0aGlzLm1hbmFnZShpZCxfZWwpO3RoaXMuZ2V0R3JvdXBNYW5hZ2VyKCkuYWRkVG9Hcm91cChncm91cCxfZWwsZG9Ob3RGaXJlRXZlbnQpO30uYmluZCh0aGlzKTtpZihBcnJheS5pc0FycmF5KGVsKSl7Zm9yKHZhciBpPTA7aTxlbC5sZW5ndGg7aSsrKXtfb25lKGVsW2ldKTt9fWVsc2V7X29uZShlbCk7fX07LyoqXHJcbiAgICAgKiBSZW1vdmUgYW4gZWxlbWVudCBmcm9tIGEgZ3JvdXAuXHJcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUZyb21Hcm91cFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwIEdyb3VwLCBvciBJRCBvZiB0aGUgZ3JvdXAsIHRvIHJlbW92ZSB0aGUgZWxlbWVudCBmcm9tLlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbCBFbGVtZW50IHRvIGFkZCB0byB0aGUgZ3JvdXAuXHJcbiAgICAgKi9fanBpLnByb3RvdHlwZS5yZW1vdmVGcm9tR3JvdXA9ZnVuY3Rpb24oZ3JvdXAsZWwsZG9Ob3RGaXJlRXZlbnQpe3RoaXMuZ2V0R3JvdXBNYW5hZ2VyKCkucmVtb3ZlRnJvbUdyb3VwKGdyb3VwLGVsLGRvTm90RmlyZUV2ZW50KTt9Oy8qKlxyXG4gICAgICogUmVtb3ZlIGEgZ3JvdXAsIGFuZCBvcHRpb25hbGx5IHJlbW92ZSBpdHMgbWVtYmVycyBmcm9tIHRoZSBqc1BsdW1iIGluc3RhbmNlLlxyXG4gICAgICogQG1ldGhvZCByZW1vdmVHcm91cFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd8R3JvdXB9IGdyb3VwIEdyb3VwIHRvIGRlbGV0ZSwgb3IgSUQgb2YgR3JvdXAgdG8gZGVsZXRlLlxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGVsZXRlTWVtYmVycz1mYWxzZV0gSWYgdHJ1ZSwgZ3JvdXAgbWVtYmVycyB3aWxsIGJlIHJlbW92ZWQgYWxvbmcgd2l0aCB0aGUgZ3JvdXAuIE90aGVyd2lzZSB0aGV5IHdpbGxcclxuICAgICAqIGp1c3QgYmUgJ29ycGhhbmVkJyAocmV0dXJuZWQgdG8gdGhlIG1haW4gY29udGFpbmVyKS5cclxuICAgICAqL19qcGkucHJvdG90eXBlLnJlbW92ZUdyb3VwPWZ1bmN0aW9uKGdyb3VwLGRlbGV0ZU1lbWJlcnMsbWFuaXB1bGF0ZURPTSxkb05vdEZpcmVFdmVudCl7dGhpcy5nZXRHcm91cE1hbmFnZXIoKS5yZW1vdmVHcm91cChncm91cCxkZWxldGVNZW1iZXJzLG1hbmlwdWxhdGVET00sZG9Ob3RGaXJlRXZlbnQpO307LyoqXHJcbiAgICAgKiBSZW1vdmUgYWxsIGdyb3VwcywgYW5kIG9wdGlvbmFsbHkgcmVtb3ZlIHRoZWlyIG1lbWJlcnMgZnJvbSB0aGUganNQbHVtYiBpbnN0YW5jZS5cclxuICAgICAqIEBtZXRob2QgcmVtb3ZlQWxsR3JvdXBcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RlbGV0ZU1lbWJlcnM9ZmFsc2VdIElmIHRydWUsIGdyb3VwIG1lbWJlcnMgd2lsbCBiZSByZW1vdmVkIGFsb25nIHdpdGggdGhlIGdyb3Vwcy4gT3RoZXJ3aXNlIHRoZXkgd2lsbFxyXG4gICAgICoganVzdCBiZSAnb3JwaGFuZWQnIChyZXR1cm5lZCB0byB0aGUgbWFpbiBjb250YWluZXIpLlxyXG4gICAgICovX2pwaS5wcm90b3R5cGUucmVtb3ZlQWxsR3JvdXBzPWZ1bmN0aW9uKGRlbGV0ZU1lbWJlcnMsbWFuaXB1bGF0ZURPTSxkb05vdEZpcmVFdmVudCl7dGhpcy5nZXRHcm91cE1hbmFnZXIoKS5yZW1vdmVBbGxHcm91cHMoZGVsZXRlTWVtYmVycyxtYW5pcHVsYXRlRE9NLGRvTm90RmlyZUV2ZW50KTt9Oy8qKlxyXG4gICAgICogR2V0IGEgR3JvdXBcclxuICAgICAqIEBtZXRob2QgZ2V0R3JvdXBcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBncm91cElkIElEIG9mIHRoZSBncm91cCB0byBnZXRcclxuICAgICAqIEByZXR1cm4ge0dyb3VwfSBHcm91cCB3aXRoIHRoZSBnaXZlbiBJRCwgbnVsbCBpZiBub3QgZm91bmQuXHJcbiAgICAgKi9fanBpLnByb3RvdHlwZS5nZXRHcm91cD1mdW5jdGlvbihncm91cElkKXtyZXR1cm4gdGhpcy5nZXRHcm91cE1hbmFnZXIoKS5nZXRHcm91cChncm91cElkKTt9Oy8qKlxyXG4gICAgICogR2V0cyBhbGwgdGhlIEdyb3VwcyBtYW5hZ2VkIGJ5IHRoZSBqc1BsdW1iIGluc3RhbmNlLlxyXG4gICAgICogQHJldHVybnMge0dyb3VwW119IExpc3Qgb2YgR3JvdXBzLiBFbXB0eSBpZiBub25lLlxyXG4gICAgICovX2pwaS5wcm90b3R5cGUuZ2V0R3JvdXBzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0R3JvdXBNYW5hZ2VyKCkuZ2V0R3JvdXBzKCk7fTsvKipcclxuICAgICAqIEV4cGFuZHMgYSBncm91cCBlbGVtZW50LiBqc1BsdW1iIGRvZXNuJ3QgZG8gXCJldmVyeXRoaW5nXCIgZm9yIHlvdSBoZXJlLCBiZWNhdXNlIHdoYXQgaXQgbWVhbnMgdG8gZXhwYW5kIGEgR3JvdXBcclxuICAgICAqIHdpbGwgdmFyeSBmcm9tIGFwcGxpY2F0aW9uIHRvIGFwcGxpY2F0aW9uLiBqc1BsdW1iIGRvZXMgdGhlc2UgdGhpbmdzOlxyXG4gICAgICpcclxuICAgICAqIC0gSGlkZXMgYW55IGNvbm5lY3Rpb25zIHRoYXQgYXJlIGludGVybmFsIHRvIHRoZSBncm91cCAoY29ubmVjdGlvbnMgYmV0d2VlbiBtZW1iZXJzLCBhbmQgY29ubmVjdGlvbnMgZnJvbSBtZW1iZXIgb2ZcclxuICAgICAqIHRoZSBncm91cCB0byB0aGUgZ3JvdXAgaXRzZWxmKVxyXG4gICAgICogLSBQcm94aWVzIGFsbCBjb25uZWN0aW9ucyBmb3Igd2hpY2ggdGhlIHNvdXJjZSBvciB0YXJnZXQgaXMgYSBtZW1iZXIgb2YgdGhlIGdyb3VwLlxyXG4gICAgICogLSBIaWRlcyB0aGUgcHJveGllZCBjb25uZWN0aW9ucy5cclxuICAgICAqIC0gQWRkcyB0aGUganRrLWdyb3VwLWV4cGFuZGVkIGNsYXNzIHRvIHRoZSBncm91cCdzIGVsZW1lbnRcclxuICAgICAqIC0gUmVtb3ZlcyB0aGUganRrLWdyb3VwLWNvbGxhcHNlZCBjbGFzcyBmcm9tIHRoZSBncm91cCdzIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCBleHBhbmRHcm91cFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd8R3JvdXB9IGdyb3VwIEdyb3VwIHRvIGV4cGFuZCwgb3IgSUQgb2YgR3JvdXAgdG8gZXhwYW5kLlxyXG4gICAgICovX2pwaS5wcm90b3R5cGUuZXhwYW5kR3JvdXA9ZnVuY3Rpb24oZ3JvdXApe3RoaXMuZ2V0R3JvdXBNYW5hZ2VyKCkuZXhwYW5kR3JvdXAoZ3JvdXApO307LyoqXHJcbiAgICAgKiBDb2xsYXBzZXMgYSBncm91cCBlbGVtZW50LiBqc1BsdW1iIGRvZXNuJ3QgZG8gXCJldmVyeXRoaW5nXCIgZm9yIHlvdSBoZXJlLCBiZWNhdXNlIHdoYXQgaXQgbWVhbnMgdG8gY29sbGFwc2UgYSBHcm91cFxyXG4gICAgICogd2lsbCB2YXJ5IGZyb20gYXBwbGljYXRpb24gdG8gYXBwbGljYXRpb24uIGpzUGx1bWIgZG9lcyB0aGVzZSB0aGluZ3M6XHJcbiAgICAgKlxyXG4gICAgICogLSBTaG93cyBhbnkgY29ubmVjdGlvbnMgdGhhdCBhcmUgaW50ZXJuYWwgdG8gdGhlIGdyb3VwIChjb25uZWN0aW9ucyBiZXR3ZWVuIG1lbWJlcnMsIGFuZCBjb25uZWN0aW9ucyBmcm9tIG1lbWJlciBvZlxyXG4gICAgICogdGhlIGdyb3VwIHRvIHRoZSBncm91cCBpdHNlbGYpXHJcbiAgICAgKiAtIFJlbW92ZXMgcHJveGllcyBmb3IgYWxsIGNvbm5lY3Rpb25zIGZvciB3aGljaCB0aGUgc291cmNlIG9yIHRhcmdldCBpcyBhIG1lbWJlciBvZiB0aGUgZ3JvdXAuXHJcbiAgICAgKiAtIFNob3dzIHRoZSBwcmV2aW91c2x5IHByb3hpZWQgY29ubmVjdGlvbnMuXHJcbiAgICAgKiAtIEFkZHMgdGhlIGp0ay1ncm91cC1jb2xsYXBzZWQgY2xhc3MgdG8gdGhlIGdyb3VwJ3MgZWxlbWVudFxyXG4gICAgICogLSBSZW1vdmVzIHRoZSBqdGstZ3JvdXAtZXhwYW5kZWQgY2xhc3MgZnJvbSB0aGUgZ3JvdXAncyBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgZXhwYW5kR3JvdXBcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEdyb3VwfSBncm91cCBHcm91cCB0byBleHBhbmQsIG9yIElEIG9mIEdyb3VwIHRvIGV4cGFuZC5cclxuICAgICAqL19qcGkucHJvdG90eXBlLmNvbGxhcHNlR3JvdXA9ZnVuY3Rpb24oZ3JvdXBJZCl7dGhpcy5nZXRHcm91cE1hbmFnZXIoKS5jb2xsYXBzZUdyb3VwKGdyb3VwSWQpO307X2pwaS5wcm90b3R5cGUucmVwYWludEdyb3VwPWZ1bmN0aW9uKGdyb3VwKXt0aGlzLmdldEdyb3VwTWFuYWdlcigpLnJlcGFpbnRHcm91cChncm91cCk7fTsvKipcclxuICAgICAqIENvbGxhcHNlcyBvciBleHBhbmRzIGEgZ3JvdXAgZWxlbWVudCBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuIFNlZSBub3RlcyBpbiB0aGUgY29sbGFwc2VHcm91cCBhbmQgZXhwYW5kR3JvdXAgbWV0aG9kLlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgdG9nZ2xlR3JvdXBcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEdyb3VwfSBncm91cCBHcm91cCB0byBleHBhbmQvY29sbGFwc2UsIG9yIElEIG9mIEdyb3VwIHRvIGV4cGFuZC9jb2xsYXBzZS5cclxuICAgICAqL19qcGkucHJvdG90eXBlLnRvZ2dsZUdyb3VwPWZ1bmN0aW9uKGdyb3VwKXtncm91cD10aGlzLmdldEdyb3VwTWFuYWdlcigpLmdldEdyb3VwKGdyb3VwKTtpZihncm91cCE9bnVsbCl7dGhpcy5nZXRHcm91cE1hbmFnZXIoKVtncm91cC5jb2xsYXBzZWQ/XCJleHBhbmRHcm91cFwiOlwiY29sbGFwc2VHcm91cFwiXShncm91cCk7fX07Ly9cbi8vIGxhenkgaW5pdCBhIGdyb3VwIG1hbmFnZXIgZm9yIHRoZSBnaXZlbiBqc3BsdW1iIGluc3RhbmNlLlxuLy9cbl9qcGkucHJvdG90eXBlLmdldEdyb3VwTWFuYWdlcj1mdW5jdGlvbigpe3ZhciBtZ3I9dGhpc1tHUk9VUF9NQU5BR0VSXTtpZihtZ3I9PW51bGwpe21ncj10aGlzW0dST1VQX01BTkFHRVJdPW5ldyBHcm91cE1hbmFnZXIodGhpcyk7fXJldHVybiBtZ3I7fTtfanBpLnByb3RvdHlwZS5yZW1vdmVHcm91cE1hbmFnZXI9ZnVuY3Rpb24oKXtkZWxldGUgdGhpc1tHUk9VUF9NQU5BR0VSXTt9Oy8qKlxyXG4gICAgICogR2V0cyB0aGUgR3JvdXAgdGhhdCB0aGUgZ2l2ZW4gZWxlbWVudCBiZWxvbmdzIHRvLCBudWxsIGlmIG5vbmUuXHJcbiAgICAgKiBAbWV0aG9kIGdldEdyb3VwRm9yXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fSBlbCBFbGVtZW50LCBvciBlbGVtZW50IElELlxyXG4gICAgICogQHJldHVybnMge0dyb3VwfSBBIEdyb3VwLCBpZiBmb3VuZCwgb3IgbnVsbC5cclxuICAgICAqL19qcGkucHJvdG90eXBlLmdldEdyb3VwRm9yPWZ1bmN0aW9uKGVsKXtlbD10aGlzLmdldEVsZW1lbnQoZWwpO2lmKGVsKXtyZXR1cm4gZWxbR1JPVVBdO319O30pLmNhbGwodHlwZW9mIHdpbmRvdyE9PSd1bmRlZmluZWQnP3dpbmRvdzp0aGlzKTsvKlxyXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdGhlICdmbG93Y2hhcnQnIGNvbm5lY3RvcnMsIGNvbnNpc3Rpbmcgb2YgdmVydGljYWwgYW5kIGhvcml6b250YWwgbGluZSBzZWdtZW50cy5cclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDEwIC0gMjAxOCBqc1BsdW1iIChoZWxsb0Bqc3BsdW1idG9vbGtpdC5jb20pXHJcbiAqXHJcbiAqIGh0dHBzOi8vanNwbHVtYnRvb2xraXQuY29tXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qc3BsdW1iL2pzcGx1bWJcclxuICpcclxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwyIGxpY2Vuc2VzLlxyXG4gKi87KGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHJvb3Q9dGhpcyxfanA9cm9vdC5qc1BsdW1iLF9qdT1yb290LmpzUGx1bWJVdGlsO3ZhciBTVFJBSUdIVD1cIlN0cmFpZ2h0XCI7dmFyIEFSQz1cIkFyY1wiO3ZhciBGbG93Y2hhcnQ9ZnVuY3Rpb24gRmxvd2NoYXJ0KHBhcmFtcyl7dGhpcy50eXBlPVwiRmxvd2NoYXJ0XCI7cGFyYW1zPXBhcmFtc3x8e307cGFyYW1zLnN0dWI9cGFyYW1zLnN0dWI9PW51bGw/MzA6cGFyYW1zLnN0dWI7dmFyIHNlZ21lbnRzLF9zdXBlcj1fanAuQ29ubmVjdG9ycy5BYnN0cmFjdENvbm5lY3Rvci5hcHBseSh0aGlzLGFyZ3VtZW50cyksbWlkcG9pbnQ9cGFyYW1zLm1pZHBvaW50PT1udWxsPzAuNTpwYXJhbXMubWlkcG9pbnQsYWx3YXlzUmVzcGVjdFN0dWJzPXBhcmFtcy5hbHdheXNSZXNwZWN0U3R1YnM9PT10cnVlLGxhc3R4PW51bGwsbGFzdHk9bnVsbCxsYXN0T3JpZW50YXRpb24sY29ybmVyUmFkaXVzPXBhcmFtcy5jb3JuZXJSYWRpdXMhPW51bGw/cGFyYW1zLmNvcm5lclJhZGl1czowLC8vIFRPRE8gbm93IGNvbW1vbiBiZXR3ZWVuIHRoaXMgYW5kIEFic3RyYWN0QmV6aWVyRWRpdG9yOyByZWZhY3RvciBpbnRvIHN1cGVyY2xhc3M/XG5sb29wYmFja1JhZGl1cz1wYXJhbXMubG9vcGJhY2tSYWRpdXN8fDI1LGlzTG9vcGJhY2tDdXJyZW50bHk9ZmFsc2Usc2duPWZ1bmN0aW9uIHNnbihuKXtyZXR1cm4gbjwwPy0xOm49PT0wPzA6MTt9LHNlZ21lbnREaXJlY3Rpb25zPWZ1bmN0aW9uIHNlZ21lbnREaXJlY3Rpb25zKHNlZ21lbnQpe3JldHVybltzZ24oc2VnbWVudFsyXS1zZWdtZW50WzBdKSxzZ24oc2VnbWVudFszXS1zZWdtZW50WzFdKV07fSwvKipcclxuICAgICAgICAgICAgICogaGVscGVyIG1ldGhvZCB0byBhZGQgYSBzZWdtZW50LlxyXG4gICAgICAgICAgICAgKi9hZGRTZWdtZW50PWZ1bmN0aW9uIGFkZFNlZ21lbnQoc2VnbWVudHMseCx5LHBhaW50SW5mbyl7aWYobGFzdHg9PT14JiZsYXN0eT09PXkpe3JldHVybjt9dmFyIGx4PWxhc3R4PT1udWxsP3BhaW50SW5mby5zeDpsYXN0eCxseT1sYXN0eT09bnVsbD9wYWludEluZm8uc3k6bGFzdHksbz1seD09PXg/XCJ2XCI6XCJoXCI7bGFzdHg9eDtsYXN0eT15O3NlZ21lbnRzLnB1c2goW2x4LGx5LHgseSxvXSk7fSxzZWdMZW5ndGg9ZnVuY3Rpb24gc2VnTGVuZ3RoKHMpe3JldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coc1swXS1zWzJdLDIpK01hdGgucG93KHNbMV0tc1szXSwyKSk7fSxfY2xvbmVBcnJheT1mdW5jdGlvbiBfY2xvbmVBcnJheShhKXt2YXIgX2E9W107X2EucHVzaC5hcHBseShfYSxhKTtyZXR1cm4gX2E7fSx3cml0ZVNlZ21lbnRzPWZ1bmN0aW9uIHdyaXRlU2VnbWVudHMoY29ubixzZWdtZW50cyxwYWludEluZm8pe3ZhciBjdXJyZW50PW51bGwsbmV4dCxjdXJyZW50RGlyZWN0aW9uLG5leHREaXJlY3Rpb247Zm9yKHZhciBpPTA7aTxzZWdtZW50cy5sZW5ndGgtMTtpKyspe2N1cnJlbnQ9Y3VycmVudHx8X2Nsb25lQXJyYXkoc2VnbWVudHNbaV0pO25leHQ9X2Nsb25lQXJyYXkoc2VnbWVudHNbaSsxXSk7Y3VycmVudERpcmVjdGlvbj1zZWdtZW50RGlyZWN0aW9ucyhjdXJyZW50KTtuZXh0RGlyZWN0aW9uPXNlZ21lbnREaXJlY3Rpb25zKG5leHQpO2lmKGNvcm5lclJhZGl1cz4wJiZjdXJyZW50WzRdIT09bmV4dFs0XSl7dmFyIHJhZGl1c1RvVXNlPU1hdGgubWluKGNvcm5lclJhZGl1cyxzZWdMZW5ndGgoY3VycmVudCksc2VnTGVuZ3RoKG5leHQpKTtjdXJyZW50WzJdLT1jdXJyZW50RGlyZWN0aW9uWzBdKnJhZGl1c1RvVXNlO2N1cnJlbnRbM10tPWN1cnJlbnREaXJlY3Rpb25bMV0qcmFkaXVzVG9Vc2U7bmV4dFswXSs9bmV4dERpcmVjdGlvblswXSpyYWRpdXNUb1VzZTtuZXh0WzFdKz1uZXh0RGlyZWN0aW9uWzFdKnJhZGl1c1RvVXNlO3ZhciBhYz1jdXJyZW50RGlyZWN0aW9uWzFdPT09bmV4dERpcmVjdGlvblswXSYmbmV4dERpcmVjdGlvblswXT09PTF8fGN1cnJlbnREaXJlY3Rpb25bMV09PT1uZXh0RGlyZWN0aW9uWzBdJiZuZXh0RGlyZWN0aW9uWzBdPT09MCYmY3VycmVudERpcmVjdGlvblswXSE9PW5leHREaXJlY3Rpb25bMV18fGN1cnJlbnREaXJlY3Rpb25bMV09PT1uZXh0RGlyZWN0aW9uWzBdJiZuZXh0RGlyZWN0aW9uWzBdPT09LTEsc2dueT1uZXh0WzFdPmN1cnJlbnRbM10/MTotMSxzZ254PW5leHRbMF0+Y3VycmVudFsyXT8xOi0xLHNnbkVxdWFsPXNnbnk9PT1zZ254LGN4PXNnbkVxdWFsJiZhY3x8IXNnbkVxdWFsJiYhYWM/bmV4dFswXTpjdXJyZW50WzJdLGN5PXNnbkVxdWFsJiZhY3x8IXNnbkVxdWFsJiYhYWM/Y3VycmVudFszXTpuZXh0WzFdO19zdXBlci5hZGRTZWdtZW50KGNvbm4sU1RSQUlHSFQse3gxOmN1cnJlbnRbMF0seTE6Y3VycmVudFsxXSx4MjpjdXJyZW50WzJdLHkyOmN1cnJlbnRbM119KTtfc3VwZXIuYWRkU2VnbWVudChjb25uLEFSQyx7cjpyYWRpdXNUb1VzZSx4MTpjdXJyZW50WzJdLHkxOmN1cnJlbnRbM10seDI6bmV4dFswXSx5MjpuZXh0WzFdLGN4OmN4LGN5OmN5LGFjOmFjfSk7fWVsc2V7Ly8gZHggKyBkeSBhcmUgdXNlZCB0byBhZGp1c3QgZm9yIGxpbmUgd2lkdGguXG52YXIgZHg9Y3VycmVudFsyXT09PWN1cnJlbnRbMF0/MDpjdXJyZW50WzJdPmN1cnJlbnRbMF0/cGFpbnRJbmZvLmx3LzI6LShwYWludEluZm8ubHcvMiksZHk9Y3VycmVudFszXT09PWN1cnJlbnRbMV0/MDpjdXJyZW50WzNdPmN1cnJlbnRbMV0/cGFpbnRJbmZvLmx3LzI6LShwYWludEluZm8ubHcvMik7X3N1cGVyLmFkZFNlZ21lbnQoY29ubixTVFJBSUdIVCx7eDE6Y3VycmVudFswXS1keCx5MTpjdXJyZW50WzFdLWR5LHgyOmN1cnJlbnRbMl0rZHgseTI6Y3VycmVudFszXStkeX0pO31jdXJyZW50PW5leHQ7fWlmKG5leHQhPW51bGwpey8vIGxhc3Qgc2VnbWVudFxuX3N1cGVyLmFkZFNlZ21lbnQoY29ubixTVFJBSUdIVCx7eDE6bmV4dFswXSx5MTpuZXh0WzFdLHgyOm5leHRbMl0seTI6bmV4dFszXX0pO319O3RoaXMuX2NvbXB1dGU9ZnVuY3Rpb24ocGFpbnRJbmZvLHBhcmFtcyl7c2VnbWVudHM9W107bGFzdHg9bnVsbDtsYXN0eT1udWxsO2xhc3RPcmllbnRhdGlvbj1udWxsO3ZhciBjb21tb25TdHViQ2FsY3VsYXRvcj1mdW5jdGlvbiBjb21tb25TdHViQ2FsY3VsYXRvcigpe3JldHVybltwYWludEluZm8uc3RhcnRTdHViWCxwYWludEluZm8uc3RhcnRTdHViWSxwYWludEluZm8uZW5kU3R1YlgscGFpbnRJbmZvLmVuZFN0dWJZXTt9LHN0dWJDYWxjdWxhdG9ycz17cGVycGVuZGljdWxhcjpjb21tb25TdHViQ2FsY3VsYXRvcixvcnRob2dvbmFsOmNvbW1vblN0dWJDYWxjdWxhdG9yLG9wcG9zaXRlOmZ1bmN0aW9uIG9wcG9zaXRlKGF4aXMpe3ZhciBwaT1wYWludEluZm8saWR4PWF4aXM9PT1cInhcIj8wOjEsYXJlSW5Qcm94aW1pdHk9e1wieFwiOmZ1bmN0aW9uIHgoKXtyZXR1cm4gcGkuc29baWR4XT09PTEmJihwaS5zdGFydFN0dWJYPnBpLmVuZFN0dWJYJiZwaS50eD5waS5zdGFydFN0dWJYfHxwaS5zeD5waS5lbmRTdHViWCYmcGkudHg+cGkuc3gpfHxwaS5zb1tpZHhdPT09LTEmJihwaS5zdGFydFN0dWJYPHBpLmVuZFN0dWJYJiZwaS50eDxwaS5zdGFydFN0dWJYfHxwaS5zeDxwaS5lbmRTdHViWCYmcGkudHg8cGkuc3gpO30sXCJ5XCI6ZnVuY3Rpb24geSgpe3JldHVybiBwaS5zb1tpZHhdPT09MSYmKHBpLnN0YXJ0U3R1Ylk+cGkuZW5kU3R1YlkmJnBpLnR5PnBpLnN0YXJ0U3R1Yll8fHBpLnN5PnBpLmVuZFN0dWJZJiZwaS50eT5waS5zeSl8fHBpLnNvW2lkeF09PT0tMSYmKHBpLnN0YXJ0U3R1Ylk8cGkuZW5kU3R1YlkmJnBpLnR5PHBpLnN0YXJ0U3R1Yll8fHBpLnN5PHBpLmVuZFN0dWJZJiZwaS50eTxwaS5zeSk7fX07aWYoIWFsd2F5c1Jlc3BlY3RTdHVicyYmYXJlSW5Qcm94aW1pdHlbYXhpc10oKSl7cmV0dXJue1wieFwiOlsocGFpbnRJbmZvLnN4K3BhaW50SW5mby50eCkvMixwYWludEluZm8uc3RhcnRTdHViWSwocGFpbnRJbmZvLnN4K3BhaW50SW5mby50eCkvMixwYWludEluZm8uZW5kU3R1YlldLFwieVwiOltwYWludEluZm8uc3RhcnRTdHViWCwocGFpbnRJbmZvLnN5K3BhaW50SW5mby50eSkvMixwYWludEluZm8uZW5kU3R1YlgsKHBhaW50SW5mby5zeStwYWludEluZm8udHkpLzJdfVtheGlzXTt9ZWxzZXtyZXR1cm5bcGFpbnRJbmZvLnN0YXJ0U3R1YlgscGFpbnRJbmZvLnN0YXJ0U3R1YlkscGFpbnRJbmZvLmVuZFN0dWJYLHBhaW50SW5mby5lbmRTdHViWV07fX19Oy8vIGNhbGN1bGF0ZSBTdHVicy5cbnZhciBzdHVicz1zdHViQ2FsY3VsYXRvcnNbcGFpbnRJbmZvLmFuY2hvck9yaWVudGF0aW9uXShwYWludEluZm8uc291cmNlQXhpcyksaWR4PXBhaW50SW5mby5zb3VyY2VBeGlzPT09XCJ4XCI/MDoxLG9pZHg9cGFpbnRJbmZvLnNvdXJjZUF4aXM9PT1cInhcIj8xOjAsc3M9c3R1YnNbaWR4XSxvc3M9c3R1YnNbb2lkeF0sZXM9c3R1YnNbaWR4KzJdLG9lcz1zdHVic1tvaWR4KzJdOy8vIGFkZCB0aGUgc3RhcnQgc3R1YiBzZWdtZW50LiB1c2Ugc3R1YnMgZm9yIGxvb3BiYWNrIGFzIGl0IHdpbGwgbG9vayBiZXR0ZXIsIHdpdGggdGhlIGxvb3Agc3BhY2VkXG4vLyBhd2F5IGZyb20gdGhlIGVsZW1lbnQuXG5hZGRTZWdtZW50KHNlZ21lbnRzLHN0dWJzWzBdLHN0dWJzWzFdLHBhaW50SW5mbyk7Ly8gaWYgaXRzIGEgbG9vcGJhY2sgYW5kIHdlIHNob3VsZCB0cmVhdCBpdCBkaWZmZXJlbnRseS5cbi8vIGlmIChmYWxzZSAmJiBwYXJhbXMuc291cmNlUG9zWzBdID09PSBwYXJhbXMudGFyZ2V0UG9zWzBdICYmIHBhcmFtcy5zb3VyY2VQb3NbMV0gPT09IHBhcmFtcy50YXJnZXRQb3NbMV0pIHtcbi8vXG4vLyAgICAgLy8gd2UgdXNlIGxvb3BiYWNrUmFkaXVzIGhlcmUsIGFzIHN0YXRlbWFjaGluZSBjb25uZWN0b3JzIGRvLlxuLy8gICAgIC8vIHNvIHdlIGdvIHJhZGl1cyB0byB0aGUgbGVmdCBmcm9tIHN0dWJzWzBdLCB0aGVuIHVwd2FyZHMgYnkgMipyYWRpdXMsIHRvIHRoZSByaWdodCBieSAyKnJhZGl1cyxcbi8vICAgICAvLyBkb3duIGJ5IDIqcmFkaXVzLCBsZWZ0IGJ5IHJhZGl1cy5cbi8vICAgICBhZGRTZWdtZW50KHNlZ21lbnRzLCBzdHVic1swXSAtIGxvb3BiYWNrUmFkaXVzLCBzdHVic1sxXSwgcGFpbnRJbmZvKTtcbi8vICAgICBhZGRTZWdtZW50KHNlZ21lbnRzLCBzdHVic1swXSAtIGxvb3BiYWNrUmFkaXVzLCBzdHVic1sxXSAtICgyICogbG9vcGJhY2tSYWRpdXMpLCBwYWludEluZm8pO1xuLy8gICAgIGFkZFNlZ21lbnQoc2VnbWVudHMsIHN0dWJzWzBdICsgbG9vcGJhY2tSYWRpdXMsIHN0dWJzWzFdIC0gKDIgKiBsb29wYmFja1JhZGl1cyksIHBhaW50SW5mbyk7XG4vLyAgICAgYWRkU2VnbWVudChzZWdtZW50cywgc3R1YnNbMF0gKyBsb29wYmFja1JhZGl1cywgc3R1YnNbMV0sIHBhaW50SW5mbyk7XG4vLyAgICAgYWRkU2VnbWVudChzZWdtZW50cywgc3R1YnNbMF0sIHN0dWJzWzFdLCBwYWludEluZm8pO1xuLy9cbi8vIH1cbi8vIGVsc2Uge1xudmFyIG1pZHg9cGFpbnRJbmZvLnN0YXJ0U3R1YlgrKHBhaW50SW5mby5lbmRTdHViWC1wYWludEluZm8uc3RhcnRTdHViWCkqbWlkcG9pbnQsbWlkeT1wYWludEluZm8uc3RhcnRTdHViWSsocGFpbnRJbmZvLmVuZFN0dWJZLXBhaW50SW5mby5zdGFydFN0dWJZKSptaWRwb2ludDt2YXIgb3JpZW50YXRpb25zPXt4OlswLDFdLHk6WzEsMF19LGxpbmVDYWxjdWxhdG9ycz17cGVycGVuZGljdWxhcjpmdW5jdGlvbiBwZXJwZW5kaWN1bGFyKGF4aXMpe3ZhciBwaT1wYWludEluZm8sc2lzPXt4OltbWzEsMiwzLDRdLG51bGwsWzIsMSw0LDNdXSxudWxsLFtbNCwzLDIsMV0sbnVsbCxbMyw0LDEsMl1dXSx5OltbWzMsMiwxLDRdLG51bGwsWzIsMyw0LDFdXSxudWxsLFtbNCwxLDIsM10sbnVsbCxbMSw0LDMsMl1dXX0sc3R1YnM9e3g6W1twaS5zdGFydFN0dWJYLHBpLmVuZFN0dWJYXSxudWxsLFtwaS5lbmRTdHViWCxwaS5zdGFydFN0dWJYXV0seTpbW3BpLnN0YXJ0U3R1YlkscGkuZW5kU3R1YlldLG51bGwsW3BpLmVuZFN0dWJZLHBpLnN0YXJ0U3R1YlldXX0sbWlkTGluZXM9e3g6W1ttaWR4LHBpLnN0YXJ0U3R1YlldLFttaWR4LHBpLmVuZFN0dWJZXV0seTpbW3BpLnN0YXJ0U3R1YlgsbWlkeV0sW3BpLmVuZFN0dWJYLG1pZHldXX0sbGluZXNUb0VuZD17eDpbW3BpLmVuZFN0dWJYLHBpLnN0YXJ0U3R1YlldXSx5OltbcGkuc3RhcnRTdHViWCxwaS5lbmRTdHViWV1dfSxzdGFydFRvRW5kPXt4OltbcGkuc3RhcnRTdHViWCxwaS5lbmRTdHViWV0sW3BpLmVuZFN0dWJYLHBpLmVuZFN0dWJZXV0seTpbW3BpLmVuZFN0dWJYLHBpLnN0YXJ0U3R1YlldLFtwaS5lbmRTdHViWCxwaS5lbmRTdHViWV1dfSxzdGFydFRvTWlkVG9FbmQ9e3g6W1twaS5zdGFydFN0dWJYLG1pZHldLFtwaS5lbmRTdHViWCxtaWR5XSxbcGkuZW5kU3R1YlgscGkuZW5kU3R1YlldXSx5OltbbWlkeCxwaS5zdGFydFN0dWJZXSxbbWlkeCxwaS5lbmRTdHViWV0sW3BpLmVuZFN0dWJYLHBpLmVuZFN0dWJZXV19LG90aGVyU3R1YnM9e3g6W3BpLnN0YXJ0U3R1YlkscGkuZW5kU3R1YlldLHk6W3BpLnN0YXJ0U3R1YlgscGkuZW5kU3R1YlhdfSxzb0lkeD1vcmllbnRhdGlvbnNbYXhpc11bMF0sdG9JZHg9b3JpZW50YXRpb25zW2F4aXNdWzFdLF9zbz1waS5zb1tzb0lkeF0rMSxfdG89cGkudG9bdG9JZHhdKzEsb3RoZXJGbGlwcGVkPXBpLnRvW3RvSWR4XT09PS0xJiZvdGhlclN0dWJzW2F4aXNdWzFdPG90aGVyU3R1YnNbYXhpc11bMF18fHBpLnRvW3RvSWR4XT09PTEmJm90aGVyU3R1YnNbYXhpc11bMV0+b3RoZXJTdHVic1theGlzXVswXSxzdHViMT1zdHVic1theGlzXVtfc29dWzBdLHN0dWIyPXN0dWJzW2F4aXNdW19zb11bMV0sc2VnbWVudEluZGV4ZXM9c2lzW2F4aXNdW19zb11bX3RvXTtpZihwaS5zZWdtZW50PT09c2VnbWVudEluZGV4ZXNbM118fHBpLnNlZ21lbnQ9PT1zZWdtZW50SW5kZXhlc1syXSYmb3RoZXJGbGlwcGVkKXtyZXR1cm4gbWlkTGluZXNbYXhpc107fWVsc2UgaWYocGkuc2VnbWVudD09PXNlZ21lbnRJbmRleGVzWzJdJiZzdHViMjxzdHViMSl7cmV0dXJuIGxpbmVzVG9FbmRbYXhpc107fWVsc2UgaWYocGkuc2VnbWVudD09PXNlZ21lbnRJbmRleGVzWzJdJiZzdHViMj49c3R1YjF8fHBpLnNlZ21lbnQ9PT1zZWdtZW50SW5kZXhlc1sxXSYmIW90aGVyRmxpcHBlZCl7cmV0dXJuIHN0YXJ0VG9NaWRUb0VuZFtheGlzXTt9ZWxzZSBpZihwaS5zZWdtZW50PT09c2VnbWVudEluZGV4ZXNbMF18fHBpLnNlZ21lbnQ9PT1zZWdtZW50SW5kZXhlc1sxXSYmb3RoZXJGbGlwcGVkKXtyZXR1cm4gc3RhcnRUb0VuZFtheGlzXTt9fSxvcnRob2dvbmFsOmZ1bmN0aW9uIG9ydGhvZ29uYWwoYXhpcyxzdGFydFN0dWIsb3RoZXJTdGFydFN0dWIsZW5kU3R1YixvdGhlckVuZFN0dWIpe3ZhciBwaT1wYWludEluZm8sZXh0ZW50PXtcInhcIjpwaS5zb1swXT09PS0xP01hdGgubWluKHN0YXJ0U3R1YixlbmRTdHViKTpNYXRoLm1heChzdGFydFN0dWIsZW5kU3R1YiksXCJ5XCI6cGkuc29bMV09PT0tMT9NYXRoLm1pbihzdGFydFN0dWIsZW5kU3R1Yik6TWF0aC5tYXgoc3RhcnRTdHViLGVuZFN0dWIpfVtheGlzXTtyZXR1cm57XCJ4XCI6W1tleHRlbnQsb3RoZXJTdGFydFN0dWJdLFtleHRlbnQsb3RoZXJFbmRTdHViXSxbZW5kU3R1YixvdGhlckVuZFN0dWJdXSxcInlcIjpbW290aGVyU3RhcnRTdHViLGV4dGVudF0sW290aGVyRW5kU3R1YixleHRlbnRdLFtvdGhlckVuZFN0dWIsZW5kU3R1Yl1dfVtheGlzXTt9LG9wcG9zaXRlOmZ1bmN0aW9uIG9wcG9zaXRlKGF4aXMsc3Msb3NzLGVzKXt2YXIgcGk9cGFpbnRJbmZvLG90aGVyQXhpcz17XCJ4XCI6XCJ5XCIsXCJ5XCI6XCJ4XCJ9W2F4aXNdLGRpbT17XCJ4XCI6XCJoZWlnaHRcIixcInlcIjpcIndpZHRoXCJ9W2F4aXNdLGNvbXBhcmF0b3I9cGlbXCJpc1wiK2F4aXMudG9VcHBlckNhc2UoKStcIkdyZWF0ZXJUaGFuU3R1YlRpbWVzMlwiXTtpZihwYXJhbXMuc291cmNlRW5kcG9pbnQuZWxlbWVudElkPT09cGFyYW1zLnRhcmdldEVuZHBvaW50LmVsZW1lbnRJZCl7dmFyIF92YWw9b3NzKygxLXBhcmFtcy5zb3VyY2VFbmRwb2ludC5hbmNob3Jbb3RoZXJBeGlzXSkqcGFyYW1zLnNvdXJjZUluZm9bZGltXStfc3VwZXIubWF4U3R1YjtyZXR1cm57XCJ4XCI6W1tzcyxfdmFsXSxbZXMsX3ZhbF1dLFwieVwiOltbX3ZhbCxzc10sW192YWwsZXNdXX1bYXhpc107fWVsc2UgaWYoIWNvbXBhcmF0b3J8fHBpLnNvW2lkeF09PT0xJiZzcz5lc3x8cGkuc29baWR4XT09PS0xJiZzczxlcyl7cmV0dXJue1wieFwiOltbc3MsbWlkeV0sW2VzLG1pZHldXSxcInlcIjpbW21pZHgsc3NdLFttaWR4LGVzXV19W2F4aXNdO31lbHNlIGlmKHBpLnNvW2lkeF09PT0xJiZzczxlc3x8cGkuc29baWR4XT09PS0xJiZzcz5lcyl7cmV0dXJue1wieFwiOltbbWlkeCxwaS5zeV0sW21pZHgscGkudHldXSxcInlcIjpbW3BpLnN4LG1pZHldLFtwaS50eCxtaWR5XV19W2F4aXNdO319fTsvLyBjb21wdXRlIHRoZSByZXN0IG9mIHRoZSBsaW5lXG52YXIgcD1saW5lQ2FsY3VsYXRvcnNbcGFpbnRJbmZvLmFuY2hvck9yaWVudGF0aW9uXShwYWludEluZm8uc291cmNlQXhpcyxzcyxvc3MsZXMsb2VzKTtpZihwKXtmb3IodmFyIGk9MDtpPHAubGVuZ3RoO2krKyl7YWRkU2VnbWVudChzZWdtZW50cyxwW2ldWzBdLHBbaV1bMV0scGFpbnRJbmZvKTt9fS8vIGxpbmUgdG8gZW5kIHN0dWJcbmFkZFNlZ21lbnQoc2VnbWVudHMsc3R1YnNbMl0sc3R1YnNbM10scGFpbnRJbmZvKTsvL31cbi8vIGVuZCBzdHViIHRvIGVuZCAoY29tbW9uKVxuYWRkU2VnbWVudChzZWdtZW50cyxwYWludEluZm8udHgscGFpbnRJbmZvLnR5LHBhaW50SW5mbyk7Ly8gd3JpdGUgb3V0IHRoZSBzZWdtZW50cy5cbndyaXRlU2VnbWVudHModGhpcyxzZWdtZW50cyxwYWludEluZm8pO307fTtfanAuQ29ubmVjdG9ycy5GbG93Y2hhcnQ9Rmxvd2NoYXJ0O19qdS5leHRlbmQoX2pwLkNvbm5lY3RvcnMuRmxvd2NoYXJ0LF9qcC5Db25uZWN0b3JzLkFic3RyYWN0Q29ubmVjdG9yKTt9KS5jYWxsKHR5cGVvZiB3aW5kb3chPT0ndW5kZWZpbmVkJz93aW5kb3c6dGhpcyk7LypcclxuICogVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSBjb2RlIGZvciB0aGUgQmV6aWVyIGNvbm5lY3RvciB0eXBlLlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgLSAyMDE4IGpzUGx1bWIgKGhlbGxvQGpzcGx1bWJ0b29sa2l0LmNvbSlcclxuICpcclxuICogaHR0cHM6Ly9qc3BsdW1idG9vbGtpdC5jb21cclxuICogaHR0cHM6Ly9naXRodWIuY29tL2pzcGx1bWIvanNwbHVtYlxyXG4gKlxyXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgYW5kIEdQTDIgbGljZW5zZXMuXHJcbiAqLzsoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgcm9vdD10aGlzLF9qcD1yb290LmpzUGx1bWIsX2p1PXJvb3QuanNQbHVtYlV0aWw7X2pwLkNvbm5lY3RvcnMuQWJzdHJhY3RCZXppZXJDb25uZWN0b3I9ZnVuY3Rpb24ocGFyYW1zKXtwYXJhbXM9cGFyYW1zfHx7fTt2YXIgc2hvd0xvb3BiYWNrPXBhcmFtcy5zaG93TG9vcGJhY2shPT1mYWxzZSxjdXJ2aW5lc3M9cGFyYW1zLmN1cnZpbmVzc3x8MTAsbWFyZ2luPXBhcmFtcy5tYXJnaW58fDUscHJveGltaXR5TGltaXQ9cGFyYW1zLnByb3hpbWl0eUxpbWl0fHw4MCxjbG9ja3dpc2U9cGFyYW1zLm9yaWVudGF0aW9uJiZwYXJhbXMub3JpZW50YXRpb249PT1cImNsb2Nrd2lzZVwiLGxvb3BiYWNrUmFkaXVzPXBhcmFtcy5sb29wYmFja1JhZGl1c3x8MjUsaXNMb29wYmFja0N1cnJlbnRseT1mYWxzZSxfc3VwZXI7dGhpcy5fY29tcHV0ZT1mdW5jdGlvbihwYWludEluZm8scCl7dmFyIHNwPXAuc291cmNlUG9zLHRwPXAudGFyZ2V0UG9zLF93PU1hdGguYWJzKHNwWzBdLXRwWzBdKSxfaD1NYXRoLmFicyhzcFsxXS10cFsxXSk7aWYoIXNob3dMb29wYmFja3x8cC5zb3VyY2VFbmRwb2ludC5lbGVtZW50SWQhPT1wLnRhcmdldEVuZHBvaW50LmVsZW1lbnRJZCl7aXNMb29wYmFja0N1cnJlbnRseT1mYWxzZTt0aGlzLl9jb21wdXRlQmV6aWVyKHBhaW50SW5mbyxwLHNwLHRwLF93LF9oKTt9ZWxzZXtpc0xvb3BiYWNrQ3VycmVudGx5PXRydWU7Ly8gYSBsb29wYmFjayBjb25uZWN0b3IuICBkcmF3IGFuIGFyYyBmcm9tIG9uZSBhbmNob3IgdG8gdGhlIG90aGVyLlxudmFyIHgxPXAuc291cmNlUG9zWzBdLHkxPXAuc291cmNlUG9zWzFdLW1hcmdpbixjeD14MSxjeT15MS1sb29wYmFja1JhZGl1cywvLyBjYW52YXMgc2l6aW5nIHN0dWZmLCB0byBlbnN1cmUgdGhlIHdob2xlIHBhaW50ZWQgYXJlYSBpcyB2aXNpYmxlLlxuX3g9Y3gtbG9vcGJhY2tSYWRpdXMsX3k9Y3ktbG9vcGJhY2tSYWRpdXM7X3c9Mipsb29wYmFja1JhZGl1cztfaD0yKmxvb3BiYWNrUmFkaXVzO3BhaW50SW5mby5wb2ludHNbMF09X3g7cGFpbnRJbmZvLnBvaW50c1sxXT1feTtwYWludEluZm8ucG9pbnRzWzJdPV93O3BhaW50SW5mby5wb2ludHNbM109X2g7Ly8gQUREIEFOIEFSQyBTRUdNRU5ULlxuX3N1cGVyLmFkZFNlZ21lbnQodGhpcyxcIkFyY1wiLHtsb29wYmFjazp0cnVlLHgxOngxLV94KzQseTE6eTEtX3ksc3RhcnRBbmdsZTowLGVuZEFuZ2xlOjIqTWF0aC5QSSxyOmxvb3BiYWNrUmFkaXVzLGFjOiFjbG9ja3dpc2UseDI6eDEtX3gtNCx5Mjp5MS1feSxjeDpjeC1feCxjeTpjeS1feX0pO319O19zdXBlcj1fanAuQ29ubmVjdG9ycy5BYnN0cmFjdENvbm5lY3Rvci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIF9zdXBlcjt9O19qdS5leHRlbmQoX2pwLkNvbm5lY3RvcnMuQWJzdHJhY3RCZXppZXJDb25uZWN0b3IsX2pwLkNvbm5lY3RvcnMuQWJzdHJhY3RDb25uZWN0b3IpO3ZhciBCZXppZXI9ZnVuY3Rpb24gQmV6aWVyKHBhcmFtcyl7cGFyYW1zPXBhcmFtc3x8e307dGhpcy50eXBlPVwiQmV6aWVyXCI7dmFyIF9zdXBlcj1fanAuQ29ubmVjdG9ycy5BYnN0cmFjdEJlemllckNvbm5lY3Rvci5hcHBseSh0aGlzLGFyZ3VtZW50cyksbWFqb3JBbmNob3I9cGFyYW1zLmN1cnZpbmVzc3x8MTUwLG1pbm9yQW5jaG9yPTEwO3RoaXMuZ2V0Q3VydmluZXNzPWZ1bmN0aW9uKCl7cmV0dXJuIG1ham9yQW5jaG9yO307dGhpcy5fZmluZENvbnRyb2xQb2ludD1mdW5jdGlvbihwb2ludCxzb3VyY2VBbmNob3JQb3NpdGlvbix0YXJnZXRBbmNob3JQb3NpdGlvbixzb3VyY2VFbmRwb2ludCx0YXJnZXRFbmRwb2ludCxzb28sdG9vKXsvLyBkZXRlcm1pbmUgaWYgdGhlIHR3byBhbmNob3JzIGFyZSBwZXJwZW5kaWN1bGFyIHRvIGVhY2ggb3RoZXIgaW4gdGhlaXIgb3JpZW50YXRpb24uICB3ZSBzd2FwIHRoZSBjb250cm9sXG4vLyBwb2ludHMgYXJvdW5kIGlmIHNvIChjb2RlIGNvdWxkIGJlIHRpZ2h0ZW5lZCB1cClcbnZhciBwZXJwZW5kaWN1bGFyPXNvb1swXSE9PXRvb1swXXx8c29vWzFdPT09dG9vWzFdLHA9W107aWYoIXBlcnBlbmRpY3VsYXIpe2lmKHNvb1swXT09PTApe3AucHVzaChzb3VyY2VBbmNob3JQb3NpdGlvblswXTx0YXJnZXRBbmNob3JQb3NpdGlvblswXT9wb2ludFswXSttaW5vckFuY2hvcjpwb2ludFswXS1taW5vckFuY2hvcik7fWVsc2V7cC5wdXNoKHBvaW50WzBdLW1ham9yQW5jaG9yKnNvb1swXSk7fWlmKHNvb1sxXT09PTApe3AucHVzaChzb3VyY2VBbmNob3JQb3NpdGlvblsxXTx0YXJnZXRBbmNob3JQb3NpdGlvblsxXT9wb2ludFsxXSttaW5vckFuY2hvcjpwb2ludFsxXS1taW5vckFuY2hvcik7fWVsc2V7cC5wdXNoKHBvaW50WzFdK21ham9yQW5jaG9yKnRvb1sxXSk7fX1lbHNle2lmKHRvb1swXT09PTApe3AucHVzaCh0YXJnZXRBbmNob3JQb3NpdGlvblswXTxzb3VyY2VBbmNob3JQb3NpdGlvblswXT9wb2ludFswXSttaW5vckFuY2hvcjpwb2ludFswXS1taW5vckFuY2hvcik7fWVsc2V7cC5wdXNoKHBvaW50WzBdK21ham9yQW5jaG9yKnRvb1swXSk7fWlmKHRvb1sxXT09PTApe3AucHVzaCh0YXJnZXRBbmNob3JQb3NpdGlvblsxXTxzb3VyY2VBbmNob3JQb3NpdGlvblsxXT9wb2ludFsxXSttaW5vckFuY2hvcjpwb2ludFsxXS1taW5vckFuY2hvcik7fWVsc2V7cC5wdXNoKHBvaW50WzFdK21ham9yQW5jaG9yKnNvb1sxXSk7fX1yZXR1cm4gcDt9O3RoaXMuX2NvbXB1dGVCZXppZXI9ZnVuY3Rpb24ocGFpbnRJbmZvLHAsc3AsdHAsX3csX2gpe3ZhciBfQ1AsX0NQMixfc3g9c3BbMF08dHBbMF0/X3c6MCxfc3k9c3BbMV08dHBbMV0/X2g6MCxfdHg9c3BbMF08dHBbMF0/MDpfdyxfdHk9c3BbMV08dHBbMV0/MDpfaDtfQ1A9dGhpcy5fZmluZENvbnRyb2xQb2ludChbX3N4LF9zeV0sc3AsdHAscC5zb3VyY2VFbmRwb2ludCxwLnRhcmdldEVuZHBvaW50LHBhaW50SW5mby5zbyxwYWludEluZm8udG8pO19DUDI9dGhpcy5fZmluZENvbnRyb2xQb2ludChbX3R4LF90eV0sdHAsc3AscC50YXJnZXRFbmRwb2ludCxwLnNvdXJjZUVuZHBvaW50LHBhaW50SW5mby50byxwYWludEluZm8uc28pO19zdXBlci5hZGRTZWdtZW50KHRoaXMsXCJCZXppZXJcIix7eDE6X3N4LHkxOl9zeSx4MjpfdHgseTI6X3R5LGNwMXg6X0NQWzBdLGNwMXk6X0NQWzFdLGNwMng6X0NQMlswXSxjcDJ5Ol9DUDJbMV19KTt9O307X2pwLkNvbm5lY3RvcnMuQmV6aWVyPUJlemllcjtfanUuZXh0ZW5kKEJlemllcixfanAuQ29ubmVjdG9ycy5BYnN0cmFjdEJlemllckNvbm5lY3Rvcik7fSkuY2FsbCh0eXBlb2Ygd2luZG93IT09J3VuZGVmaW5lZCc/d2luZG93OnRoaXMpOy8qXHJcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUgc3RhdGUgbWFjaGluZSBjb25uZWN0b3JzLCB3aGljaCBleHRlbmQgQWJzdHJhY3RCZXppZXJDb25uZWN0b3IuXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMCAtIDIwMTgganNQbHVtYiAoaGVsbG9AanNwbHVtYnRvb2xraXQuY29tKVxyXG4gKlxyXG4gKiBodHRwczovL2pzcGx1bWJ0b29sa2l0LmNvbVxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vanNwbHVtYi9qc3BsdW1iXHJcbiAqIFxyXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgYW5kIEdQTDIgbGljZW5zZXMuXHJcbiAqLzsoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgcm9vdD10aGlzLF9qcD1yb290LmpzUGx1bWIsX2p1PXJvb3QuanNQbHVtYlV0aWw7dmFyIF9zZWdtZW50PWZ1bmN0aW9uIF9zZWdtZW50KHgxLHkxLHgyLHkyKXtpZih4MTw9eDImJnkyPD15MSl7cmV0dXJuIDE7fWVsc2UgaWYoeDE8PXgyJiZ5MTw9eTIpe3JldHVybiAyO31lbHNlIGlmKHgyPD14MSYmeTI+PXkxKXtyZXR1cm4gMzt9cmV0dXJuIDQ7fSwvLyB0aGUgY29udHJvbCBwb2ludCB3ZSB3aWxsIHVzZSBkZXBlbmRzIG9uIHRoZSBmYWNlcyB0byB3aGljaCBlYWNoIGVuZCBvZiB0aGUgY29ubmVjdGlvbiBpcyBhc3NpZ25lZCwgc3BlY2lmaWNhbGx5IHdoZXRoZXIgb3Igbm90IHRoZVxuLy8gdHdvIGZhY2VzIGFyZSBwYXJhbGxlbCBvciBwZXJwZW5kaWN1bGFyLiAgaWYgdGhleSBhcmUgcGFyYWxsZWwgdGhlbiB0aGUgY29udHJvbCBwb2ludCBsaWVzIG9uIHRoZSBtaWRwb2ludCBvZiB0aGUgYXhpcyBpbiB3aGljaCB0aGV5XG4vLyBhcmUgcGFyZWxsZWwgYW5kIHZhcmllcyBvbmx5IGluIHRoZSBvdGhlciBheGlzOyB0aGlzIHZhcmlhdGlvbiBpcyBwcm9wb3J0aW9uYWwgdG8gdGhlIGRpc3RhbmNlIHRoYXQgdGhlIGFuY2hvciBwb2ludHMgbGllIGZyb20gdGhlXG4vLyBjZW50ZXIgb2YgdGhhdCBmYWNlLiAgaWYgdGhlIHR3byBmYWNlcyBhcmUgcGVycGVuZGljdWxhciB0aGVuIHRoZSBjb250cm9sIHBvaW50IGlzIGF0IHNvbWUgZGlzdGFuY2UgZnJvbSBib3RoIHRoZSBtaWRwb2ludHM7IHRoZSBhbW91bnQgYW5kXG4vLyBkaXJlY3Rpb24gYXJlIGRlcGVuZGVudCBvbiB0aGUgb3JpZW50YXRpb24gb2YgdGhlIHR3byBlbGVtZW50cy4gJ3NlZycsIHBhc3NlZCBpbiB0byB0aGlzIG1ldGhvZCwgdGVsbHMgeW91IHdoaWNoIHNlZ21lbnQgdGhlIHRhcmdldCBlbGVtZW50XG4vLyBsaWVzIGluIHdpdGggcmVzcGVjdCB0byB0aGUgc291cmNlOiAxIGlzIHRvcCByaWdodCwgMiBpcyBib3R0b20gcmlnaHQsIDMgaXMgYm90dG9tIGxlZnQsIDQgaXMgdG9wIGxlZnQuXG4vL1xuLy8gc291cmNlUG9zIGFuZCB0YXJnZXRQb3MgYXJlIGFycmF5cyBvZiBpbmZvIGFib3V0IHdoZXJlIG9uIHRoZSBzb3VyY2UgYW5kIHRhcmdldCBlYWNoIGFuY2hvciBpcyBsb2NhdGVkLiAgdGhlaXIgY29udGVudHMgYXJlOlxuLy9cbi8vIDAgLSBhYnNvbHV0ZSB4XG4vLyAxIC0gYWJzb2x1dGUgeVxuLy8gMiAtIHByb3BvcnRpb25hbCB4IGluIGVsZW1lbnQgKDAgaXMgbGVmdCBlZGdlLCAxIGlzIHJpZ2h0IGVkZ2UpXG4vLyAzIC0gcHJvcG9ydGlvbmFsIHkgaW4gZWxlbWVudCAoMCBpcyB0b3AgZWRnZSwgMSBpcyBib3R0b20gZWRnZSlcbi8vXG5fZmluZENvbnRyb2xQb2ludD1mdW5jdGlvbiBfZmluZENvbnRyb2xQb2ludChtaWR4LG1pZHksc2VnbWVudCxzb3VyY2VFZGdlLHRhcmdldEVkZ2UsZHgsZHksZGlzdGFuY2UscHJveGltaXR5TGltaXQpey8vIFRPRE8gKG1heWJlKVxuLy8gLSBpZiBhbmNob3IgcG9zIGlzIDAuNSwgbWFrZSB0aGUgY29udHJvbCBwb2ludCB0YWtlIGludG8gYWNjb3VudCB0aGUgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnRzLlxuaWYoZGlzdGFuY2U8PXByb3hpbWl0eUxpbWl0KXtyZXR1cm5bbWlkeCxtaWR5XTt9aWYoc2VnbWVudD09PTEpe2lmKHNvdXJjZUVkZ2VbM108PTAmJnRhcmdldEVkZ2VbM10+PTEpe3JldHVyblttaWR4Kyhzb3VyY2VFZGdlWzJdPDAuNT8tMSpkeDpkeCksbWlkeV07fWVsc2UgaWYoc291cmNlRWRnZVsyXT49MSYmdGFyZ2V0RWRnZVsyXTw9MCl7cmV0dXJuW21pZHgsbWlkeSsoc291cmNlRWRnZVszXTwwLjU/LTEqZHk6ZHkpXTt9ZWxzZXtyZXR1cm5bbWlkeCstMSpkeCxtaWR5Ky0xKmR5XTt9fWVsc2UgaWYoc2VnbWVudD09PTIpe2lmKHNvdXJjZUVkZ2VbM10+PTEmJnRhcmdldEVkZ2VbM108PTApe3JldHVyblttaWR4Kyhzb3VyY2VFZGdlWzJdPDAuNT8tMSpkeDpkeCksbWlkeV07fWVsc2UgaWYoc291cmNlRWRnZVsyXT49MSYmdGFyZ2V0RWRnZVsyXTw9MCl7cmV0dXJuW21pZHgsbWlkeSsoc291cmNlRWRnZVszXTwwLjU/LTEqZHk6ZHkpXTt9ZWxzZXtyZXR1cm5bbWlkeCtkeCxtaWR5Ky0xKmR5XTt9fWVsc2UgaWYoc2VnbWVudD09PTMpe2lmKHNvdXJjZUVkZ2VbM10+PTEmJnRhcmdldEVkZ2VbM108PTApe3JldHVyblttaWR4Kyhzb3VyY2VFZGdlWzJdPDAuNT8tMSpkeDpkeCksbWlkeV07fWVsc2UgaWYoc291cmNlRWRnZVsyXTw9MCYmdGFyZ2V0RWRnZVsyXT49MSl7cmV0dXJuW21pZHgsbWlkeSsoc291cmNlRWRnZVszXTwwLjU/LTEqZHk6ZHkpXTt9ZWxzZXtyZXR1cm5bbWlkeCstMSpkeCxtaWR5Ky0xKmR5XTt9fWVsc2UgaWYoc2VnbWVudD09PTQpe2lmKHNvdXJjZUVkZ2VbM108PTAmJnRhcmdldEVkZ2VbM10+PTEpe3JldHVyblttaWR4Kyhzb3VyY2VFZGdlWzJdPDAuNT8tMSpkeDpkeCksbWlkeV07fWVsc2UgaWYoc291cmNlRWRnZVsyXTw9MCYmdGFyZ2V0RWRnZVsyXT49MSl7cmV0dXJuW21pZHgsbWlkeSsoc291cmNlRWRnZVszXTwwLjU/LTEqZHk6ZHkpXTt9ZWxzZXtyZXR1cm5bbWlkeCtkeCxtaWR5Ky0xKmR5XTt9fX07dmFyIFN0YXRlTWFjaGluZT1mdW5jdGlvbiBTdGF0ZU1hY2hpbmUocGFyYW1zKXtwYXJhbXM9cGFyYW1zfHx7fTt0aGlzLnR5cGU9XCJTdGF0ZU1hY2hpbmVcIjt2YXIgX3N1cGVyPV9qcC5Db25uZWN0b3JzLkFic3RyYWN0QmV6aWVyQ29ubmVjdG9yLmFwcGx5KHRoaXMsYXJndW1lbnRzKSxjdXJ2aW5lc3M9cGFyYW1zLmN1cnZpbmVzc3x8MTAsbWFyZ2luPXBhcmFtcy5tYXJnaW58fDUscHJveGltaXR5TGltaXQ9cGFyYW1zLnByb3hpbWl0eUxpbWl0fHw4MCxjbG9ja3dpc2U9cGFyYW1zLm9yaWVudGF0aW9uJiZwYXJhbXMub3JpZW50YXRpb249PT1cImNsb2Nrd2lzZVwiLF9jb250cm9sUG9pbnQ7dGhpcy5fY29tcHV0ZUJlemllcj1mdW5jdGlvbihwYWludEluZm8scGFyYW1zLHNwLHRwLHcsaCl7dmFyIF9zeD1wYXJhbXMuc291cmNlUG9zWzBdPHBhcmFtcy50YXJnZXRQb3NbMF0/MDp3LF9zeT1wYXJhbXMuc291cmNlUG9zWzFdPHBhcmFtcy50YXJnZXRQb3NbMV0/MDpoLF90eD1wYXJhbXMuc291cmNlUG9zWzBdPHBhcmFtcy50YXJnZXRQb3NbMF0/dzowLF90eT1wYXJhbXMuc291cmNlUG9zWzFdPHBhcmFtcy50YXJnZXRQb3NbMV0/aDowOy8vIG5vdyBhZGp1c3QgZm9yIHRoZSBtYXJnaW5cbmlmKHBhcmFtcy5zb3VyY2VQb3NbMl09PT0wKXtfc3gtPW1hcmdpbjt9aWYocGFyYW1zLnNvdXJjZVBvc1syXT09PTEpe19zeCs9bWFyZ2luO31pZihwYXJhbXMuc291cmNlUG9zWzNdPT09MCl7X3N5LT1tYXJnaW47fWlmKHBhcmFtcy5zb3VyY2VQb3NbM109PT0xKXtfc3krPW1hcmdpbjt9aWYocGFyYW1zLnRhcmdldFBvc1syXT09PTApe190eC09bWFyZ2luO31pZihwYXJhbXMudGFyZ2V0UG9zWzJdPT09MSl7X3R4Kz1tYXJnaW47fWlmKHBhcmFtcy50YXJnZXRQb3NbM109PT0wKXtfdHktPW1hcmdpbjt9aWYocGFyYW1zLnRhcmdldFBvc1szXT09PTEpe190eSs9bWFyZ2luO30vL1xuLy8gdGhlc2UgY29ubmVjdG9ycyBhcmUgcXVhZHJhdGljIGJlemllciBjdXJ2ZXMsIGhhdmluZyBhIHNpbmdsZSBjb250cm9sIHBvaW50LiBpZiBib3RoIGFuY2hvcnNcbi8vIGFyZSBsb2NhdGVkIGF0IDAuNSBvbiB0aGVpciByZXNwZWN0aXZlIGZhY2VzLCB0aGUgY29udHJvbCBwb2ludCBpcyBzZXQgdG8gdGhlIG1pZHBvaW50IGFuZCB5b3Vcbi8vIGdldCBhIHN0cmFpZ2h0IGxpbmUuICB0aGlzIGlzIGFsc28gdGhlIGNhc2UgaWYgdGhlIHR3byBhbmNob3JzIGFyZSB3aXRoaW4gJ3Byb3hpbWl0eUxpbWl0Jywgc2luY2Vcbi8vIGl0IHNlZW1zIHRvIG1ha2UgZ29vZCBhZXN0aGV0aWMgc2Vuc2UgdG8gZG8gdGhhdC4gb3V0c2lkZSBvZiB0aGF0LCB0aGUgY29udHJvbCBwb2ludCBpcyBwb3NpdGlvbmVkXG4vLyBhdCAnY3VydmluZXNzJyBwaXhlbHMgYXdheSBhbG9uZyB0aGUgbm9ybWFsIHRvIHRoZSBzdHJhaWdodCBsaW5lIGNvbm5lY3RpbmcgdGhlIHR3byBhbmNob3JzLlxuLy9cbi8vIHRoZXJlIG1heSBiZSB0d28gaW1wcm92ZW1lbnRzIHRvIHRoaXMuICBmaXJzdGx5LCB3ZSBtaWdodCBhY3R1YWxseSBzdXBwb3J0IHRoZSBub3Rpb24gb2YgYXZvaWRpbmcgbm9kZXNcbi8vIGluIHRoZSBVSSwgb3IgYXQgbGVhc3QgbWFraW5nIGEgZ29vZCBlZmZvcnQgYXQgZG9pbmcgc28uICBpZiBhIGNvbm5lY3Rpb24gd291bGQgcGFzcyB1bmRlcm5lYXRoIHNvbWUgbm9kZSxcbi8vIGZvciBleGFtcGxlLCB3ZSBtaWdodCBpbmNyZWFzZSB0aGUgZGlzdGFuY2UgdGhlIGNvbnRyb2wgcG9pbnQgaXMgYXdheSBmcm9tIHRoZSBtaWRwb2ludCBpbiBhIGJpZCB0b1xuLy8gc3RlZXIgaXQgYXJvdW5kIHRoYXQgbm9kZS4gIHRoaXMgd2lsbCB3b3JrIHdpdGhpbiBsaW1pdHMsIGJ1dCBpIHRoaW5rIHRob3NlIGxpbWl0cyB3b3VsZCBhbHNvIGJlIHRoZSBsaWtlbHlcbi8vIGxpbWl0cyBmb3IsIG9uY2UgYWdhaW4sIGFlc3RoZXRpYyBnb29kIHNlbnNlIGluIHRoZSBsYXlvdXQgb2YgYSBjaGFydCB1c2luZyB0aGVzZSBjb25uZWN0b3JzLlxuLy9cbi8vIHRoZSBzZWNvbmQgcG9zc2libGUgY2hhbmdlIGlzIGFjdHVhbGx5IHR3byBwb3NzaWJsZSBjaGFuZ2VzOiBmaXJzdGx5LCBpdCBpcyBwb3NzaWJsZSB3ZSBzaG91bGQgZ3JhZHVhbGx5XG4vLyBkZWNyZWFzZSB0aGUgJ2N1cnZpbmVzcycgYXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGFuY2hvcnMgZGVjcmVhc2VzOyBzdGFydCB0YWlsaW5nIGl0IG9mZiB0byAwIGF0IHNvbWVcbi8vIHBvaW50ICh3aGljaCBzaG91bGQgYmUgY29uZmlndXJhYmxlKS4gIHNlY29uZGx5LCB3ZSBtaWdodCBzbGlnaHRseSBpbmNyZWFzZSB0aGUgJ2N1cnZpbmVzcycgZm9yIGNvbm5lY3RvcnNcbi8vIHdpdGggcmVzcGVjdCB0byBob3cgZmFyIHRoZWlyIGFuY2hvciBpcyBmcm9tIHRoZSBjZW50ZXIgb2YgaXRzIHJlc3BlY3RpdmUgZmFjZS4gdGhpcyBjb3VsZCBlaXRoZXIgbG9vayBjb29sLFxuLy8gb3Igc3R1cGlkLCBhbmQgbWF5IGluZGVlZCB3b3JrIG9ubHkgaW4gYSB3YXkgdGhhdCBpcyBzbyBzdWJ0bGUgYXMgdG8gaGF2ZSBiZWVuIGEgd2FzdGUgb2YgdGltZS5cbi8vXG52YXIgX21pZHg9KF9zeCtfdHgpLzIsX21pZHk9KF9zeStfdHkpLzIsc2VnbWVudD1fc2VnbWVudChfc3gsX3N5LF90eCxfdHkpLGRpc3RhbmNlPU1hdGguc3FydChNYXRoLnBvdyhfdHgtX3N4LDIpK01hdGgucG93KF90eS1fc3ksMikpLGNwMXgsY3AyeCxjcDF5LGNwMnk7Ly8gY2FsY3VsYXRlIHRoZSBjb250cm9sIHBvaW50LiAgdGhpcyBjb2RlIHdpbGwgYmUgd2hlcmUgd2UnbGwgcHV0IGluIGEgcnVkaW1lbnRhcnkgZWxlbWVudCBhdm9pZGFuY2Ugc2NoZW1lOyBpdFxuLy8gd2lsbCB3b3JrIGJ5IGV4dGVuZGluZyB0aGUgY29udHJvbCBwb2ludCB0byBmb3JjZSB0aGUgY3VydmUgdG8gYmUsIHVtLCBjdXJ2aWVyLlxuX2NvbnRyb2xQb2ludD1fZmluZENvbnRyb2xQb2ludChfbWlkeCxfbWlkeSxzZWdtZW50LHBhcmFtcy5zb3VyY2VQb3MscGFyYW1zLnRhcmdldFBvcyxjdXJ2aW5lc3MsY3VydmluZXNzLGRpc3RhbmNlLHByb3hpbWl0eUxpbWl0KTtjcDF4PV9jb250cm9sUG9pbnRbMF07Y3AyeD1fY29udHJvbFBvaW50WzBdO2NwMXk9X2NvbnRyb2xQb2ludFsxXTtjcDJ5PV9jb250cm9sUG9pbnRbMV07X3N1cGVyLmFkZFNlZ21lbnQodGhpcyxcIkJlemllclwiLHt4MTpfdHgseTE6X3R5LHgyOl9zeCx5Mjpfc3ksY3AxeDpjcDF4LGNwMXk6Y3AxeSxjcDJ4OmNwMngsY3AyeTpjcDJ5fSk7fTt9O19qcC5Db25uZWN0b3JzLlN0YXRlTWFjaGluZT1TdGF0ZU1hY2hpbmU7X2p1LmV4dGVuZChTdGF0ZU1hY2hpbmUsX2pwLkNvbm5lY3RvcnMuQWJzdHJhY3RCZXppZXJDb25uZWN0b3IpO30pLmNhbGwodHlwZW9mIHdpbmRvdyE9PSd1bmRlZmluZWQnP3dpbmRvdzp0aGlzKTsvKlxyXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdGhlICdmbG93Y2hhcnQnIGNvbm5lY3RvcnMsIGNvbnNpc3Rpbmcgb2YgdmVydGljYWwgYW5kIGhvcml6b250YWwgbGluZSBzZWdtZW50cy5cclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDEwIC0gMjAxOCBqc1BsdW1iIChoZWxsb0Bqc3BsdW1idG9vbGtpdC5jb20pXHJcbiAqXHJcbiAqIGh0dHBzOi8vanNwbHVtYnRvb2xraXQuY29tXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qc3BsdW1iL2pzcGx1bWJcclxuICpcclxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwyIGxpY2Vuc2VzLlxyXG4gKi87KGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHJvb3Q9dGhpcyxfanA9cm9vdC5qc1BsdW1iLF9qdT1yb290LmpzUGx1bWJVdGlsO3ZhciBTVFJBSUdIVD1cIlN0cmFpZ2h0XCI7dmFyIFN0cmFpZ2h0PWZ1bmN0aW9uIFN0cmFpZ2h0KHBhcmFtcyl7dGhpcy50eXBlPVNUUkFJR0hUO3ZhciBfc3VwZXI9X2pwLkNvbm5lY3RvcnMuQWJzdHJhY3RDb25uZWN0b3IuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMuX2NvbXB1dGU9ZnVuY3Rpb24ocGFpbnRJbmZvLF8pe19zdXBlci5hZGRTZWdtZW50KHRoaXMsU1RSQUlHSFQse3gxOnBhaW50SW5mby5zeCx5MTpwYWludEluZm8uc3kseDI6cGFpbnRJbmZvLnN0YXJ0U3R1YlgseTI6cGFpbnRJbmZvLnN0YXJ0U3R1Yll9KTtfc3VwZXIuYWRkU2VnbWVudCh0aGlzLFNUUkFJR0hULHt4MTpwYWludEluZm8uc3RhcnRTdHViWCx5MTpwYWludEluZm8uc3RhcnRTdHViWSx4MjpwYWludEluZm8uZW5kU3R1YlgseTI6cGFpbnRJbmZvLmVuZFN0dWJZfSk7X3N1cGVyLmFkZFNlZ21lbnQodGhpcyxTVFJBSUdIVCx7eDE6cGFpbnRJbmZvLmVuZFN0dWJYLHkxOnBhaW50SW5mby5lbmRTdHViWSx4MjpwYWludEluZm8udHgseTI6cGFpbnRJbmZvLnR5fSk7fTt9O19qcC5Db25uZWN0b3JzLlN0cmFpZ2h0PVN0cmFpZ2h0O19qdS5leHRlbmQoU3RyYWlnaHQsX2pwLkNvbm5lY3RvcnMuQWJzdHJhY3RDb25uZWN0b3IpO30pLmNhbGwodHlwZW9mIHdpbmRvdyE9PSd1bmRlZmluZWQnP3dpbmRvdzp0aGlzKTsvKlxyXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdGhlIFNWRyByZW5kZXJlcnMuXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMCAtIDIwMTgganNQbHVtYiAoaGVsbG9AanNwbHVtYnRvb2xraXQuY29tKVxyXG4gKiBcclxuICogaHR0cHM6Ly9qc3BsdW1idG9vbGtpdC5jb21cclxuICogaHR0cHM6Ly9naXRodWIuY29tL2pzcGx1bWIvanNwbHVtYlxyXG4gKiBcclxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwyIGxpY2Vuc2VzLlxyXG4gKi87KGZ1bmN0aW9uKCl7Ly8gKioqKioqKioqKioqKioqKioqKioqKioqKiogU1ZHIHV0aWxpdHkgbWV0aG9kcyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlx0XG5cInVzZSBzdHJpY3RcIjt2YXIgcm9vdD10aGlzLF9qcD1yb290LmpzUGx1bWIsX2p1PXJvb3QuanNQbHVtYlV0aWw7dmFyIHN2Z0F0dHJpYnV0ZU1hcD17XCJzdHJva2UtbGluZWpvaW5cIjpcInN0cm9rZS1saW5lam9pblwiLFwic3Ryb2tlLWRhc2hvZmZzZXRcIjpcInN0cm9rZS1kYXNob2Zmc2V0XCIsXCJzdHJva2UtbGluZWNhcFwiOlwic3Ryb2tlLWxpbmVjYXBcIn0sU1RST0tFX0RBU0hBUlJBWT1cInN0cm9rZS1kYXNoYXJyYXlcIixEQVNIU1RZTEU9XCJkYXNoc3R5bGVcIixMSU5FQVJfR1JBRElFTlQ9XCJsaW5lYXJHcmFkaWVudFwiLFJBRElBTF9HUkFESUVOVD1cInJhZGlhbEdyYWRpZW50XCIsREVGUz1cImRlZnNcIixGSUxMPVwiZmlsbFwiLFNUT1A9XCJzdG9wXCIsU1RST0tFPVwic3Ryb2tlXCIsU1RST0tFX1dJRFRIPVwic3Ryb2tlLXdpZHRoXCIsU1RZTEU9XCJzdHlsZVwiLE5PTkU9XCJub25lXCIsSlNQTFVNQl9HUkFESUVOVD1cImpzcGx1bWJfZ3JhZGllbnRfXCIsTElORV9XSURUSD1cInN0cm9rZVdpZHRoXCIsbnM9e3N2ZzpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJ9LF9hdHRyPWZ1bmN0aW9uIF9hdHRyKG5vZGUsYXR0cmlidXRlcyl7Zm9yKHZhciBpIGluIGF0dHJpYnV0ZXMpe25vZGUuc2V0QXR0cmlidXRlKGksXCJcIithdHRyaWJ1dGVzW2ldKTt9fSxfbm9kZT1mdW5jdGlvbiBfbm9kZShuYW1lLGF0dHJpYnV0ZXMpe2F0dHJpYnV0ZXM9YXR0cmlidXRlc3x8e307YXR0cmlidXRlcy52ZXJzaW9uPVwiMS4xXCI7YXR0cmlidXRlcy54bWxucz1ucy5zdmc7cmV0dXJuIF9qcC5jcmVhdGVFbGVtZW50TlMobnMuc3ZnLG5hbWUsbnVsbCxudWxsLGF0dHJpYnV0ZXMpO30sX3Bvcz1mdW5jdGlvbiBfcG9zKGQpe3JldHVyblwicG9zaXRpb246YWJzb2x1dGU7bGVmdDpcIitkWzBdK1wicHg7dG9wOlwiK2RbMV0rXCJweFwiO30sX2NsZWFyR3JhZGllbnQ9ZnVuY3Rpb24gX2NsZWFyR3JhZGllbnQocGFyZW50KXt2YXIgZWxzPXBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKFwiIGRlZnMsbGluZWFyR3JhZGllbnQscmFkaWFsR3JhZGllbnRcIik7Zm9yKHZhciBpPTA7aTxlbHMubGVuZ3RoO2krKyl7ZWxzW2ldLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxzW2ldKTt9fSxfdXBkYXRlR3JhZGllbnQ9ZnVuY3Rpb24gX3VwZGF0ZUdyYWRpZW50KHBhcmVudCxub2RlLHN0eWxlLGRpbWVuc2lvbnMsdWlDb21wb25lbnQpe3ZhciBpZD1KU1BMVU1CX0dSQURJRU5UK3VpQ29tcG9uZW50Ll9qc1BsdW1iLmluc3RhbmNlLmlkc3RhbXAoKTsvLyBmaXJzdCBjbGVhciBvdXQgYW55IGV4aXN0aW5nIGdyYWRpZW50XG5fY2xlYXJHcmFkaWVudChwYXJlbnQpOy8vIHRoaXMgY2hlY2tzIGZvciBhbiAnb2Zmc2V0JyBwcm9wZXJ0eSBpbiB0aGUgZ3JhZGllbnQsIGFuZCBpbiB0aGUgYWJzZW5jZSBvZiBpdCwgYXNzdW1lc1xuLy8gd2Ugd2FudCBhIGxpbmVhciBncmFkaWVudC4gaWYgaXQncyB0aGVyZSwgd2UgY3JlYXRlIGEgcmFkaWFsIGdyYWRpZW50LlxuLy8gaXQgaXMgcG9zc2libGUgdGhhdCBhIG1vcmUgZXhwbGljaXQgbWVhbnMgb2YgZGVmaW5pbmcgdGhlIGdyYWRpZW50IHR5cGUgd291bGQgYmVcbi8vIGJldHRlci4gcmVseWluZyBvbiAnb2Zmc2V0JyBtZWFucyB0aGF0IHdlIGNhbiBuZXZlciBoYXZlIGEgcmFkaWFsIGdyYWRpZW50IHRoYXQgdXNlc1xuLy8gc29tZSBkZWZhdWx0IG9mZnNldCwgZm9yIGluc3RhbmNlLlxuLy8gaXNzdWUgMjQ0IHN1Z2dlc3RlZCB0aGUgJ2dyYWRpZW50VW5pdHMnIGF0dHJpYnV0ZTsgd2l0aG91dCB0aGlzLCBzdHJhaWdodC9mbG93Y2hhcnQgY29ubmVjdG9ycyB3aXRoIGdyYWRpZW50cyB3b3VsZFxuLy8gbm90IHNob3cgZ3JhZGllbnRzIHdoZW4gdGhlIGxpbmUgd2FzIHBlcmZlY3RseSBob3Jpem9udGFsIG9yIHZlcnRpY2FsLlxudmFyIGc7aWYoIXN0eWxlLmdyYWRpZW50Lm9mZnNldCl7Zz1fbm9kZShMSU5FQVJfR1JBRElFTlQse2lkOmlkLGdyYWRpZW50VW5pdHM6XCJ1c2VyU3BhY2VPblVzZVwifSk7fWVsc2V7Zz1fbm9kZShSQURJQUxfR1JBRElFTlQse2lkOmlkfSk7fXZhciBkZWZzPV9ub2RlKERFRlMpO3BhcmVudC5hcHBlbmRDaGlsZChkZWZzKTtkZWZzLmFwcGVuZENoaWxkKGcpOy8vIHRoZSBzdmcgcmFkaWFsIGdyYWRpZW50IHNlZW1zIHRvIHRyZWF0IHN0b3BzIGluIHRoZSByZXZlcnNlXG4vLyBvcmRlciB0byBob3cgY2FudmFzIGRvZXMgaXQuICBzbyB3ZSB3YW50IHRvIGtlZXAgYWxsIHRoZSBtYXRocyB0aGUgc2FtZSwgYnV0XG4vLyBpdGVyYXRlIHRoZSBhY3R1YWwgc3R5bGUgZGVjbGFyYXRpb25zIGluIHJldmVyc2Ugb3JkZXIsIGlmIHRoZSB4IGluZGV4ZXMgYXJlIG5vdCBpbiBvcmRlci5cbmZvcih2YXIgaT0wO2k8c3R5bGUuZ3JhZGllbnQuc3RvcHMubGVuZ3RoO2krKyl7dmFyIHN0eWxlVG9Vc2U9dWlDb21wb25lbnQuc2VnbWVudD09PTF8fHVpQ29tcG9uZW50LnNlZ21lbnQ9PT0yP2k6c3R5bGUuZ3JhZGllbnQuc3RvcHMubGVuZ3RoLTEtaSxzdG9wQ29sb3I9c3R5bGUuZ3JhZGllbnQuc3RvcHNbc3R5bGVUb1VzZV1bMV0scz1fbm9kZShTVE9QLHtcIm9mZnNldFwiOk1hdGguZmxvb3Ioc3R5bGUuZ3JhZGllbnQuc3RvcHNbaV1bMF0qMTAwKStcIiVcIixcInN0b3AtY29sb3JcIjpzdG9wQ29sb3J9KTtnLmFwcGVuZENoaWxkKHMpO312YXIgYXBwbHlHcmFkaWVudFRvPXN0eWxlLnN0cm9rZT9TVFJPS0U6RklMTDtub2RlLnNldEF0dHJpYnV0ZShhcHBseUdyYWRpZW50VG8sXCJ1cmwoI1wiK2lkK1wiKVwiKTt9LF9hcHBseVN0eWxlcz1mdW5jdGlvbiBfYXBwbHlTdHlsZXMocGFyZW50LG5vZGUsc3R5bGUsZGltZW5zaW9ucyx1aUNvbXBvbmVudCl7bm9kZS5zZXRBdHRyaWJ1dGUoRklMTCxzdHlsZS5maWxsP3N0eWxlLmZpbGw6Tk9ORSk7bm9kZS5zZXRBdHRyaWJ1dGUoU1RST0tFLHN0eWxlLnN0cm9rZT9zdHlsZS5zdHJva2U6Tk9ORSk7aWYoc3R5bGUuZ3JhZGllbnQpe191cGRhdGVHcmFkaWVudChwYXJlbnQsbm9kZSxzdHlsZSxkaW1lbnNpb25zLHVpQ29tcG9uZW50KTt9ZWxzZXsvLyBtYWtlIHN1cmUgd2UgY2xlYXIgYW55IGV4aXN0aW5nIGdyYWRpZW50XG5fY2xlYXJHcmFkaWVudChwYXJlbnQpO25vZGUuc2V0QXR0cmlidXRlKFNUWUxFLFwiXCIpO31pZihzdHlsZS5zdHJva2VXaWR0aCl7bm9kZS5zZXRBdHRyaWJ1dGUoU1RST0tFX1dJRFRILHN0eWxlLnN0cm9rZVdpZHRoKTt9Ly8gaW4gU1ZHIHRoZXJlIGlzIGEgc3Ryb2tlLWRhc2hhcnJheSBhdHRyaWJ1dGUgd2UgY2FuIHNldCwgYW5kIGl0cyBzeW50YXggbG9va3MgbGlrZVxuLy8gdGhlIHN5bnRheCBpbiBWTUwgYnV0IGlzIGFjdHVhbGx5IGtpbmQgb2YgbmFzdHk6IHZhbHVlcyBhcmUgZ2l2ZW4gaW4gdGhlIHBpeGVsXG4vLyBjb29yZGluYXRlIHNwYWNlLCB3aGVyZWFzIGluIFZNTCB0aGV5IGFyZSBtdWx0aXBsZXMgb2YgdGhlIHdpZHRoIG9mIHRoZSBzdHJva2VkXG4vLyBsaW5lLCB3aGljaCBtYWtlcyBhIGxvdCBtb3JlIHNlbnNlLiAgZm9yIHRoYXQgcmVhc29uLCBqc1BsdW1iIGlzIHN1cHBvcnRpbmcgYm90aFxuLy8gdGhlIG5hdGl2ZSBzdmcgJ3N0cm9rZS1kYXNoYXJyYXknIGF0dHJpYnV0ZSwgYW5kIGFsc28gdGhlICdkYXNoc3R5bGUnIGNvbmNlcHQgZnJvbVxuLy8gVk1MLCB3aGljaCB3aWxsIGJlIHRoZSBwcmVmZXJyZWQgbWV0aG9kLiAgdGhlIGNvZGUgYmVsb3cgdGhpcyBjb252ZXJ0cyBhIGRhc2hzdHlsZVxuLy8gYXR0cmlidXRlIGdpdmVuIGluIHRlcm1zIG9mIHN0cm9rZSB3aWR0aCBpbnRvIGEgcGl4ZWwgcmVwcmVzZW50YXRpb24sIGJ5IHVzaW5nIHRoZVxuLy8gc3Ryb2tlJ3MgbGluZVdpZHRoLlxuaWYoc3R5bGVbREFTSFNUWUxFXSYmc3R5bGVbTElORV9XSURUSF0mJiFzdHlsZVtTVFJPS0VfREFTSEFSUkFZXSl7dmFyIHNlcD1zdHlsZVtEQVNIU1RZTEVdLmluZGV4T2YoXCIsXCIpPT09LTE/XCIgXCI6XCIsXCIscGFydHM9c3R5bGVbREFTSFNUWUxFXS5zcGxpdChzZXApLHN0eWxlVG9Vc2U9XCJcIjtwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uKHApe3N0eWxlVG9Vc2UrPU1hdGguZmxvb3IocCpzdHlsZS5zdHJva2VXaWR0aCkrc2VwO30pO25vZGUuc2V0QXR0cmlidXRlKFNUUk9LRV9EQVNIQVJSQVksc3R5bGVUb1VzZSk7fWVsc2UgaWYoc3R5bGVbU1RST0tFX0RBU0hBUlJBWV0pe25vZGUuc2V0QXR0cmlidXRlKFNUUk9LRV9EQVNIQVJSQVksc3R5bGVbU1RST0tFX0RBU0hBUlJBWV0pO30vLyBleHRyYSBhdHRyaWJ1dGVzIHN1Y2ggYXMgam9pbiB0eXBlLCBkYXNoIG9mZnNldC5cbmZvcih2YXIgaSBpbiBzdmdBdHRyaWJ1dGVNYXApe2lmKHN0eWxlW2ldKXtub2RlLnNldEF0dHJpYnV0ZShzdmdBdHRyaWJ1dGVNYXBbaV0sc3R5bGVbaV0pO319fSxfYXBwZW5kQXRJbmRleD1mdW5jdGlvbiBfYXBwZW5kQXRJbmRleChzdmcscGF0aCxpZHgpe2lmKHN2Zy5jaGlsZE5vZGVzLmxlbmd0aD5pZHgpe3N2Zy5pbnNlcnRCZWZvcmUocGF0aCxzdmcuY2hpbGROb2Rlc1tpZHhdKTt9ZWxzZXtzdmcuYXBwZW5kQ2hpbGQocGF0aCk7fX07LyoqXHJcbiAgICAgdXRpbGl0eSBtZXRob2RzIGZvciBvdGhlciBvYmplY3RzIHRvIHVzZS5cclxuICAgICAqL19qdS5zdmc9e25vZGU6X25vZGUsYXR0cjpfYXR0cixwb3M6X3Bvc307Ly8gKioqKioqKioqKioqKioqKioqKioqKioqKiogLyBTVkcgdXRpbGl0eSBtZXRob2RzICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKlxyXG4gICAgICogQmFzZSBjbGFzcyBmb3IgU1ZHIGNvbXBvbmVudHMuXHJcbiAgICAgKi92YXIgU3ZnQ29tcG9uZW50PWZ1bmN0aW9uIFN2Z0NvbXBvbmVudChwYXJhbXMpe3ZhciBwb2ludGVyRXZlbnRzU3BlYz1wYXJhbXMucG9pbnRlckV2ZW50c1NwZWN8fFwiYWxsXCIscmVuZGVyZXI9e307X2pwLmpzUGx1bWJVSUNvbXBvbmVudC5hcHBseSh0aGlzLHBhcmFtcy5vcmlnaW5hbEFyZ3MpO3RoaXMuY2FudmFzPW51bGw7dGhpcy5wYXRoPW51bGw7dGhpcy5zdmc9bnVsbDt0aGlzLmJnQ2FudmFzPW51bGw7dmFyIGNsYXp6PXBhcmFtcy5jc3NDbGFzcytcIiBcIisocGFyYW1zLm9yaWdpbmFsQXJnc1swXS5jc3NDbGFzc3x8XCJcIiksc3ZnUGFyYW1zPXtcInN0eWxlXCI6XCJcIixcIndpZHRoXCI6MCxcImhlaWdodFwiOjAsXCJwb2ludGVyLWV2ZW50c1wiOnBvaW50ZXJFdmVudHNTcGVjLFwicG9zaXRpb25cIjpcImFic29sdXRlXCJ9O3RoaXMuc3ZnPV9ub2RlKFwic3ZnXCIsc3ZnUGFyYW1zKTtpZihwYXJhbXMudXNlRGl2V3JhcHBlcil7dGhpcy5jYW52YXM9X2pwLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7cG9zaXRpb246XCJhYnNvbHV0ZVwifSk7X2p1LnNpemVFbGVtZW50KHRoaXMuY2FudmFzLDAsMCwxLDEpO3RoaXMuY2FudmFzLmNsYXNzTmFtZT1jbGF6ejt9ZWxzZXtfYXR0cih0aGlzLnN2Zyx7XCJjbGFzc1wiOmNsYXp6fSk7dGhpcy5jYW52YXM9dGhpcy5zdmc7fXBhcmFtcy5fanNQbHVtYi5hcHBlbmRFbGVtZW50KHRoaXMuY2FudmFzLHBhcmFtcy5vcmlnaW5hbEFyZ3NbMF0ucGFyZW50KTtpZihwYXJhbXMudXNlRGl2V3JhcHBlcil7dGhpcy5jYW52YXMuYXBwZW5kQ2hpbGQodGhpcy5zdmcpO312YXIgZGlzcGxheUVsZW1lbnRzPVt0aGlzLmNhbnZhc107dGhpcy5nZXREaXNwbGF5RWxlbWVudHM9ZnVuY3Rpb24oKXtyZXR1cm4gZGlzcGxheUVsZW1lbnRzO307dGhpcy5hcHBlbmREaXNwbGF5RWxlbWVudD1mdW5jdGlvbihlbCl7ZGlzcGxheUVsZW1lbnRzLnB1c2goZWwpO307dGhpcy5wYWludD1mdW5jdGlvbihzdHlsZSxhbmNob3IsZXh0ZW50cyl7aWYoc3R5bGUhPW51bGwpe3ZhciB4eT1bdGhpcy54LHRoaXMueV0sd2g9W3RoaXMudyx0aGlzLmhdLHA7aWYoZXh0ZW50cyE9bnVsbCl7aWYoZXh0ZW50cy54bWluPDApe3h5WzBdKz1leHRlbnRzLnhtaW47fWlmKGV4dGVudHMueW1pbjwwKXt4eVsxXSs9ZXh0ZW50cy55bWluO313aFswXT1leHRlbnRzLnhtYXgrKGV4dGVudHMueG1pbjwwPy1leHRlbnRzLnhtaW46MCk7d2hbMV09ZXh0ZW50cy55bWF4KyhleHRlbnRzLnltaW48MD8tZXh0ZW50cy55bWluOjApO31pZihwYXJhbXMudXNlRGl2V3JhcHBlcil7X2p1LnNpemVFbGVtZW50KHRoaXMuY2FudmFzLHh5WzBdLHh5WzFdLHdoWzBdLHdoWzFdKTt4eVswXT0wO3h5WzFdPTA7cD1fcG9zKFswLDBdKTt9ZWxzZXtwPV9wb3MoW3h5WzBdLHh5WzFdXSk7fXJlbmRlcmVyLnBhaW50LmFwcGx5KHRoaXMsYXJndW1lbnRzKTtfYXR0cih0aGlzLnN2Zyx7XCJzdHlsZVwiOnAsXCJ3aWR0aFwiOndoWzBdfHwwLFwiaGVpZ2h0XCI6d2hbMV18fDB9KTt9fTtyZXR1cm57cmVuZGVyZXI6cmVuZGVyZXJ9O307X2p1LmV4dGVuZChTdmdDb21wb25lbnQsX2pwLmpzUGx1bWJVSUNvbXBvbmVudCx7Y2xlYW51cDpmdW5jdGlvbiBjbGVhbnVwKGZvcmNlKXtpZihmb3JjZXx8dGhpcy50eXBlSWQ9PW51bGwpe2lmKHRoaXMuY2FudmFzKXt0aGlzLmNhbnZhcy5fanNQbHVtYj1udWxsO31pZih0aGlzLnN2Zyl7dGhpcy5zdmcuX2pzUGx1bWI9bnVsbDt9aWYodGhpcy5iZ0NhbnZhcyl7dGhpcy5iZ0NhbnZhcy5fanNQbHVtYj1udWxsO31pZih0aGlzLmNhbnZhcyYmdGhpcy5jYW52YXMucGFyZW50Tm9kZSl7dGhpcy5jYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNhbnZhcyk7fWlmKHRoaXMuYmdDYW52YXMmJnRoaXMuYmdDYW52YXMucGFyZW50Tm9kZSl7dGhpcy5jYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNhbnZhcyk7fXRoaXMuc3ZnPW51bGw7dGhpcy5jYW52YXM9bnVsbDt0aGlzLnBhdGg9bnVsbDt0aGlzLmdyb3VwPW51bGw7fWVsc2V7Ly8gaWYgbm90IGEgZm9yY2VkIGNsZWFudXAsIGp1c3QgZGV0YWNoIGZyb20gRE9NIGZvciBub3cuXG5pZih0aGlzLmNhbnZhcyYmdGhpcy5jYW52YXMucGFyZW50Tm9kZSl7dGhpcy5jYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNhbnZhcyk7fWlmKHRoaXMuYmdDYW52YXMmJnRoaXMuYmdDYW52YXMucGFyZW50Tm9kZSl7dGhpcy5iZ0NhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuYmdDYW52YXMpO319fSxyZWF0dGFjaDpmdW5jdGlvbiByZWF0dGFjaChpbnN0YW5jZSl7dmFyIGM9aW5zdGFuY2UuZ2V0Q29udGFpbmVyKCk7aWYodGhpcy5jYW52YXMmJnRoaXMuY2FudmFzLnBhcmVudE5vZGU9PW51bGwpe2MuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO31pZih0aGlzLmJnQ2FudmFzJiZ0aGlzLmJnQ2FudmFzLnBhcmVudE5vZGU9PW51bGwpe2MuYXBwZW5kQ2hpbGQodGhpcy5iZ0NhbnZhcyk7fX0sc2V0VmlzaWJsZTpmdW5jdGlvbiBzZXRWaXNpYmxlKHYpe2lmKHRoaXMuY2FudmFzKXt0aGlzLmNhbnZhcy5zdHlsZS5kaXNwbGF5PXY/XCJibG9ja1wiOlwibm9uZVwiO319fSk7LypcclxuICAgICAqIEJhc2UgY2xhc3MgZm9yIFNWRyBjb25uZWN0b3JzLlxyXG4gICAgICovX2pwLkNvbm5lY3RvclJlbmRlcmVycy5zdmc9ZnVuY3Rpb24ocGFyYW1zKXt2YXIgc2VsZj10aGlzLF9zdXBlcj1TdmdDb21wb25lbnQuYXBwbHkodGhpcyxbe2Nzc0NsYXNzOnBhcmFtcy5fanNQbHVtYi5jb25uZWN0b3JDbGFzcyxvcmlnaW5hbEFyZ3M6YXJndW1lbnRzLHBvaW50ZXJFdmVudHNTcGVjOlwibm9uZVwiLF9qc1BsdW1iOnBhcmFtcy5fanNQbHVtYn1dKTtfc3VwZXIucmVuZGVyZXIucGFpbnQ9ZnVuY3Rpb24oc3R5bGUsYW5jaG9yLGV4dGVudHMpe3ZhciBzZWdtZW50cz1zZWxmLmdldFNlZ21lbnRzKCkscD1cIlwiLG9mZnNldD1bMCwwXTtpZihleHRlbnRzLnhtaW48MCl7b2Zmc2V0WzBdPS1leHRlbnRzLnhtaW47fWlmKGV4dGVudHMueW1pbjwwKXtvZmZzZXRbMV09LWV4dGVudHMueW1pbjt9aWYoc2VnbWVudHMubGVuZ3RoPjApe3A9c2VsZi5nZXRQYXRoRGF0YSgpO3ZhciBhPXtkOnAsdHJhbnNmb3JtOlwidHJhbnNsYXRlKFwiK29mZnNldFswXStcIixcIitvZmZzZXRbMV0rXCIpXCIsXCJwb2ludGVyLWV2ZW50c1wiOnBhcmFtc1tcInBvaW50ZXItZXZlbnRzXCJdfHxcInZpc2libGVTdHJva2VcIn0sb3V0bGluZVN0eWxlPW51bGwsZD1bc2VsZi54LHNlbGYueSxzZWxmLncsc2VsZi5oXTsvLyBvdXRsaW5lIHN0eWxlLiAgYWN0dWFsbHkgbWVhbnMgZHJhd2luZyBhbiBzdmcgb2JqZWN0IHVuZGVybmVhdGggdGhlIG1haW4gb25lLlxuaWYoc3R5bGUub3V0bGluZVN0cm9rZSl7dmFyIG91dGxpbmVXaWR0aD1zdHlsZS5vdXRsaW5lV2lkdGh8fDEsb3V0bGluZVN0cm9rZVdpZHRoPXN0eWxlLnN0cm9rZVdpZHRoKzIqb3V0bGluZVdpZHRoO291dGxpbmVTdHlsZT1fanAuZXh0ZW5kKHt9LHN0eWxlKTtkZWxldGUgb3V0bGluZVN0eWxlLmdyYWRpZW50O291dGxpbmVTdHlsZS5zdHJva2U9c3R5bGUub3V0bGluZVN0cm9rZTtvdXRsaW5lU3R5bGUuc3Ryb2tlV2lkdGg9b3V0bGluZVN0cm9rZVdpZHRoO2lmKHNlbGYuYmdQYXRoPT1udWxsKXtzZWxmLmJnUGF0aD1fbm9kZShcInBhdGhcIixhKTtfanAuYWRkQ2xhc3Moc2VsZi5iZ1BhdGgsX2pwLmNvbm5lY3Rvck91dGxpbmVDbGFzcyk7X2FwcGVuZEF0SW5kZXgoc2VsZi5zdmcsc2VsZi5iZ1BhdGgsMCk7fWVsc2V7X2F0dHIoc2VsZi5iZ1BhdGgsYSk7fV9hcHBseVN0eWxlcyhzZWxmLnN2ZyxzZWxmLmJnUGF0aCxvdXRsaW5lU3R5bGUsZCxzZWxmKTt9aWYoc2VsZi5wYXRoPT1udWxsKXtzZWxmLnBhdGg9X25vZGUoXCJwYXRoXCIsYSk7X2FwcGVuZEF0SW5kZXgoc2VsZi5zdmcsc2VsZi5wYXRoLHN0eWxlLm91dGxpbmVTdHJva2U/MTowKTt9ZWxzZXtfYXR0cihzZWxmLnBhdGgsYSk7fV9hcHBseVN0eWxlcyhzZWxmLnN2ZyxzZWxmLnBhdGgsc3R5bGUsZCxzZWxmKTt9fTt9O19qdS5leHRlbmQoX2pwLkNvbm5lY3RvclJlbmRlcmVycy5zdmcsU3ZnQ29tcG9uZW50KTsvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIHN2ZyBzZWdtZW50IHJlbmRlcmVyICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHRcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogL3N2ZyBzZWdtZW50cyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLypcclxuICAgICAqIEJhc2UgY2xhc3MgZm9yIFNWRyBlbmRwb2ludHMuXHJcbiAgICAgKi92YXIgU3ZnRW5kcG9pbnQ9X2pwLlN2Z0VuZHBvaW50PWZ1bmN0aW9uKHBhcmFtcyl7dmFyIF9zdXBlcj1TdmdDb21wb25lbnQuYXBwbHkodGhpcyxbe2Nzc0NsYXNzOnBhcmFtcy5fanNQbHVtYi5lbmRwb2ludENsYXNzLG9yaWdpbmFsQXJnczphcmd1bWVudHMscG9pbnRlckV2ZW50c1NwZWM6XCJhbGxcIix1c2VEaXZXcmFwcGVyOnRydWUsX2pzUGx1bWI6cGFyYW1zLl9qc1BsdW1ifV0pO19zdXBlci5yZW5kZXJlci5wYWludD1mdW5jdGlvbihzdHlsZSl7dmFyIHM9X2pwLmV4dGVuZCh7fSxzdHlsZSk7aWYocy5vdXRsaW5lU3Ryb2tlKXtzLnN0cm9rZT1zLm91dGxpbmVTdHJva2U7fWlmKHRoaXMubm9kZT09bnVsbCl7dGhpcy5ub2RlPXRoaXMubWFrZU5vZGUocyk7dGhpcy5zdmcuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKTt9ZWxzZSBpZih0aGlzLnVwZGF0ZU5vZGUhPW51bGwpe3RoaXMudXBkYXRlTm9kZSh0aGlzLm5vZGUpO31fYXBwbHlTdHlsZXModGhpcy5zdmcsdGhpcy5ub2RlLHMsW3RoaXMueCx0aGlzLnksdGhpcy53LHRoaXMuaF0sdGhpcyk7X3Bvcyh0aGlzLm5vZGUsW3RoaXMueCx0aGlzLnldKTt9LmJpbmQodGhpcyk7fTtfanUuZXh0ZW5kKFN2Z0VuZHBvaW50LFN2Z0NvbXBvbmVudCk7LypcclxuICAgICAqIFNWRyBEb3QgRW5kcG9pbnRcclxuICAgICAqL19qcC5FbmRwb2ludHMuc3ZnLkRvdD1mdW5jdGlvbigpe19qcC5FbmRwb2ludHMuRG90LmFwcGx5KHRoaXMsYXJndW1lbnRzKTtTdmdFbmRwb2ludC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dGhpcy5tYWtlTm9kZT1mdW5jdGlvbihzdHlsZSl7cmV0dXJuIF9ub2RlKFwiY2lyY2xlXCIse1wiY3hcIjp0aGlzLncvMixcImN5XCI6dGhpcy5oLzIsXCJyXCI6dGhpcy5yYWRpdXN9KTt9O3RoaXMudXBkYXRlTm9kZT1mdW5jdGlvbihub2RlKXtfYXR0cihub2RlLHtcImN4XCI6dGhpcy53LzIsXCJjeVwiOnRoaXMuaC8yLFwiclwiOnRoaXMucmFkaXVzfSk7fTt9O19qdS5leHRlbmQoX2pwLkVuZHBvaW50cy5zdmcuRG90LFtfanAuRW5kcG9pbnRzLkRvdCxTdmdFbmRwb2ludF0pOy8qXHJcbiAgICAgKiBTVkcgUmVjdGFuZ2xlIEVuZHBvaW50XHJcbiAgICAgKi9fanAuRW5kcG9pbnRzLnN2Zy5SZWN0YW5nbGU9ZnVuY3Rpb24oKXtfanAuRW5kcG9pbnRzLlJlY3RhbmdsZS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7U3ZnRW5kcG9pbnQuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMubWFrZU5vZGU9ZnVuY3Rpb24oc3R5bGUpe3JldHVybiBfbm9kZShcInJlY3RcIix7XCJ3aWR0aFwiOnRoaXMudyxcImhlaWdodFwiOnRoaXMuaH0pO307dGhpcy51cGRhdGVOb2RlPWZ1bmN0aW9uKG5vZGUpe19hdHRyKG5vZGUse1wid2lkdGhcIjp0aGlzLncsXCJoZWlnaHRcIjp0aGlzLmh9KTt9O307X2p1LmV4dGVuZChfanAuRW5kcG9pbnRzLnN2Zy5SZWN0YW5nbGUsW19qcC5FbmRwb2ludHMuUmVjdGFuZ2xlLFN2Z0VuZHBvaW50XSk7Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBDb25uZWN0b3JzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuX2pwLkNvbm5lY3RvcnMuc3ZnLkZsb3djaGFydD1mdW5jdGlvbigpe19qcC5Db25uZWN0b3JzLkZsb3djaGFydC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7X2pwLkNvbm5lY3RvclJlbmRlcmVycy5zdmcuYXBwbHkodGhpcyxhcmd1bWVudHMpO307X2p1LmV4dGVuZChfanAuQ29ubmVjdG9ycy5zdmcuRmxvd2NoYXJ0LFtfanAuQ29ubmVjdG9ycy5GbG93Y2hhcnQsX2pwLkNvbm5lY3RvclJlbmRlcmVycy5zdmddKTtfanAuQ29ubmVjdG9ycy5zdmcuQmV6aWVyPWZ1bmN0aW9uKCl7X2pwLkNvbm5lY3RvcnMuQmV6aWVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtfanAuQ29ubmVjdG9yUmVuZGVyZXJzLnN2Zy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7fTtfanUuZXh0ZW5kKF9qcC5Db25uZWN0b3JzLnN2Zy5CZXppZXIsW19qcC5Db25uZWN0b3JzLkJlemllcixfanAuQ29ubmVjdG9yUmVuZGVyZXJzLnN2Z10pO19qcC5Db25uZWN0b3JzLnN2Zy5TdHJhaWdodD1mdW5jdGlvbigpe19qcC5Db25uZWN0b3JzLlN0cmFpZ2h0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTtfanAuQ29ubmVjdG9yUmVuZGVyZXJzLnN2Zy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7fTtfanUuZXh0ZW5kKF9qcC5Db25uZWN0b3JzLnN2Zy5TdHJhaWdodCxbX2pwLkNvbm5lY3RvcnMuU3RyYWlnaHQsX2pwLkNvbm5lY3RvclJlbmRlcmVycy5zdmddKTtfanAuQ29ubmVjdG9ycy5zdmcuU3RhdGVNYWNoaW5lPWZ1bmN0aW9uKCl7X2pwLkNvbm5lY3RvcnMuU3RhdGVNYWNoaW5lLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtfanAuQ29ubmVjdG9yUmVuZGVyZXJzLnN2Zy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7fTtfanUuZXh0ZW5kKF9qcC5Db25uZWN0b3JzLnN2Zy5TdGF0ZU1hY2hpbmUsW19qcC5Db25uZWN0b3JzLlN0YXRlTWFjaGluZSxfanAuQ29ubmVjdG9yUmVuZGVyZXJzLnN2Z10pOy8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvIENvbm5lY3RvcnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qXHJcbiAgICAgKiBTVkcgSW1hZ2UgRW5kcG9pbnQgaXMgdGhlIGRlZmF1bHQgaW1hZ2UgZW5kcG9pbnQuXHJcbiAgICAgKi9fanAuRW5kcG9pbnRzLnN2Zy5JbWFnZT1fanAuRW5kcG9pbnRzLkltYWdlOy8qXHJcbiAgICAgKiBCbGFuayBlbmRwb2ludCBpbiBzdmcgcmVuZGVyZXIgaXMgdGhlIGRlZmF1bHQgQmxhbmsgZW5kcG9pbnQuXHJcbiAgICAgKi9fanAuRW5kcG9pbnRzLnN2Zy5CbGFuaz1fanAuRW5kcG9pbnRzLkJsYW5rOy8qXHJcbiAgICAgKiBMYWJlbCBvdmVybGF5IGluIHN2ZyByZW5kZXJlciBpcyB0aGUgZGVmYXVsdCBMYWJlbCBvdmVybGF5LlxyXG4gICAgICovX2pwLk92ZXJsYXlzLnN2Zy5MYWJlbD1fanAuT3ZlcmxheXMuTGFiZWw7LypcclxuICAgICAqIEN1c3RvbSBvdmVybGF5IGluIHN2ZyByZW5kZXJlciBpcyB0aGUgZGVmYXVsdCBDdXN0b20gb3ZlcmxheS5cclxuICAgICAqL19qcC5PdmVybGF5cy5zdmcuQ3VzdG9tPV9qcC5PdmVybGF5cy5DdXN0b207dmFyIEFic3RyYWN0U3ZnQXJyb3dPdmVybGF5PWZ1bmN0aW9uIEFic3RyYWN0U3ZnQXJyb3dPdmVybGF5KHN1cGVyY2xhc3Msb3JpZ2luYWxBcmdzKXtzdXBlcmNsYXNzLmFwcGx5KHRoaXMsb3JpZ2luYWxBcmdzKTtfanAuanNQbHVtYlVJQ29tcG9uZW50LmFwcGx5KHRoaXMsb3JpZ2luYWxBcmdzKTt0aGlzLmlzQXBwZW5kZWRBdFRvcExldmVsPWZhbHNlO3ZhciBzZWxmPXRoaXM7dGhpcy5wYXRoPW51bGw7dGhpcy5wYWludD1mdW5jdGlvbihwYXJhbXMsY29udGFpbmVyRXh0ZW50cyl7Ly8gb25seSBkcmF3cyBvbiBjb25uZWN0aW9ucywgbm90IGVuZHBvaW50cy5cbmlmKHBhcmFtcy5jb21wb25lbnQuc3ZnJiZjb250YWluZXJFeHRlbnRzKXtpZih0aGlzLnBhdGg9PW51bGwpe3RoaXMucGF0aD1fbm9kZShcInBhdGhcIix7XCJwb2ludGVyLWV2ZW50c1wiOlwiYWxsXCJ9KTtwYXJhbXMuY29tcG9uZW50LnN2Zy5hcHBlbmRDaGlsZCh0aGlzLnBhdGgpO2lmKHRoaXMuZWxlbWVudENyZWF0ZWQpe3RoaXMuZWxlbWVudENyZWF0ZWQodGhpcy5wYXRoLHBhcmFtcy5jb21wb25lbnQpO310aGlzLmNhbnZhcz1wYXJhbXMuY29tcG9uZW50LnN2ZzsvLyBmb3IgdGhlIHNha2Ugb2YgY29tcGxldGVuZXNzOyB0aGlzIGJlaGF2ZXMgdGhlIHNhbWUgYXMgb3RoZXIgb3ZlcmxheXNcbn12YXIgY2xheno9b3JpZ2luYWxBcmdzJiZvcmlnaW5hbEFyZ3MubGVuZ3RoPT09MT9vcmlnaW5hbEFyZ3NbMF0uY3NzQ2xhc3N8fFwiXCI6XCJcIixvZmZzZXQ9WzAsMF07aWYoY29udGFpbmVyRXh0ZW50cy54bWluPDApe29mZnNldFswXT0tY29udGFpbmVyRXh0ZW50cy54bWluO31pZihjb250YWluZXJFeHRlbnRzLnltaW48MCl7b2Zmc2V0WzFdPS1jb250YWluZXJFeHRlbnRzLnltaW47fV9hdHRyKHRoaXMucGF0aCx7XCJkXCI6bWFrZVBhdGgocGFyYW1zLmQpLFwiY2xhc3NcIjpjbGF6eixzdHJva2U6cGFyYW1zLnN0cm9rZT9wYXJhbXMuc3Ryb2tlOm51bGwsZmlsbDpwYXJhbXMuZmlsbD9wYXJhbXMuZmlsbDpudWxsLHRyYW5zZm9ybTpcInRyYW5zbGF0ZShcIitvZmZzZXRbMF0rXCIsXCIrb2Zmc2V0WzFdK1wiKVwifSk7fX07dmFyIG1ha2VQYXRoPWZ1bmN0aW9uIG1ha2VQYXRoKGQpe3JldHVybiBpc05hTihkLmN4eS54KXx8aXNOYU4oZC5jeHkueSk/XCJcIjpcIk1cIitkLmh4eS54K1wiLFwiK2QuaHh5LnkrXCIgTFwiK2QudGFpbFswXS54K1wiLFwiK2QudGFpbFswXS55K1wiIExcIitkLmN4eS54K1wiLFwiK2QuY3h5LnkrXCIgTFwiK2QudGFpbFsxXS54K1wiLFwiK2QudGFpbFsxXS55K1wiIExcIitkLmh4eS54K1wiLFwiK2QuaHh5Lnk7fTt0aGlzLnRyYW5zZmVyPWZ1bmN0aW9uKHRhcmdldCl7aWYodGFyZ2V0LmNhbnZhcyYmdGhpcy5wYXRoJiZ0aGlzLnBhdGgucGFyZW50Tm9kZSl7dGhpcy5wYXRoLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5wYXRoKTt0YXJnZXQuY2FudmFzLmFwcGVuZENoaWxkKHRoaXMucGF0aCk7fX07fTtfanUuZXh0ZW5kKEFic3RyYWN0U3ZnQXJyb3dPdmVybGF5LFtfanAuanNQbHVtYlVJQ29tcG9uZW50LF9qcC5PdmVybGF5cy5BYnN0cmFjdE92ZXJsYXldLHtjbGVhbnVwOmZ1bmN0aW9uIGNsZWFudXAoZm9yY2Upe2lmKHRoaXMucGF0aCE9bnVsbCl7aWYoZm9yY2Upe3RoaXMuX2pzUGx1bWIuaW5zdGFuY2UucmVtb3ZlRWxlbWVudCh0aGlzLnBhdGgpO31lbHNle2lmKHRoaXMucGF0aC5wYXJlbnROb2RlKXt0aGlzLnBhdGgucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBhdGgpO319fX0scmVhdHRhY2g6ZnVuY3Rpb24gcmVhdHRhY2goaW5zdGFuY2UsY29tcG9uZW50KXtpZih0aGlzLnBhdGgmJmNvbXBvbmVudC5jYW52YXMpe2NvbXBvbmVudC5jYW52YXMuYXBwZW5kQ2hpbGQodGhpcy5wYXRoKTt9fSxzZXRWaXNpYmxlOmZ1bmN0aW9uIHNldFZpc2libGUodil7aWYodGhpcy5wYXRoIT1udWxsKXt0aGlzLnBhdGguc3R5bGUuZGlzcGxheT12P1wiYmxvY2tcIjpcIm5vbmVcIjt9fX0pO19qcC5PdmVybGF5cy5zdmcuQXJyb3c9ZnVuY3Rpb24oKXtBYnN0cmFjdFN2Z0Fycm93T3ZlcmxheS5hcHBseSh0aGlzLFtfanAuT3ZlcmxheXMuQXJyb3csYXJndW1lbnRzXSk7fTtfanUuZXh0ZW5kKF9qcC5PdmVybGF5cy5zdmcuQXJyb3csW19qcC5PdmVybGF5cy5BcnJvdyxBYnN0cmFjdFN2Z0Fycm93T3ZlcmxheV0pO19qcC5PdmVybGF5cy5zdmcuUGxhaW5BcnJvdz1mdW5jdGlvbigpe0Fic3RyYWN0U3ZnQXJyb3dPdmVybGF5LmFwcGx5KHRoaXMsW19qcC5PdmVybGF5cy5QbGFpbkFycm93LGFyZ3VtZW50c10pO307X2p1LmV4dGVuZChfanAuT3ZlcmxheXMuc3ZnLlBsYWluQXJyb3csW19qcC5PdmVybGF5cy5QbGFpbkFycm93LEFic3RyYWN0U3ZnQXJyb3dPdmVybGF5XSk7X2pwLk92ZXJsYXlzLnN2Zy5EaWFtb25kPWZ1bmN0aW9uKCl7QWJzdHJhY3RTdmdBcnJvd092ZXJsYXkuYXBwbHkodGhpcyxbX2pwLk92ZXJsYXlzLkRpYW1vbmQsYXJndW1lbnRzXSk7fTtfanUuZXh0ZW5kKF9qcC5PdmVybGF5cy5zdmcuRGlhbW9uZCxbX2pwLk92ZXJsYXlzLkRpYW1vbmQsQWJzdHJhY3RTdmdBcnJvd092ZXJsYXldKTsvLyBhIHRlc3Rcbl9qcC5PdmVybGF5cy5zdmcuR3VpZGVMaW5lcz1mdW5jdGlvbigpe3ZhciBwYXRoPW51bGwsc2VsZj10aGlzLHAxXzEscDFfMjtfanAuT3ZlcmxheXMuR3VpZGVMaW5lcy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dGhpcy5wYWludD1mdW5jdGlvbihwYXJhbXMsY29udGFpbmVyRXh0ZW50cyl7aWYocGF0aD09bnVsbCl7cGF0aD1fbm9kZShcInBhdGhcIik7cGFyYW1zLmNvbm5lY3Rvci5zdmcuYXBwZW5kQ2hpbGQocGF0aCk7c2VsZi5hdHRhY2hMaXN0ZW5lcnMocGF0aCxwYXJhbXMuY29ubmVjdG9yKTtzZWxmLmF0dGFjaExpc3RlbmVycyhwYXRoLHNlbGYpO3AxXzE9X25vZGUoXCJwYXRoXCIpO3BhcmFtcy5jb25uZWN0b3Iuc3ZnLmFwcGVuZENoaWxkKHAxXzEpO3NlbGYuYXR0YWNoTGlzdGVuZXJzKHAxXzEscGFyYW1zLmNvbm5lY3Rvcik7c2VsZi5hdHRhY2hMaXN0ZW5lcnMocDFfMSxzZWxmKTtwMV8yPV9ub2RlKFwicGF0aFwiKTtwYXJhbXMuY29ubmVjdG9yLnN2Zy5hcHBlbmRDaGlsZChwMV8yKTtzZWxmLmF0dGFjaExpc3RlbmVycyhwMV8yLHBhcmFtcy5jb25uZWN0b3IpO3NlbGYuYXR0YWNoTGlzdGVuZXJzKHAxXzIsc2VsZik7fXZhciBvZmZzZXQ9WzAsMF07aWYoY29udGFpbmVyRXh0ZW50cy54bWluPDApe29mZnNldFswXT0tY29udGFpbmVyRXh0ZW50cy54bWluO31pZihjb250YWluZXJFeHRlbnRzLnltaW48MCl7b2Zmc2V0WzFdPS1jb250YWluZXJFeHRlbnRzLnltaW47fV9hdHRyKHBhdGgse1wiZFwiOm1ha2VQYXRoKHBhcmFtcy5oZWFkLHBhcmFtcy50YWlsKSxzdHJva2U6XCJyZWRcIixmaWxsOm51bGwsdHJhbnNmb3JtOlwidHJhbnNsYXRlKFwiK29mZnNldFswXStcIixcIitvZmZzZXRbMV0rXCIpXCJ9KTtfYXR0cihwMV8xLHtcImRcIjptYWtlUGF0aChwYXJhbXMudGFpbExpbmVbMF0scGFyYW1zLnRhaWxMaW5lWzFdKSxzdHJva2U6XCJibHVlXCIsZmlsbDpudWxsLHRyYW5zZm9ybTpcInRyYW5zbGF0ZShcIitvZmZzZXRbMF0rXCIsXCIrb2Zmc2V0WzFdK1wiKVwifSk7X2F0dHIocDFfMix7XCJkXCI6bWFrZVBhdGgocGFyYW1zLmhlYWRMaW5lWzBdLHBhcmFtcy5oZWFkTGluZVsxXSksc3Ryb2tlOlwiZ3JlZW5cIixmaWxsOm51bGwsdHJhbnNmb3JtOlwidHJhbnNsYXRlKFwiK29mZnNldFswXStcIixcIitvZmZzZXRbMV0rXCIpXCJ9KTt9O3ZhciBtYWtlUGF0aD1mdW5jdGlvbiBtYWtlUGF0aChkMSxkMil7cmV0dXJuXCJNIFwiK2QxLngrXCIsXCIrZDEueStcIiBMXCIrZDIueCtcIixcIitkMi55O307fTtfanUuZXh0ZW5kKF9qcC5PdmVybGF5cy5zdmcuR3VpZGVMaW5lcyxfanAuT3ZlcmxheXMuR3VpZGVMaW5lcyk7fSkuY2FsbCh0eXBlb2Ygd2luZG93IT09J3VuZGVmaW5lZCc/d2luZG93OnRoaXMpOy8qXHJcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUgJ3ZhbmlsbGEnIGFkYXB0ZXIgLSBoYXZpbmcgbm8gZXh0ZXJuYWwgZGVwZW5kZW5jaWVzIG90aGVyIHRoYW4gYnVuZGxlZCBsaWJzLlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgLSAyMDE4IGpzUGx1bWIgKGhlbGxvQGpzcGx1bWJ0b29sa2l0LmNvbSlcclxuICogXHJcbiAqIGh0dHBzOi8vanNwbHVtYnRvb2xraXQuY29tXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qc3BsdW1iL2pzcGx1bWJcclxuICogXHJcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMMiBsaWNlbnNlcy5cclxuICovOyhmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3ZhciByb290PXRoaXMsX2pwPXJvb3QuanNQbHVtYixfanU9cm9vdC5qc1BsdW1iVXRpbCxfams9cm9vdC5LYXRhdm9yaW8sX2pnPXJvb3QuQmlsdG9uZzt2YXIgX2dldERyYWdNYW5hZ2VyPWZ1bmN0aW9uIF9nZXREcmFnTWFuYWdlcihpbnN0YW5jZSxjYXRlZ29yeSl7Y2F0ZWdvcnk9Y2F0ZWdvcnl8fFwibWFpblwiO3ZhciBrZXk9XCJfa2F0YXZvcmlvX1wiK2NhdGVnb3J5O3ZhciBrPWluc3RhbmNlW2tleV0sZT1pbnN0YW5jZS5nZXRFdmVudE1hbmFnZXIoKTtpZighayl7az1uZXcgX2prKHtiaW5kOmUub24sdW5iaW5kOmUub2ZmLGdldFNpemU6X2pwLmdldFNpemUsZ2V0Q29uc3RyYWluaW5nUmVjdGFuZ2xlOmZ1bmN0aW9uIGdldENvbnN0cmFpbmluZ1JlY3RhbmdsZShlbCl7cmV0dXJuW2VsLnBhcmVudE5vZGUuc2Nyb2xsV2lkdGgsZWwucGFyZW50Tm9kZS5zY3JvbGxIZWlnaHRdO30sZ2V0UG9zaXRpb246ZnVuY3Rpb24gZ2V0UG9zaXRpb24oZWwscmVsYXRpdmVUb1Jvb3Qpey8vIGlmIHRoaXMgaXMgYSBuZXN0ZWQgZHJhZ2dhYmxlIHRoZW4gY29tcHV0ZSB0aGUgb2Zmc2V0IGFnYWluc3QgaXRzIG93biBvZmZzZXRQYXJlbnQsIG90aGVyd2lzZVxuLy8gY29tcHV0ZSBhZ2FpbnN0IHRoZSBDb250YWluZXIncyBvcmlnaW4uIHNlZSBhbHNvIHRoZSBnZXRVSVBvc2l0aW9uIG1ldGhvZCBiZWxvdy5cbnZhciBvPWluc3RhbmNlLmdldE9mZnNldChlbCxyZWxhdGl2ZVRvUm9vdCxlbC5fa2F0YXZvcmlvRHJhZz9lbC5vZmZzZXRQYXJlbnQ6bnVsbCk7cmV0dXJuW28ubGVmdCxvLnRvcF07fSxzZXRQb3NpdGlvbjpmdW5jdGlvbiBzZXRQb3NpdGlvbihlbCx4eSl7ZWwuc3R5bGUubGVmdD14eVswXStcInB4XCI7ZWwuc3R5bGUudG9wPXh5WzFdK1wicHhcIjt9LGFkZENsYXNzOl9qcC5hZGRDbGFzcyxyZW1vdmVDbGFzczpfanAucmVtb3ZlQ2xhc3MsaW50ZXJzZWN0czpfamcuaW50ZXJzZWN0cyxpbmRleE9mOmZ1bmN0aW9uIGluZGV4T2YobCxpKXtyZXR1cm4gbC5pbmRleE9mKGkpO30sc2NvcGU6aW5zdGFuY2UuZ2V0RGVmYXVsdFNjb3BlKCksY3NzOntub1NlbGVjdDppbnN0YW5jZS5kcmFnU2VsZWN0Q2xhc3MsZHJvcHBhYmxlOlwianRrLWRyb3BwYWJsZVwiLGRyYWdnYWJsZTpcImp0ay1kcmFnZ2FibGVcIixkcmFnOlwianRrLWRyYWdcIixzZWxlY3RlZDpcImp0ay1kcmFnLXNlbGVjdGVkXCIsYWN0aXZlOlwianRrLWRyYWctYWN0aXZlXCIsaG92ZXI6XCJqdGstZHJhZy1ob3ZlclwiLGdob3N0UHJveHk6XCJqdGstZ2hvc3QtcHJveHlcIn19KTtrLnNldFpvb20oaW5zdGFuY2UuZ2V0Wm9vbSgpKTtpbnN0YW5jZVtrZXldPWs7aW5zdGFuY2UuYmluZChcInpvb21cIixrLnNldFpvb20pO31yZXR1cm4gazt9O3ZhciBfYW5pbVByb3BzPWZ1bmN0aW9uIF9hbmltUHJvcHMobyxwKXt2YXIgX29uZT1mdW5jdGlvbiBfb25lKHBOYW1lKXtpZihwW3BOYW1lXSE9bnVsbCl7aWYoX2p1LmlzU3RyaW5nKHBbcE5hbWVdKSl7dmFyIG09cFtwTmFtZV0ubWF0Y2goLy09Lyk/LTE6MSx2PXBbcE5hbWVdLnN1YnN0cmluZygyKTtyZXR1cm4gb1twTmFtZV0rbSp2O31lbHNle3JldHVybiBwW3BOYW1lXTt9fWVsc2V7cmV0dXJuIG9bcE5hbWVdO319O3JldHVybltfb25lKFwibGVmdFwiKSxfb25lKFwidG9wXCIpXTt9O19qcC5leHRlbmQocm9vdC5qc1BsdW1iSW5zdGFuY2UucHJvdG90eXBlLHthbmltYXRpb25TdXBwb3J0ZWQ6dHJ1ZSxnZXRFbGVtZW50OmZ1bmN0aW9uIGdldEVsZW1lbnQoZWwpe2lmKGVsPT1udWxsKXtyZXR1cm4gbnVsbDt9Ly8gaGVyZSB3ZSBwbHVjayB0aGUgZmlyc3QgZW50cnkgaWYgZWwgd2FzIGEgbGlzdCBvZiBlbnRyaWVzLlxuLy8gdGhpcyBpcyBub3QgbXkgZmF2b3VyaXRlIHRoaW5nIHRvIGRvLCBidXQgcHJldmlvdXMgdmVyc2lvbnMgb2Zcbi8vIGpzcGx1bWIgc3VwcG9ydGVkIGpxdWVyeSBzZWxlY3RvcnMsIGFuZCBpdCBpcyBwb3NzaWJsZSBhIHNlbGVjdG9yXG4vLyB3aWxsIGJlIHBhc3NlZCBpbiBoZXJlLlxuZWw9dHlwZW9mIGVsPT09XCJzdHJpbmdcIj9lbDplbC5sZW5ndGghPW51bGwmJmVsLmVuY3R5cGU9PW51bGw/ZWxbMF06ZWw7cmV0dXJuIHR5cGVvZiBlbD09PVwic3RyaW5nXCI/ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWwpOmVsO30scmVtb3ZlRWxlbWVudDpmdW5jdGlvbiByZW1vdmVFbGVtZW50KGVsZW1lbnQpe19nZXREcmFnTWFuYWdlcih0aGlzKS5lbGVtZW50UmVtb3ZlZChlbGVtZW50KTt0aGlzLmdldEV2ZW50TWFuYWdlcigpLnJlbW92ZShlbGVtZW50KTt9LC8vXG4vLyB0aGlzIGFkYXB0ZXIgc3VwcG9ydHMgYSBydWRpbWVudGFyeSBhbmltYXRpb24gZnVuY3Rpb24uIG5vIGVhc2luZyBpcyBzdXBwb3J0ZWQuICBvbmx5XG4vLyBsZWZ0L3RvcCBwcm9wZXJ0aWVzIGFyZSBzdXBwb3J0ZWQuIHByb3BlcnR5IGRlbHRhIGFyZ3MgYXJlIGV4cGVjdGVkIHRvIGJlIGluIHRoZSBmb3JtXG4vL1xuLy8gKz14Lnh4eHhcbi8vXG4vLyBvclxuLy9cbi8vIC09eC54eHh4XG4vL1xuZG9BbmltYXRlOmZ1bmN0aW9uIGRvQW5pbWF0ZShlbCxwcm9wZXJ0aWVzLG9wdGlvbnMpe29wdGlvbnM9b3B0aW9uc3x8e307dmFyIG89dGhpcy5nZXRPZmZzZXQoZWwpLGFwPV9hbmltUHJvcHMobyxwcm9wZXJ0aWVzKSxsZGlzdD1hcFswXS1vLmxlZnQsdGRpc3Q9YXBbMV0tby50b3AsZD1vcHRpb25zLmR1cmF0aW9ufHwyNTAsc3RlcD0xNSxzdGVwcz1kL3N0ZXAsbGluYz1zdGVwL2QqbGRpc3QsdGluYz1zdGVwL2QqdGRpc3QsaWR4PTAsX2ludD1zZXRJbnRlcnZhbChmdW5jdGlvbigpe19qcC5zZXRQb3NpdGlvbihlbCx7bGVmdDpvLmxlZnQrbGluYyooaWR4KzEpLHRvcDpvLnRvcCt0aW5jKihpZHgrMSl9KTtpZihvcHRpb25zLnN0ZXAhPW51bGwpe29wdGlvbnMuc3RlcChpZHgsTWF0aC5jZWlsKHN0ZXBzKSk7fWlkeCsrO2lmKGlkeD49c3RlcHMpe3dpbmRvdy5jbGVhckludGVydmFsKF9pbnQpO2lmKG9wdGlvbnMuY29tcGxldGUhPW51bGwpe29wdGlvbnMuY29tcGxldGUoKTt9fX0sc3RlcCk7fSwvLyBEUkFHL0RST1BcbmRlc3Ryb3lEcmFnZ2FibGU6ZnVuY3Rpb24gZGVzdHJveURyYWdnYWJsZShlbCxjYXRlZ29yeSl7X2dldERyYWdNYW5hZ2VyKHRoaXMsY2F0ZWdvcnkpLmRlc3Ryb3lEcmFnZ2FibGUoZWwpO30sdW5iaW5kRHJhZ2dhYmxlOmZ1bmN0aW9uIHVuYmluZERyYWdnYWJsZShlbCxldnQsZm4sY2F0ZWdvcnkpe19nZXREcmFnTWFuYWdlcih0aGlzLGNhdGVnb3J5KS5kZXN0cm95RHJhZ2dhYmxlKGVsLGV2dCxmbik7fSxkZXN0cm95RHJvcHBhYmxlOmZ1bmN0aW9uIGRlc3Ryb3lEcm9wcGFibGUoZWwsY2F0ZWdvcnkpe19nZXREcmFnTWFuYWdlcih0aGlzLGNhdGVnb3J5KS5kZXN0cm95RHJvcHBhYmxlKGVsKTt9LHVuYmluZERyb3BwYWJsZTpmdW5jdGlvbiB1bmJpbmREcm9wcGFibGUoZWwsZXZ0LGZuLGNhdGVnb3J5KXtfZ2V0RHJhZ01hbmFnZXIodGhpcyxjYXRlZ29yeSkuZGVzdHJveURyb3BwYWJsZShlbCxldnQsZm4pO30saW5pdERyYWdnYWJsZTpmdW5jdGlvbiBpbml0RHJhZ2dhYmxlKGVsLG9wdGlvbnMsY2F0ZWdvcnkpe19nZXREcmFnTWFuYWdlcih0aGlzLGNhdGVnb3J5KS5kcmFnZ2FibGUoZWwsb3B0aW9ucyk7fSxpbml0RHJvcHBhYmxlOmZ1bmN0aW9uIGluaXREcm9wcGFibGUoZWwsb3B0aW9ucyxjYXRlZ29yeSl7X2dldERyYWdNYW5hZ2VyKHRoaXMsY2F0ZWdvcnkpLmRyb3BwYWJsZShlbCxvcHRpb25zKTt9LGlzQWxyZWFkeURyYWdnYWJsZTpmdW5jdGlvbiBpc0FscmVhZHlEcmFnZ2FibGUoZWwpe3JldHVybiBlbC5fa2F0YXZvcmlvRHJhZyE9bnVsbDt9LGlzRHJhZ1N1cHBvcnRlZDpmdW5jdGlvbiBpc0RyYWdTdXBwb3J0ZWQoZWwsb3B0aW9ucyl7cmV0dXJuIHRydWU7fSxpc0Ryb3BTdXBwb3J0ZWQ6ZnVuY3Rpb24gaXNEcm9wU3VwcG9ydGVkKGVsLG9wdGlvbnMpe3JldHVybiB0cnVlO30saXNFbGVtZW50RHJhZ2dhYmxlOmZ1bmN0aW9uIGlzRWxlbWVudERyYWdnYWJsZShlbCl7ZWw9X2pwLmdldEVsZW1lbnQoZWwpO3JldHVybiBlbC5fa2F0YXZvcmlvRHJhZyYmZWwuX2thdGF2b3Jpb0RyYWcuaXNFbmFibGVkKCk7fSxnZXREcmFnT2JqZWN0OmZ1bmN0aW9uIGdldERyYWdPYmplY3QoZXZlbnRBcmdzKXtyZXR1cm4gZXZlbnRBcmdzWzBdLmRyYWcuZ2V0RHJhZ0VsZW1lbnQoKTt9LGdldERyYWdTY29wZTpmdW5jdGlvbiBnZXREcmFnU2NvcGUoZWwpe3JldHVybiBlbC5fa2F0YXZvcmlvRHJhZyYmZWwuX2thdGF2b3Jpb0RyYWcuc2NvcGVzLmpvaW4oXCIgXCIpfHxcIlwiO30sZ2V0RHJvcEV2ZW50OmZ1bmN0aW9uIGdldERyb3BFdmVudChhcmdzKXtyZXR1cm4gYXJnc1swXS5lO30sZ2V0VUlQb3NpdGlvbjpmdW5jdGlvbiBnZXRVSVBvc2l0aW9uKGV2ZW50QXJncyx6b29tKXsvLyBoZXJlIHRoZSBwb3NpdGlvbiByZXBvcnRlZCB0byB1cyBieSBLYXRhdm9yaW8gaXMgcmVsYXRpdmUgdG8gdGhlIGVsZW1lbnQncyBvZmZzZXRQYXJlbnQuIEZvciB0b3Bcbi8vIGxldmVsIG5vZGVzIHRoYXQgaXMgZmluZSwgYnV0IGlmIHdlIGhhdmUgYSBuZXN0ZWQgZHJhZ2dhYmxlIHRoZW4gaXRzIG9mZnNldFBhcmVudCBpcyBhY3R1YWxseVxuLy8gbm90IGdvaW5nIHRvIGJlIHRoZSBqc3BsdW1iIGNvbnRhaW5lcjsgaXQncyBnb2luZyB0byBiZSBzb21lIGNoaWxkIG9mIHRoYXQgZWxlbWVudC4gSW4gdGhhdCBjYXNlXG4vLyB3ZSB3YW50IHRvIGFkanVzdCB0aGUgVUkgcG9zaXRpb24gdG8gYWNjb3VudCBmb3IgdGhlIG9mZnNldFBhcmVudCdzIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBDb250YWluZXJcbi8vIG9yaWdpbi5cbnZhciBlbD1ldmVudEFyZ3NbMF0uZWw7aWYoZWwub2Zmc2V0UGFyZW50PT1udWxsKXtyZXR1cm4gbnVsbDt9dmFyIGZpbmFsUG9zPWV2ZW50QXJnc1swXS5maW5hbFBvc3x8ZXZlbnRBcmdzWzBdLnBvczt2YXIgcD17bGVmdDpmaW5hbFBvc1swXSx0b3A6ZmluYWxQb3NbMV19O2lmKGVsLl9rYXRhdm9yaW9EcmFnJiZlbC5vZmZzZXRQYXJlbnQhPT10aGlzLmdldENvbnRhaW5lcigpKXt2YXIgb2M9dGhpcy5nZXRPZmZzZXQoZWwub2Zmc2V0UGFyZW50KTtwLmxlZnQrPW9jLmxlZnQ7cC50b3ArPW9jLnRvcDt9cmV0dXJuIHA7fSxzZXREcmFnRmlsdGVyOmZ1bmN0aW9uIHNldERyYWdGaWx0ZXIoZWwsZmlsdGVyLF9leGNsdWRlKXtpZihlbC5fa2F0YXZvcmlvRHJhZyl7ZWwuX2thdGF2b3Jpb0RyYWcuc2V0RmlsdGVyKGZpbHRlcixfZXhjbHVkZSk7fX0sc2V0RWxlbWVudERyYWdnYWJsZTpmdW5jdGlvbiBzZXRFbGVtZW50RHJhZ2dhYmxlKGVsLGRyYWdnYWJsZSl7ZWw9X2pwLmdldEVsZW1lbnQoZWwpO2lmKGVsLl9rYXRhdm9yaW9EcmFnKXtlbC5fa2F0YXZvcmlvRHJhZy5zZXRFbmFibGVkKGRyYWdnYWJsZSk7fX0sc2V0RHJhZ1Njb3BlOmZ1bmN0aW9uIHNldERyYWdTY29wZShlbCxzY29wZSl7aWYoZWwuX2thdGF2b3Jpb0RyYWcpe2VsLl9rYXRhdm9yaW9EcmFnLmsuc2V0RHJhZ1Njb3BlKGVsLHNjb3BlKTt9fSxzZXREcm9wU2NvcGU6ZnVuY3Rpb24gc2V0RHJvcFNjb3BlKGVsLHNjb3BlKXtpZihlbC5fa2F0YXZvcmlvRHJvcCYmZWwuX2thdGF2b3Jpb0Ryb3AubGVuZ3RoPjApe2VsLl9rYXRhdm9yaW9Ecm9wWzBdLmsuc2V0RHJvcFNjb3BlKGVsLHNjb3BlKTt9fSxhZGRUb1Bvc3NlOmZ1bmN0aW9uIGFkZFRvUG9zc2UoZWwsc3BlYyl7dmFyIHNwZWNzPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKTt2YXIgZG09X2dldERyYWdNYW5hZ2VyKHRoaXMpO19qcC5lYWNoKGVsLGZ1bmN0aW9uKF9lbCl7X2VsPVtfanAuZ2V0RWxlbWVudChfZWwpXTtfZWwucHVzaC5hcHBseShfZWwsc3BlY3MpO2RtLmFkZFRvUG9zc2UuYXBwbHkoZG0sX2VsKTt9KTt9LHNldFBvc3NlOmZ1bmN0aW9uIHNldFBvc3NlKGVsLHNwZWMpe3ZhciBzcGVjcz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSk7dmFyIGRtPV9nZXREcmFnTWFuYWdlcih0aGlzKTtfanAuZWFjaChlbCxmdW5jdGlvbihfZWwpe19lbD1bX2pwLmdldEVsZW1lbnQoX2VsKV07X2VsLnB1c2guYXBwbHkoX2VsLHNwZWNzKTtkbS5zZXRQb3NzZS5hcHBseShkbSxfZWwpO30pO30scmVtb3ZlRnJvbVBvc3NlOmZ1bmN0aW9uIHJlbW92ZUZyb21Qb3NzZShlbCxwb3NzZUlkKXt2YXIgc3BlY3M9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpO3ZhciBkbT1fZ2V0RHJhZ01hbmFnZXIodGhpcyk7X2pwLmVhY2goZWwsZnVuY3Rpb24oX2VsKXtfZWw9W19qcC5nZXRFbGVtZW50KF9lbCldO19lbC5wdXNoLmFwcGx5KF9lbCxzcGVjcyk7ZG0ucmVtb3ZlRnJvbVBvc3NlLmFwcGx5KGRtLF9lbCk7fSk7fSxyZW1vdmVGcm9tQWxsUG9zc2VzOmZ1bmN0aW9uIHJlbW92ZUZyb21BbGxQb3NzZXMoZWwpe3ZhciBkbT1fZ2V0RHJhZ01hbmFnZXIodGhpcyk7X2pwLmVhY2goZWwsZnVuY3Rpb24oX2VsKXtkbS5yZW1vdmVGcm9tQWxsUG9zc2VzKF9qcC5nZXRFbGVtZW50KF9lbCkpO30pO30sc2V0UG9zc2VTdGF0ZTpmdW5jdGlvbiBzZXRQb3NzZVN0YXRlKGVsLHBvc3NlSWQsc3RhdGUpe3ZhciBkbT1fZ2V0RHJhZ01hbmFnZXIodGhpcyk7X2pwLmVhY2goZWwsZnVuY3Rpb24oX2VsKXtkbS5zZXRQb3NzZVN0YXRlKF9qcC5nZXRFbGVtZW50KF9lbCkscG9zc2VJZCxzdGF0ZSk7fSk7fSxkcmFnRXZlbnRzOnsnc3RhcnQnOidzdGFydCcsJ3N0b3AnOidzdG9wJywnZHJhZyc6J2RyYWcnLCdzdGVwJzonc3RlcCcsJ292ZXInOidvdmVyJywnb3V0Jzonb3V0JywnZHJvcCc6J2Ryb3AnLCdjb21wbGV0ZSc6J2NvbXBsZXRlJywnYmVmb3JlU3RhcnQnOidiZWZvcmVTdGFydCd9LGFuaW1FdmVudHM6eydzdGVwJzpcInN0ZXBcIiwnY29tcGxldGUnOidjb21wbGV0ZSd9LHN0b3BEcmFnOmZ1bmN0aW9uIHN0b3BEcmFnKGVsKXtpZihlbC5fa2F0YXZvcmlvRHJhZyl7ZWwuX2thdGF2b3Jpb0RyYWcuYWJvcnQoKTt9fSxhZGRUb0RyYWdTZWxlY3Rpb246ZnVuY3Rpb24gYWRkVG9EcmFnU2VsZWN0aW9uKHNwZWMpe19nZXREcmFnTWFuYWdlcih0aGlzKS5zZWxlY3Qoc3BlYyk7fSxyZW1vdmVGcm9tRHJhZ1NlbGVjdGlvbjpmdW5jdGlvbiByZW1vdmVGcm9tRHJhZ1NlbGVjdGlvbihzcGVjKXtfZ2V0RHJhZ01hbmFnZXIodGhpcykuZGVzZWxlY3Qoc3BlYyk7fSxjbGVhckRyYWdTZWxlY3Rpb246ZnVuY3Rpb24gY2xlYXJEcmFnU2VsZWN0aW9uKCl7X2dldERyYWdNYW5hZ2VyKHRoaXMpLmRlc2VsZWN0QWxsKCk7fSx0cmlnZ2VyOmZ1bmN0aW9uIHRyaWdnZXIoZWwsZXZlbnQsb3JpZ2luYWxFdmVudCxwYXlsb2FkKXt0aGlzLmdldEV2ZW50TWFuYWdlcigpLnRyaWdnZXIoZWwsZXZlbnQsb3JpZ2luYWxFdmVudCxwYXlsb2FkKTt9LGRvUmVzZXQ6ZnVuY3Rpb24gZG9SZXNldCgpey8vIGxvb2sgZm9yIGthdGF2b3JpbyBpbnN0YW5jZXMgYW5kIHJlc2V0IGVhY2ggb25lIGlmIGZvdW5kLlxuZm9yKHZhciBrZXkgaW4gdGhpcyl7aWYoa2V5LmluZGV4T2YoXCJfa2F0YXZvcmlvX1wiKT09PTApe3RoaXNba2V5XS5yZXNldCgpO319fX0pO3ZhciByZWFkeT1mdW5jdGlvbiByZWFkeShmKXt2YXIgX2RvPWZ1bmN0aW9uIF9kbygpe2lmKC9jb21wbGV0ZXxsb2FkZWR8aW50ZXJhY3RpdmUvLnRlc3QoZG9jdW1lbnQucmVhZHlTdGF0ZSkmJnR5cGVvZiBkb2N1bWVudC5ib2R5IT09XCJ1bmRlZmluZWRcIiYmZG9jdW1lbnQuYm9keSE9bnVsbCl7ZigpO31lbHNle3NldFRpbWVvdXQoX2RvLDkpO319O19kbygpO307cmVhZHkoX2pwLmluaXQpO30pLmNhbGwodHlwZW9mIHdpbmRvdyE9PSd1bmRlZmluZWQnP3dpbmRvdzp0aGlzKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvcmUvY2hhcnQvanNQbHVtYi5qc1xuLy8gbW9kdWxlIGlkID0gMTYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///160\n')},161:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_chart_chartNode_js__ = __webpack_require__(85);\n\n\nvar chartNodeBase = function chartNodeBase(nodeId, options) {\n    __WEBPACK_IMPORTED_MODULE_0__core_chart_chartNode_js__["a" /* default */].call(this, nodeId, options);\n\n    this.addSmallPort = function (options) {\n        var pos = options.position || \'Bottom\';\n\n        var strokeColor = pos === \'Top\' ? "#f65d3b" : \'#1fb139\';\n        var cssClass = pos === \'Top\' ? "jspl-point-top" : \'jspl-point-bottom\';\n        var hoverClass = pos === \'TOP\' ? "jspl-point-top-hover2" : \'jspl-point-bottom-hover2\';\n\n        var endpointConf = {\n            endpoint: ["Dot", {\n                radius: 4,\n                cssClass: cssClass,\n                hoverClass: hoverClass\n            }],\n\n            paintStyle: this.optionStyle.getPaintStyle(strokeColor),\n            anchor: pos, //[pos, [0.5, 0, 0, -1]],\n            isSource: !!options.isSource,\n            isTarget: !!options.isTarget,\n            maxConnections: -1,\n            connector: this.optionStyle.connector,\n\n            connectorStyle: {\n                strokeWidth: 2,\n                joinstyle: "round",\n                stroke: "#1fb139"\n            },\n\n            dragOptions: options.dragOptions || {},\n\n            allowLoopback: false\n        };\n\n        this[pos + "Endpoint"] = this._jsPlumb.addEndpoint(this._el, endpointConf);\n    };\n\n    //线条事件\n    var connectorEvent = {\n        dblclickEvent: function dblclickEvent(connect, options) {\n            var _this = this;\n\n            connect.unbind(\'dblclick\').bind(\'dblclick\', function (e) {\n\n                if (options && options.connectorDblclick) {\n                    if (!options.connectorDblclick(e)) {\n                        return;\n                    }\n                }\n                _this.dblclick(e);\n            });\n        }\n    };\n    this.connectorEvent = $.extend(this.connectorEvent, connectorEvent);\n};\n\nchartNodeBase.prototype = new __WEBPACK_IMPORTED_MODULE_0__core_chart_chartNode_js__["a" /* default */]();\n\n/* harmony default export */ __webpack_exports__["a"] = (chartNodeBase);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc2NhZmYvY2hhcnQvYmFzZS9jaGFydE5vZGVCYXNlLmpzP2I0YzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNoYXJ0Tm9kZUNvcmUgZnJvbSBcIi4uLy4uLy4uL2NvcmUvY2hhcnQvY2hhcnROb2RlLmpzXCI7XG5cbnZhciBjaGFydE5vZGVCYXNlID0gZnVuY3Rpb24gY2hhcnROb2RlQmFzZShub2RlSWQsIG9wdGlvbnMpIHtcbiAgICBjaGFydE5vZGVDb3JlLmNhbGwodGhpcywgbm9kZUlkLCBvcHRpb25zKTtcblxuICAgIHRoaXMuYWRkU21hbGxQb3J0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHBvcyA9IG9wdGlvbnMucG9zaXRpb24gfHwgJ0JvdHRvbSc7XG5cbiAgICAgICAgdmFyIHN0cm9rZUNvbG9yID0gcG9zID09PSAnVG9wJyA/IFwiI2Y2NWQzYlwiIDogJyMxZmIxMzknO1xuICAgICAgICB2YXIgY3NzQ2xhc3MgPSBwb3MgPT09ICdUb3AnID8gXCJqc3BsLXBvaW50LXRvcFwiIDogJ2pzcGwtcG9pbnQtYm90dG9tJztcbiAgICAgICAgdmFyIGhvdmVyQ2xhc3MgPSBwb3MgPT09ICdUT1AnID8gXCJqc3BsLXBvaW50LXRvcC1ob3ZlcjJcIiA6ICdqc3BsLXBvaW50LWJvdHRvbS1ob3ZlcjInO1xuXG4gICAgICAgIHZhciBlbmRwb2ludENvbmYgPSB7XG4gICAgICAgICAgICBlbmRwb2ludDogW1wiRG90XCIsIHtcbiAgICAgICAgICAgICAgICByYWRpdXM6IDQsXG4gICAgICAgICAgICAgICAgY3NzQ2xhc3M6IGNzc0NsYXNzLFxuICAgICAgICAgICAgICAgIGhvdmVyQ2xhc3M6IGhvdmVyQ2xhc3NcbiAgICAgICAgICAgIH1dLFxuXG4gICAgICAgICAgICBwYWludFN0eWxlOiB0aGlzLm9wdGlvblN0eWxlLmdldFBhaW50U3R5bGUoc3Ryb2tlQ29sb3IpLFxuICAgICAgICAgICAgYW5jaG9yOiBwb3MsIC8vW3BvcywgWzAuNSwgMCwgMCwgLTFdXSxcbiAgICAgICAgICAgIGlzU291cmNlOiAhIW9wdGlvbnMuaXNTb3VyY2UsXG4gICAgICAgICAgICBpc1RhcmdldDogISFvcHRpb25zLmlzVGFyZ2V0LFxuICAgICAgICAgICAgbWF4Q29ubmVjdGlvbnM6IC0xLFxuICAgICAgICAgICAgY29ubmVjdG9yOiB0aGlzLm9wdGlvblN0eWxlLmNvbm5lY3RvcixcblxuICAgICAgICAgICAgY29ubmVjdG9yU3R5bGU6IHtcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogMixcbiAgICAgICAgICAgICAgICBqb2luc3R5bGU6IFwicm91bmRcIixcbiAgICAgICAgICAgICAgICBzdHJva2U6IFwiIzFmYjEzOVwiXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBkcmFnT3B0aW9uczogb3B0aW9ucy5kcmFnT3B0aW9ucyB8fCB7fSxcblxuICAgICAgICAgICAgYWxsb3dMb29wYmFjazogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzW3BvcyArIFwiRW5kcG9pbnRcIl0gPSB0aGlzLl9qc1BsdW1iLmFkZEVuZHBvaW50KHRoaXMuX2VsLCBlbmRwb2ludENvbmYpO1xuICAgIH07XG5cbiAgICAvL+e6v+adoeS6i+S7tlxuICAgIHZhciBjb25uZWN0b3JFdmVudCA9IHtcbiAgICAgICAgZGJsY2xpY2tFdmVudDogZnVuY3Rpb24gZGJsY2xpY2tFdmVudChjb25uZWN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgICAgICBjb25uZWN0LnVuYmluZCgnZGJsY2xpY2snKS5iaW5kKCdkYmxjbGljaycsIGZ1bmN0aW9uIChlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNvbm5lY3RvckRibGNsaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5jb25uZWN0b3JEYmxjbGljayhlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLmRibGNsaWNrKGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuY29ubmVjdG9yRXZlbnQgPSAkLmV4dGVuZCh0aGlzLmNvbm5lY3RvckV2ZW50LCBjb25uZWN0b3JFdmVudCk7XG59O1xuXG5jaGFydE5vZGVCYXNlLnByb3RvdHlwZSA9IG5ldyBjaGFydE5vZGVDb3JlKCk7XG5cbmV4cG9ydCBkZWZhdWx0IGNoYXJ0Tm9kZUJhc2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zY2FmZi9jaGFydC9iYXNlL2NoYXJ0Tm9kZUJhc2UuanNcbi8vIG1vZHVsZSBpZCA9IDE2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///161\n')},162:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* unused harmony export normal */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__crsBase_js__ = __webpack_require__(27);\n/* unused harmony reexport menuRegister */\n\n\n\nvar normal = function normal() {\n    __WEBPACK_IMPORTED_MODULE_0__crsBase_js__["a" /* menuBase */].call(this);\n\n    this.text = "普通计算";\n    this.procId = "normal";\n    this.parentId = "crs";\n\n    //自定义函数  画布在添加node时,设置节点样式\n    this.setNodeElement = function (data) {\n        var str = "<span class=\\"node-scatt node-blue\\"><i class=\\"fa fa-calculator\\"></i><b>" + data.status + "</b></span>";\n        return str;\n    };\n\n    this.scattData = {\n        status: "",\n\n        containerImage: "",\n        executorCpuRequirement: "",\n        executorMemRequirement: "",\n        json: {\n            a: 11,\n            result: false\n        }\n    };\n\n    this.scattHTML = "<div class=\\"params-content\\">\\n        <div class=\\"v-title\\">\\u666E\\u901A\\u8BA1\\u7B97</div>                \\n        <div class=\\"v-params\\">\\n            <span>\\u8BF4\\u660E</span>\\n            <div class=\\"v-params-value\\" @click=\\"aa\\">\\n                \\u8FD9\\u662F\\u63CF\\u8FF0~~~~~~~~{{json.result}}\\n            </div>\\n          \\n        </div>\\n    </div>\\n    <input v-model=\\"json.a\\" /> \\n    <div class=\\"params-content\\">\\n        <div class=\\"v-title\\">\\u7EC4\\u4EF6\\u53C2\\u6570</div>  \\n\\n        <div class=\\"v-params\\">\\n            <span>containerImage</span>\\n            <div class=\\"v-params-value\\">\\n                <input v-model=\\"containerImage\\" />\\n            </div>\\n        </div>\\n\\n        <div class=\\"v-params\\">\\n            <span>executorCpuRequirement</span>\\n            <div class=\\"v-params-value\\">\\n                <input v-model=\\"executorCpuRequirement\\" />\\n            </div>\\n        </div>\\n\\n        <div class=\\"v-params\\">\\n            <span>executorMemRequirement</span>\\n            <div class=\\"v-params-value\\">\\n                <input v-model=\\"executorMemRequirement\\" />\\n            </div>\\n        </div>\\n\\n    </div>\\n    \\n    ";\n};\n\n__WEBPACK_IMPORTED_MODULE_0__crsBase_js__["b" /* menuRegister */].add(normal);\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc2NhZmYvbWVudXMvY3JzQ2hpbGQvY29tbWVudHMvbm9ybWFsLmpzPzlmM2UiXSwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgeyBtZW51QmFzZSBhcyBtZW51QmFzZXMsIG1lbnVSZWdpc3RlciB9IGZyb20gJy4uL2Nyc0Jhc2UuanMnO1xuXG52YXIgbm9ybWFsID0gZnVuY3Rpb24gbm9ybWFsKCkge1xuICAgIG1lbnVCYXNlcy5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy50ZXh0ID0gXCLmma7pgJrorqHnrpdcIjtcbiAgICB0aGlzLnByb2NJZCA9IFwibm9ybWFsXCI7XG4gICAgdGhpcy5wYXJlbnRJZCA9IFwiY3JzXCI7XG5cbiAgICAvL+iHquWumuS5ieWHveaVsCAg55S75biD5Zyo5re75Yqgbm9kZeaXtizorr7nva7oioLngrnmoLflvI9cbiAgICB0aGlzLnNldE5vZGVFbGVtZW50ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHN0ciA9IFwiPHNwYW4gY2xhc3M9XFxcIm5vZGUtc2NhdHQgbm9kZS1ibHVlXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtY2FsY3VsYXRvclxcXCI+PC9pPjxiPlwiICsgZGF0YS5zdGF0dXMgKyBcIjwvYj48L3NwYW4+XCI7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcblxuICAgIHRoaXMuc2NhdHREYXRhID0ge1xuICAgICAgICBzdGF0dXM6IFwiXCIsXG5cbiAgICAgICAgY29udGFpbmVySW1hZ2U6IFwiXCIsXG4gICAgICAgIGV4ZWN1dG9yQ3B1UmVxdWlyZW1lbnQ6IFwiXCIsXG4gICAgICAgIGV4ZWN1dG9yTWVtUmVxdWlyZW1lbnQ6IFwiXCIsXG4gICAgICAgIGpzb246IHtcbiAgICAgICAgICAgIGE6IDExLFxuICAgICAgICAgICAgcmVzdWx0OiBmYWxzZVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuc2NhdHRIVE1MID0gXCI8ZGl2IGNsYXNzPVxcXCJwYXJhbXMtY29udGVudFxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ2LXRpdGxlXFxcIj5cXHU2NjZFXFx1OTAxQVxcdThCQTFcXHU3Qjk3PC9kaXY+ICAgICAgICAgICAgICAgIFxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidi1wYXJhbXNcXFwiPlxcbiAgICAgICAgICAgIDxzcGFuPlxcdThCRjRcXHU2NjBFPC9zcGFuPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInYtcGFyYW1zLXZhbHVlXFxcIiBAY2xpY2s9XFxcImFhXFxcIj5cXG4gICAgICAgICAgICAgICAgXFx1OEZEOVxcdTY2MkZcXHU2M0NGXFx1OEZGMH5+fn5+fn5+e3tqc29uLnJlc3VsdH19XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIFxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8aW5wdXQgdi1tb2RlbD1cXFwianNvbi5hXFxcIiAvPiBcXG4gICAgPGRpdiBjbGFzcz1cXFwicGFyYW1zLWNvbnRlbnRcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidi10aXRsZVxcXCI+XFx1N0VDNFxcdTRFRjZcXHU1M0MyXFx1NjU3MDwvZGl2PiAgXFxuXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ2LXBhcmFtc1xcXCI+XFxuICAgICAgICAgICAgPHNwYW4+Y29udGFpbmVySW1hZ2U8L3NwYW4+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidi1wYXJhbXMtdmFsdWVcXFwiPlxcbiAgICAgICAgICAgICAgICA8aW5wdXQgdi1tb2RlbD1cXFwiY29udGFpbmVySW1hZ2VcXFwiIC8+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInYtcGFyYW1zXFxcIj5cXG4gICAgICAgICAgICA8c3Bhbj5leGVjdXRvckNwdVJlcXVpcmVtZW50PC9zcGFuPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInYtcGFyYW1zLXZhbHVlXFxcIj5cXG4gICAgICAgICAgICAgICAgPGlucHV0IHYtbW9kZWw9XFxcImV4ZWN1dG9yQ3B1UmVxdWlyZW1lbnRcXFwiIC8+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInYtcGFyYW1zXFxcIj5cXG4gICAgICAgICAgICA8c3Bhbj5leGVjdXRvck1lbVJlcXVpcmVtZW50PC9zcGFuPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInYtcGFyYW1zLXZhbHVlXFxcIj5cXG4gICAgICAgICAgICAgICAgPGlucHV0IHYtbW9kZWw9XFxcImV4ZWN1dG9yTWVtUmVxdWlyZW1lbnRcXFwiIC8+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG5cXG4gICAgPC9kaXY+XFxuICAgIFxcbiAgICBcIjtcbn07XG5cbm1lbnVSZWdpc3Rlci5hZGQobm9ybWFsKTtcblxuZXhwb3J0IHsgbm9ybWFsLCBtZW51UmVnaXN0ZXIgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NjYWZmL21lbnVzL2Nyc0NoaWxkL2NvbW1lbnRzL25vcm1hbC5qc1xuLy8gbW9kdWxlIGlkID0gMTYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///162\n')},163:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* unused harmony export pySpark */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__crsBase_js__ = __webpack_require__(27);\n/* unused harmony reexport menuRegister */\n\n\n\nvar pySpark = function pySpark() {\n    __WEBPACK_IMPORTED_MODULE_0__crsBase_js__["a" /* menuBase */].call(this);\n\n    this.text = "pySpark";\n    this.procId = "pySpark";\n    this.parentId = "crs";\n\n    //自定义函数  画布在添加node时,设置节点样式\n    this.setNodeElement = function (data) {\n        var str = "<span class=\\"node-scatt node-blue\\"><i class=\\"fa fa-calculator\\"></i><b>" + data.status + "</b></span>";\n        return str;\n    };\n\n    this.scattData = {\n        status: "",\n\n        containerImage: "",\n        executorCpuRequirement: "",\n        executorMemRequirement: ""\n\n    };\n\n    this.scattHTML = "<div class=\\"params-content\\">\\n        <div class=\\"v-title\\">\\u7EC4\\u4EF6\\u53C2\\u6570</div>  \\n\\n        <div class=\\"v-params\\">\\n            <span>containerImage</span>\\n            <div class=\\"v-params-value\\">\\n                <input v-model=\\"containerImage\\" />\\n            </div>\\n        </div>\\n\\n        <div class=\\"v-params\\">\\n            <span>executorCpuRequirement</span>\\n            <div class=\\"v-params-value\\">\\n                <input v-model=\\"executorCpuRequirement\\" />\\n            </div>\\n        </div>\\n\\n        <div class=\\"v-params\\">\\n            <span>executorMemRequirement</span>\\n            <div class=\\"v-params-value\\">\\n                <input v-model=\\"executorMemRequirement\\" />\\n            </div>\\n        </div>\\n\\n    </div>\\n    \\n    ";\n};\n\n__WEBPACK_IMPORTED_MODULE_0__crsBase_js__["b" /* menuRegister */].add(pySpark);\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc2NhZmYvbWVudXMvY3JzQ2hpbGQvY29tbWVudHMvcHlTcGFyay5qcz9iMDM5Il0sInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHsgbWVudUJhc2UgYXMgbWVudUJhc2VzLCBtZW51UmVnaXN0ZXIgfSBmcm9tICcuLi9jcnNCYXNlLmpzJztcblxudmFyIHB5U3BhcmsgPSBmdW5jdGlvbiBweVNwYXJrKCkge1xuICAgIG1lbnVCYXNlcy5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy50ZXh0ID0gXCJweVNwYXJrXCI7XG4gICAgdGhpcy5wcm9jSWQgPSBcInB5U3BhcmtcIjtcbiAgICB0aGlzLnBhcmVudElkID0gXCJjcnNcIjtcblxuICAgIC8v6Ieq5a6a5LmJ5Ye95pWwICDnlLvluIPlnKjmt7vliqBub2Rl5pe2LOiuvue9ruiKgueCueagt+W8j1xuICAgIHRoaXMuc2V0Tm9kZUVsZW1lbnQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgc3RyID0gXCI8c3BhbiBjbGFzcz1cXFwibm9kZS1zY2F0dCBub2RlLWJsdWVcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1jYWxjdWxhdG9yXFxcIj48L2k+PGI+XCIgKyBkYXRhLnN0YXR1cyArIFwiPC9iPjwvc3Bhbj5cIjtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9O1xuXG4gICAgdGhpcy5zY2F0dERhdGEgPSB7XG4gICAgICAgIHN0YXR1czogXCJcIixcblxuICAgICAgICBjb250YWluZXJJbWFnZTogXCJcIixcbiAgICAgICAgZXhlY3V0b3JDcHVSZXF1aXJlbWVudDogXCJcIixcbiAgICAgICAgZXhlY3V0b3JNZW1SZXF1aXJlbWVudDogXCJcIlxuXG4gICAgfTtcblxuICAgIHRoaXMuc2NhdHRIVE1MID0gXCI8ZGl2IGNsYXNzPVxcXCJwYXJhbXMtY29udGVudFxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ2LXRpdGxlXFxcIj5cXHU3RUM0XFx1NEVGNlxcdTUzQzJcXHU2NTcwPC9kaXY+ICBcXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInYtcGFyYW1zXFxcIj5cXG4gICAgICAgICAgICA8c3Bhbj5jb250YWluZXJJbWFnZTwvc3Bhbj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ2LXBhcmFtcy12YWx1ZVxcXCI+XFxuICAgICAgICAgICAgICAgIDxpbnB1dCB2LW1vZGVsPVxcXCJjb250YWluZXJJbWFnZVxcXCIgLz5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidi1wYXJhbXNcXFwiPlxcbiAgICAgICAgICAgIDxzcGFuPmV4ZWN1dG9yQ3B1UmVxdWlyZW1lbnQ8L3NwYW4+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidi1wYXJhbXMtdmFsdWVcXFwiPlxcbiAgICAgICAgICAgICAgICA8aW5wdXQgdi1tb2RlbD1cXFwiZXhlY3V0b3JDcHVSZXF1aXJlbWVudFxcXCIgLz5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidi1wYXJhbXNcXFwiPlxcbiAgICAgICAgICAgIDxzcGFuPmV4ZWN1dG9yTWVtUmVxdWlyZW1lbnQ8L3NwYW4+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidi1wYXJhbXMtdmFsdWVcXFwiPlxcbiAgICAgICAgICAgICAgICA8aW5wdXQgdi1tb2RlbD1cXFwiZXhlY3V0b3JNZW1SZXF1aXJlbWVudFxcXCIgLz5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICA8L2Rpdj5cXG4gICAgXFxuICAgIFwiO1xufTtcblxubWVudVJlZ2lzdGVyLmFkZChweVNwYXJrKTtcblxuZXhwb3J0IHsgcHlTcGFyaywgbWVudVJlZ2lzdGVyIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zY2FmZi9tZW51cy9jcnNDaGlsZC9jb21tZW50cy9weVNwYXJrLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///163\n')},164:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* unused harmony export spark */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__crsBase_js__ = __webpack_require__(27);\n/* unused harmony reexport menuRegister */\n\n\n\nvar spark = function spark() {\n    __WEBPACK_IMPORTED_MODULE_0__crsBase_js__["a" /* menuBase */].call(this);\n\n    this.text = "spark";\n    this.procId = "spark";\n    this.parentId = "crs";\n\n    //自定义函数  画布在添加node时,设置节点样式\n    this.setNodeElement = function (data) {\n        return \'\';\n    };\n\n    this.scattData = {\n\n        containerImage: "",\n        executorCpuRequirement: "",\n        executorMemRequirement: ""\n\n    };\n\n    this.scattHTML = "<div class=\\"params-content\\">\\n        <div class=\\"v-title\\">\\u7EC4\\u4EF6\\u53C2\\u6570</div>  \\n\\n        <div class=\\"v-params\\">\\n            <span>containerImage</span>\\n            <div class=\\"v-params-value\\">\\n                <input v-model=\\"containerImage\\" />\\n            </div>\\n        </div>\\n\\n        <div class=\\"v-params\\">\\n            <span>executorCpuRequirement</span>\\n            <div class=\\"v-params-value\\">\\n                <input v-model=\\"executorCpuRequirement\\" />\\n            </div>\\n        </div>\\n\\n        <div class=\\"v-params\\">\\n            <span>executorMemRequirement</span>\\n            <div class=\\"v-params-value\\">\\n                <input v-model=\\"executorMemRequirement\\" />\\n            </div>\\n        </div>\\n\\n    </div>\\n    \\n    ";\n};\n\n__WEBPACK_IMPORTED_MODULE_0__crsBase_js__["b" /* menuRegister */].add(spark);\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc2NhZmYvbWVudXMvY3JzQ2hpbGQvY29tbWVudHMvc3BhcmsuanM/NWU0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IG1lbnVCYXNlIGFzIG1lbnVCYXNlcywgbWVudVJlZ2lzdGVyIH0gZnJvbSAnLi4vY3JzQmFzZS5qcyc7XG5cbnZhciBzcGFyayA9IGZ1bmN0aW9uIHNwYXJrKCkge1xuICAgIG1lbnVCYXNlcy5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy50ZXh0ID0gXCJzcGFya1wiO1xuICAgIHRoaXMucHJvY0lkID0gXCJzcGFya1wiO1xuICAgIHRoaXMucGFyZW50SWQgPSBcImNyc1wiO1xuXG4gICAgLy/oh6rlrprkuYnlh73mlbAgIOeUu+W4g+WcqOa3u+WKoG5vZGXml7Ys6K6+572u6IqC54K55qC35byPXG4gICAgdGhpcy5zZXROb2RlRWxlbWVudCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9O1xuXG4gICAgdGhpcy5zY2F0dERhdGEgPSB7XG5cbiAgICAgICAgY29udGFpbmVySW1hZ2U6IFwiXCIsXG4gICAgICAgIGV4ZWN1dG9yQ3B1UmVxdWlyZW1lbnQ6IFwiXCIsXG4gICAgICAgIGV4ZWN1dG9yTWVtUmVxdWlyZW1lbnQ6IFwiXCJcblxuICAgIH07XG5cbiAgICB0aGlzLnNjYXR0SFRNTCA9IFwiPGRpdiBjbGFzcz1cXFwicGFyYW1zLWNvbnRlbnRcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidi10aXRsZVxcXCI+XFx1N0VDNFxcdTRFRjZcXHU1M0MyXFx1NjU3MDwvZGl2PiAgXFxuXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ2LXBhcmFtc1xcXCI+XFxuICAgICAgICAgICAgPHNwYW4+Y29udGFpbmVySW1hZ2U8L3NwYW4+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidi1wYXJhbXMtdmFsdWVcXFwiPlxcbiAgICAgICAgICAgICAgICA8aW5wdXQgdi1tb2RlbD1cXFwiY29udGFpbmVySW1hZ2VcXFwiIC8+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInYtcGFyYW1zXFxcIj5cXG4gICAgICAgICAgICA8c3Bhbj5leGVjdXRvckNwdVJlcXVpcmVtZW50PC9zcGFuPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInYtcGFyYW1zLXZhbHVlXFxcIj5cXG4gICAgICAgICAgICAgICAgPGlucHV0IHYtbW9kZWw9XFxcImV4ZWN1dG9yQ3B1UmVxdWlyZW1lbnRcXFwiIC8+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInYtcGFyYW1zXFxcIj5cXG4gICAgICAgICAgICA8c3Bhbj5leGVjdXRvck1lbVJlcXVpcmVtZW50PC9zcGFuPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInYtcGFyYW1zLXZhbHVlXFxcIj5cXG4gICAgICAgICAgICAgICAgPGlucHV0IHYtbW9kZWw9XFxcImV4ZWN1dG9yTWVtUmVxdWlyZW1lbnRcXFwiIC8+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG5cXG4gICAgPC9kaXY+XFxuICAgIFxcbiAgICBcIjtcbn07XG5cbm1lbnVSZWdpc3Rlci5hZGQoc3BhcmspO1xuXG5leHBvcnQgeyBzcGFyaywgbWVudVJlZ2lzdGVyIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zY2FmZi9tZW51cy9jcnNDaGlsZC9jb21tZW50cy9zcGFyay5qc1xuLy8gbW9kdWxlIGlkID0gMTY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///164\n')},165:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* unused harmony export tdwInput */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__tdwBase_js__ = __webpack_require__(86);\n/* unused harmony reexport menuRegister */\n\n\n\nvar tdwInput = function tdwInput() {\n    __WEBPACK_IMPORTED_MODULE_0__tdwBase_js__["a" /* menuBase */].call(this);\n\n    this.text = "tdwInput";\n    this.procId = "tdwInput";\n    this.parentId = "tdw";\n\n    //自定义函数  画布在添加node时,设置节点样式\n    this.setNodeElement = function (data) {\n        return \'\';\n    };\n\n    this.scattData = {\n        "details": [{\n            "srcHdfsAddr": " hdfs://sh.hdfs.cr.ied.com:9000/tdw-transfer-data/dbyin/20170707193351313/20171008",\n            "tdwHdfsAddr": "hdfs://tl-if-nn-tdw.tencent-distribute.com:54310/stage/outface/IEG/dbyin_app/dbyin/docker_test/20171008"\n        }, {\n            "srcHdfsAddr": " hdfs://sh.hdfs.cr.ied.com:9000/tdw-transfer-data/dbyin/20170707193351313/20171009",\n            "tdwHdfsAddr": "hdfs://tl-if-nn-tdw.tencent-distribute.com:54310/stage/outface/IEG/dbyin_app/dbyin/docker_test/20171009"\n        }]\n    };\n\n    this.scattHTML = "<div class=\\"params-content\\">\\n        <div class=\\"v-title\\">\\u7EC4\\u4EF6\\u53C2\\u6570</div>  \\n\\n        <template v-for=\\"(dval,dindex) in details\\">\\n        <p>{{dindex+1}}</p>\\n            <div class=\\"v-params\\" v-for=\\"(val,key) in details[dindex]\\">\\n                <span>{{key}}</span>\\n                <div class=\\"v-params-value\\">\\n                    <input v-model=\\"details[dindex][key]\\" />\\n                </div>\\n            </div>\\n        </template>\\n\\n    </div>\\n    \\n    ";\n};\n\n__WEBPACK_IMPORTED_MODULE_0__tdwBase_js__["b" /* menuRegister */].add(tdwInput);\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc2NhZmYvbWVudXMvY3JzQ2hpbGQvaW5wdXQvdGR3SW5wdXQuanM/YzYyZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IG1lbnVCYXNlIGFzIG1lbnVCYXNlcywgbWVudVJlZ2lzdGVyIH0gZnJvbSAnLi4vdGR3QmFzZS5qcyc7XG5cbnZhciB0ZHdJbnB1dCA9IGZ1bmN0aW9uIHRkd0lucHV0KCkge1xuICAgIG1lbnVCYXNlcy5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy50ZXh0ID0gXCJ0ZHdJbnB1dFwiO1xuICAgIHRoaXMucHJvY0lkID0gXCJ0ZHdJbnB1dFwiO1xuICAgIHRoaXMucGFyZW50SWQgPSBcInRkd1wiO1xuXG4gICAgLy/oh6rlrprkuYnlh73mlbAgIOeUu+W4g+WcqOa3u+WKoG5vZGXml7Ys6K6+572u6IqC54K55qC35byPXG4gICAgdGhpcy5zZXROb2RlRWxlbWVudCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9O1xuXG4gICAgdGhpcy5zY2F0dERhdGEgPSB7XG4gICAgICAgIFwiZGV0YWlsc1wiOiBbe1xuICAgICAgICAgICAgXCJzcmNIZGZzQWRkclwiOiBcIiBoZGZzOi8vc2guaGRmcy5jci5pZWQuY29tOjkwMDAvdGR3LXRyYW5zZmVyLWRhdGEvZGJ5aW4vMjAxNzA3MDcxOTMzNTEzMTMvMjAxNzEwMDhcIixcbiAgICAgICAgICAgIFwidGR3SGRmc0FkZHJcIjogXCJoZGZzOi8vdGwtaWYtbm4tdGR3LnRlbmNlbnQtZGlzdHJpYnV0ZS5jb206NTQzMTAvc3RhZ2Uvb3V0ZmFjZS9JRUcvZGJ5aW5fYXBwL2RieWluL2RvY2tlcl90ZXN0LzIwMTcxMDA4XCJcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJzcmNIZGZzQWRkclwiOiBcIiBoZGZzOi8vc2guaGRmcy5jci5pZWQuY29tOjkwMDAvdGR3LXRyYW5zZmVyLWRhdGEvZGJ5aW4vMjAxNzA3MDcxOTMzNTEzMTMvMjAxNzEwMDlcIixcbiAgICAgICAgICAgIFwidGR3SGRmc0FkZHJcIjogXCJoZGZzOi8vdGwtaWYtbm4tdGR3LnRlbmNlbnQtZGlzdHJpYnV0ZS5jb206NTQzMTAvc3RhZ2Uvb3V0ZmFjZS9JRUcvZGJ5aW5fYXBwL2RieWluL2RvY2tlcl90ZXN0LzIwMTcxMDA5XCJcbiAgICAgICAgfV1cbiAgICB9O1xuXG4gICAgdGhpcy5zY2F0dEhUTUwgPSBcIjxkaXYgY2xhc3M9XFxcInBhcmFtcy1jb250ZW50XFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInYtdGl0bGVcXFwiPlxcdTdFQzRcXHU0RUY2XFx1NTNDMlxcdTY1NzA8L2Rpdj4gIFxcblxcbiAgICAgICAgPHRlbXBsYXRlIHYtZm9yPVxcXCIoZHZhbCxkaW5kZXgpIGluIGRldGFpbHNcXFwiPlxcbiAgICAgICAgPHA+e3tkaW5kZXgrMX19PC9wPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInYtcGFyYW1zXFxcIiB2LWZvcj1cXFwiKHZhbCxrZXkpIGluIGRldGFpbHNbZGluZGV4XVxcXCI+XFxuICAgICAgICAgICAgICAgIDxzcGFuPnt7a2V5fX08L3NwYW4+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInYtcGFyYW1zLXZhbHVlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB2LW1vZGVsPVxcXCJkZXRhaWxzW2RpbmRleF1ba2V5XVxcXCIgLz5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L3RlbXBsYXRlPlxcblxcbiAgICA8L2Rpdj5cXG4gICAgXFxuICAgIFwiO1xufTtcblxubWVudVJlZ2lzdGVyLmFkZCh0ZHdJbnB1dCk7XG5cbmV4cG9ydCB7IHRkd0lucHV0LCBtZW51UmVnaXN0ZXIgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NjYWZmL21lbnVzL2Nyc0NoaWxkL2lucHV0L3Rkd0lucHV0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///165\n')},166:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* unused harmony export tdwOutput */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__tdwBase_js__ = __webpack_require__(86);\n/* unused harmony reexport menuRegister */\n\n\n\nvar tdwOutput = function tdwOutput() {\n    __WEBPACK_IMPORTED_MODULE_0__tdwBase_js__["a" /* menuBase */].call(this);\n\n    this.text = "tdwOutput";\n    this.procId = "tdwOutput";\n    this.parentId = "tdw";\n\n    //自定义函数  画布在添加node时,设置节点样式\n    this.setNodeElement = function (data) {\n        return \'\';\n    };\n\n    this.scattData = {\n\n        "details": [{\n            "srcHdfsAddr": " hdfs://sh.hdfs.cr.ied.com:9000/tdw-transfer-data/dbyin/20170707193351313/20171008",\n            "tdwHdfsAddr": "hdfs://tl-if-nn-tdw.tencent-distribute.com:54310/stage/outface/IEG/dbyin_app/dbyin/docker_test/20171008"\n        }, {\n            "srcHdfsAddr": " hdfs://sh.hdfs.cr.ied.com:9000/tdw-transfer-data/dbyin/20170707193351313/20171009",\n            "tdwHdfsAddr": "hdfs://tl-if-nn-tdw.tencent-distribute.com:54310/stage/outface/IEG/dbyin_app/dbyin/docker_test/20171009"\n        }]\n\n    };\n\n    this.scattHTML = "<div class=\\"params-content\\">\\n        <div class=\\"v-title\\">\\u7EC4\\u4EF6\\u53C2\\u6570</div>  \\n\\n        <template v-for=\\"(dval,dindex) in details\\">\\n        <p>{{dindex+1}}</p>\\n            <div class=\\"v-params\\" v-for=\\"(val,key) in details[dindex]\\">\\n                <span>{{key}}</span>\\n                <div class=\\"v-params-value\\">\\n                    <input v-model=\\"details[dindex][key]\\" />\\n                </div>\\n            </div>\\n        </template>\\n\\n    </div>\\n    \\n    ";\n};\n\n__WEBPACK_IMPORTED_MODULE_0__tdwBase_js__["b" /* menuRegister */].add(tdwOutput);\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc2NhZmYvbWVudXMvY3JzQ2hpbGQvb3V0cHV0L3Rkd091dHB1dC5qcz9lODJlIl0sInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHsgbWVudUJhc2UgYXMgbWVudUJhc2VzLCBtZW51UmVnaXN0ZXIgfSBmcm9tICcuLi90ZHdCYXNlLmpzJztcblxudmFyIHRkd091dHB1dCA9IGZ1bmN0aW9uIHRkd091dHB1dCgpIHtcbiAgICBtZW51QmFzZXMuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMudGV4dCA9IFwidGR3T3V0cHV0XCI7XG4gICAgdGhpcy5wcm9jSWQgPSBcInRkd091dHB1dFwiO1xuICAgIHRoaXMucGFyZW50SWQgPSBcInRkd1wiO1xuXG4gICAgLy/oh6rlrprkuYnlh73mlbAgIOeUu+W4g+WcqOa3u+WKoG5vZGXml7Ys6K6+572u6IqC54K55qC35byPXG4gICAgdGhpcy5zZXROb2RlRWxlbWVudCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9O1xuXG4gICAgdGhpcy5zY2F0dERhdGEgPSB7XG5cbiAgICAgICAgXCJkZXRhaWxzXCI6IFt7XG4gICAgICAgICAgICBcInNyY0hkZnNBZGRyXCI6IFwiIGhkZnM6Ly9zaC5oZGZzLmNyLmllZC5jb206OTAwMC90ZHctdHJhbnNmZXItZGF0YS9kYnlpbi8yMDE3MDcwNzE5MzM1MTMxMy8yMDE3MTAwOFwiLFxuICAgICAgICAgICAgXCJ0ZHdIZGZzQWRkclwiOiBcImhkZnM6Ly90bC1pZi1ubi10ZHcudGVuY2VudC1kaXN0cmlidXRlLmNvbTo1NDMxMC9zdGFnZS9vdXRmYWNlL0lFRy9kYnlpbl9hcHAvZGJ5aW4vZG9ja2VyX3Rlc3QvMjAxNzEwMDhcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInNyY0hkZnNBZGRyXCI6IFwiIGhkZnM6Ly9zaC5oZGZzLmNyLmllZC5jb206OTAwMC90ZHctdHJhbnNmZXItZGF0YS9kYnlpbi8yMDE3MDcwNzE5MzM1MTMxMy8yMDE3MTAwOVwiLFxuICAgICAgICAgICAgXCJ0ZHdIZGZzQWRkclwiOiBcImhkZnM6Ly90bC1pZi1ubi10ZHcudGVuY2VudC1kaXN0cmlidXRlLmNvbTo1NDMxMC9zdGFnZS9vdXRmYWNlL0lFRy9kYnlpbl9hcHAvZGJ5aW4vZG9ja2VyX3Rlc3QvMjAxNzEwMDlcIlxuICAgICAgICB9XVxuXG4gICAgfTtcblxuICAgIHRoaXMuc2NhdHRIVE1MID0gXCI8ZGl2IGNsYXNzPVxcXCJwYXJhbXMtY29udGVudFxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ2LXRpdGxlXFxcIj5cXHU3RUM0XFx1NEVGNlxcdTUzQzJcXHU2NTcwPC9kaXY+ICBcXG5cXG4gICAgICAgIDx0ZW1wbGF0ZSB2LWZvcj1cXFwiKGR2YWwsZGluZGV4KSBpbiBkZXRhaWxzXFxcIj5cXG4gICAgICAgIDxwPnt7ZGluZGV4KzF9fTwvcD5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ2LXBhcmFtc1xcXCIgdi1mb3I9XFxcIih2YWwsa2V5KSBpbiBkZXRhaWxzW2RpbmRleF1cXFwiPlxcbiAgICAgICAgICAgICAgICA8c3Bhbj57e2tleX19PC9zcGFuPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ2LXBhcmFtcy12YWx1ZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdi1tb2RlbD1cXFwiZGV0YWlsc1tkaW5kZXhdW2tleV1cXFwiIC8+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC90ZW1wbGF0ZT5cXG5cXG4gICAgPC9kaXY+XFxuICAgIFxcbiAgICBcIjtcbn07XG5cbm1lbnVSZWdpc3Rlci5hZGQodGR3T3V0cHV0KTtcblxuZXhwb3J0IHsgdGR3T3V0cHV0LCBtZW51UmVnaXN0ZXIgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NjYWZmL21lbnVzL2Nyc0NoaWxkL291dHB1dC90ZHdPdXRwdXQuanNcbi8vIG1vZHVsZSBpZCA9IDE2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///166\n')},167:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('Object.defineProperty(__webpack_exports__, "__esModule", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_font_awesome_css_font_awesome_css__ = __webpack_require__(168);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_font_awesome_css_font_awesome_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_font_awesome_css_font_awesome_css__);\n\n\n\n//Vue.use(Element, { size: \'small\', zIndex: 3000 });\n\n//执行的代码示例\nvar getExampleCode = {\n    demo1: {\n        //渲染\n        render: function render() {\n            return \'if(!demo.chart){ \\n\' + \'   demo.chart = new  window.tPlugin({ \\n\' + \'   _els:{ \\n\' + \'       chart:chartControl \\n\' + \'   },\\n\' + \'   useProp:false,\\n\' + \'   useTips:false,\\n\' + \'   useEnd: false \\n\' + \'   });\\n\' + \'}\\n\' + \'demo.chart.renderChart(json)\';\n        },\n        //节点配置\n        nodeJson: function nodeJson(x, y) {\n            return \'var nodeJson = { \\n\' + \'"name": "demo",\\n\' + \'"point":{\' + \'"x":\' + x + \',\' + \'"y":\' + y + \'},\\n\' + \'"class": "node-process",\\n\' + \'"removable": true,\\n\' + \'"creat":function(node,element){ \\n\' + \'    console.log(\\\'add a node\\\') \\n\' + \'},\\n\' + \'"data": { \\n\' + \'   "procId": -1, \\n\' + \'   "params": {} \\n\' + \'}\\n\' + \'}\\n\';\n        },\n        //添加节点\n        addNode: function addNode() {\n            return this.nodeJson(parseInt(Math.random() * 200), parseInt(Math.random() * 320)) + "//以下的chart即为demo.chart,也就是插件的实例化对象 \\n" + "chart.chartControl.addNode(nodeJson)";\n        },\n        //保存\n        save: function save() {\n            return "return JSON.stringify(chart.save())";\n        }\n    },\n    demo2: {\n        //渲染\n        render: function render() {\n            return \'if(demo.chart){ \\n\' + \'demo.chart.properControl.destroy(); \\n\' + \'} \\n\' + \'   demo.chart = new  window.tPlugin({ \\n\' + \'   menusData: [{\\n\' + \'    text: "tt",\\n\' + \'    procId: "ppx",\\n\' + \'    baseData: {\\n\' + \'        "namespace": "default",\\n\' + \'         "taskName": "export-001",\\n\' + \'    },\\n\' + \'    scattData: {\\n\' + \'        bb: 456\\n\' + \'    },\\n\' + \'    baseHTML: `<div class="params-content">\\n\' + \'<div class="v-title">公共参数</div>            \\n\' + \'<div class="v-params">\\n\' + \'    <span>namespace</span>\\n\' + \'    <div class="v-params-value">\\n\' + \'        <input v-model="namespace" />\\n\' + \'    </div>\\n\' + \'</div>\\n\' + \'<div class="v-params">\\n\' + \'    <span>taskName</span>\\n\' + \'    <div class="v-params-value">\\n\' + \'        <input v-model="taskName" />\\n\' + \'    </div>\\n\' + \'</div>\\n\' + \'<div class="v-params">\\n\' + \'    <span>owner</span>\\n\' + \'    <div class="v-params-value">\\n\' + \'        <input v-model="owner" />\\n\' + \'    </div>\\n\' + \'</div>                           \\n\' + \'</div>`,\\n\' + \'    scattHTML: `<input v-model="bb" />`\\n\' + \'}],         \' + \'   _els:{ \\n\' + \'       prop:chartControl \\n\' + \'   },\\n\' + \' \\n\' + \'   useProp:true,\\n\' + \'   useTips:false,\\n\' + \'   useEnd: false \\n\' + \'   });\\n\' + \'var menu = demo.chart.menuRegister.getMenuObj("ppx")\\n\' + \'var data = $.extend({},menu.baseData,menu.scattData,{\\n\' + \'         "owner":"fnh"         \\n\' + \'    });\\n\' + \' demo.chart._els.prop = $(demo.chart._els.prop); \\n\' + \'demo.chart.properControl.render({\\n\' + \'    el: demo.chart._els.prop.children()[0],\\n\' + \'    data: data,\\n\' + \'    html: menu.baseHTML + menu.scattHTML,\\n\' + \'    dataChange(key, newVal) {\\n\' + \'        data[key] = newVal;\\n\' + \'        demo.saveJson = JSON.stringify(data);\\n\' + \'        \\n\' + \'    },\\n\' + \'    methods: {\\n\' + \'    }\\n\' + \'});                                                         \\n\';\n        }\n    },\n    demo3: {\n        render: function render() {\n            return \'if(!demo.chart){ \\n\' + \'   demo.chart = new  window.tPlugin({ \\n\' + \' menusData: [{\\n\' + \'    text: "参数menu",\\n\' + \'    procId: "ppx1",\\n\' + \'    baseData: {\\n\' + \'        "namespace": "default",\\n\' + \'         "taskName": "export-001",\\n\' + \'    },\\n\' + \'    scattData: {\\n\' + \'        bb: 456\\n\' + \'    },\\n\' + \'    baseHTML: `<div class="params-content">\\n\' + \'     <div class="v-title">公共参数</div>            \\n\' + \'     <div class="v-params">\\n\' + \'         <span>namespace</span>\\n\' + \'         <div class="v-params-value">\\n\' + \'             <input v-model="namespace" />\\n\' + \'         </div>\\n\' + \'     </div>` \\n\' + \'   }],\' + \'   useProp:false,\\n\' + \'   useTips:false,\\n\' + \'   useEnd: false \\n\' + \'   });\\n\' + \'   demo.chart.render(_vue.$refs.demo3chartControl,json) \\n\' + \'}else { \\n\' + \'  demo.chart.renderChart(json)  \' + \'}\\n\';\n        }\n    },\n    demo4: {\n        render: function render() {\n            return \'if(!demo.chart){ \\n\' + \'   demo.chart = new  window.tPlugin({ \\n\' + \'   menusData: [{\\n\' + \'      text: "参数menu",\\n\' + \'      procId: "ppx2",\\n\' + \'      baseData: {\\n\' + \'          "namespace": "default",\\n\' + \'           "taskName": "export-001",\\n\' + \'      },\\n\' + \'      scattData: {\\n\' + \'          bb: 789 \\n\' + \'      },\\n\' + \'      baseHTML: `<div class="params-content">\\n\' + \'       <div class="v-title">公共参数</div>            \\n\' + \'       <div class="v-params">\\n\' + \'           <span>namespace</span>\\n\' + \'           <div class="v-params-value">\\n\' + \'               <input v-model="namespace" />\\n\' + \'           </div>\\n\' + \'       </div>` \\n\' + \'   }], \\n\' + \'   prop:{ \\n\' + \'       methods:{ \\n\' + \'           aa(){ \\n\' + \'               console.log("aa") \\n\' + \'           }                       \\n\' + \'       }     \\n  \' + \'   },   \\n\' + \'   useProp:true,\\n\' + \'   useTips:false,\\n\' + \'   useEnd: false \\n\' + \'   });\\n\' + \'   demo.chart.render(_vue.$refs.demo4chartControl,json) \\n\' + \'}else { \\n\' + \'  demo.chart.renderChart(json)  \' + \'}\\n\';\n        }\n    }\n};\n\nnew __WEBPACK_IMPORTED_MODULE_0_vue___default.a({\n    el: \'#app\',\n    data: function data() {\n        return {\n            menus: {\n                demo1: {\n                    saveJson: \'{"nodes":[],"connections":[]}\',\n                    render: getExampleCode.demo1.render(),\n                    nodeJson: getExampleCode.demo1.nodeJson(parseInt(Math.random() * 200), parseInt(Math.random() * 320)),\n                    addNode: getExampleCode.demo1.addNode(),\n                    save: getExampleCode.demo1.save()\n                },\n                demo2: {\n                    saveJson: "",\n                    render: getExampleCode.demo2.render()\n                },\n                demo3: {\n                    saveJson: \'{"nodes":[],"connections":[]}\',\n                    render: getExampleCode.demo3.render(),\n                    save: getExampleCode.demo1.save()\n                },\n                demo4: {\n                    saveJson: \'{"nodes":[],"connections":[]}\',\n                    render: getExampleCode.demo4.render(),\n                    save: getExampleCode.demo1.save()\n                }\n            },\n            curBtn: {\n                methodDemo: \'\',\n                demo: "",\n                method: \'\'\n            },\n            contentStatus: "introduce",\n            //示例代码\n            demoCodeText: \'\'\n        };\n    },\n    created: function created() {},\n    mounted: function mounted() {\n        var _this = this;\n\n        $(\'.v-content\').removeClass(\'v-none\');\n        //默认 渲染 状态\n        this.hoverBtn(\'render\', \'demo1\');\n        this.$nextTick(function () {\n            _this.render(\'demo1\');\n        });\n    },\n\n    methods: {\n        conTarget: function conTarget(name) {\n            this.contentStatus = name;\n        },\n        toTarget: function toTarget(demo) {\n            var _this2 = this;\n\n            this.contentStatus = \'demo\';\n\n            var $t = $(\'[data-target="\' + demo + \'"]\');\n            var top = $t.position().top + $(this.$refs.content).scrollTop();\n\n            $(this.$refs.content).scrollTop(top);\n\n            this.hoverBtn(\'render\', demo);\n            this.$nextTick(function () {\n                _this2.render(demo);\n            });\n        },\n        demoCodeChange: function demoCodeChange() {\n            if (this.curBtn.methodDemo == "") {\n                return;\n            }\n            this.menus[this.curBtn.demo][this.curBtn.method] = this.demoCodeText;\n        },\n        hoverBtn: function hoverBtn(method, demo) {\n            var methodDemo = method + demo;\n\n            if (this.curBtn.methodDemo == methodDemo) {\n                return;\n            }\n            this.curBtn.methodDemo = methodDemo;\n            this.curBtn.demo = demo;\n            this.curBtn.method = method;\n\n            this.demoCodeText = this.menus[demo][method]; //getExampleCode[demo][method]();\n\n\n            var $code = $(this.$refs.democode).find(\'textarea\');\n            var times = 0;\n            var func = function func() {\n                if (times < 0) {\n                    return;\n                }\n                times--;\n                $code.css(\'border\', \'1px solid rgb(64,158,255)\');\n                setTimeout(function () {\n                    $code.css(\'border\', \'\');\n                    setTimeout(function () {\n                        func();\n                    }, 300);\n                }, 300);\n            };\n            func();\n        },\n        addNodeAll: function addNodeAll(demo) {\n            if (demo in this.menus) {\n                this.addNode(demo);\n            }\n        },\n        renderAll: function renderAll() {\n            for (var i in this.menus) {\n                this.render(i);\n            }\n        },\n        render: function render(key) {\n            var demo = this.menus[key];\n\n            var json = this.menus[key].saveJson;\n            var chartControl = this.$refs[key + \'chartControl\'];\n            var menuControl = this.$refs[key + \'menuControl\'] || null;\n\n            var code = this.demoCodeText;\n            if (!demo.chart) {\n                var code = demo.render;\n            }\n            var c = new Function("demo", "json", "chartControl", "menuControl", "_vue", code);\n\n            c(demo, json, chartControl, menuControl, this);\n\n            this.demoCodeText = code;\n        },\n        addNode: function addNode(key) {\n            var chart = this.menus[key].chart;\n\n            var code = this.demoCodeText;\n\n            new Function("chart", code)(chart);\n        },\n        save: function save(key) {\n            var chart = this.menus[key].chart;\n\n            var code = this.demoCodeText;\n\n            var str = new Function("chart", code)(chart);\n\n            this.menus[key].saveJson = str;\n        }\n    }\n});\n\n$(function () {\n    return;\n    var t = window.t = new window.tPlugin({\n        //节点数据\n        menusData: [{\n            text: "tt",\n            procId: "ppx",\n            baseData: {\n                aa: 123\n            },\n            scattData: {\n                bb: 456\n            },\n            baseHTML: \'<input v-model="aa" />\',\n            scattHTML: \'<input v-model="bb" />\'\n        }],\n        chart: {\n            nodeDel: {\n                cover: true,\n                run: function run(nodeData, delNode) {\n\n                    if (delNode) {\n                        delNode.dispose();\n                        this.removeNode(delNode._id);\n                    }\n                }\n            }\n        },\n        useProp: true,\n        prop: {\n            methods: {\n                aam: function aam() {\n                    this.json.result = "true";\n                }\n            },\n            dataChange: function dataChange(node, key, newVal) {\n                console.log(node, key, newVal);\n            }\n        },\n        useStart: true,\n        useEnd: false\n    });\n\n    var arr = [\'{"nodes":[{"procId":"pySpark","params":{"removable":true,"status":"","namespace":"","taskName":"","owner":"","containerImage":"","executorCpuRequirement":"","executorMemRequirement":""},"name":"pySpark","nodeId":"n13172878880","_x":263,"_y":250,"className":"node-process","removable":true,"elId":"n13172878880","unPort":false},{"procId":"spark","params":{"removable":true,"namespace":"","taskName":"","owner":"","containerImage":"","executorCpuRequirement":"","executorMemRequirement":""},"name":"spark","nodeId":"n43172895192","_x":415,"_y":360,"className":"node-process","removable":true,"elId":"n43172895192","unPort":false},{"name":"","nodeId":"n03449778737","_x":419,"_y":11,"className":"","removable":false,"elId":"n03449778737","unPort":true,"nodeStyle":"start"},{"name":"","nodeId":"n13449778740","_x":258,"_y":472,"className":"","removable":false,"elId":"n13449778740","unPort":true,"nodeStyle":"end"},{"procId":"normal","params":{"namespace":"default","taskName":"export-001","owner":"dbyin","removable":true,"status":"","containerImage":"","executorCpuRequirement":"","executorMemRequirement":"","json":{"a":"11ggg"}},"name":"\\u666E\\u901A\\u8BA1\\u7B97","nodeId":"n14118724561","_x":399,"_y":142,"className":"node-process","removable":true,"elId":"n14118724561","unPort":false}],"connections":[{"connectionId":"con_25","pageSourceId":"n13172878880","pageTargetId":"n43172895192"},{"connectionId":"con_35","pageSourceId":"n43172895192","pageTargetId":"n13449778740","nodeStyle":"end"},{"connectionId":"con_58","pageSourceId":"n03449778737","pageTargetId":"n14118724561","nodeStyle":"start"},{"connectionId":"con_62","pageSourceId":"n14118724561","pageTargetId":"n13172878880"}]}\', \'{"nodes":[{"procId":"pySpark","params":{"removable":true,"status":"","namespace":"","taskName":"","owner":"","containerImage":"","executorCpuRequirement":"","executorMemRequirement":""},"name":"pySpark","nodeId":"n13172878880","_x":108,"_y":248,"className":"node-process","removable":true,"elId":"n13172878880","unPort":false},{"procId":"spark","params":{"removable":true,"namespace":"","taskName":"","owner":"","containerImage":"","executorCpuRequirement":"","executorMemRequirement":""},"name":"spark","nodeId":"n43172895192","_x":458,"_y":256,"className":"node-process","removable":true,"elId":"n43172895192","unPort":false},{"name":"","nodeId":"n03449893054","_x":382,"_y":19,"className":"","removable":false,"elId":"n03449893054","unPort":true,"nodeStyle":"start"},{"name":"","nodeId":"n13449893057","_x":306,"_y":348,"className":"","removable":false,"elId":"n13449893057","unPort":true,"nodeStyle":"end"},{"procId":"normal","params":{"namespace":"default","taskName":"export-001","owner":"dbyin","removable":true,"status":"","containerImage":"","executorCpuRequirement":"","executorMemRequirement":"","json":{"a":11}},"name":"\\u666E\\u901A\\u8BA1\\u7B97","nodeId":"n24118776057","_x":280,"_y":133,"className":"node-process","removable":true,"elId":"n24118776057","unPort":false}],"connections":[{"connectionId":"con_105","pageSourceId":"n13172878880","pageTargetId":"n13449893057","nodeStyle":"end"},{"connectionId":"con_110","pageSourceId":"n43172895192","pageTargetId":"n13449893057","nodeStyle":"end"},{"connectionId":"con_128","pageSourceId":"n03449893054","pageTargetId":"n24118776057","nodeStyle":"start"},{"connectionId":"con_132","pageSourceId":"n24118776057","pageTargetId":"n13172878880"},{"connectionId":"con_138","pageSourceId":"n24118776057","pageTargetId":"n43172895192"}]}\', \'{"nodes":[{"procId":"pySpark","params":{"removable":true,"status":"","namespace":"","taskName":"","owner":"","containerImage":"","executorCpuRequirement":"","executorMemRequirement":""},"name":"pySpark","nodeId":"n13172878880","_x":204,"_y":123,"className":"node-process","removable":true,"elId":"n13172878880","unPort":false},{"procId":"tdwOutput","params":{"namespace":"default","taskName":"export-001","owner":"dbyin","removable":true,"tdwUserPwd":"tdw_dbyin:dbyin","tdwAppId":"dbyin_app","details":[{"srcHdfsAddr":" hdfs://sh.hdfs.cr.ied.com:9000/tdw-transfer-data/dbyin/20170707193351313/20171008","tdwHdfsAddr":"hdfs://tl-if-nn-tdw.tencent-distribute.com:54310/stage/outface/IEG/dbyin_app/dbyin/docker_test/20171008"},{"srcHdfsAddr":" hdfs://sh.hdfs.cr.ied.com:9000/tdw-transfer-data/dbyin/20170707193351313/20171009","tdwHdfsAddr":"hdfs://tl-if-nn-tdw.tencent-distribute.com:54310/stage/outface/IEG/dbyin_app/dbyin/docker_test/20171009"}]},"name":"tdwOutput","nodeId":"n43449947576","_x":-267,"_y":385,"className":"node-process","removable":true,"elId":"n43449947576","unPort":false},{"name":"","nodeId":"n23449926868","_x":194,"_y":25,"className":"","removable":false,"elId":"n23449926868","unPort":true,"nodeStyle":"start"},{"name":"","nodeId":"n33449926871","_x":489,"_y":278,"className":"","removable":false,"elId":"n33449926871","unPort":true,"nodeStyle":"end"},{"procId":"tdwInput","params":{"namespace":"default","taskName":"export-001","owner":"dbyin","removable":true,"tdwUserPwd":"tdw_dbyin:dbyin","tdwAppId":"dbyin_app","details":[{"srcHdfsAddr":" hdfs://sh.hdfs.cr.ied.com:9000/tdw-transfer-data/dbyin/20170707193351313/20171008","tdwHdfsAddr":"hdfs://tl-if-nn-tdw.tencent-distribute.com:54310/stage/outface/IEG/dbyin_app/dbyin/docker_test/20171008"},{"srcHdfsAddr":" hdfs://sh.hdfs.cr.ied.com:9000/tdw-transfer-data/dbyin/20170707193351313/20171009","tdwHdfsAddr":"hdfs://tl-if-nn-tdw.tencent-distribute.com:54310/stage/outface/IEG/dbyin_app/dbyin/docker_test/20171009"}]},"name":"tdwInput","nodeId":"n23450102311","_x":384,"_y":182,"className":"node-process","removable":true,"elId":"n23450102311","unPort":false}],"connections":[{"connectionId":"con_99","pageSourceId":"n23449926868","pageTargetId":"n13172878880"},{"connectionId":"con_121","pageSourceId":"n23450102311","pageTargetId":"n33449926871"},{"connectionId":"con_134","pageSourceId":"n13172878880","pageTargetId":"n23450102311"}]}\', \'{"nodes":[],"connections":[]}\'];\n    return;\n\n    //初次载入\n    t.render("#chartContent", arr[0]);\n\n    //载入\n    $("#selectToor").on(\'change\', function () {\n        var val = parseInt($(this).val());\n        //二次渲染\n        t.renderChart(arr[val - 1]);\n    });\n\n    //保存\n    $(\'#save\').on(\'click\', function () {\n        return;\n        var str = JSON.stringify(t.chartControl.toJson());\n        console.log(str);\n        var blg = t.checkControl.check(\'closedLoop island\', t.chartControl.toJson());\n        if (!blg) {\n            console.log("含有闭环 或者 孤立节点");\n        }\n    });\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vdHBsdWdpbi9zcmMvanMvc2NhZmYvY3JzL2Nycy5pbmRleC5qcz81M2RhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2dWUgZnJvbSAndnVlJztcblxuaW1wb3J0ICdmb250LWF3ZXNvbWUvY3NzL2ZvbnQtYXdlc29tZS5jc3MnO1xuLy9WdWUudXNlKEVsZW1lbnQsIHsgc2l6ZTogJ3NtYWxsJywgekluZGV4OiAzMDAwIH0pO1xuXG4vL+aJp+ihjOeahOS7o+eggeekuuS+i1xudmFyIGdldEV4YW1wbGVDb2RlID0ge1xuICAgIGRlbW8xOiB7XG4gICAgICAgIC8v5riy5p+TXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuICdpZighZGVtby5jaGFydCl7IFxcbicgKyAnICAgZGVtby5jaGFydCA9IG5ldyAgd2luZG93LnRQbHVnaW4oeyBcXG4nICsgJyAgIF9lbHM6eyBcXG4nICsgJyAgICAgICBjaGFydDpjaGFydENvbnRyb2wgXFxuJyArICcgICB9LFxcbicgKyAnICAgdXNlUHJvcDpmYWxzZSxcXG4nICsgJyAgIHVzZVRpcHM6ZmFsc2UsXFxuJyArICcgICB1c2VFbmQ6IGZhbHNlIFxcbicgKyAnICAgfSk7XFxuJyArICd9XFxuJyArICdkZW1vLmNoYXJ0LnJlbmRlckNoYXJ0KGpzb24pJztcbiAgICAgICAgfSxcbiAgICAgICAgLy/oioLngrnphY3nva5cbiAgICAgICAgbm9kZUpzb246IGZ1bmN0aW9uIG5vZGVKc29uKHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiAndmFyIG5vZGVKc29uID0geyBcXG4nICsgJ1wibmFtZVwiOiBcImRlbW9cIixcXG4nICsgJ1wicG9pbnRcIjp7JyArICdcInhcIjonICsgeCArICcsJyArICdcInlcIjonICsgeSArICd9LFxcbicgKyAnXCJjbGFzc1wiOiBcIm5vZGUtcHJvY2Vzc1wiLFxcbicgKyAnXCJyZW1vdmFibGVcIjogdHJ1ZSxcXG4nICsgJ1wiY3JlYXRcIjpmdW5jdGlvbihub2RlLGVsZW1lbnQpeyBcXG4nICsgJyAgICBjb25zb2xlLmxvZyhcXCdhZGQgYSBub2RlXFwnKSBcXG4nICsgJ30sXFxuJyArICdcImRhdGFcIjogeyBcXG4nICsgJyAgIFwicHJvY0lkXCI6IC0xLCBcXG4nICsgJyAgIFwicGFyYW1zXCI6IHt9IFxcbicgKyAnfVxcbicgKyAnfVxcbic7XG4gICAgICAgIH0sXG4gICAgICAgIC8v5re75Yqg6IqC54K5XG4gICAgICAgIGFkZE5vZGU6IGZ1bmN0aW9uIGFkZE5vZGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlSnNvbihwYXJzZUludChNYXRoLnJhbmRvbSgpICogMjAwKSwgcGFyc2VJbnQoTWF0aC5yYW5kb20oKSAqIDMyMCkpICsgXCIvL+S7peS4i+eahGNoYXJ05Y2z5Li6ZGVtby5jaGFydCzkuZ/lsLHmmK/mj5Lku7bnmoTlrp7kvovljJblr7nosaEgXFxuXCIgKyBcImNoYXJ0LmNoYXJ0Q29udHJvbC5hZGROb2RlKG5vZGVKc29uKVwiO1xuICAgICAgICB9LFxuICAgICAgICAvL+S/neWtmFxuICAgICAgICBzYXZlOiBmdW5jdGlvbiBzYXZlKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwicmV0dXJuIEpTT04uc3RyaW5naWZ5KGNoYXJ0LnNhdmUoKSlcIjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGVtbzI6IHtcbiAgICAgICAgLy/muLLmn5NcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2lmKGRlbW8uY2hhcnQpeyBcXG4nICsgJ2RlbW8uY2hhcnQucHJvcGVyQ29udHJvbC5kZXN0cm95KCk7IFxcbicgKyAnfSBcXG4nICsgJyAgIGRlbW8uY2hhcnQgPSBuZXcgIHdpbmRvdy50UGx1Z2luKHsgXFxuJyArICcgICBtZW51c0RhdGE6IFt7XFxuJyArICcgICAgdGV4dDogXCJ0dFwiLFxcbicgKyAnICAgIHByb2NJZDogXCJwcHhcIixcXG4nICsgJyAgICBiYXNlRGF0YToge1xcbicgKyAnICAgICAgICBcIm5hbWVzcGFjZVwiOiBcImRlZmF1bHRcIixcXG4nICsgJyAgICAgICAgIFwidGFza05hbWVcIjogXCJleHBvcnQtMDAxXCIsXFxuJyArICcgICAgfSxcXG4nICsgJyAgICBzY2F0dERhdGE6IHtcXG4nICsgJyAgICAgICAgYmI6IDQ1NlxcbicgKyAnICAgIH0sXFxuJyArICcgICAgYmFzZUhUTUw6IGA8ZGl2IGNsYXNzPVwicGFyYW1zLWNvbnRlbnRcIj5cXG4nICsgJzxkaXYgY2xhc3M9XCJ2LXRpdGxlXCI+5YWs5YWx5Y+C5pWwPC9kaXY+ICAgICAgICAgICAgXFxuJyArICc8ZGl2IGNsYXNzPVwidi1wYXJhbXNcIj5cXG4nICsgJyAgICA8c3Bhbj5uYW1lc3BhY2U8L3NwYW4+XFxuJyArICcgICAgPGRpdiBjbGFzcz1cInYtcGFyYW1zLXZhbHVlXCI+XFxuJyArICcgICAgICAgIDxpbnB1dCB2LW1vZGVsPVwibmFtZXNwYWNlXCIgLz5cXG4nICsgJyAgICA8L2Rpdj5cXG4nICsgJzwvZGl2PlxcbicgKyAnPGRpdiBjbGFzcz1cInYtcGFyYW1zXCI+XFxuJyArICcgICAgPHNwYW4+dGFza05hbWU8L3NwYW4+XFxuJyArICcgICAgPGRpdiBjbGFzcz1cInYtcGFyYW1zLXZhbHVlXCI+XFxuJyArICcgICAgICAgIDxpbnB1dCB2LW1vZGVsPVwidGFza05hbWVcIiAvPlxcbicgKyAnICAgIDwvZGl2PlxcbicgKyAnPC9kaXY+XFxuJyArICc8ZGl2IGNsYXNzPVwidi1wYXJhbXNcIj5cXG4nICsgJyAgICA8c3Bhbj5vd25lcjwvc3Bhbj5cXG4nICsgJyAgICA8ZGl2IGNsYXNzPVwidi1wYXJhbXMtdmFsdWVcIj5cXG4nICsgJyAgICAgICAgPGlucHV0IHYtbW9kZWw9XCJvd25lclwiIC8+XFxuJyArICcgICAgPC9kaXY+XFxuJyArICc8L2Rpdj4gICAgICAgICAgICAgICAgICAgICAgICAgICBcXG4nICsgJzwvZGl2PmAsXFxuJyArICcgICAgc2NhdHRIVE1MOiBgPGlucHV0IHYtbW9kZWw9XCJiYlwiIC8+YFxcbicgKyAnfV0sICAgICAgICAgJyArICcgICBfZWxzOnsgXFxuJyArICcgICAgICAgcHJvcDpjaGFydENvbnRyb2wgXFxuJyArICcgICB9LFxcbicgKyAnIFxcbicgKyAnICAgdXNlUHJvcDp0cnVlLFxcbicgKyAnICAgdXNlVGlwczpmYWxzZSxcXG4nICsgJyAgIHVzZUVuZDogZmFsc2UgXFxuJyArICcgICB9KTtcXG4nICsgJ3ZhciBtZW51ID0gZGVtby5jaGFydC5tZW51UmVnaXN0ZXIuZ2V0TWVudU9iaihcInBweFwiKVxcbicgKyAndmFyIGRhdGEgPSAkLmV4dGVuZCh7fSxtZW51LmJhc2VEYXRhLG1lbnUuc2NhdHREYXRhLHtcXG4nICsgJyAgICAgICAgIFwib3duZXJcIjpcImZuaFwiICAgICAgICAgXFxuJyArICcgICAgfSk7XFxuJyArICcgZGVtby5jaGFydC5fZWxzLnByb3AgPSAkKGRlbW8uY2hhcnQuX2Vscy5wcm9wKTsgXFxuJyArICdkZW1vLmNoYXJ0LnByb3BlckNvbnRyb2wucmVuZGVyKHtcXG4nICsgJyAgICBlbDogZGVtby5jaGFydC5fZWxzLnByb3AuY2hpbGRyZW4oKVswXSxcXG4nICsgJyAgICBkYXRhOiBkYXRhLFxcbicgKyAnICAgIGh0bWw6IG1lbnUuYmFzZUhUTUwgKyBtZW51LnNjYXR0SFRNTCxcXG4nICsgJyAgICBkYXRhQ2hhbmdlKGtleSwgbmV3VmFsKSB7XFxuJyArICcgICAgICAgIGRhdGFba2V5XSA9IG5ld1ZhbDtcXG4nICsgJyAgICAgICAgZGVtby5zYXZlSnNvbiA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xcbicgKyAnICAgICAgICBcXG4nICsgJyAgICB9LFxcbicgKyAnICAgIG1ldGhvZHM6IHtcXG4nICsgJyAgICB9XFxuJyArICd9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG4nO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkZW1vMzoge1xuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgICAgIHJldHVybiAnaWYoIWRlbW8uY2hhcnQpeyBcXG4nICsgJyAgIGRlbW8uY2hhcnQgPSBuZXcgIHdpbmRvdy50UGx1Z2luKHsgXFxuJyArICcgbWVudXNEYXRhOiBbe1xcbicgKyAnICAgIHRleHQ6IFwi5Y+C5pWwbWVudVwiLFxcbicgKyAnICAgIHByb2NJZDogXCJwcHgxXCIsXFxuJyArICcgICAgYmFzZURhdGE6IHtcXG4nICsgJyAgICAgICAgXCJuYW1lc3BhY2VcIjogXCJkZWZhdWx0XCIsXFxuJyArICcgICAgICAgICBcInRhc2tOYW1lXCI6IFwiZXhwb3J0LTAwMVwiLFxcbicgKyAnICAgIH0sXFxuJyArICcgICAgc2NhdHREYXRhOiB7XFxuJyArICcgICAgICAgIGJiOiA0NTZcXG4nICsgJyAgICB9LFxcbicgKyAnICAgIGJhc2VIVE1MOiBgPGRpdiBjbGFzcz1cInBhcmFtcy1jb250ZW50XCI+XFxuJyArICcgICAgIDxkaXYgY2xhc3M9XCJ2LXRpdGxlXCI+5YWs5YWx5Y+C5pWwPC9kaXY+ICAgICAgICAgICAgXFxuJyArICcgICAgIDxkaXYgY2xhc3M9XCJ2LXBhcmFtc1wiPlxcbicgKyAnICAgICAgICAgPHNwYW4+bmFtZXNwYWNlPC9zcGFuPlxcbicgKyAnICAgICAgICAgPGRpdiBjbGFzcz1cInYtcGFyYW1zLXZhbHVlXCI+XFxuJyArICcgICAgICAgICAgICAgPGlucHV0IHYtbW9kZWw9XCJuYW1lc3BhY2VcIiAvPlxcbicgKyAnICAgICAgICAgPC9kaXY+XFxuJyArICcgICAgIDwvZGl2PmAgXFxuJyArICcgICB9XSwnICsgJyAgIHVzZVByb3A6ZmFsc2UsXFxuJyArICcgICB1c2VUaXBzOmZhbHNlLFxcbicgKyAnICAgdXNlRW5kOiBmYWxzZSBcXG4nICsgJyAgIH0pO1xcbicgKyAnICAgZGVtby5jaGFydC5yZW5kZXIoX3Z1ZS4kcmVmcy5kZW1vM2NoYXJ0Q29udHJvbCxqc29uKSBcXG4nICsgJ31lbHNlIHsgXFxuJyArICcgIGRlbW8uY2hhcnQucmVuZGVyQ2hhcnQoanNvbikgICcgKyAnfVxcbic7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRlbW80OiB7XG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuICdpZighZGVtby5jaGFydCl7IFxcbicgKyAnICAgZGVtby5jaGFydCA9IG5ldyAgd2luZG93LnRQbHVnaW4oeyBcXG4nICsgJyAgIG1lbnVzRGF0YTogW3tcXG4nICsgJyAgICAgIHRleHQ6IFwi5Y+C5pWwbWVudVwiLFxcbicgKyAnICAgICAgcHJvY0lkOiBcInBweDJcIixcXG4nICsgJyAgICAgIGJhc2VEYXRhOiB7XFxuJyArICcgICAgICAgICAgXCJuYW1lc3BhY2VcIjogXCJkZWZhdWx0XCIsXFxuJyArICcgICAgICAgICAgIFwidGFza05hbWVcIjogXCJleHBvcnQtMDAxXCIsXFxuJyArICcgICAgICB9LFxcbicgKyAnICAgICAgc2NhdHREYXRhOiB7XFxuJyArICcgICAgICAgICAgYmI6IDc4OSBcXG4nICsgJyAgICAgIH0sXFxuJyArICcgICAgICBiYXNlSFRNTDogYDxkaXYgY2xhc3M9XCJwYXJhbXMtY29udGVudFwiPlxcbicgKyAnICAgICAgIDxkaXYgY2xhc3M9XCJ2LXRpdGxlXCI+5YWs5YWx5Y+C5pWwPC9kaXY+ICAgICAgICAgICAgXFxuJyArICcgICAgICAgPGRpdiBjbGFzcz1cInYtcGFyYW1zXCI+XFxuJyArICcgICAgICAgICAgIDxzcGFuPm5hbWVzcGFjZTwvc3Bhbj5cXG4nICsgJyAgICAgICAgICAgPGRpdiBjbGFzcz1cInYtcGFyYW1zLXZhbHVlXCI+XFxuJyArICcgICAgICAgICAgICAgICA8aW5wdXQgdi1tb2RlbD1cIm5hbWVzcGFjZVwiIC8+XFxuJyArICcgICAgICAgICAgIDwvZGl2PlxcbicgKyAnICAgICAgIDwvZGl2PmAgXFxuJyArICcgICB9XSwgXFxuJyArICcgICBwcm9wOnsgXFxuJyArICcgICAgICAgbWV0aG9kczp7IFxcbicgKyAnICAgICAgICAgICBhYSgpeyBcXG4nICsgJyAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiYWFcIikgXFxuJyArICcgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgIFxcbicgKyAnICAgICAgIH0gICAgIFxcbiAgJyArICcgICB9LCAgIFxcbicgKyAnICAgdXNlUHJvcDp0cnVlLFxcbicgKyAnICAgdXNlVGlwczpmYWxzZSxcXG4nICsgJyAgIHVzZUVuZDogZmFsc2UgXFxuJyArICcgICB9KTtcXG4nICsgJyAgIGRlbW8uY2hhcnQucmVuZGVyKF92dWUuJHJlZnMuZGVtbzRjaGFydENvbnRyb2wsanNvbikgXFxuJyArICd9ZWxzZSB7IFxcbicgKyAnICBkZW1vLmNoYXJ0LnJlbmRlckNoYXJ0KGpzb24pICAnICsgJ31cXG4nO1xuICAgICAgICB9XG4gICAgfVxufTtcblxubmV3IHZ1ZSh7XG4gICAgZWw6ICcjYXBwJyxcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVudXM6IHtcbiAgICAgICAgICAgICAgICBkZW1vMToge1xuICAgICAgICAgICAgICAgICAgICBzYXZlSnNvbjogJ3tcIm5vZGVzXCI6W10sXCJjb25uZWN0aW9uc1wiOltdfScsXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcjogZ2V0RXhhbXBsZUNvZGUuZGVtbzEucmVuZGVyKCksXG4gICAgICAgICAgICAgICAgICAgIG5vZGVKc29uOiBnZXRFeGFtcGxlQ29kZS5kZW1vMS5ub2RlSnNvbihwYXJzZUludChNYXRoLnJhbmRvbSgpICogMjAwKSwgcGFyc2VJbnQoTWF0aC5yYW5kb20oKSAqIDMyMCkpLFxuICAgICAgICAgICAgICAgICAgICBhZGROb2RlOiBnZXRFeGFtcGxlQ29kZS5kZW1vMS5hZGROb2RlKCksXG4gICAgICAgICAgICAgICAgICAgIHNhdmU6IGdldEV4YW1wbGVDb2RlLmRlbW8xLnNhdmUoKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVtbzI6IHtcbiAgICAgICAgICAgICAgICAgICAgc2F2ZUpzb246IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcjogZ2V0RXhhbXBsZUNvZGUuZGVtbzIucmVuZGVyKClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRlbW8zOiB7XG4gICAgICAgICAgICAgICAgICAgIHNhdmVKc29uOiAne1wibm9kZXNcIjpbXSxcImNvbm5lY3Rpb25zXCI6W119JyxcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyOiBnZXRFeGFtcGxlQ29kZS5kZW1vMy5yZW5kZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgc2F2ZTogZ2V0RXhhbXBsZUNvZGUuZGVtbzEuc2F2ZSgpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkZW1vNDoge1xuICAgICAgICAgICAgICAgICAgICBzYXZlSnNvbjogJ3tcIm5vZGVzXCI6W10sXCJjb25uZWN0aW9uc1wiOltdfScsXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcjogZ2V0RXhhbXBsZUNvZGUuZGVtbzQucmVuZGVyKCksXG4gICAgICAgICAgICAgICAgICAgIHNhdmU6IGdldEV4YW1wbGVDb2RlLmRlbW8xLnNhdmUoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjdXJCdG46IHtcbiAgICAgICAgICAgICAgICBtZXRob2REZW1vOiAnJyxcbiAgICAgICAgICAgICAgICBkZW1vOiBcIlwiLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250ZW50U3RhdHVzOiBcImludHJvZHVjZVwiLFxuICAgICAgICAgICAgLy/npLrkvovku6PnoIFcbiAgICAgICAgICAgIGRlbW9Db2RlVGV4dDogJydcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7fSxcbiAgICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgICQoJy52LWNvbnRlbnQnKS5yZW1vdmVDbGFzcygndi1ub25lJyk7XG4gICAgICAgIC8v6buY6K6kIOa4suafkyDnirbmgIFcbiAgICAgICAgdGhpcy5ob3ZlckJ0bigncmVuZGVyJywgJ2RlbW8xJyk7XG4gICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnJlbmRlcignZGVtbzEnKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgY29uVGFyZ2V0OiBmdW5jdGlvbiBjb25UYXJnZXQobmFtZSkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50U3RhdHVzID0gbmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9UYXJnZXQ6IGZ1bmN0aW9uIHRvVGFyZ2V0KGRlbW8pIHtcbiAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRTdGF0dXMgPSAnZGVtbyc7XG5cbiAgICAgICAgICAgIHZhciAkdCA9ICQoJ1tkYXRhLXRhcmdldD1cIicgKyBkZW1vICsgJ1wiXScpO1xuICAgICAgICAgICAgdmFyIHRvcCA9ICR0LnBvc2l0aW9uKCkudG9wICsgJCh0aGlzLiRyZWZzLmNvbnRlbnQpLnNjcm9sbFRvcCgpO1xuXG4gICAgICAgICAgICAkKHRoaXMuJHJlZnMuY29udGVudCkuc2Nyb2xsVG9wKHRvcCk7XG5cbiAgICAgICAgICAgIHRoaXMuaG92ZXJCdG4oJ3JlbmRlcicsIGRlbW8pO1xuICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzMi5yZW5kZXIoZGVtbyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVtb0NvZGVDaGFuZ2U6IGZ1bmN0aW9uIGRlbW9Db2RlQ2hhbmdlKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VyQnRuLm1ldGhvZERlbW8gPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWVudXNbdGhpcy5jdXJCdG4uZGVtb11bdGhpcy5jdXJCdG4ubWV0aG9kXSA9IHRoaXMuZGVtb0NvZGVUZXh0O1xuICAgICAgICB9LFxuICAgICAgICBob3ZlckJ0bjogZnVuY3Rpb24gaG92ZXJCdG4obWV0aG9kLCBkZW1vKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kRGVtbyA9IG1ldGhvZCArIGRlbW87XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmN1ckJ0bi5tZXRob2REZW1vID09IG1ldGhvZERlbW8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmN1ckJ0bi5tZXRob2REZW1vID0gbWV0aG9kRGVtbztcbiAgICAgICAgICAgIHRoaXMuY3VyQnRuLmRlbW8gPSBkZW1vO1xuICAgICAgICAgICAgdGhpcy5jdXJCdG4ubWV0aG9kID0gbWV0aG9kO1xuXG4gICAgICAgICAgICB0aGlzLmRlbW9Db2RlVGV4dCA9IHRoaXMubWVudXNbZGVtb11bbWV0aG9kXTsgLy9nZXRFeGFtcGxlQ29kZVtkZW1vXVttZXRob2RdKCk7XG5cblxuICAgICAgICAgICAgdmFyICRjb2RlID0gJCh0aGlzLiRyZWZzLmRlbW9jb2RlKS5maW5kKCd0ZXh0YXJlYScpO1xuICAgICAgICAgICAgdmFyIHRpbWVzID0gMDtcbiAgICAgICAgICAgIHZhciBmdW5jID0gZnVuY3Rpb24gZnVuYygpIHtcbiAgICAgICAgICAgICAgICBpZiAodGltZXMgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGltZXMtLTtcbiAgICAgICAgICAgICAgICAkY29kZS5jc3MoJ2JvcmRlcicsICcxcHggc29saWQgcmdiKDY0LDE1OCwyNTUpJyk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICRjb2RlLmNzcygnYm9yZGVyJywgJycpO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgICAgICAgICB9LCAzMDApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZ1bmMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkTm9kZUFsbDogZnVuY3Rpb24gYWRkTm9kZUFsbChkZW1vKSB7XG4gICAgICAgICAgICBpZiAoZGVtbyBpbiB0aGlzLm1lbnVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGROb2RlKGRlbW8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZW5kZXJBbGw6IGZ1bmN0aW9uIHJlbmRlckFsbCgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5tZW51cykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihrZXkpIHtcbiAgICAgICAgICAgIHZhciBkZW1vID0gdGhpcy5tZW51c1trZXldO1xuXG4gICAgICAgICAgICB2YXIganNvbiA9IHRoaXMubWVudXNba2V5XS5zYXZlSnNvbjtcbiAgICAgICAgICAgIHZhciBjaGFydENvbnRyb2wgPSB0aGlzLiRyZWZzW2tleSArICdjaGFydENvbnRyb2wnXTtcbiAgICAgICAgICAgIHZhciBtZW51Q29udHJvbCA9IHRoaXMuJHJlZnNba2V5ICsgJ21lbnVDb250cm9sJ10gfHwgbnVsbDtcblxuICAgICAgICAgICAgdmFyIGNvZGUgPSB0aGlzLmRlbW9Db2RlVGV4dDtcbiAgICAgICAgICAgIGlmICghZGVtby5jaGFydCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gZGVtby5yZW5kZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYyA9IG5ldyBGdW5jdGlvbihcImRlbW9cIiwgXCJqc29uXCIsIFwiY2hhcnRDb250cm9sXCIsIFwibWVudUNvbnRyb2xcIiwgXCJfdnVlXCIsIGNvZGUpO1xuXG4gICAgICAgICAgICBjKGRlbW8sIGpzb24sIGNoYXJ0Q29udHJvbCwgbWVudUNvbnRyb2wsIHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzLmRlbW9Db2RlVGV4dCA9IGNvZGU7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZE5vZGU6IGZ1bmN0aW9uIGFkZE5vZGUoa2V5KSB7XG4gICAgICAgICAgICB2YXIgY2hhcnQgPSB0aGlzLm1lbnVzW2tleV0uY2hhcnQ7XG5cbiAgICAgICAgICAgIHZhciBjb2RlID0gdGhpcy5kZW1vQ29kZVRleHQ7XG5cbiAgICAgICAgICAgIG5ldyBGdW5jdGlvbihcImNoYXJ0XCIsIGNvZGUpKGNoYXJ0KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2F2ZTogZnVuY3Rpb24gc2F2ZShrZXkpIHtcbiAgICAgICAgICAgIHZhciBjaGFydCA9IHRoaXMubWVudXNba2V5XS5jaGFydDtcblxuICAgICAgICAgICAgdmFyIGNvZGUgPSB0aGlzLmRlbW9Db2RlVGV4dDtcblxuICAgICAgICAgICAgdmFyIHN0ciA9IG5ldyBGdW5jdGlvbihcImNoYXJ0XCIsIGNvZGUpKGNoYXJ0KTtcblxuICAgICAgICAgICAgdGhpcy5tZW51c1trZXldLnNhdmVKc29uID0gc3RyO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbiQoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybjtcbiAgICB2YXIgdCA9IHdpbmRvdy50ID0gbmV3IHdpbmRvdy50UGx1Z2luKHtcbiAgICAgICAgLy/oioLngrnmlbDmja5cbiAgICAgICAgbWVudXNEYXRhOiBbe1xuICAgICAgICAgICAgdGV4dDogXCJ0dFwiLFxuICAgICAgICAgICAgcHJvY0lkOiBcInBweFwiLFxuICAgICAgICAgICAgYmFzZURhdGE6IHtcbiAgICAgICAgICAgICAgICBhYTogMTIzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2NhdHREYXRhOiB7XG4gICAgICAgICAgICAgICAgYmI6IDQ1NlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJhc2VIVE1MOiAnPGlucHV0IHYtbW9kZWw9XCJhYVwiIC8+JyxcbiAgICAgICAgICAgIHNjYXR0SFRNTDogJzxpbnB1dCB2LW1vZGVsPVwiYmJcIiAvPidcbiAgICAgICAgfV0sXG4gICAgICAgIGNoYXJ0OiB7XG4gICAgICAgICAgICBub2RlRGVsOiB7XG4gICAgICAgICAgICAgICAgY292ZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgcnVuOiBmdW5jdGlvbiBydW4obm9kZURhdGEsIGRlbE5vZGUpIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVsTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsTm9kZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU5vZGUoZGVsTm9kZS5faWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1c2VQcm9wOiB0cnVlLFxuICAgICAgICBwcm9wOiB7XG4gICAgICAgICAgICBtZXRob2RzOiB7XG4gICAgICAgICAgICAgICAgYWFtOiBmdW5jdGlvbiBhYW0oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuanNvbi5yZXN1bHQgPSBcInRydWVcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0YUNoYW5nZTogZnVuY3Rpb24gZGF0YUNoYW5nZShub2RlLCBrZXksIG5ld1ZhbCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG5vZGUsIGtleSwgbmV3VmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdXNlU3RhcnQ6IHRydWUsXG4gICAgICAgIHVzZUVuZDogZmFsc2VcbiAgICB9KTtcblxuICAgIHZhciBhcnIgPSBbJ3tcIm5vZGVzXCI6W3tcInByb2NJZFwiOlwicHlTcGFya1wiLFwicGFyYW1zXCI6e1wicmVtb3ZhYmxlXCI6dHJ1ZSxcInN0YXR1c1wiOlwiXCIsXCJuYW1lc3BhY2VcIjpcIlwiLFwidGFza05hbWVcIjpcIlwiLFwib3duZXJcIjpcIlwiLFwiY29udGFpbmVySW1hZ2VcIjpcIlwiLFwiZXhlY3V0b3JDcHVSZXF1aXJlbWVudFwiOlwiXCIsXCJleGVjdXRvck1lbVJlcXVpcmVtZW50XCI6XCJcIn0sXCJuYW1lXCI6XCJweVNwYXJrXCIsXCJub2RlSWRcIjpcIm4xMzE3Mjg3ODg4MFwiLFwiX3hcIjoyNjMsXCJfeVwiOjI1MCxcImNsYXNzTmFtZVwiOlwibm9kZS1wcm9jZXNzXCIsXCJyZW1vdmFibGVcIjp0cnVlLFwiZWxJZFwiOlwibjEzMTcyODc4ODgwXCIsXCJ1blBvcnRcIjpmYWxzZX0se1wicHJvY0lkXCI6XCJzcGFya1wiLFwicGFyYW1zXCI6e1wicmVtb3ZhYmxlXCI6dHJ1ZSxcIm5hbWVzcGFjZVwiOlwiXCIsXCJ0YXNrTmFtZVwiOlwiXCIsXCJvd25lclwiOlwiXCIsXCJjb250YWluZXJJbWFnZVwiOlwiXCIsXCJleGVjdXRvckNwdVJlcXVpcmVtZW50XCI6XCJcIixcImV4ZWN1dG9yTWVtUmVxdWlyZW1lbnRcIjpcIlwifSxcIm5hbWVcIjpcInNwYXJrXCIsXCJub2RlSWRcIjpcIm40MzE3Mjg5NTE5MlwiLFwiX3hcIjo0MTUsXCJfeVwiOjM2MCxcImNsYXNzTmFtZVwiOlwibm9kZS1wcm9jZXNzXCIsXCJyZW1vdmFibGVcIjp0cnVlLFwiZWxJZFwiOlwibjQzMTcyODk1MTkyXCIsXCJ1blBvcnRcIjpmYWxzZX0se1wibmFtZVwiOlwiXCIsXCJub2RlSWRcIjpcIm4wMzQ0OTc3ODczN1wiLFwiX3hcIjo0MTksXCJfeVwiOjExLFwiY2xhc3NOYW1lXCI6XCJcIixcInJlbW92YWJsZVwiOmZhbHNlLFwiZWxJZFwiOlwibjAzNDQ5Nzc4NzM3XCIsXCJ1blBvcnRcIjp0cnVlLFwibm9kZVN0eWxlXCI6XCJzdGFydFwifSx7XCJuYW1lXCI6XCJcIixcIm5vZGVJZFwiOlwibjEzNDQ5Nzc4NzQwXCIsXCJfeFwiOjI1OCxcIl95XCI6NDcyLFwiY2xhc3NOYW1lXCI6XCJcIixcInJlbW92YWJsZVwiOmZhbHNlLFwiZWxJZFwiOlwibjEzNDQ5Nzc4NzQwXCIsXCJ1blBvcnRcIjp0cnVlLFwibm9kZVN0eWxlXCI6XCJlbmRcIn0se1wicHJvY0lkXCI6XCJub3JtYWxcIixcInBhcmFtc1wiOntcIm5hbWVzcGFjZVwiOlwiZGVmYXVsdFwiLFwidGFza05hbWVcIjpcImV4cG9ydC0wMDFcIixcIm93bmVyXCI6XCJkYnlpblwiLFwicmVtb3ZhYmxlXCI6dHJ1ZSxcInN0YXR1c1wiOlwiXCIsXCJjb250YWluZXJJbWFnZVwiOlwiXCIsXCJleGVjdXRvckNwdVJlcXVpcmVtZW50XCI6XCJcIixcImV4ZWN1dG9yTWVtUmVxdWlyZW1lbnRcIjpcIlwiLFwianNvblwiOntcImFcIjpcIjExZ2dnXCJ9fSxcIm5hbWVcIjpcIlxcdTY2NkVcXHU5MDFBXFx1OEJBMVxcdTdCOTdcIixcIm5vZGVJZFwiOlwibjE0MTE4NzI0NTYxXCIsXCJfeFwiOjM5OSxcIl95XCI6MTQyLFwiY2xhc3NOYW1lXCI6XCJub2RlLXByb2Nlc3NcIixcInJlbW92YWJsZVwiOnRydWUsXCJlbElkXCI6XCJuMTQxMTg3MjQ1NjFcIixcInVuUG9ydFwiOmZhbHNlfV0sXCJjb25uZWN0aW9uc1wiOlt7XCJjb25uZWN0aW9uSWRcIjpcImNvbl8yNVwiLFwicGFnZVNvdXJjZUlkXCI6XCJuMTMxNzI4Nzg4ODBcIixcInBhZ2VUYXJnZXRJZFwiOlwibjQzMTcyODk1MTkyXCJ9LHtcImNvbm5lY3Rpb25JZFwiOlwiY29uXzM1XCIsXCJwYWdlU291cmNlSWRcIjpcIm40MzE3Mjg5NTE5MlwiLFwicGFnZVRhcmdldElkXCI6XCJuMTM0NDk3Nzg3NDBcIixcIm5vZGVTdHlsZVwiOlwiZW5kXCJ9LHtcImNvbm5lY3Rpb25JZFwiOlwiY29uXzU4XCIsXCJwYWdlU291cmNlSWRcIjpcIm4wMzQ0OTc3ODczN1wiLFwicGFnZVRhcmdldElkXCI6XCJuMTQxMTg3MjQ1NjFcIixcIm5vZGVTdHlsZVwiOlwic3RhcnRcIn0se1wiY29ubmVjdGlvbklkXCI6XCJjb25fNjJcIixcInBhZ2VTb3VyY2VJZFwiOlwibjE0MTE4NzI0NTYxXCIsXCJwYWdlVGFyZ2V0SWRcIjpcIm4xMzE3Mjg3ODg4MFwifV19JywgJ3tcIm5vZGVzXCI6W3tcInByb2NJZFwiOlwicHlTcGFya1wiLFwicGFyYW1zXCI6e1wicmVtb3ZhYmxlXCI6dHJ1ZSxcInN0YXR1c1wiOlwiXCIsXCJuYW1lc3BhY2VcIjpcIlwiLFwidGFza05hbWVcIjpcIlwiLFwib3duZXJcIjpcIlwiLFwiY29udGFpbmVySW1hZ2VcIjpcIlwiLFwiZXhlY3V0b3JDcHVSZXF1aXJlbWVudFwiOlwiXCIsXCJleGVjdXRvck1lbVJlcXVpcmVtZW50XCI6XCJcIn0sXCJuYW1lXCI6XCJweVNwYXJrXCIsXCJub2RlSWRcIjpcIm4xMzE3Mjg3ODg4MFwiLFwiX3hcIjoxMDgsXCJfeVwiOjI0OCxcImNsYXNzTmFtZVwiOlwibm9kZS1wcm9jZXNzXCIsXCJyZW1vdmFibGVcIjp0cnVlLFwiZWxJZFwiOlwibjEzMTcyODc4ODgwXCIsXCJ1blBvcnRcIjpmYWxzZX0se1wicHJvY0lkXCI6XCJzcGFya1wiLFwicGFyYW1zXCI6e1wicmVtb3ZhYmxlXCI6dHJ1ZSxcIm5hbWVzcGFjZVwiOlwiXCIsXCJ0YXNrTmFtZVwiOlwiXCIsXCJvd25lclwiOlwiXCIsXCJjb250YWluZXJJbWFnZVwiOlwiXCIsXCJleGVjdXRvckNwdVJlcXVpcmVtZW50XCI6XCJcIixcImV4ZWN1dG9yTWVtUmVxdWlyZW1lbnRcIjpcIlwifSxcIm5hbWVcIjpcInNwYXJrXCIsXCJub2RlSWRcIjpcIm40MzE3Mjg5NTE5MlwiLFwiX3hcIjo0NTgsXCJfeVwiOjI1NixcImNsYXNzTmFtZVwiOlwibm9kZS1wcm9jZXNzXCIsXCJyZW1vdmFibGVcIjp0cnVlLFwiZWxJZFwiOlwibjQzMTcyODk1MTkyXCIsXCJ1blBvcnRcIjpmYWxzZX0se1wibmFtZVwiOlwiXCIsXCJub2RlSWRcIjpcIm4wMzQ0OTg5MzA1NFwiLFwiX3hcIjozODIsXCJfeVwiOjE5LFwiY2xhc3NOYW1lXCI6XCJcIixcInJlbW92YWJsZVwiOmZhbHNlLFwiZWxJZFwiOlwibjAzNDQ5ODkzMDU0XCIsXCJ1blBvcnRcIjp0cnVlLFwibm9kZVN0eWxlXCI6XCJzdGFydFwifSx7XCJuYW1lXCI6XCJcIixcIm5vZGVJZFwiOlwibjEzNDQ5ODkzMDU3XCIsXCJfeFwiOjMwNixcIl95XCI6MzQ4LFwiY2xhc3NOYW1lXCI6XCJcIixcInJlbW92YWJsZVwiOmZhbHNlLFwiZWxJZFwiOlwibjEzNDQ5ODkzMDU3XCIsXCJ1blBvcnRcIjp0cnVlLFwibm9kZVN0eWxlXCI6XCJlbmRcIn0se1wicHJvY0lkXCI6XCJub3JtYWxcIixcInBhcmFtc1wiOntcIm5hbWVzcGFjZVwiOlwiZGVmYXVsdFwiLFwidGFza05hbWVcIjpcImV4cG9ydC0wMDFcIixcIm93bmVyXCI6XCJkYnlpblwiLFwicmVtb3ZhYmxlXCI6dHJ1ZSxcInN0YXR1c1wiOlwiXCIsXCJjb250YWluZXJJbWFnZVwiOlwiXCIsXCJleGVjdXRvckNwdVJlcXVpcmVtZW50XCI6XCJcIixcImV4ZWN1dG9yTWVtUmVxdWlyZW1lbnRcIjpcIlwiLFwianNvblwiOntcImFcIjoxMX19LFwibmFtZVwiOlwiXFx1NjY2RVxcdTkwMUFcXHU4QkExXFx1N0I5N1wiLFwibm9kZUlkXCI6XCJuMjQxMTg3NzYwNTdcIixcIl94XCI6MjgwLFwiX3lcIjoxMzMsXCJjbGFzc05hbWVcIjpcIm5vZGUtcHJvY2Vzc1wiLFwicmVtb3ZhYmxlXCI6dHJ1ZSxcImVsSWRcIjpcIm4yNDExODc3NjA1N1wiLFwidW5Qb3J0XCI6ZmFsc2V9XSxcImNvbm5lY3Rpb25zXCI6W3tcImNvbm5lY3Rpb25JZFwiOlwiY29uXzEwNVwiLFwicGFnZVNvdXJjZUlkXCI6XCJuMTMxNzI4Nzg4ODBcIixcInBhZ2VUYXJnZXRJZFwiOlwibjEzNDQ5ODkzMDU3XCIsXCJub2RlU3R5bGVcIjpcImVuZFwifSx7XCJjb25uZWN0aW9uSWRcIjpcImNvbl8xMTBcIixcInBhZ2VTb3VyY2VJZFwiOlwibjQzMTcyODk1MTkyXCIsXCJwYWdlVGFyZ2V0SWRcIjpcIm4xMzQ0OTg5MzA1N1wiLFwibm9kZVN0eWxlXCI6XCJlbmRcIn0se1wiY29ubmVjdGlvbklkXCI6XCJjb25fMTI4XCIsXCJwYWdlU291cmNlSWRcIjpcIm4wMzQ0OTg5MzA1NFwiLFwicGFnZVRhcmdldElkXCI6XCJuMjQxMTg3NzYwNTdcIixcIm5vZGVTdHlsZVwiOlwic3RhcnRcIn0se1wiY29ubmVjdGlvbklkXCI6XCJjb25fMTMyXCIsXCJwYWdlU291cmNlSWRcIjpcIm4yNDExODc3NjA1N1wiLFwicGFnZVRhcmdldElkXCI6XCJuMTMxNzI4Nzg4ODBcIn0se1wiY29ubmVjdGlvbklkXCI6XCJjb25fMTM4XCIsXCJwYWdlU291cmNlSWRcIjpcIm4yNDExODc3NjA1N1wiLFwicGFnZVRhcmdldElkXCI6XCJuNDMxNzI4OTUxOTJcIn1dfScsICd7XCJub2Rlc1wiOlt7XCJwcm9jSWRcIjpcInB5U3BhcmtcIixcInBhcmFtc1wiOntcInJlbW92YWJsZVwiOnRydWUsXCJzdGF0dXNcIjpcIlwiLFwibmFtZXNwYWNlXCI6XCJcIixcInRhc2tOYW1lXCI6XCJcIixcIm93bmVyXCI6XCJcIixcImNvbnRhaW5lckltYWdlXCI6XCJcIixcImV4ZWN1dG9yQ3B1UmVxdWlyZW1lbnRcIjpcIlwiLFwiZXhlY3V0b3JNZW1SZXF1aXJlbWVudFwiOlwiXCJ9LFwibmFtZVwiOlwicHlTcGFya1wiLFwibm9kZUlkXCI6XCJuMTMxNzI4Nzg4ODBcIixcIl94XCI6MjA0LFwiX3lcIjoxMjMsXCJjbGFzc05hbWVcIjpcIm5vZGUtcHJvY2Vzc1wiLFwicmVtb3ZhYmxlXCI6dHJ1ZSxcImVsSWRcIjpcIm4xMzE3Mjg3ODg4MFwiLFwidW5Qb3J0XCI6ZmFsc2V9LHtcInByb2NJZFwiOlwidGR3T3V0cHV0XCIsXCJwYXJhbXNcIjp7XCJuYW1lc3BhY2VcIjpcImRlZmF1bHRcIixcInRhc2tOYW1lXCI6XCJleHBvcnQtMDAxXCIsXCJvd25lclwiOlwiZGJ5aW5cIixcInJlbW92YWJsZVwiOnRydWUsXCJ0ZHdVc2VyUHdkXCI6XCJ0ZHdfZGJ5aW46ZGJ5aW5cIixcInRkd0FwcElkXCI6XCJkYnlpbl9hcHBcIixcImRldGFpbHNcIjpbe1wic3JjSGRmc0FkZHJcIjpcIiBoZGZzOi8vc2guaGRmcy5jci5pZWQuY29tOjkwMDAvdGR3LXRyYW5zZmVyLWRhdGEvZGJ5aW4vMjAxNzA3MDcxOTMzNTEzMTMvMjAxNzEwMDhcIixcInRkd0hkZnNBZGRyXCI6XCJoZGZzOi8vdGwtaWYtbm4tdGR3LnRlbmNlbnQtZGlzdHJpYnV0ZS5jb206NTQzMTAvc3RhZ2Uvb3V0ZmFjZS9JRUcvZGJ5aW5fYXBwL2RieWluL2RvY2tlcl90ZXN0LzIwMTcxMDA4XCJ9LHtcInNyY0hkZnNBZGRyXCI6XCIgaGRmczovL3NoLmhkZnMuY3IuaWVkLmNvbTo5MDAwL3Rkdy10cmFuc2Zlci1kYXRhL2RieWluLzIwMTcwNzA3MTkzMzUxMzEzLzIwMTcxMDA5XCIsXCJ0ZHdIZGZzQWRkclwiOlwiaGRmczovL3RsLWlmLW5uLXRkdy50ZW5jZW50LWRpc3RyaWJ1dGUuY29tOjU0MzEwL3N0YWdlL291dGZhY2UvSUVHL2RieWluX2FwcC9kYnlpbi9kb2NrZXJfdGVzdC8yMDE3MTAwOVwifV19LFwibmFtZVwiOlwidGR3T3V0cHV0XCIsXCJub2RlSWRcIjpcIm40MzQ0OTk0NzU3NlwiLFwiX3hcIjotMjY3LFwiX3lcIjozODUsXCJjbGFzc05hbWVcIjpcIm5vZGUtcHJvY2Vzc1wiLFwicmVtb3ZhYmxlXCI6dHJ1ZSxcImVsSWRcIjpcIm40MzQ0OTk0NzU3NlwiLFwidW5Qb3J0XCI6ZmFsc2V9LHtcIm5hbWVcIjpcIlwiLFwibm9kZUlkXCI6XCJuMjM0NDk5MjY4NjhcIixcIl94XCI6MTk0LFwiX3lcIjoyNSxcImNsYXNzTmFtZVwiOlwiXCIsXCJyZW1vdmFibGVcIjpmYWxzZSxcImVsSWRcIjpcIm4yMzQ0OTkyNjg2OFwiLFwidW5Qb3J0XCI6dHJ1ZSxcIm5vZGVTdHlsZVwiOlwic3RhcnRcIn0se1wibmFtZVwiOlwiXCIsXCJub2RlSWRcIjpcIm4zMzQ0OTkyNjg3MVwiLFwiX3hcIjo0ODksXCJfeVwiOjI3OCxcImNsYXNzTmFtZVwiOlwiXCIsXCJyZW1vdmFibGVcIjpmYWxzZSxcImVsSWRcIjpcIm4zMzQ0OTkyNjg3MVwiLFwidW5Qb3J0XCI6dHJ1ZSxcIm5vZGVTdHlsZVwiOlwiZW5kXCJ9LHtcInByb2NJZFwiOlwidGR3SW5wdXRcIixcInBhcmFtc1wiOntcIm5hbWVzcGFjZVwiOlwiZGVmYXVsdFwiLFwidGFza05hbWVcIjpcImV4cG9ydC0wMDFcIixcIm93bmVyXCI6XCJkYnlpblwiLFwicmVtb3ZhYmxlXCI6dHJ1ZSxcInRkd1VzZXJQd2RcIjpcInRkd19kYnlpbjpkYnlpblwiLFwidGR3QXBwSWRcIjpcImRieWluX2FwcFwiLFwiZGV0YWlsc1wiOlt7XCJzcmNIZGZzQWRkclwiOlwiIGhkZnM6Ly9zaC5oZGZzLmNyLmllZC5jb206OTAwMC90ZHctdHJhbnNmZXItZGF0YS9kYnlpbi8yMDE3MDcwNzE5MzM1MTMxMy8yMDE3MTAwOFwiLFwidGR3SGRmc0FkZHJcIjpcImhkZnM6Ly90bC1pZi1ubi10ZHcudGVuY2VudC1kaXN0cmlidXRlLmNvbTo1NDMxMC9zdGFnZS9vdXRmYWNlL0lFRy9kYnlpbl9hcHAvZGJ5aW4vZG9ja2VyX3Rlc3QvMjAxNzEwMDhcIn0se1wic3JjSGRmc0FkZHJcIjpcIiBoZGZzOi8vc2guaGRmcy5jci5pZWQuY29tOjkwMDAvdGR3LXRyYW5zZmVyLWRhdGEvZGJ5aW4vMjAxNzA3MDcxOTMzNTEzMTMvMjAxNzEwMDlcIixcInRkd0hkZnNBZGRyXCI6XCJoZGZzOi8vdGwtaWYtbm4tdGR3LnRlbmNlbnQtZGlzdHJpYnV0ZS5jb206NTQzMTAvc3RhZ2Uvb3V0ZmFjZS9JRUcvZGJ5aW5fYXBwL2RieWluL2RvY2tlcl90ZXN0LzIwMTcxMDA5XCJ9XX0sXCJuYW1lXCI6XCJ0ZHdJbnB1dFwiLFwibm9kZUlkXCI6XCJuMjM0NTAxMDIzMTFcIixcIl94XCI6Mzg0LFwiX3lcIjoxODIsXCJjbGFzc05hbWVcIjpcIm5vZGUtcHJvY2Vzc1wiLFwicmVtb3ZhYmxlXCI6dHJ1ZSxcImVsSWRcIjpcIm4yMzQ1MDEwMjMxMVwiLFwidW5Qb3J0XCI6ZmFsc2V9XSxcImNvbm5lY3Rpb25zXCI6W3tcImNvbm5lY3Rpb25JZFwiOlwiY29uXzk5XCIsXCJwYWdlU291cmNlSWRcIjpcIm4yMzQ0OTkyNjg2OFwiLFwicGFnZVRhcmdldElkXCI6XCJuMTMxNzI4Nzg4ODBcIn0se1wiY29ubmVjdGlvbklkXCI6XCJjb25fMTIxXCIsXCJwYWdlU291cmNlSWRcIjpcIm4yMzQ1MDEwMjMxMVwiLFwicGFnZVRhcmdldElkXCI6XCJuMzM0NDk5MjY4NzFcIn0se1wiY29ubmVjdGlvbklkXCI6XCJjb25fMTM0XCIsXCJwYWdlU291cmNlSWRcIjpcIm4xMzE3Mjg3ODg4MFwiLFwicGFnZVRhcmdldElkXCI6XCJuMjM0NTAxMDIzMTFcIn1dfScsICd7XCJub2Rlc1wiOltdLFwiY29ubmVjdGlvbnNcIjpbXX0nXTtcbiAgICByZXR1cm47XG5cbiAgICAvL+WIneasoei9veWFpVxuICAgIHQucmVuZGVyKFwiI2NoYXJ0Q29udGVudFwiLCBhcnJbMF0pO1xuXG4gICAgLy/ovb3lhaVcbiAgICAkKFwiI3NlbGVjdFRvb3JcIikub24oJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbCA9IHBhcnNlSW50KCQodGhpcykudmFsKCkpO1xuICAgICAgICAvL+S6jOasoea4suafk1xuICAgICAgICB0LnJlbmRlckNoYXJ0KGFyclt2YWwgLSAxXSk7XG4gICAgfSk7XG5cbiAgICAvL+S/neWtmFxuICAgICQoJyNzYXZlJykub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBzdHIgPSBKU09OLnN0cmluZ2lmeSh0LmNoYXJ0Q29udHJvbC50b0pzb24oKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKHN0cik7XG4gICAgICAgIHZhciBibGcgPSB0LmNoZWNrQ29udHJvbC5jaGVjaygnY2xvc2VkTG9vcCBpc2xhbmQnLCB0LmNoYXJ0Q29udHJvbC50b0pzb24oKSk7XG4gICAgICAgIGlmICghYmxnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIuWQq+aciemXreeOryDmiJbogIUg5a2k56uL6IqC54K5XCIpO1xuICAgICAgICB9XG4gICAgfSk7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3RwbHVnaW4vc3JjL2pzL3NjYWZmL2Nycy9jcnMuaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///167\n')},27:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return menuBases; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_menu_menuBase_js__ = __webpack_require__(68);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_0__core_menu_menuBase_js__["b"]; });\n\n\nvar menuBases = function menuBases() {\n    __WEBPACK_IMPORTED_MODULE_0__core_menu_menuBase_js__["a" /* menuBase */].call(this);\n\n    this.procId = "crs";\n    this.text = "crs";\n    //组件的 公共数据结构\n    this.baseData = $.extend(this.baseData, {\n        "namespace": "default",\n        "taskName": "export-001",\n        "owner": "dbyin"\n    });\n\n    this.baseHTML = "\\n        <div class=\\"params-content\\">\\n            <div class=\\"v-title\\">\\u516C\\u5171\\u53C2\\u6570</div>  \\n\\n            <div class=\\"v-params\\">\\n                <span>namespace</span>\\n                <div class=\\"v-params-value\\">\\n                    <input v-model=\\"namespace\\" />\\n                </div>\\n            </div>\\n            <div class=\\"v-params\\">\\n                <span>taskName</span>\\n                <div class=\\"v-params-value\\">\\n                    <input v-model=\\"taskName\\" />\\n                </div>\\n            </div>\\n            <div class=\\"v-params\\">\\n                <span>owner</span>\\n                <div class=\\"v-params-value\\">\\n                    <input v-model=\\"owner\\" />\\n                </div>\\n            </div>\\n        </div>\\n    ";\n\n    //添加后的节点是否可以删除\n    this.baseData.removable = true;\n\n    //设置 图形节点的内容\n    this.setNodeElement = function (data) {\n\n        return "";\n    };\n};\n\n__WEBPACK_IMPORTED_MODULE_0__core_menu_menuBase_js__["b" /* menuRegister */].add(menuBases);\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zY2FmZi9tZW51cy9jcnNDaGlsZC9jcnNCYXNlLmpzP2JjMWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbWVudUJhc2UsIG1lbnVSZWdpc3RlciB9IGZyb20gJy4uLy4uLy4uL2NvcmUvbWVudS9tZW51QmFzZS5qcyc7XG5cbnZhciBtZW51QmFzZXMgPSBmdW5jdGlvbiBtZW51QmFzZXMoKSB7XG4gICAgbWVudUJhc2UuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMucHJvY0lkID0gXCJjcnNcIjtcbiAgICB0aGlzLnRleHQgPSBcImNyc1wiO1xuICAgIC8v57uE5Lu255qEIOWFrOWFseaVsOaNrue7k+aehFxuICAgIHRoaXMuYmFzZURhdGEgPSAkLmV4dGVuZCh0aGlzLmJhc2VEYXRhLCB7XG4gICAgICAgIFwibmFtZXNwYWNlXCI6IFwiZGVmYXVsdFwiLFxuICAgICAgICBcInRhc2tOYW1lXCI6IFwiZXhwb3J0LTAwMVwiLFxuICAgICAgICBcIm93bmVyXCI6IFwiZGJ5aW5cIlxuICAgIH0pO1xuXG4gICAgdGhpcy5iYXNlSFRNTCA9IFwiXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwYXJhbXMtY29udGVudFxcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidi10aXRsZVxcXCI+XFx1NTE2Q1xcdTUxNzFcXHU1M0MyXFx1NjU3MDwvZGl2PiAgXFxuXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidi1wYXJhbXNcXFwiPlxcbiAgICAgICAgICAgICAgICA8c3Bhbj5uYW1lc3BhY2U8L3NwYW4+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInYtcGFyYW1zLXZhbHVlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB2LW1vZGVsPVxcXCJuYW1lc3BhY2VcXFwiIC8+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInYtcGFyYW1zXFxcIj5cXG4gICAgICAgICAgICAgICAgPHNwYW4+dGFza05hbWU8L3NwYW4+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInYtcGFyYW1zLXZhbHVlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB2LW1vZGVsPVxcXCJ0YXNrTmFtZVxcXCIgLz5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidi1wYXJhbXNcXFwiPlxcbiAgICAgICAgICAgICAgICA8c3Bhbj5vd25lcjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidi1wYXJhbXMtdmFsdWVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHYtbW9kZWw9XFxcIm93bmVyXFxcIiAvPlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICBcIjtcblxuICAgIC8v5re75Yqg5ZCO55qE6IqC54K55piv5ZCm5Y+v5Lul5Yig6ZmkXG4gICAgdGhpcy5iYXNlRGF0YS5yZW1vdmFibGUgPSB0cnVlO1xuXG4gICAgLy/orr7nva4g5Zu+5b2i6IqC54K555qE5YaF5a65XG4gICAgdGhpcy5zZXROb2RlRWxlbWVudCA9IGZ1bmN0aW9uIChkYXRhKSB7XG5cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfTtcbn07XG5cbm1lbnVSZWdpc3Rlci5hZGQobWVudUJhc2VzKTtcblxuZXhwb3J0IHsgbWVudUJhc2VzIGFzIG1lbnVCYXNlLCBtZW51UmVnaXN0ZXIgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NjYWZmL21lbnVzL2Nyc0NoaWxkL2Nyc0Jhc2UuanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///27\n')},67:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('var chartController = function chartController(select, options) {\n    this.jq = $(select);\n    this.options = $.extend({\n        nodeClick: function nodeClick(data, node) {},\n        nodeDbClick: function nodeDbClick(data, node) {},\n        nodeDel: function nodeDel(data, node) {},\n        nodeInputBlur: function nodeInputBlur(data, node) {},\n        contentClick: function contentClick() {}\n    }, options);\n\n    //新建 流程图实例\n    this.createFlow = function (chart) {\n        this.chart = new chart($(this.jq), this.options);\n    };\n\n    //添加一个节点\n    this.addNode = function (option) {\n        this.chart.addNode(option);\n    };\n\n    //清空画布\n    this.clear = function () {\n        this.chart.clear();\n    };\n\n    //把图形转为json，并返回\n    this.toJson = function () {\n        return this.chart.toJson();\n    };\n\n    //基于json 渲染图形\n    this.fromJson = function (json, option) {\n        return this.chart.fromJson(json, option);\n    };\n\n    //添加起点 节点\n    this.addNodeStart = function (options) {\n        return this.chart.addNodeStart(options);\n    };\n};\n\n/* harmony default export */ __webpack_exports__["a"] = (chartController);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zY2FmZi9jaGFydC9iYXNlL2NoYXJ0Q29udHJvbGxlci5qcz9jMDA1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBjaGFydENvbnRyb2xsZXIgPSBmdW5jdGlvbiBjaGFydENvbnRyb2xsZXIoc2VsZWN0LCBvcHRpb25zKSB7XG4gICAgdGhpcy5qcSA9ICQoc2VsZWN0KTtcbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7XG4gICAgICAgIG5vZGVDbGljazogZnVuY3Rpb24gbm9kZUNsaWNrKGRhdGEsIG5vZGUpIHt9LFxuICAgICAgICBub2RlRGJDbGljazogZnVuY3Rpb24gbm9kZURiQ2xpY2soZGF0YSwgbm9kZSkge30sXG4gICAgICAgIG5vZGVEZWw6IGZ1bmN0aW9uIG5vZGVEZWwoZGF0YSwgbm9kZSkge30sXG4gICAgICAgIG5vZGVJbnB1dEJsdXI6IGZ1bmN0aW9uIG5vZGVJbnB1dEJsdXIoZGF0YSwgbm9kZSkge30sXG4gICAgICAgIGNvbnRlbnRDbGljazogZnVuY3Rpb24gY29udGVudENsaWNrKCkge31cbiAgICB9LCBvcHRpb25zKTtcblxuICAgIC8v5paw5bu6IOa1geeoi+WbvuWunuS+i1xuICAgIHRoaXMuY3JlYXRlRmxvdyA9IGZ1bmN0aW9uIChjaGFydCkge1xuICAgICAgICB0aGlzLmNoYXJ0ID0gbmV3IGNoYXJ0KCQodGhpcy5qcSksIHRoaXMub3B0aW9ucyk7XG4gICAgfTtcblxuICAgIC8v5re75Yqg5LiA5Liq6IqC54K5XG4gICAgdGhpcy5hZGROb2RlID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICB0aGlzLmNoYXJ0LmFkZE5vZGUob3B0aW9uKTtcbiAgICB9O1xuXG4gICAgLy/muIXnqbrnlLvluINcbiAgICB0aGlzLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNoYXJ0LmNsZWFyKCk7XG4gICAgfTtcblxuICAgIC8v5oqK5Zu+5b2i6L2s5Li6anNvbu+8jOW5tui/lOWbnlxuICAgIHRoaXMudG9Kc29uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFydC50b0pzb24oKTtcbiAgICB9O1xuXG4gICAgLy/ln7rkuo5qc29uIOa4suafk+WbvuW9olxuICAgIHRoaXMuZnJvbUpzb24gPSBmdW5jdGlvbiAoanNvbiwgb3B0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYXJ0LmZyb21Kc29uKGpzb24sIG9wdGlvbik7XG4gICAgfTtcblxuICAgIC8v5re75Yqg6LW354K5IOiKgueCuVxuICAgIHRoaXMuYWRkTm9kZVN0YXJ0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhcnQuYWRkTm9kZVN0YXJ0KG9wdGlvbnMpO1xuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjaGFydENvbnRyb2xsZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zY2FmZi9jaGFydC9iYXNlL2NoYXJ0Q29udHJvbGxlci5qc1xuLy8gbW9kdWxlIGlkID0gNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///67\n')},68:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return menuRegister; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return menuBase; });\nvar menuRegister = {\n    _menus: [],\n    add: function add(menu) {\n        var tmp = null;\n        if (typeof menu === "function") {\n            tmp = new menu();\n        } else {\n            tmp = menu;\n        }\n        var blg = false;\n        this._menus.forEach(function (m) {\n            if (tmp.procId === m.procId) {\n                blg = true;\n                return false;\n            }\n        });\n        if (blg === false) {\n            this._menus.push(tmp);\n        }\n    },\n    //获得具体的menu对象\n    getMenuObj: function getMenuObj(procId) {\n        for (var i = 0; i < this._menus.length; i++) {\n            var menu = this._menus[i];\n\n            if (menu.procId == procId) {\n                return menu;\n            }\n        };\n        return null;\n    },\n\n    //获取menu对象\n    getMenus: function getMenus() {\n        return this._menus;\n    }\n};\n\nvar menuBase = function menuBase() {\n    //菜单标题\n    this.text = "root";\n    //类的唯一标识\n    this.procId = "0";\n\n    //组件的 公共数据结构\n    this.baseData = {};\n\n    //组件的 特性数据结构\n    this.scattData = {};\n\n    //组件的 公共模板 (vue.js模板语法)\n    this.baseHTML = "";\n\n    //特性模板\n    this.scattHTML = "";\n};\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb3JlL21lbnUvbWVudUJhc2UuanM/YWI3YyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbWVudVJlZ2lzdGVyID0ge1xuICAgIF9tZW51czogW10sXG4gICAgYWRkOiBmdW5jdGlvbiBhZGQobWVudSkge1xuICAgICAgICB2YXIgdG1wID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBtZW51ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRtcCA9IG5ldyBtZW51KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0bXAgPSBtZW51O1xuICAgICAgICB9XG4gICAgICAgIHZhciBibGcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbWVudXMuZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgaWYgKHRtcC5wcm9jSWQgPT09IG0ucHJvY0lkKSB7XG4gICAgICAgICAgICAgICAgYmxnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYmxnID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5fbWVudXMucHVzaCh0bXApO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvL+iOt+W+l+WFt+S9k+eahG1lbnXlr7nosaFcbiAgICBnZXRNZW51T2JqOiBmdW5jdGlvbiBnZXRNZW51T2JqKHByb2NJZCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX21lbnVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWVudSA9IHRoaXMuX21lbnVzW2ldO1xuXG4gICAgICAgICAgICBpZiAobWVudS5wcm9jSWQgPT0gcHJvY0lkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lbnU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvL+iOt+WPlm1lbnXlr7nosaFcbiAgICBnZXRNZW51czogZnVuY3Rpb24gZ2V0TWVudXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZW51cztcbiAgICB9XG59O1xuXG52YXIgbWVudUJhc2UgPSBmdW5jdGlvbiBtZW51QmFzZSgpIHtcbiAgICAvL+iPnOWNleagh+mimFxuICAgIHRoaXMudGV4dCA9IFwicm9vdFwiO1xuICAgIC8v57G755qE5ZSv5LiA5qCH6K+GXG4gICAgdGhpcy5wcm9jSWQgPSBcIjBcIjtcblxuICAgIC8v57uE5Lu255qEIOWFrOWFseaVsOaNrue7k+aehFxuICAgIHRoaXMuYmFzZURhdGEgPSB7fTtcblxuICAgIC8v57uE5Lu255qEIOeJueaAp+aVsOaNrue7k+aehFxuICAgIHRoaXMuc2NhdHREYXRhID0ge307XG5cbiAgICAvL+e7hOS7tueahCDlhazlhbHmqKHmnb8gKHZ1ZS5qc+aooeadv+ivreazlSlcbiAgICB0aGlzLmJhc2VIVE1MID0gXCJcIjtcblxuICAgIC8v54m55oCn5qih5p2/XG4gICAgdGhpcy5zY2F0dEhUTUwgPSBcIlwiO1xufTtcblxuZXhwb3J0IHsgbWVudVJlZ2lzdGVyLCBtZW51QmFzZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29yZS9tZW51L21lbnVCYXNlLmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///68\n')},85:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/**\r\n * @class 流程节点\r\n * @param {Object} container      节点容器（画布），jquery对象\r\n * @param {String} id      节点id\r\n * @param {String} name    节点名称\r\n * @param {Number} x       节点x坐标\r\n * @param {Number} y       节点y坐标\r\n * @param {Object} [options] 节点附加属性\r\n * @param {String} [options.color] 节点文字颜色\r\n * @param {String} [options.bgColor] 节点背景色\r\n * @param {Number} [options.radius] 节点圆角大小\r\n * @param {Number} [options.data] 绑定到节点的附加数据\r\n * @param {Number} [options.container] 节点容器（画布），若设置此选项则会自动将节点添加到画布上\r\n * @param {Boolean} [options.removable=true] 是否支持删除功能（鼠标放上去显示关闭图标）\r\n */\nvar ChartNode = function ChartNode(nodeId, options) {\n    if (arguments.length < 2) {\n        return;\n    }\n    this._jsPlumb = null;\n    this._container = null;\n    this._id = nodeId;\n    this._name = options.name;\n    this._x = options.point.x;\n    this._y = options.point.y;\n    this._clsName = options.class || '';\n    this._data = options && options.data || {};\n\n    this._options = $.extend({ // 默认属性\n        removable: true\n    }, options);\n    this._el = null;\n\n    if (options && options.container) {\n        //this.appendTo(options.container);\n    }\n};\n\n/**\r\n * 样式配置\r\n * @type {Object}\r\n */\nChartNode.prototype.optionStyle = {\n    lineStyle: {\n        strokeWidth: 2,\n        joinstyle: \"round\",\n        stroke: \"#0096f2\"\n    },\n    getPaintStyle: function getPaintStyle(strokeColor) {\n        return {\n            fill: strokeColor,\n            stroke: \"rgba(0,0,0,0)\",\n            strokeWidth: 8\n        };\n    },\n    connector: [\"Bezier\", {\n        curviness: 100\n    }]\n};\n\nChartNode.prototype.setPlumb = function (plumb) {\n    this._jsPlumb = plumb;\n};\nChartNode.prototype.setContainer = function (container) {\n    this._container = container;\n};\n\nChartNode.prototype.px = function (value) {\n    return value + 'px';\n};\n\nChartNode.prototype.getId = function () {\n    return this._id;\n};\n\nChartNode.prototype.getData = function () {\n    return this._data || {};\n};\nChartNode.prototype.setData = function (data) {\n    this._data = data;\n};\n\nChartNode.prototype.createElemt = function (options) {\n    var $node = $(options.html.trim()),\n        container = options.container,\n        elementCallback = options.elementCallback;\n\n    $node.addClass(\"\" + this._clsName).attr('id', this._id).css({\n        left: this.px(this._x),\n        top: this.px(this._y)\n    });\n\n    if (elementCallback) {\n        elementCallback(this, $node);\n    }\n\n    if (options.removable) {\n        var removeIcon = $('<div>').addClass('remove');\n        $node.append(removeIcon);\n    }\n\n    container.append($node);\n\n    var _this = this,\n        startX = 0,\n        startY = 0,\n        moveX = 0,\n        moveY = 0;\n    //节点拖动属性\n    this._jsPlumb.draggable($node, {\n        grid: [1, 1],\n        start: function start(e) {\n            startX = parseInt($(e.el).css('left'));\n            startY = parseInt($(e.el).css('top'));\n        },\n        stop: function stop(e) {\n            var left = parseInt($(e.el).css('left')),\n                top = parseInt($(e.el).css('top')),\n                maxWith = parseInt($(_this._container).width()) - parseInt($(e.el).outerWidth()),\n                maxHeight = parseInt($(_this._container).height()) - parseInt($(e.el).outerHeight());\n\n            left = left < 0 ? 0 : left > maxWith ? maxWith : left;\n            top = top < 0 ? 0 : top > maxHeight ? maxHeight : top;\n\n            moveX = left - startX;\n            moveY = top - startY;\n\n            e.drag.moveBy(moveX, moveY, e);\n        }\n        /* startEvent:function(){\r\n             console.log(arguments)\r\n         },\r\n         drag:function(){\r\n             console.log(arguments)\r\n         },\r\n         stop:function(){\r\n             console.log(arguments)\r\n         }\r\n        */\n    });\n\n    this._el = $node;\n};\n\n/**\r\n * 添加连接端口\r\n * @param {Object} options 连接端口参数\r\n * @param {String} [options.color=#0096f2] 端口颜色\r\n * @param {Boolean} [options.isSource=false] 是否为源端口\r\n * @param {Boolean} [options.isTarget=false] 是否为目标端口\r\n * @param {String} [options.label] 端口名称\r\n * @param {String} [options.position=bottom] 端口位置，可设置为 'Top'\r\n */\nChartNode.prototype.addPort = function (options) {\n    var pos = options.position || 'Bottom';\n\n    var strokeColor = pos === 'Top' ? \"#f65d3b\" : '#0096f2';\n    var cssClass = pos === 'Top' ? \"jspl-point-top\" : 'jspl-point-bottom';\n    var hoverClass = pos === 'TOP' ? \"jspl-point-top-hover\" : 'jspl-point-bottom-hover';\n\n    var endpointConf = {\n        endpoint: [\"Dot\", {\n            radius: 6,\n            cssClass: cssClass,\n            hoverClass: hoverClass\n        }],\n        //hoverPaintStyle:{ stroke:\"rgb(0, 0, 135)\" },\n        paintStyle: this.optionStyle.getPaintStyle(strokeColor),\n        anchor: pos, //[pos, [0.5, 0, 0, -1]],\n        isSource: !!options.isSource,\n        isTarget: !!options.isTarget,\n        maxConnections: -1,\n        connector: this.optionStyle.connector,\n\n        connectorStyle: this.optionStyle.lineStyle,\n\n        dragOptions: options.dragOptions || {},\n\n        allowLoopback: false\n    };\n\n    this[pos + \"Endpoint\"] = this._jsPlumb.addEndpoint(this._el, endpointConf);\n};\n\n/**\r\n * 更新坐标\r\n */\nChartNode.prototype.updatePos = function () {\n    var el = this._el;\n    this._x = parseInt(el.css(\"left\"), 10);\n    this._y = parseInt(el.css(\"top\"), 10);\n};\n\nChartNode.prototype.getPos = function () {\n    return {\n        x: this._x,\n        y: this._y\n    };\n};\n\nChartNode.prototype.toPlainObj = function () {\n    this.updatePos();\n\n    var data = $.extend({}, this._data);\n\n    data.name = this._name;\n    data.nodeId = this._id;\n    data._x = this._x;\n    data._y = this._y;\n    data.className = this._clsName;\n    data.removable = this._options.removable;\n    data.elId = this._el[0].id;\n\n    data.unPort = this._options.unPort || false;\n    data.nodeStyle = this._options.nodeStyle;\n\n    return data;\n};\n\nChartNode.prototype.dispose = function () {\n    var el = this._el;\n    var domEl = el.get(0);\n\n    this._jsPlumb.deleteEndpoint(this.TopEndpoint);\n    this._jsPlumb.remove(domEl);\n    el.remove();\n};\n\n/**\r\n * 设置params数据\r\n */\nChartNode.prototype.setParams = function (data) {\n    this._data.params = data;\n};\n\n/**\r\n * 返回params数据\r\n */\nChartNode.prototype.getParams = function () {\n    return this._data.params;\n};\n\n/**\r\n * 设置params数据 key=>val 形式设置\r\n */\nChartNode.prototype.setParamsOfKey = function (key, data) {\n    this._data.params[key] = data;\n};\n\n/**\r\n * connector连接线的绑定事件\r\n */\n\nChartNode.prototype.connectorEvent = {\n    upper: null,\n    init: function init(self, connect, options) {\n        this.upper = self;\n\n        this.mousedownEvent(connect, options);\n        this.mouseoverEvent(connect, options);\n        this.mouseoutEvent(connect, options);\n        this.dblclickEvent(connect, options);\n    },\n    mousedownEvent: function mousedownEvent(connect) {\n        var _this2 = this;\n\n        connect.unbind('mousedown').bind('mousedown', function (e) {\n\n            _this2.mousedown(e);\n        });\n    },\n    mousedown: function mousedown(e) {},\n    mouseoverEvent: function mouseoverEvent(connect) {\n        var _this3 = this;\n\n        connect.unbind('mouseover').bind('mouseover', function (e) {\n            _this3.mouseover(e);\n        });\n    },\n    mouseover: function mouseover(e) {\n        var p = e.connector.path;\n        if (typeof p.normalEvenPrams === \"undefined\") {\n            p.normalEvenPrams = {};\n        }\n        p.normalEvenPrams.strokeWidth = p.attributes[\"stroke-width\"].value;\n        p.attributes[\"stroke-width\"].value = 5;\n    },\n    mouseoutEvent: function mouseoutEvent(connect) {\n        var _this4 = this;\n\n        connect.unbind('mouseout').bind('mouseout', function (e) {\n            _this4.mouseout(e);\n        });\n    },\n    mouseout: function mouseout(e) {\n        var p = e.connector.path;\n        p.attributes[\"stroke-width\"].value = p.normalEvenPrams.strokeWidth;\n    },\n    dblclickEvent: function dblclickEvent(connect) {\n        var _this5 = this;\n\n        connect.unbind('dblclick').bind('dblclick', function (e) {\n            _this5.dblclick(e);\n        });\n    },\n    dblclick: function dblclick(e) {\n        this.upper._jsPlumb.deleteConnection(e);\n    }\n\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ChartNode);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb3JlL2NoYXJ0L2NoYXJ0Tm9kZS5qcz83MDEwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAY2xhc3Mg5rWB56iL6IqC54K5XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250YWluZXIgICAgICDoioLngrnlrrnlmajvvIjnlLvluIPvvInvvIxqcXVlcnnlr7nosaFcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkICAgICAg6IqC54K5aWRcclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgICAg6IqC54K55ZCN56ewXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4ICAgICAgIOiKgueCuXjlnZDmoIdcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgICAgICAg6IqC54K5eeWdkOagh1xyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIOiKgueCuemZhOWKoOWxnuaAp1xyXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY29sb3JdIOiKgueCueaWh+Wtl+minOiJslxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYmdDb2xvcl0g6IqC54K56IOM5pmv6ImyXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yYWRpdXNdIOiKgueCueWchuinkuWkp+Wwj1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZGF0YV0g57uR5a6a5Yiw6IqC54K555qE6ZmE5Yqg5pWw5o2uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb250YWluZXJdIOiKgueCueWuueWZqO+8iOeUu+W4g++8ie+8jOiLpeiuvue9ruatpOmAiemhueWImeS8muiHquWKqOWwhuiKgueCuea3u+WKoOWIsOeUu+W4g+S4ilxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJlbW92YWJsZT10cnVlXSDmmK/lkKbmlK/mjIHliKDpmaTlip/og73vvIjpvKDmoIfmlL7kuIrljrvmmL7npLrlhbPpl63lm77moIfvvIlcclxuICovXG52YXIgQ2hhcnROb2RlID0gZnVuY3Rpb24gQ2hhcnROb2RlKG5vZGVJZCwgb3B0aW9ucykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2pzUGx1bWIgPSBudWxsO1xuICAgIHRoaXMuX2NvbnRhaW5lciA9IG51bGw7XG4gICAgdGhpcy5faWQgPSBub2RlSWQ7XG4gICAgdGhpcy5fbmFtZSA9IG9wdGlvbnMubmFtZTtcbiAgICB0aGlzLl94ID0gb3B0aW9ucy5wb2ludC54O1xuICAgIHRoaXMuX3kgPSBvcHRpb25zLnBvaW50Lnk7XG4gICAgdGhpcy5fY2xzTmFtZSA9IG9wdGlvbnMuY2xhc3MgfHwgJyc7XG4gICAgdGhpcy5fZGF0YSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kYXRhIHx8IHt9O1xuXG4gICAgdGhpcy5fb3B0aW9ucyA9ICQuZXh0ZW5kKHsgLy8g6buY6K6k5bGe5oCnXG4gICAgICAgIHJlbW92YWJsZTogdHJ1ZVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHRoaXMuX2VsID0gbnVsbDtcblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY29udGFpbmVyKSB7XG4gICAgICAgIC8vdGhpcy5hcHBlbmRUbyhvcHRpb25zLmNvbnRhaW5lcik7XG4gICAgfVxufTtcblxuLyoqXHJcbiAqIOagt+W8j+mFjee9rlxyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKi9cbkNoYXJ0Tm9kZS5wcm90b3R5cGUub3B0aW9uU3R5bGUgPSB7XG4gICAgbGluZVN0eWxlOiB7XG4gICAgICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgICAgICBqb2luc3R5bGU6IFwicm91bmRcIixcbiAgICAgICAgc3Ryb2tlOiBcIiMwMDk2ZjJcIlxuICAgIH0sXG4gICAgZ2V0UGFpbnRTdHlsZTogZnVuY3Rpb24gZ2V0UGFpbnRTdHlsZShzdHJva2VDb2xvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmlsbDogc3Ryb2tlQ29sb3IsXG4gICAgICAgICAgICBzdHJva2U6IFwicmdiYSgwLDAsMCwwKVwiLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDhcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGNvbm5lY3RvcjogW1wiQmV6aWVyXCIsIHtcbiAgICAgICAgY3VydmluZXNzOiAxMDBcbiAgICB9XVxufTtcblxuQ2hhcnROb2RlLnByb3RvdHlwZS5zZXRQbHVtYiA9IGZ1bmN0aW9uIChwbHVtYikge1xuICAgIHRoaXMuX2pzUGx1bWIgPSBwbHVtYjtcbn07XG5DaGFydE5vZGUucHJvdG90eXBlLnNldENvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG59O1xuXG5DaGFydE5vZGUucHJvdG90eXBlLnB4ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgJ3B4Jztcbn07XG5cbkNoYXJ0Tm9kZS5wcm90b3R5cGUuZ2V0SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lkO1xufTtcblxuQ2hhcnROb2RlLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhIHx8IHt9O1xufTtcbkNoYXJ0Tm9kZS5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG59O1xuXG5DaGFydE5vZGUucHJvdG90eXBlLmNyZWF0ZUVsZW10ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgJG5vZGUgPSAkKG9wdGlvbnMuaHRtbC50cmltKCkpLFxuICAgICAgICBjb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lcixcbiAgICAgICAgZWxlbWVudENhbGxiYWNrID0gb3B0aW9ucy5lbGVtZW50Q2FsbGJhY2s7XG5cbiAgICAkbm9kZS5hZGRDbGFzcyhcIlwiICsgdGhpcy5fY2xzTmFtZSkuYXR0cignaWQnLCB0aGlzLl9pZCkuY3NzKHtcbiAgICAgICAgbGVmdDogdGhpcy5weCh0aGlzLl94KSxcbiAgICAgICAgdG9wOiB0aGlzLnB4KHRoaXMuX3kpXG4gICAgfSk7XG5cbiAgICBpZiAoZWxlbWVudENhbGxiYWNrKSB7XG4gICAgICAgIGVsZW1lbnRDYWxsYmFjayh0aGlzLCAkbm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucmVtb3ZhYmxlKSB7XG4gICAgICAgIHZhciByZW1vdmVJY29uID0gJCgnPGRpdj4nKS5hZGRDbGFzcygncmVtb3ZlJyk7XG4gICAgICAgICRub2RlLmFwcGVuZChyZW1vdmVJY29uKTtcbiAgICB9XG5cbiAgICBjb250YWluZXIuYXBwZW5kKCRub2RlKTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIHN0YXJ0WCA9IDAsXG4gICAgICAgIHN0YXJ0WSA9IDAsXG4gICAgICAgIG1vdmVYID0gMCxcbiAgICAgICAgbW92ZVkgPSAwO1xuICAgIC8v6IqC54K55ouW5Yqo5bGe5oCnXG4gICAgdGhpcy5fanNQbHVtYi5kcmFnZ2FibGUoJG5vZGUsIHtcbiAgICAgICAgZ3JpZDogWzEsIDFdLFxuICAgICAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQoZSkge1xuICAgICAgICAgICAgc3RhcnRYID0gcGFyc2VJbnQoJChlLmVsKS5jc3MoJ2xlZnQnKSk7XG4gICAgICAgICAgICBzdGFydFkgPSBwYXJzZUludCgkKGUuZWwpLmNzcygndG9wJykpO1xuICAgICAgICB9LFxuICAgICAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKGUpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gcGFyc2VJbnQoJChlLmVsKS5jc3MoJ2xlZnQnKSksXG4gICAgICAgICAgICAgICAgdG9wID0gcGFyc2VJbnQoJChlLmVsKS5jc3MoJ3RvcCcpKSxcbiAgICAgICAgICAgICAgICBtYXhXaXRoID0gcGFyc2VJbnQoJChfdGhpcy5fY29udGFpbmVyKS53aWR0aCgpKSAtIHBhcnNlSW50KCQoZS5lbCkub3V0ZXJXaWR0aCgpKSxcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQgPSBwYXJzZUludCgkKF90aGlzLl9jb250YWluZXIpLmhlaWdodCgpKSAtIHBhcnNlSW50KCQoZS5lbCkub3V0ZXJIZWlnaHQoKSk7XG5cbiAgICAgICAgICAgIGxlZnQgPSBsZWZ0IDwgMCA/IDAgOiBsZWZ0ID4gbWF4V2l0aCA/IG1heFdpdGggOiBsZWZ0O1xuICAgICAgICAgICAgdG9wID0gdG9wIDwgMCA/IDAgOiB0b3AgPiBtYXhIZWlnaHQgPyBtYXhIZWlnaHQgOiB0b3A7XG5cbiAgICAgICAgICAgIG1vdmVYID0gbGVmdCAtIHN0YXJ0WDtcbiAgICAgICAgICAgIG1vdmVZID0gdG9wIC0gc3RhcnRZO1xuXG4gICAgICAgICAgICBlLmRyYWcubW92ZUJ5KG1vdmVYLCBtb3ZlWSwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyogc3RhcnRFdmVudDpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgY29uc29sZS5sb2coYXJndW1lbnRzKVxyXG4gICAgICAgICB9LFxyXG4gICAgICAgICBkcmFnOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICBjb25zb2xlLmxvZyhhcmd1bWVudHMpXHJcbiAgICAgICAgIH0sXHJcbiAgICAgICAgIHN0b3A6ZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgIGNvbnNvbGUubG9nKGFyZ3VtZW50cylcclxuICAgICAgICAgfVxyXG4gICAgICAgICovXG4gICAgfSk7XG5cbiAgICB0aGlzLl9lbCA9ICRub2RlO1xufTtcblxuLyoqXHJcbiAqIOa3u+WKoOi/nuaOpeerr+WPo1xyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyDov57mjqXnq6/lj6Plj4LmlbBcclxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNvbG9yPSMwMDk2ZjJdIOerr+WPo+minOiJslxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmlzU291cmNlPWZhbHNlXSDmmK/lkKbkuLrmupDnq6/lj6NcclxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pc1RhcmdldD1mYWxzZV0g5piv5ZCm5Li655uu5qCH56uv5Y+jXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5sYWJlbF0g56uv5Y+j5ZCN56ewXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wb3NpdGlvbj1ib3R0b21dIOerr+WPo+S9jee9ru+8jOWPr+iuvue9ruS4uiAnVG9wJ1xyXG4gKi9cbkNoYXJ0Tm9kZS5wcm90b3R5cGUuYWRkUG9ydCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHBvcyA9IG9wdGlvbnMucG9zaXRpb24gfHwgJ0JvdHRvbSc7XG5cbiAgICB2YXIgc3Ryb2tlQ29sb3IgPSBwb3MgPT09ICdUb3AnID8gXCIjZjY1ZDNiXCIgOiAnIzAwOTZmMic7XG4gICAgdmFyIGNzc0NsYXNzID0gcG9zID09PSAnVG9wJyA/IFwianNwbC1wb2ludC10b3BcIiA6ICdqc3BsLXBvaW50LWJvdHRvbSc7XG4gICAgdmFyIGhvdmVyQ2xhc3MgPSBwb3MgPT09ICdUT1AnID8gXCJqc3BsLXBvaW50LXRvcC1ob3ZlclwiIDogJ2pzcGwtcG9pbnQtYm90dG9tLWhvdmVyJztcblxuICAgIHZhciBlbmRwb2ludENvbmYgPSB7XG4gICAgICAgIGVuZHBvaW50OiBbXCJEb3RcIiwge1xuICAgICAgICAgICAgcmFkaXVzOiA2LFxuICAgICAgICAgICAgY3NzQ2xhc3M6IGNzc0NsYXNzLFxuICAgICAgICAgICAgaG92ZXJDbGFzczogaG92ZXJDbGFzc1xuICAgICAgICB9XSxcbiAgICAgICAgLy9ob3ZlclBhaW50U3R5bGU6eyBzdHJva2U6XCJyZ2IoMCwgMCwgMTM1KVwiIH0sXG4gICAgICAgIHBhaW50U3R5bGU6IHRoaXMub3B0aW9uU3R5bGUuZ2V0UGFpbnRTdHlsZShzdHJva2VDb2xvciksXG4gICAgICAgIGFuY2hvcjogcG9zLCAvL1twb3MsIFswLjUsIDAsIDAsIC0xXV0sXG4gICAgICAgIGlzU291cmNlOiAhIW9wdGlvbnMuaXNTb3VyY2UsXG4gICAgICAgIGlzVGFyZ2V0OiAhIW9wdGlvbnMuaXNUYXJnZXQsXG4gICAgICAgIG1heENvbm5lY3Rpb25zOiAtMSxcbiAgICAgICAgY29ubmVjdG9yOiB0aGlzLm9wdGlvblN0eWxlLmNvbm5lY3RvcixcblxuICAgICAgICBjb25uZWN0b3JTdHlsZTogdGhpcy5vcHRpb25TdHlsZS5saW5lU3R5bGUsXG5cbiAgICAgICAgZHJhZ09wdGlvbnM6IG9wdGlvbnMuZHJhZ09wdGlvbnMgfHwge30sXG5cbiAgICAgICAgYWxsb3dMb29wYmFjazogZmFsc2VcbiAgICB9O1xuXG4gICAgdGhpc1twb3MgKyBcIkVuZHBvaW50XCJdID0gdGhpcy5fanNQbHVtYi5hZGRFbmRwb2ludCh0aGlzLl9lbCwgZW5kcG9pbnRDb25mKTtcbn07XG5cbi8qKlxyXG4gKiDmm7TmlrDlnZDmoIdcclxuICovXG5DaGFydE5vZGUucHJvdG90eXBlLnVwZGF0ZVBvcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLl9lbDtcbiAgICB0aGlzLl94ID0gcGFyc2VJbnQoZWwuY3NzKFwibGVmdFwiKSwgMTApO1xuICAgIHRoaXMuX3kgPSBwYXJzZUludChlbC5jc3MoXCJ0b3BcIiksIDEwKTtcbn07XG5cbkNoYXJ0Tm9kZS5wcm90b3R5cGUuZ2V0UG9zID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHRoaXMuX3gsXG4gICAgICAgIHk6IHRoaXMuX3lcbiAgICB9O1xufTtcblxuQ2hhcnROb2RlLnByb3RvdHlwZS50b1BsYWluT2JqID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudXBkYXRlUG9zKCk7XG5cbiAgICB2YXIgZGF0YSA9ICQuZXh0ZW5kKHt9LCB0aGlzLl9kYXRhKTtcblxuICAgIGRhdGEubmFtZSA9IHRoaXMuX25hbWU7XG4gICAgZGF0YS5ub2RlSWQgPSB0aGlzLl9pZDtcbiAgICBkYXRhLl94ID0gdGhpcy5feDtcbiAgICBkYXRhLl95ID0gdGhpcy5feTtcbiAgICBkYXRhLmNsYXNzTmFtZSA9IHRoaXMuX2Nsc05hbWU7XG4gICAgZGF0YS5yZW1vdmFibGUgPSB0aGlzLl9vcHRpb25zLnJlbW92YWJsZTtcbiAgICBkYXRhLmVsSWQgPSB0aGlzLl9lbFswXS5pZDtcblxuICAgIGRhdGEudW5Qb3J0ID0gdGhpcy5fb3B0aW9ucy51blBvcnQgfHwgZmFsc2U7XG4gICAgZGF0YS5ub2RlU3R5bGUgPSB0aGlzLl9vcHRpb25zLm5vZGVTdHlsZTtcblxuICAgIHJldHVybiBkYXRhO1xufTtcblxuQ2hhcnROb2RlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IHRoaXMuX2VsO1xuICAgIHZhciBkb21FbCA9IGVsLmdldCgwKTtcblxuICAgIHRoaXMuX2pzUGx1bWIuZGVsZXRlRW5kcG9pbnQodGhpcy5Ub3BFbmRwb2ludCk7XG4gICAgdGhpcy5fanNQbHVtYi5yZW1vdmUoZG9tRWwpO1xuICAgIGVsLnJlbW92ZSgpO1xufTtcblxuLyoqXHJcbiAqIOiuvue9rnBhcmFtc+aVsOaNrlxyXG4gKi9cbkNoYXJ0Tm9kZS5wcm90b3R5cGUuc2V0UGFyYW1zID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB0aGlzLl9kYXRhLnBhcmFtcyA9IGRhdGE7XG59O1xuXG4vKipcclxuICog6L+U5ZuecGFyYW1z5pWw5o2uXHJcbiAqL1xuQ2hhcnROb2RlLnByb3RvdHlwZS5nZXRQYXJhbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEucGFyYW1zO1xufTtcblxuLyoqXHJcbiAqIOiuvue9rnBhcmFtc+aVsOaNriBrZXk9PnZhbCDlvaLlvI/orr7nva5cclxuICovXG5DaGFydE5vZGUucHJvdG90eXBlLnNldFBhcmFtc09mS2V5ID0gZnVuY3Rpb24gKGtleSwgZGF0YSkge1xuICAgIHRoaXMuX2RhdGEucGFyYW1zW2tleV0gPSBkYXRhO1xufTtcblxuLyoqXHJcbiAqIGNvbm5lY3Rvcui/nuaOpee6v+eahOe7keWumuS6i+S7tlxyXG4gKi9cblxuQ2hhcnROb2RlLnByb3RvdHlwZS5jb25uZWN0b3JFdmVudCA9IHtcbiAgICB1cHBlcjogbnVsbCxcbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KHNlbGYsIGNvbm5lY3QsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy51cHBlciA9IHNlbGY7XG5cbiAgICAgICAgdGhpcy5tb3VzZWRvd25FdmVudChjb25uZWN0LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5tb3VzZW92ZXJFdmVudChjb25uZWN0LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5tb3VzZW91dEV2ZW50KGNvbm5lY3QsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmRibGNsaWNrRXZlbnQoY29ubmVjdCwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBtb3VzZWRvd25FdmVudDogZnVuY3Rpb24gbW91c2Vkb3duRXZlbnQoY29ubmVjdCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICBjb25uZWN0LnVuYmluZCgnbW91c2Vkb3duJykuYmluZCgnbW91c2Vkb3duJywgZnVuY3Rpb24gKGUpIHtcblxuICAgICAgICAgICAgX3RoaXMyLm1vdXNlZG93bihlKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBtb3VzZWRvd246IGZ1bmN0aW9uIG1vdXNlZG93bihlKSB7fSxcbiAgICBtb3VzZW92ZXJFdmVudDogZnVuY3Rpb24gbW91c2VvdmVyRXZlbnQoY29ubmVjdCkge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICBjb25uZWN0LnVuYmluZCgnbW91c2VvdmVyJykuYmluZCgnbW91c2VvdmVyJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIF90aGlzMy5tb3VzZW92ZXIoZSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgbW91c2VvdmVyOiBmdW5jdGlvbiBtb3VzZW92ZXIoZSkge1xuICAgICAgICB2YXIgcCA9IGUuY29ubmVjdG9yLnBhdGg7XG4gICAgICAgIGlmICh0eXBlb2YgcC5ub3JtYWxFdmVuUHJhbXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHAubm9ybWFsRXZlblByYW1zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcC5ub3JtYWxFdmVuUHJhbXMuc3Ryb2tlV2lkdGggPSBwLmF0dHJpYnV0ZXNbXCJzdHJva2Utd2lkdGhcIl0udmFsdWU7XG4gICAgICAgIHAuYXR0cmlidXRlc1tcInN0cm9rZS13aWR0aFwiXS52YWx1ZSA9IDU7XG4gICAgfSxcbiAgICBtb3VzZW91dEV2ZW50OiBmdW5jdGlvbiBtb3VzZW91dEV2ZW50KGNvbm5lY3QpIHtcbiAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgICAgY29ubmVjdC51bmJpbmQoJ21vdXNlb3V0JykuYmluZCgnbW91c2VvdXQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgX3RoaXM0Lm1vdXNlb3V0KGUpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIG1vdXNlb3V0OiBmdW5jdGlvbiBtb3VzZW91dChlKSB7XG4gICAgICAgIHZhciBwID0gZS5jb25uZWN0b3IucGF0aDtcbiAgICAgICAgcC5hdHRyaWJ1dGVzW1wic3Ryb2tlLXdpZHRoXCJdLnZhbHVlID0gcC5ub3JtYWxFdmVuUHJhbXMuc3Ryb2tlV2lkdGg7XG4gICAgfSxcbiAgICBkYmxjbGlja0V2ZW50OiBmdW5jdGlvbiBkYmxjbGlja0V2ZW50KGNvbm5lY3QpIHtcbiAgICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgICAgY29ubmVjdC51bmJpbmQoJ2RibGNsaWNrJykuYmluZCgnZGJsY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgX3RoaXM1LmRibGNsaWNrKGUpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGRibGNsaWNrOiBmdW5jdGlvbiBkYmxjbGljayhlKSB7XG4gICAgICAgIHRoaXMudXBwZXIuX2pzUGx1bWIuZGVsZXRlQ29ubmVjdGlvbihlKTtcbiAgICB9XG5cbn07XG5cbmV4cG9ydCBkZWZhdWx0IENoYXJ0Tm9kZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvcmUvY2hhcnQvY2hhcnROb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///85\n")},86:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return menuBases; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__crsBase_js__ = __webpack_require__(27);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_0__crsBase_js__["b"]; });\n\n\nvar menuBases = function menuBases() {\n    __WEBPACK_IMPORTED_MODULE_0__crsBase_js__["a" /* menuBase */].call(this);\n\n    this.procId = "tdw";\n    this.text = "tdw";\n    //组件的 公共数据结构\n    this.baseData = $.extend(this.baseData, {\n        "tdwUserPwd": "tdw_dbyin:dbyin",\n        "tdwAppId": "dbyin_app"\n    });\n\n    this.baseHTML = "\\n    <div class=\\"params-content\\">\\n        <div class=\\"v-title\\">\\u516C\\u5171\\u53C2\\u6570</div>  \\n\\n        <div class=\\"v-params\\">\\n            <span>namespace</span>\\n            <div class=\\"v-params-value\\">\\n                <input v-model=\\"namespace\\" />\\n            </div>\\n        </div>\\n        <div class=\\"v-params\\">\\n            <span>taskName</span>\\n            <div class=\\"v-params-value\\">\\n                <input v-model=\\"taskName\\" />\\n            </div>\\n        </div>\\n        <div class=\\"v-params\\">\\n            <span>owner</span>\\n            <div class=\\"v-params-value\\">\\n                <input v-model=\\"owner\\" />\\n            </div>\\n        </div>\\n        <div class=\\"v-params\\">\\n            <span>tdwUserPwd</span>\\n            <div class=\\"v-params-value\\">\\n                <input v-model=\\"tdwUserPwd\\" />\\n            </div>\\n        </div>\\n        <div class=\\"v-params\\">\\n            <span>tdwAppId</span>\\n            <div class=\\"v-params-value\\">\\n                <input v-model=\\"tdwAppId\\" />\\n            </div>\\n        </div>\\n\\n    </div>\\n    ";\n\n    //添加后的节点是否可以删除\n    this.baseData.removable = true;\n\n    //设置 图形节点的内容\n    this.setNodeElement = function (data) {\n\n        return "";\n    };\n};\n\n__WEBPACK_IMPORTED_MODULE_0__crsBase_js__["b" /* menuRegister */].add(menuBases);\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zY2FmZi9tZW51cy9jcnNDaGlsZC90ZHdCYXNlLmpzPzMxODciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbWVudUJhc2UsIG1lbnVSZWdpc3RlciB9IGZyb20gJy4vY3JzQmFzZS5qcyc7XG5cbnZhciBtZW51QmFzZXMgPSBmdW5jdGlvbiBtZW51QmFzZXMoKSB7XG4gICAgbWVudUJhc2UuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMucHJvY0lkID0gXCJ0ZHdcIjtcbiAgICB0aGlzLnRleHQgPSBcInRkd1wiO1xuICAgIC8v57uE5Lu255qEIOWFrOWFseaVsOaNrue7k+aehFxuICAgIHRoaXMuYmFzZURhdGEgPSAkLmV4dGVuZCh0aGlzLmJhc2VEYXRhLCB7XG4gICAgICAgIFwidGR3VXNlclB3ZFwiOiBcInRkd19kYnlpbjpkYnlpblwiLFxuICAgICAgICBcInRkd0FwcElkXCI6IFwiZGJ5aW5fYXBwXCJcbiAgICB9KTtcblxuICAgIHRoaXMuYmFzZUhUTUwgPSBcIlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJwYXJhbXMtY29udGVudFxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ2LXRpdGxlXFxcIj5cXHU1MTZDXFx1NTE3MVxcdTUzQzJcXHU2NTcwPC9kaXY+ICBcXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInYtcGFyYW1zXFxcIj5cXG4gICAgICAgICAgICA8c3Bhbj5uYW1lc3BhY2U8L3NwYW4+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidi1wYXJhbXMtdmFsdWVcXFwiPlxcbiAgICAgICAgICAgICAgICA8aW5wdXQgdi1tb2RlbD1cXFwibmFtZXNwYWNlXFxcIiAvPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ2LXBhcmFtc1xcXCI+XFxuICAgICAgICAgICAgPHNwYW4+dGFza05hbWU8L3NwYW4+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidi1wYXJhbXMtdmFsdWVcXFwiPlxcbiAgICAgICAgICAgICAgICA8aW5wdXQgdi1tb2RlbD1cXFwidGFza05hbWVcXFwiIC8+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInYtcGFyYW1zXFxcIj5cXG4gICAgICAgICAgICA8c3Bhbj5vd25lcjwvc3Bhbj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ2LXBhcmFtcy12YWx1ZVxcXCI+XFxuICAgICAgICAgICAgICAgIDxpbnB1dCB2LW1vZGVsPVxcXCJvd25lclxcXCIgLz5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidi1wYXJhbXNcXFwiPlxcbiAgICAgICAgICAgIDxzcGFuPnRkd1VzZXJQd2Q8L3NwYW4+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidi1wYXJhbXMtdmFsdWVcXFwiPlxcbiAgICAgICAgICAgICAgICA8aW5wdXQgdi1tb2RlbD1cXFwidGR3VXNlclB3ZFxcXCIgLz5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidi1wYXJhbXNcXFwiPlxcbiAgICAgICAgICAgIDxzcGFuPnRkd0FwcElkPC9zcGFuPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInYtcGFyYW1zLXZhbHVlXFxcIj5cXG4gICAgICAgICAgICAgICAgPGlucHV0IHYtbW9kZWw9XFxcInRkd0FwcElkXFxcIiAvPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuXFxuICAgIDwvZGl2PlxcbiAgICBcIjtcblxuICAgIC8v5re75Yqg5ZCO55qE6IqC54K55piv5ZCm5Y+v5Lul5Yig6ZmkXG4gICAgdGhpcy5iYXNlRGF0YS5yZW1vdmFibGUgPSB0cnVlO1xuXG4gICAgLy/orr7nva4g5Zu+5b2i6IqC54K555qE5YaF5a65XG4gICAgdGhpcy5zZXROb2RlRWxlbWVudCA9IGZ1bmN0aW9uIChkYXRhKSB7XG5cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfTtcbn07XG5cbm1lbnVSZWdpc3Rlci5hZGQobWVudUJhc2VzKTtcblxuZXhwb3J0IHsgbWVudUJhc2VzIGFzIG1lbnVCYXNlLCBtZW51UmVnaXN0ZXIgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NjYWZmL21lbnVzL2Nyc0NoaWxkL3Rkd0Jhc2UuanNcbi8vIG1vZHVsZSBpZCA9IDg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///86\n')}},[108]);